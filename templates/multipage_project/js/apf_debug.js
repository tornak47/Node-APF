
/*FILEHEAD(/var/lib/platform/source/trunk/jpack_begin.js)SIZE(0)TIME(1238593371)*/



/*FILEHEAD(/var/lib/platform/source/trunk/apf.js)SIZE(115883)TIME(1265038748)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Ajax.org Platform
 *
 * @author    Ruben Daniels (ruben AT javeline DOT com)
 * @version   3.0
 * @url       http://www.ajax.org
 *
 * @event domready      Fires when the browsers' dom is ready to be manipulated.
 * @event movefocus         Fires when the focus moves from one element to another.
 *   object:
 *   {AMLElement} toElement the element that will receive the focus.
 * @event exit              Fires when the application wants to exit.
 *   cancelable:  Prevents the application from exiting. The returnValue of the
 *   event object is displayed in a popup which asks the user for permission.
 * @event keyup         Fires when the user stops pressing a key.
 *   cancelable: Prevents the behaviour.
 *   object:
 *   {Number}  keyCode   the char code of the pressed key.
 *   {Boolean} ctrlKey   whether the ctrl key was pressed.
 *   {Boolean} shiftKey  whether the shift key was pressed.
 *   {Boolean} altKey    whether the alt key was pressed.
 *   {Object}  htmlEvent the html event object.
 * @event mousescroll   Fires when the user scrolls the mouse
 *   cancelable: Prevents the container to scroll
 *   object:
 *   {Number} delta the scroll impulse.
 * @event hotkey        Fires when the user presses a hotkey
 *   bubbles: yes
 *   cancelable: Prevents the default hotkey behaviour.
 *   object:
 *   {Number}  keyCode   the char code of the pressed key.
 *   {Boolean} ctrlKey   whether the ctrl key was pressed.
 *   {Boolean} shiftKey  whether the shift key was pressed.
 *   {Boolean} altKey    whether the alt key was pressed.
 *   {Object}  htmlEvent the html event object.
 * @event keydown       Fires when the user presses a key
 *   bubbles: yes
 *   cancelable: Prevents the behaviour.
 *   object:
 *   {Number}  keyCode   the char code of the pressed key.
 *   {Boolean} ctrlKey   whether the ctrl key was pressed.
 *   {Boolean} shiftKey  whether the shift key was pressed.
 *   {Boolean} altKey    whether the alt key was pressed.
 *   {Object}  htmlEvent the html event object.
 * @event mousedown     Fires when the user presses a mouse button
 *   object:
 *   {Event}      htmlEvent the char code of the pressed key.
 *   {AMLElement} amlNode   the element on which is clicked.
 * @event onbeforeprint Fires before the application will print.
 * @event onafterprint  Fires after the application has printed.
 * @event load          Fires after the application is loaded.
 * @event error         Fires when a communication error has occured while making a request for this element.
 *   cancelable: Prevents the error from being thrown.
 *   bubbles:
 *   object:
 *   {Error}          error     the error object that is thrown when the event callback doesn't return false.
 *   {Number}         state     the state of the call
 *     Possible values:
 *     apf.SUCCESS  the request was successfull
 *     apf.TIMEOUT  the request has timed out.
 *     apf.ERROR    an error has occurred while making the request.
 *     apf.OFFLINE  the request was made while the application was offline.
 *   {mixed}          userdata  data that the caller wanted to be available in the callback of the http request.
 *   {XMLHttpRequest} http      the object that executed the actual http request.
 *   {String}         url       the url that was requested.
 *   {Http}           tpModule  the teleport module that is making the request.
 *   {Number}         id        the id of the request.
 *   {String}         message   the error message.
 * @default_private
 */
var apf = {
VERSION:'3.0beta',
    // Content Distribution Network URL:
    
    /**
     * The url to the content delivery network.
     * @type {String}
     */
    CDN            : "",
    

    /**
     * Boolean specifying whether apf is ready for dom operations.
     * @type {Boolean}
     */
    READY          : false,

    //AML nodeFunc constants
    /**
     * Constant for a hidden aml element.
     * @type {Number}
     */
    NODE_HIDDEN    : 101,
    /**
     * Constant for a visible aml element.
     * @type {Number}
     */
    NODE_VISIBLE   : 102,
    /**
     * Constant for an o3 widget.
     * @type {Number}
     */
    NODE_O3 : 103,

    /**
     * Constant for specifying that a widget is using only the keyboard to receive focus.
     * @type {Number}
     * @see baseclass.guielement.method.focus
     */
    KEYBOARD       : 2,
    /**
     * Constant for specifying that a widget is using the keyboard or the mouse to receive focus.
     * @type {Boolean}
     * @see baseclass.guielement.method.focus
     */
    KEYBOARD_MOUSE : true,

    /**
     * Constant for specifying success.
     * @type {Number}
     * @see element.teleport
     */
    SUCCESS : 1,
    /**
     * Constant for specifying a timeout.
     * @type {Number}
     * @see element.teleport
     */
    TIMEOUT : 2,
    /**
     * Constant for specifying an error.
     * @type {Number}
     * @see element.teleport
     */
    ERROR   : 3,
    /**
     * Constant for specifying the application is offline.
     * @type {Number}
     * @see element.teleport
     */
    OFFLINE : 4,

    
    debug         : true,
    debugType     : "Memory",
    debugFilter   : "!teleport",
    

    includeStack  : [],
    initialized   : false,
    AppModules    : [],
    
    /**
     * Boolean specifying whether apf tries to load a skin from skins.xml when no skin element is specified.
     * @type {Boolean}
     */
    autoLoadSkin  : false,
    /**
     * Boolean specifying whether apf has started loading scripts and started the init process.
     * @type {Boolean}
     */
    started       : false,
    /**
     * Namespace for all crypto libraries included with Ajax.org Platform.
     */
    crypto        : {}, //namespace
    config        : {},
    _GET          : {},
    $asyncObjects : {"apf.oHttp" : 1},
    
    /**
     * String specifying the basepath for loading apf from seperate files.
     * @type {String}
     */
    
    basePath      : "./",
    

    
    /**
     * {Object} contains several known and often used namespace URI's.
     * @private
     */
    ns : {
        apf    : "http://ajax.org/2005/aml",
        aml    : "http://ajax.org/2005/aml",
        xsd    : "http://www.w3.org/2001/XMLSchema",
        xhtml  : "http://www.w3.org/1999/xhtml",
        xslt   : "http://www.w3.org/1999/XSL/Transform",
        xforms : "http://www.w3.org/2002/xforms",
        ev     : "http://www.w3.org/2001/xml-events"
    },
    
    
    availHTTP  : [],
    /**
     * @private
     */
    releaseHTTP: function(http){
        if (apf.brokenHttpAbort) 
            return;
        if (self.XMLHttpRequestUnSafe && http.constructor == XMLHttpRequestUnSafe) 
            return;
        
        http.onreadystatechange = function(){};
        http.abort();
        this.availHTTP.push(http);
    },

    /**
     * @private
     */
    browserDetect : function(){
        if (this.$bdetect)
            return;
        this.$bdetect = true;

        var sAgent = navigator.userAgent.toLowerCase() || "";

        // Browser Detection, using feature inference methods where possible:
        // http://www.thespanner.co.uk/2009/01/29/detecting-browsers-javascript-hacks/
        // http://webreflection.blogspot.com/2009/01/32-bytes-to-know-if-your-browser-is-ie.html
        
        /**
         * Specifies whether the application is running in the Opera browser.
         * @type {Boolean}
         */
        this.isOpera      = (self.opera && Object.prototype.toString.call(self.opera) == "[object Opera]");
        
        /**
         * Specifies whether the application is running in the Konqueror browser.
         * @type {Boolean}
         */
        this.isKonqueror  = sAgent.indexOf("konqueror") != -1;
        
        /**
         * Specifies whether the application is running in the Safari browser.
         * @type {Boolean}
         */
        this.isSafari     = /a/.__proto__ == "//";
        
        /**
         * Specifies whether the application is running in the Safari browser version 2.4 or below.
         * @type {Boolean}
         */
        this.isSafariOld  = false;

        /**
         * Specifies whether the application is running on the Iphone.
         * @type {Boolean}
         */
        this.isIphone     = sAgent.indexOf("iphone") != -1 || sAgent.indexOf("aspen simulator") != -1;

        /**
         * Specifies whether the application is running in the Chrome browser.
         * @type {Boolean}
         */
        this.isChrome     = Boolean(/source/.test((/a/.toString + ""))) || sAgent.indexOf("chrome") != -1;
        
        /**
         * Specifies whether the application is running in a Webkit-based browser
         * @type {Boolean}
         */
        this.isWebkit     = this.isSafari || this.isChrome || this.isKonquerer;

        if (this.isWebkit) {
            var matches   = sAgent.match(/applewebkit\/(\d+)/);
            if (matches) {
                this.webkitRev   = parseInt(matches[1])
                this.isSafariOld = parseInt(matches[1]) < 420;
            }
        }

        /**
         * Specifies whether the application is running in a Gecko based browser.
         * @type {Boolean}
         */
        this.isGecko      = (function(o) { o[o] = o + ""; return o[o] != o + ""; })(new String("__count__"));

        /**
         * Specifies whether the application is running in the Firefox browser version 3.
         * @type {Boolean}
         */
        this.isGecko3     = this.isGecko && (function x(){})[-5] == "x";
        this.isGecko35    = this.isGecko && (/a/[-1] && Object.getPrototypeOf) ? true : false;
        this.versionGecko = this.isGecko ? parseFloat(sAgent.match(/(?:firefox|gecko)\/([\d\.]+)/i)[1]) : -1;
        
        var found;
        /**
         * Specifies whether the application is running in the Internet Explorer browser, any version.
         * @type {Boolean}
         */
        this.isIE         = ! + "\v1";
        if (this.isIE)
            this.isIE = parseFloat(sAgent.match(/msie ([\d\.]*)/)[1]);
        
        /**
         * Specifies whether the application is running in the Internet Explorer browser version 8.
         * @type {Boolean}
         */
        this.isIE8        = this.isIE == 8 && (found = true);
        
        /**
         * Specifies whether the application is running in the Internet Explorer browser version 7.
         * @type {Boolean}
         */
        this.isIE7        = !found && this.isIE == 7 && (found = true);
        
        //Mode detection
        if (this.isIE == 8 && document.documentMode == 7) {
            apf.isIE7        = true;
            apf.isIE8        = false;
            apf.isIE7Emulate = true;
            apf.isIE         = 7;
        }
        
        /**
         * Specifies whether the application is running in the Internet Explorer browser version 6.
         * @type {Boolean}
         */
        this.isIE6       = !found && this.isIE == 6 && (found = true);

        var os           = (navigator.platform.match(/mac|win|linux/i) || ["other"])[0].toLowerCase();
        /**
         * Specifies whether the application is running on the Windows operating system.
         * @type {Boolean}
         */
        this.isWin       = (os == "win");
        /**
         * Specifies whether the application is running in the OSX operating system..
         * @type {Boolean}
         */
        this.isMac       = (os == "mac");
        /**
         * Specifies whether the application is running in the OSX operating system..
         * @type {Boolean}
         */
        this.isLinux     = (os == "linux");

        /**
         * Specifies whether the application is running in the AIR runtime.
         * @type {Boolean}
         */
        this.isAIR       = sAgent.indexOf("adobeair") != -1;

        

        
        try {
            //this.isDeskrun = window.external.shell.runtime == 2;
        }
        catch(e) {
            /**
             * Specifies whether the application is running in the Deskrun runtime.
             * @type {Boolean}
             */
            this.isDeskrun = false;
        }
        
    },

    /**
     * @private
     */
    setCompatFlags : function(){
        //Set Compatibility
        this.TAGNAME                   = apf.isIE ? "baseName" : "localName";
        this.styleSheetRules           = apf.isIE ? "rules" : "cssRules";
        this.brokenHttpAbort           = apf.isIE6;
        this.canUseHtmlAsXml           = apf.isIE;
        this.supportNamespaces         = !apf.isIE;
        this.cannotSizeIframe          = apf.isIE;
        this.hasConditionCompilation   = apf.isIE;
        this.supportOverflowComponent  = apf.isIE;
        this.hasEventSrcElement        = apf.isIE;
        this.canHaveHtmlOverSelects    = !apf.isIE6 && !apf.isIE5;
        this.hasInnerText              = apf.isIE;
        this.hasMsRangeObject          = apf.isIE;
        this.descPropJs                = apf.isIE;
        this.hasClickFastBug           = apf.isIE;
        this.hasExecScript             = window.execScript ? true : false;
        this.canDisableKeyCodes        = apf.isIE;
        this.hasTextNodeWhiteSpaceBug  = apf.isIE || apf.isIE >= 8;
        this.hasCssUpdateScrollbarBug  = apf.isIE;
        this.canUseInnerHtmlWithTables = !apf.isIE;
        this.hasSingleResizeEvent      = !apf.isIE;
        this.hasStyleFilters           = apf.isIE;
        this.supportOpacity            = !apf.isIE;
        this.supportPng24              = !apf.isIE6 && !apf.isIE5;
        this.cantParseXmlDefinition    = apf.isIE50;
        this.hasDynamicItemList        = !apf.isIE || apf.isIE >= 7;
        this.canImportNode             = apf.isIE;
        this.hasSingleRszEvent         = !apf.isIE;
        this.hasXPathHtmlSupport       = !apf.isIE;
        this.hasFocusBug               = apf.isIE;
        this.hasReadyStateBug          = apf.isIE50;
        this.dateSeparator             = apf.isIE ? "-" : "/";
        this.canCreateStyleNode        = !apf.isIE;
        this.supportFixedPosition      = !apf.isIE || apf.isIE >= 7;
        this.hasHtmlIdsInJs            = apf.isIE && apf.isIE < 8 || apf.isWebkit;
        this.needsCssPx                = !apf.isIE;
        this.hasCSSChildOfSelector     = !apf.isIE || apf.isIE >= 8;
        this.styleAttrIsObj            = apf.isIE < 8;
        this.hasAutocompleteXulBug     = apf.isGecko;
        this.loadsLocalFilesSync       = apf.isIE || apf.isGecko;
        this.mouseEventBuffer          = apf.isIE ? 20 : 6;
        this.hasComputedStyle          = typeof document.defaultView != "undefined"
                                           && typeof document.defaultView.getComputedStyle != "undefined";
        this.supportCSSAnim            = apf.isWebkit && (apf.webkitRev > 525);//apf.isIphone;
        this.w3cRange                  = Boolean(window["getSelection"]);
        this.locale                    = (apf.isIE
                                            ? navigator.userLanguage
                                            : navigator.language).toLowerCase();
        this.characterSet              = document.characterSet || document.defaultCharset || "utf-8";
        var t = document.createElement("div");
        this.hasContentEditable        = (typeof t.contentEditable == "string"
                                       || typeof t.contentEditable == "boolean");
        t = null;
        delete t;

        this.supportVML                = apf.isIE;
        this.supportSVG                = !apf.isIE;
        this.hasHtml5XDomain           = apf.versionGecko >= 3.5;
        this.supportCanvas             = !!document.createElement("canvas").getContext;
        this.supportCanvasText         = !!(this.supportCanvas
            && typeof document.createElement("canvas").getContext("2d").fillText == "function")

        this.hasVideo                  = !!document.createElement("video")["canPlayType"];
        this.hasAudio                  = !!document.createElement("audio")["canPlayType"];
        this.hasGeolocation            = !!navigator.geolocation;
        this.supportHashChange         = ("onhashchange" in self) && !apf.isIE7Emulate || apf.isIE8;
        
        // Run through HTML5's new input types to see if the UA understands any.
        //   This is put behind the tests runloop because it doesn't return a
        //   true/false like all the other tests; instead, it returns an array
        //   containing properties that represent the 'supported' input types.
        t = document.createElement("input");
        var _self = this;
        (function(props) {
            for (var i in props) {
                t.setAttribute("type", i);
                _self["hasInput" + i.charAt(0).toUpperCase()
                    + i.substr(1).replace("-l", "L")] = !!(t.type !== "text");
            }
        })({"search":1, "tel":1, "url":1, "email":1, "datetime":1, "date":1,
            "month":1, "week":1, "time":1, "datetime-local":1, "number":1,
            "range":1, "color":1});
        t = null;
        delete t;

        //Other settings
        this.maxHttpRetries = apf.isOpera ? 0 : 3;

        
        this.percentageMatch = new RegExp();
        this.percentageMatch.compile("([\\-\\d\\.]+)\\%", "g");
        
        
        this.reMatchXpath = new RegExp();
        this.reMatchXpath.compile("(^|\\|)(?!\\@|[\\w-]+::)", "g");

        
        apf.isGears      = !!apf.initGears() || 0;
        
    },

    
    /**
     * Restarts the application.
     */
    reboot : function(){
        apf.console.info("Restarting application...");

        location.href = location.href;
    },
    

    /**
     * Extends an object with one or more other objects by copying all their
     * properties.
     * @param {Object} dest the destination object.
     * @param {Object} src the object that is copies from.
     * @return {Object} the destination object.
     */
    extend : function(dest, src){
        var prop, i, x = !dest.notNull;
        if (arguments.length == 2) {
            for (prop in src) {
                if (x || src[prop])
                    dest[prop] = src[prop];
            }
            return dest;
        }

        for (i = 1; i < arguments.length; i++) {
            src = arguments[i];
            for (prop in src) {
                if (x || src[prop])
                    dest[prop] = src[prop];
            }
        }
        return dest;
    },
    
    $extend : function(dest, src){
        for (var prop in src) {
            dest[prop] = src[prop];
        }
        return dest;
    },
    
    
    /**
     * Sends and retrieves data from remote locations over http.
     * Example:
     * <code>
     *  var content = apf.ajax("http://www.ajax.org", {
     *      method   : "POST",
     *      data     : "<data />",
     *      async    : false,
     *      callback : function( data, state ) {
     *          if (state == apf.SUCCESS)
     *              alert("Success");
     *          else
     *              alert("Failure")
     *      }
     *  });
     *  alert(content);
     * </code>
     *
     * @param {String}   url       the url that is accessed.
     * @param {Object}   options   the options for the http request
     *   Properties:
     *   {Boolean} async          whether the request is sent asynchronously. Defaults to true.
     *   {mixed}   userdata       custom data that is available to the callback function.
     *   {String}  method         the request method (POST|GET|PUT|DELETE). Defaults to GET.
     *   {Boolean} nocache        whether browser caching is prevented.
     *   {String}  data           the data sent in the body of the message.
     *   {Boolean} useXML         whether the result should be interpreted as xml.
     *   {Boolean} autoroute      whether the request can fallback to a server proxy.
     *   {Boolean} caching        whether the request should use internal caching.
     *   {Boolean} ignoreOffline  whether to ignore offline catching.
     *   {Function} callback      the handler that gets called whenever the
     *                            request completes succesfully or with an error,
     *                            or when the request times out.
     */
    ajax : function(){
        return this.oHttp.get.apply(this.oHttp, arguments);
    },
    

    /**
     * Starts the application.
     * @private
     */
    start : function(){
        this.started = true;
        var sHref = location.href.split("#")[0].split("?")[0];

        //Set Variables
        this.host     = location.hostname && sHref.replace(/(\/\/[^\/]*)\/.*$/, "$1");
        this.hostPath = sHref.replace(/\/[^\/]*$/, "") + "/";

        
        apf.console.info("Starting Ajax.org Platform Application...");
        apf.console.warn("This is a debug build of Ajax.org Platform; be aware "
            + "that\nexecution speed of this build is <strong>several times</strong> "
            + "slower than a release build\nof Ajax.org Platform.");
        

        //mozilla root detection
        //try{ISROOT = !window.opener || !window.opener.apf}catch(e){ISROOT = true}

        //Browser Specific Stuff
        //this.browserDetect();
        this.setCompatFlags();

        
        apf.debugwin.init();
        

        //Load Browser Specific Code
        
        if (this.isIE) apf.runIE();
            //this.importClass(apf.runIE, true, self);
        
        
        if (apf.isWebkit) apf.runWebkit();
            //this.importClass(apf.runSafari, true, self);
        
        
        if (this.isOpera) apf.runOpera();
            //this.importClass(apf.runOpera, true, self);
        
        
        if (this.isGecko || !this.isIE && !apf.isWebkit && !this.isOpera)
            apf.runGecko();
            //this.importClass(apf.runGecko, true, self);
        

        
        for (var i, l2, a, m, n, o, v, p = location.href.split(/[?&]/), l = p.length, k = 1; k < l; k++) {
            if (m = p[k].match(/(.*?)(\..*?|\[.*?\])?=([^#]*)/)) {
                n = decodeURI(m[1]).toLowerCase(), o = this._GET;
                if (m[2]) {
                    for (a = decodeURI(m[2]).replace(/\[\s*\]/g, "[-1]").split(/[\.\[\]]/), i = 0, l2 = a.length; i < l2; i++) {
                        v = a[i],
                        o = o[n]
                            ? o[n]
                            : o[n] = (parseInt(v) == v)
                                ? []
                                : {},
                        n = v.replace(/^["\'](.*)["\']$/, "$1");
                    }
                }
                o[n != "-1" ? n : o.length] = unescape(decodeURI(m[3]));
            }
        }
        

        
        // Start HTTP object
        this.oHttp = new this.http();
        

        
        // Load user defined includes
        this.Init.addConditional(this.parseAppMarkup, apf, ["body"]);
        //@todo, as an experiment I removed 'HTTP' and 'Teleport'
        

        //IE fix
        try {
            if (apf.isIE)
                document.execCommand("BackgroundImageCache", false, true);
        }
        catch(e) {}

        
        //apf.window.init();
        

        this.started = true;
        
        
        // DOMReady already fired, so plz continue the loading and parsing
        if (this.load_done)
            this.execDeferred();
        

        //try{apf.root = !window.opener || !window.opener.apf;}
        //catch(e){apf.root = false}
        this.root = true;
        
        
        for (var i = 0; i < apf.$required.length; i++) {
            apf.include(apf.$required[i]);
        }
        apf.require = apf.include;
        
        
        

    },

    nsqueue   : {},

    
    /**
     * @private
     */
    findPrefix : function(xmlNode, xmlns){
        var docEl;
        if (xmlNode.nodeType == 9) {
            if (!xmlNode.documentElement)
                return false;
            if (xmlNode.documentElement.namespaceURI == xmlns)
                return xmlNode.prefix || xmlNode.scopeName;
            docEl = xmlNode.documentElement;
        }
        else {
            if (xmlNode.namespaceURI == xmlns)
                return xmlNode.prefix || xmlNode.scopeName;
            docEl = xmlNode.ownerDocument.documentElement;
            if (docEl && docEl.namespaceURI == xmlns)
                return xmlNode.prefix || xmlNode.scopeName;

            while (xmlNode.parentNode) {
                xmlNode = xmlNode.parentNode;
                if (xmlNode.namespaceURI == xmlns)
                    return xmlNode.prefix || xmlNode.scopeName;
            }
        }

        if (docEl) {
            for (var i = 0; i < docEl.attributes.length; i++) {
                if (docEl.attributes[i].nodeValue == xmlns)
                    return docEl.attributes[i][apf.TAGNAME]
            }
        }

        return false;
    },
    

    /**
     * @private
     */
    importClass : function(ref, strip, win){
        if (!ref)
            throw new Error(apf.formatErrorString(1018, null,
                "importing class",
                "Could not load reference. Reference is null"));

        if (!strip)
            return apf.exec(ref.toString(), win);

        var q = ref.toString().replace(/^\s*function\s*\w*\s*\([^\)]*\)\s*\{/, "")
                              .replace(/\}\s*$/, "");

        return apf.exec(q, win);
    },

    /**
    * This method returns a string representation of the object
    * @return {String}    Returns a string representing the object.
    */
    toString : function(){
        return "[Ajax.org Platform (apf)]";
    },

    all : [],

    /**
    * This method implements all properties and methods to this object from another class
    * @param {Function}    classRef    Class reference
    * @private
    */
    implement : function(classRef) {
        // for speed, we check for the most common  case first
        if (arguments.length == 1) {
            
            if (!classRef) {
                throw new Error(apf.formatErrorString(0, this,
                    "Implementing class",
                    "Could not implement from '" + classRef[i] + "'", this));
            }
            
            classRef.call(this);//classRef
        }
        else {
            for (var a, i = 0, l = arguments.length; i < l; i++) {
                a = arguments[i];
                
                if (!a) {
                    throw new Error(apf.formatErrorString(0, this,
                        "Implementing class",
                        "Could not implement from '" + arguments[i] + "'", this));
                }
                
                arguments[i].call(this);//classRef
            }
        }

        return this;
    },

    /**
     * @private
     */
    uniqueHtmlIds : 0,

    /**
     * Adds a unique id attribute to an html element.
     * @param {HTMLElement} oHtml the object getting the attribute.
     */
    setUniqueHtmlId : function(oHtml){
        var id;
        oHtml.setAttribute("id", id = "q" + this.uniqueHtmlIds++);
        return id;
    },

    /**
     * Retrieves a new unique id
     */
    getUniqueId : function(){
        return this.uniqueHtmlIds++;
    },

    /**
     * Finds a aml element based on it's uniqueId
     */
    lookup : function(uniqueId){
        return this.all[uniqueId];
    },

    /**
     * Searches in the html tree from a certain point to find the
     * aml element that is responsible for rendering the specified html
     * element.
     * @param {HTMLElement} oHtml the html context to start the search from.
     */
    findHost : function(o){
        while (o && o.parentNode) { //!o.host && 
            try {
                if (o.host)
                    break;
            }
            catch(e){}
            
            o = o.parentNode;
        }
        return (o && o.host && typeof o.host != "string") ? o.host : false;
    },

    /**
     * Sets a reference to an object by name in the global javascript space.
     * @param {String} name the name of the reference.
     * @param {mixed}  o    the reference to the object subject to the reference.
     */
    setReference : function(name, o){
        return self[name] && self[name].hasFeature
            ? 0
            : (self[name] = o);
    },

    /**
     * The console outputs to the debug screen and offers differents ways to do
     * this.
     */
    console : {
        
        /**
         * @private
         */
        data : {
            time  : {
                icon     : "time.png",
                color    : "black",
                messages : {}
            },

            info  : {
                icon     : "bullet_green.png",
                color    : "black",
                messages : {}
            },

            warn  : {
                icon     : "error.png",
                color    : "green",
                messages : {}
            },

            error : {
                icon     : "exclamation.png",
                color    : "red",
                messages : {}
            },
            
            repeat : {
                icon     : "bullet_green.png",
                color    : "#AAA",
                messages : {}
            }
        },

        /**
         * @private
         */
        toggle : function(node, id){
            var sPath = apf.debugwin ? apf.debugwin.resPath : apf.basePath + "core/debug/resources/";
            if (node.style.display == "block") {
                node.style.display = "none";
                node.parentNode.style.backgroundImage = "url(" + sPath + "splus.gif)";
                node.innerHTML = "";
            }
            else {
                node.style.display = "block";
                node.parentNode.style.backgroundImage = "url(" + sPath + "smin.gif)";
                node.innerHTML = this.cache[id]
                    .replace(/\&/g, "&amp;")
                    .replace(/\t/g,"&nbsp;&nbsp;&nbsp;")
                    .replace(/ /g,"&nbsp;")
                    .replace(/\</g, "&lt;")
                    .replace(/\n/g, "<br />");

                var p  = node.parentNode.parentNode.parentNode,
                    el = node.parentNode.parentNode;
                if(p.scrollTop + p.offsetHeight < el.offsetTop + el.offsetHeight)
                    p.scrollTop = el.offsetTop + el.offsetHeight - p.offsetHeight;
            }
        },

        cache : [],
        $lastmsg : "",
        $lastmsgcount : 0,

        $detectSameMessage : function(){
            apf.console.$lastmsg = "";
            if (apf.console.$lastmsgcount) {
                var msg = apf.console.$lastmsgcount + " times the same message";
                apf.console.$lastmsgcount = 0;
                apf.console.write(msg, "repeat");
                clearTimeout(apf.console.$timer);
            }
        },

        /**
         * @private
         * @event debug Fires when a message is sent to the console.
         *   object:
         *      {String} message the content of the message.
         */
        write : function(msg, type, subtype, data, forceWin, nodate){
            clearTimeout(this.$timer);
            if (msg == this.$lastmsg) {
                this.$lastmsgcount++;
                this.$timer = $setTimeout(this.$detectSameMessage, 1000);
                return;
            }

            this.$detectSameMessage();
            this.$lastmsg = msg;
            this.$timer = $setTimeout(this.$detectSameMessage, 1000);
            
            //if (!apf.debug) return;
            if (!Number.prototype.toPrettyDigit) {
                Number.prototype.toPrettyDigit = function() {
                    var n = this.toString();
                    return (n.length == 1) ? "0" + n : n;
                }
            }

            var dt   = new Date(),
                ms   = String(dt.getMilliseconds());
            while (ms.length < 3)
                ms += "0";
            var date = dt.getHours().toPrettyDigit()   + ":"
                     + dt.getMinutes().toPrettyDigit() + ":"
                     + dt.getSeconds().toPrettyDigit() + "." + ms;

            msg = (!nodate ? "[" + date + "] " : "")
                    + String(msg)
                        .replace(/ /g, "&nbsp;")
                        .replace(/\n/g, "\n<br />")
                        .replace(/\t/g,"&nbsp;&nbsp;&nbsp;");
            var sPath = apf.debugwin
                ? (apf.debugwin.resPath || "{imgpath}")
                : apf.basePath + "core/debug/resources/";

            if (data) {
                msg += "<blockquote style='margin:2px 0 0 0;"
                    +  "background:url(" + sPath + "splus.gif) no-repeat 2px 3px'>"
                    +  "<strong style='width:120px;cursor:default;display:block;padding:0 0 0 17px' "
                    +  "onmousedown='(self.apf || window.opener.apf).console.toggle(this.nextSibling, "
                    +  (this.cache.push(data) - 1) + ")'>More information"
                    +  "</strong><div style='display:none;background-color:#EEEEEE;"
                    +  "padding:3px 3px 20px 3px;overflow:auto;max-height:200px'>"
                    +  "</div></blockquote>";
            }

            msg = "<div style='min-height:15px;padding:2px 2px 2px 22px;"
                + "line-height:15px;border-bottom:1px solid #EEE;background:url("
                + sPath + this.data[type].icon + ") no-repeat 2px 2px;color:"
                + this.data[type].color + "'>" + msg + "\n<br style='line-height:0'/></div>";

            if (!subtype)
                subtype = "default";

            if (!this.data[type].messages[subtype])
                this.data[type].messages[subtype] = [];

            this.data[type].messages[subtype].push(msg);

            if (this.win && !this.win.closed)
                this.showWindow(msg);

            //if (apf.debugFilter.match(new RegExp("!" + subtype + "(\||$)", "i")))
            //    return;

            this.debugInfo.push(msg);

            if (apf.dispatchEvent)
                apf.dispatchEvent("debug", {message: msg});
        },
        

        /**
         * Writes a message to the console.
         * @param {String} msg      the message to display in the console.
         * @param {String} subtype  the category for this message. This is used for filtering the messages.
         * @param {String} data     extra data that might help in debugging.
         */
        debug : function(msg, subtype, data){
            
            this.write(msg, "time", subtype, data);
            
        },

        /**
         * Writes a message to the console with the time icon next to it.
         * @param {String} msg      the message to display in the console.
         * @param {String} subtype  the category for this message. This is used for filtering the messages.
         * @param {String} data     extra data that might help in debugging.
         */
        time : function(msg, subtype, data){
            
            this.write(msg, "time", subtype, data);
            
        },

        /**
         * Writes a message to the console.
         * @param {String} msg      the message to display in the console.
         * @param {String} subtype  the category for this message. This is used for filtering the messages.
         * @param {String} data     extra data that might help in debugging.
         */
        log : function(msg, subtype, data){
            
            this.info(msg, subtype, data);
            
        },

        /**
         * Writes a message to the console with the visual "info" icon and color
         * coding.
         * @param {String} msg      the message to display in the console.
         * @param {String} subtype  the category for this message. This is used for filtering the messages.
         * @param {String} data     extra data that might help in debugging.
         */
        info : function(msg, subtype, data){
            
            this.write(msg, "info", subtype, data);
            
        },

        /**
         * Writes a message to the console with the visual "warning" icon and
         * color coding.
         * @param {String} msg      the message to display in the console.
         * @param {String} subtype  the category for this message. This is used for filtering the messages.
         * @param {String} data     extra data that might help in debugging.
         */
        warn : function(msg, subtype, data){
            
            this.write(msg, "warn", subtype, data);
            
        },

        /**
         * Writes a message to the console with the visual "error" icon and
         * color coding.
         * @param {String} msg      the message to display in the console.
         * @param {String} subtype  the category for this message. This is used for filtering the messages.
         * @param {String} data     extra data that might help in debugging.
         */
        error : function(msg, subtype, data){
            
            this.write(msg, "error", subtype, data);
            
        },

        /**
         * Prints a listing of all properties of the object.
         * @param {mixed} obj the object for which the properties are displayed.
         */
        dir : function(obj){
            this.info(apf.vardump(obj, null, false).replace(/ /g, "&nbsp;").replace(/</g, "&lt;"));
        }

        
        ,
        debugInfo : [],
        debugType : "",

        /**
         * Shows a browser window with the contents of the console.
         * @param {String} msg a new message to add to the new window.
         */
        showWindow : function(msg){
            if (!this.win || this.win.closed) {
                this.win = window.open("", "debug");
                this.win.document.write(
                    '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'
                  + '<body style="margin:0;font-family:Verdana;font-size:8pt;"></body>');
            }
            if (!this.win) {
                if (!this.haspopupkiller)
                    alert("Could not open debug window, please check your popupkiller");
                this.haspopupkiller = true;
            }
            else {
                this.win.document.write((msg || this.debugInfo.join(""))
                    .replace(/\{imgpath\}/g, apf.debugwin
                        ? apf.debugwin.resPath
                        : apf.basePath + "core/debug/resources/"));
            }
        }

        
    },

    /**
     * Formats a Ajax.org Platform error message.
     * @param {Number}      number      the number of the error. This can be used to look up more information about the error.
     * @param {AMLElement}  control     the aml element that will throw the error.
     * @param {String}      process     the action that was being executed.
     * @param {String}      message     the actual error message.
     * @param {XMLElement}  amlContext  the xml relevant to the error. For instance a piece of Ajax.org Markup Language xml.
     */
    formatErrorString : function(number, control, process, message, amlContext, outputname, output){
        
        var str = ["---- APF Error ----"];
        if (amlContext) {
            if (amlContext.nodeType == 9)
                amlContext = amlContext.documentElement;

            //Determine file context
            if (amlContext.ownerDocument.documentElement) {
                var file = amlContext.ownerDocument.documentElement.getAttribute("filename");
                if (!file && amlContext.ownerDocument.documentElement.tagName == "html")
                    file = location.href;
                file = file
                    ? apf.removePathContext(apf.hostPath, file)
                    : "Unkown filename";
            }
            else file = "Unknown filename";

            //Get serialized version of context
            var amlStr = (amlContext.outerHTML || amlContext.xml || amlContext.serialize())
                .replace(/\<\?xml\:namespace prefix = j ns = "http\:\/\/ajax.org\/2005\/aml" \/\>/g, "")
                .replace(/xmlns:a="[^"]*"\s*/g, "");

            //Determine line number
            var diff, linenr = 0, w = amlContext.previousSibling
                || amlContext.parentNode && amlContext.parentNode.previousSibling;
            while (w && w[apf.TAGNAME] != "body") {
                diff    = (w.outerHTML || w.xml || w.serialize()).split("\n").length;
                linenr += diff - 1;
                w       = w.previousSibling || w.parentNode && w.parentNode.previousSibling;
            }
            if (w && w[apf.TAGNAME] != "body")
                linenr = "unknown";
            else if(amlContext.ownerDocument 
              && amlContext.ownerDocument.documentElement.tagName == "html")
                linenr += apf.lineBodyStart;

            //Grmbl line numbers are wrong when \n's in attribute space

            //Set file and line number
            str.push("aml file: [line: " + linenr + "] " + file);
        }
        if (control)
            str.push("Control: '"
                + (control.name
                    || (control.$aml ? control.getAttribute("id") : null)
                    || "{Anonymous}")
                + "' [" + control.tagName + "]");
        if (process)
            str.push("Process: " + process.replace(/ +/g, " "));
        if (message)
            str.push("Message: [" + number + "] " + message.replace(/ +/g, " "));
        if (outputname)
            str.push(outputname + ": " + output);
        if (amlContext)
            str.push("\n===\n" + amlStr);
        
        return (apf.lastErrorMessage = str.join("\n"));
        
    },

    /* Init */

    /**
     * Returns the directory portion of a url
     * @param {String} url the url to retrieve from.
     * @return {String} the directory portion of a url.
     */
    getDirname : function(url){
        return ((url || "").match(/^([^#]*\/)[^\/]*(?:$|\#)/) || {})[1]; //Mike will check out how to optimize this line
    },
    
    /**
     * Returns the file portion of a url
     * @param {String} url the url to retrieve from.
     * @return {String} the file portion of a url.
     */
    getFilename : function(url){
        return ((url || "").split("?")[0].match(/(?:\/|^)([^\/]+)$/) || {})[1];
    },
    
    /**
     * Returns an absolute url based on url.
     * @param {String} base the start of the url to which relative url's work.
     * @param {String} url  the url to transform.
     * @return {String} the absolute url.
     */
    getAbsolutePath : function(base, url){
        return !url || !base || url.match(/^\w+\:\/\//) ? url : base.replace(/\/$/, "") + "/" + url;
    },

    /**
     * Loads javascript from a url.
     * 
     * @param {String}  sourceFile the url where the javascript is located.
     * @param {Boolean} [doBase]   check for basePath, otherwise prepend it
     * @param {String}  [type]     set the type of a script tag, for later use
     * @type  {void}
     */
    include : function(sourceFile, doBase, type){
        apf.console.info("including js file: " + sourceFile);

        var sSrc = doBase ? apf.getAbsolutePath(apf.basePath || "", sourceFile) : sourceFile;
        if (apf.isSafariOld && !apf.started) {
            document.write('<script type="text/javascript" src="' + sSrc + '"><\/script>');
        }
        else {
            var head     = document.getElementsByTagName("head")[0],//$("head")[0]
                elScript = document.createElement("script");
            //elScript.defer = true;
            if (type)
                elScript.setAttribute("_apf_type", type);
            elScript.src   = sSrc;
            head.appendChild(elScript);
        }
    },
    
    $required : [],
    require : function(){
        var dir = apf.getDirname(location.href),
            i   = 0,
            l   = arguments.length;
        for (; i < l; i++)
            this.$required.push(apf.getAbsolutePath(dir, arguments[i]));
    },

    /**
     * @private
     */
    Init : {
        queue : [],
        cond  : {
            combined : []
        },
        done  : {},

        add   : function(func, o){
            if (this.inited)
                func.call(o);
            else if (func)
                this.queue.push([func, o]);
        },

        addConditional : function(func, o, strObj){
            if (typeof strObj != "string") {
                if (this.checkCombined(strObj))
                    return func.call(o);
                this.cond.combined.push([func, o, strObj]);
            }
            else if (self[strObj]) {
                func.call(o);
            }
            else {
                if (!this.cond[strObj])
                    this.cond[strObj] = [];
                this.cond[strObj].push([func, o]);

                this.checkAllCombined();
            }
        },

        checkAllCombined : function(){
            for (var i = 0; i < this.cond.combined.length; i++) {
                if (!this.cond.combined[i]) continue;

                if (this.checkCombined(this.cond.combined[i][2])) {
                    this.cond.combined[i][0].call(this.cond.combined[i][1])
                    this.cond.combined[i] = null;
                }
            }
        },

        checkCombined : function(arr){
            for (var i = 0; i < arr.length; i++) {
                if (!this.done[arr[i]])
                    return false;
            }

            return true;
        },

        run : function(strObj){
            this.inited = this.done[strObj] = true;

            this.checkAllCombined();

            var data = strObj ? this.cond[strObj] : this.queue;
            if (!data) return;
            for (var i = 0; i < data.length; i++)
                data[i][0].call(data[i][1]);
        }
    },

    
    
    
    /**
     * @private
     */
    amlParts : [],
    

    /**
     * Determines the way apf tries to render this application. Set this value
     * before apf is starts parsing.
     *   Possible values:
     *   0    auto
     *   1    partial
     *   11   partial from a comment
     *   2    full from serialized document or file fallback
     *   21   full from file
     * @type {Number}
     */
    parseStrategy : 0,

    
    /**
     * @private
     */
    parsePartialAml : function(docElement){
        
        apf.console.warn("The aml namespace definition wasn't found "
                       + "on the root node of this document. We're assuming "
                       + "you want to load a partial piece of aml embedded "
                       + "in this document. Starting to search for it now.");
        

        var findAml;
        if (apf.isIE) {
            findAml = function(htmlNode){
                
                if (htmlNode.outerHTML.match(/\/>$/)) {
                    throw new Error("Cannot have self closing elements!\n"
                        + htmlNode.outerHTML);
                }
                
                
                try {
                    var tags   = {"IMG":1,"LINK":1,"META":1,"INPUT":1,"BR":1,"HR":1,"AREA":1,"BASEFONT":1},
                        regex  = new RegExp(htmlNode.outerHTML.replace(/([\(\)\|\\\.\^\$\{\}\[\]])/g, "\\$1")
                               + ".*" + htmlNode.tagName),
                        match  = htmlNode.parentNode.outerHTML.replace(/\n/g, "").match(regex),
                        strXml = match[0] + ">"
                            .replace(/(\w+)\s*=\s*([^\>="'\s ]+)( |\s|\>|\/\>)/g, "$1=\"$2\"$3")
                            .replace(/ disabled /g, " disabled='true' ")
                            .replace(/\]\]\&gt;/g, "]]>")
                            .replace(/<(\w+)(\s[^>]*[^\/])?>/g, function(m, tag, c){
                                if (tags[tag]) {
                                    return "<" + tag + (c||"") + "/>";
                                }
                                else {
                                    return m;
                                }
                            });
                } 
                catch(e) {
                    
                    throw new Error(apf.formatErrorString(0, null,
                        "Parsing inline aml (without xmlns on root node)",
                        "Could not parse inline aml. This happens when the html"
                      + "is mangled too much by Internet Explorer. Either you "
                      + "are using a cdata section or javascript containing "
                      + "symbols that throw off the browser. Please put this aml "
                      + "in a seperate file and load it using an include element."));
                    
                    
                    return;
                }

                var xmlNode = apf.getAmlDocFromString("<div jid='"
                            + (id++) + "' " + strXmlns + ">"
                            + strXml + "</div>").documentElement;

                while (xmlNode.childNodes.length > 1)
                    xmlNode.removeChild(xmlNode.lastChild);

                apf.AppNode.appendChild(xmlNode);
            }
        }
        else {
            findAml = function(htmlNode){
                var strXml  = htmlNode.outerHTML.replace(/ _moz-userdefined=""/g, ""),
                    xmlNode = apf.getAmlDocFromString("<div jid='"
                            + (id++) + "' " + strXmlns + ">"
                            + strXml + "</div>").documentElement;

                while (xmlNode.childNodes.length > 1)
                    xmlNode.removeChild(xmlNode.lastChild);

                if (apf.isWebkit)
                    xmlNode = apf.AppNode.ownerDocument.importNode(xmlNode, true);

                apf.AppNode.appendChild(xmlNode);
            }
        }

        var match = document.body.outerHTML
                    .match(/(\w+)\s*=\s*["']http:\/\/ajax\.org\/2005\/aml["']/);
        if (!match)
            return false;

        var strXmlns = "xmlns:" + match[0],
            prefix = (RegExp.$1 || "").toUpperCase();
        if (apf.isOpera)
            prefix = prefix.toLowerCase();
        if (!prefix)
            return false;

        prefix += ":";

        apf.AppNode = apf.getAmlDocFromString("<" + prefix.toLowerCase()
            + "application " + strXmlns + " />").documentElement;

        var temp, loop, cnode,
            isPrefix = false,
            id       = 0,
            node     = document.body;
        while (node) {
            isPrefix = node.nodeType == 1
                && node.tagName.substr(0,2) == prefix;

            if (isPrefix) {
                findAml(cnode = node);

                if (apf.isIE) {
                    loop = node;
                    var count = 1, next = loop.nextSibling;
                    if (next) {
                        loop.parentNode.removeChild(loop);

                        while (next && (next.nodeType != 1 || next.tagName.indexOf(prefix) > -1)){
                            if (next.nodeType == 1)
                                count += next.tagName.charAt(0) == "/" ? -1 : 1;

                            if (count == 0) {
                                if (temp)
                                    temp.parentNode.removeChild(temp);
                                temp = next;
                                break;
                            }

                            next = (loop = next).nextSibling;
                            if (!next) {
                                next = loop;
                                break;
                            }
                            if (loop.nodeType == 1) {
                                loop.parentNode.removeChild(loop);
                                if (temp) {
                                    temp.parentNode.removeChild(temp);
                                    temp = null;
                                }
                            }
                            else {
                                if (temp)
                                    temp.parentNode.removeChild(temp);

                                temp = loop;
                            }
                        }

                        node = next; //@todo item should be deleted
                        //check here for one too far
                    }
                    else {
                        if (temp)
                            temp.parentNode.removeChild(temp);
                        temp = loop;
                    }
                }
                else {
                    if (temp)
                        temp.parentNode.removeChild(temp);

                    temp = node;
                    //node = node.nextSibling;
                }

                if (apf.amlParts.length
                  && apf.amlParts[apf.amlParts.length-1][1] == cnode)
                    apf.amlParts[apf.amlParts.length-1][1] = -1;

                apf.amlParts.push([node.parentNode, apf.isIE
                    ? node.nextSibling : node.nextSibling]);
            }
            else if (node.tagName == "SCRIPT" && node.getAttribute("src")
              && (node.getAttribute("src").indexOf("ajax.org") > -1)) {
                var strXml = node.outerHTML
                    .replace(/&lt;/g, "<")
                    .replace(/&gt;/g, ">")
                    .replace(/&amp;/g, "&")
                    .replace(/<SCRIPT[^>]*\>\s*<\!\[CDATA\[>?/i, "")
                    .replace(/<SCRIPT[^>]*\>(?:<\!\-\-)?/i, "")
                    .replace(/(\/\/)?\s*\&\#8211;>\s*<\/SCRIPT>/i, "")
                    .replace(/\-\->\s*<\/SCRIPT>/i, "")
                    .replace(/\]\](?:\&gt\;|>)\s*<\/SCRIPT>/i, "")
                    .replace(/<\/SCRIPT>$/mi, "")
                    .replace(/<\/?\s*(?:p|br)\s*\/?>/ig, "")
                    .replace(/<\!--\s*.*?\s*-->\s*<script.*/ig, "")
                    .replace(/\\+(['"])/g, "$1");

                if (strXml.trim()) {
                    var xmlNode = apf.getAmlDocFromString("<div jid='"
                        + (id++) + "' " + strXmlns + ">"
                        + strXml + "</div>").documentElement;

                    if (apf.isWebkit)
                        xmlNode = apf.AppNode.ownerDocument.importNode(xmlNode, true);

                    apf.AppNode.appendChild(xmlNode);

                    apf.amlParts.push([node.parentNode, node.nextSibling]);
                }
            }

            //Walk entire html tree
            if (!isPrefix && node.firstChild
              || node.nextSibling) {
                if (!isPrefix && node.firstChild) {
                    node = node.firstChild;
                }
                else {
                    node = node.nextSibling;
                }
            }
            else {
                do {
                    node = node.parentNode;

                    if (node.tagName == "BODY")
                        node = null;

                } while (node && !node.nextSibling)

                if (node) {
                    node = node.nextSibling;
                }
            }
        }

        if (temp)
            temp.parentNode.removeChild(temp);
    },
    

    /**
     * @private
     */
    parseAppMarkup : function(docElement){
        var isEmptyDocument = false;
        
        
        if (this.parseStrategy == 1 || !this.parseStrategy && !docElement
          && document.documentElement.outerHTML.split(">", 1)[0]
             .indexOf(apf.ns.aml) == -1) {
            this.parsePartialAml(docElement);

            if (this.parseStrategy == 1 || apf.amlParts.length) {
                
                if (apf.amlParts.length)
                    apf.console.warn("Aml found, parsing...");
                

                apf.isParsingPartial = true;

                apf.loadAmlIncludes(apf.AppNode);

                if (!self.ERROR_HAS_OCCURRED) {
                    apf.initialize();
                }

                return;
            }
            else {
                
                apf.console.warn("No aml found.");
                
                isEmptyDocument = true;
            }
        }
        

        

        

        
        if (isEmptyDocument && document.documentElement.outerHTML
          .split(">", 1)[0]
          .indexOf(apf.ns.aml) == -1) {
            
            apf.console.warn("The aml namespace declaration wasn't found. "
                           + "No aml elements were found in the body. Exiting");
            
            return false;
        }

        //Load current HTML document as 'second DOM'
        if (this.parseStrategy == 21 || !this.parseStrategy && !docElement) {
            return apf.oHttp.get((apf.alternativeAml 
              || document.body && document.body.getAttribute("xmlurl") 
              || location.href).split(/#/)[0], {
                callback: function(xmlString, state, extra){
                    if (state != apf.SUCCESS) {
                        var oError = new Error(apf.formatErrorString(0, null,
                            "Loading XML application data", "Could not load "
                          + "XML from remote source: " + extra.message));

                        if (extra.tpModule.retryTimeout(extra, state, null, oError) === true)
                            return true;

                        throw oError;
                    }

                    
                    apf.lineBodyStart = (xmlString.replace(/\n/g, "\\n")
                        .match(/(.*)<body/) || [""])[0].split("\\n").length;
                    

                    //@todo apf3.0 rewrite this flow
                    var str = xmlString.replace(/\<\!DOCTYPE[^>]*>/, "")
                      .replace(/&nbsp;/g, " ").replace(/^[\r\n\s]*/, "");
                    if (!apf.supportNamespaces)
                        str = str.replace(/xmlns\=\"[^"]*\"/g, "");
                    //var xmlNode = apf.getXmlDom(str);//apf.getAmlDocFromString(xmlString);

                    if (self.ERROR_HAS_OCCURRED)
                        return;

                    //Clear Body
                    if (apf.isIE)
                        document.body.innerHTML ="";
                    else {
                        var nodes = document.body.childNodes;
                        for (var i = nodes.length - 1; i >= 0; i--)
                            nodes[i].parentNode.removeChild(nodes[i]);
                    }

                    
                    document.body.style.display = "block"; //might wanna make this variable based on layout loading...
                    

                    apf.initialize(str);

                }, ignoreOffline: true});
        }
        else {
            
            //might wanna make this variable based on layout loading...
            document.body.style.display = "block";
            

            if (!self.ERROR_HAS_OCCURRED)
                apf.initialize(docElement.outerHTML || docElement.xml);
        }
        
    },
    
    namespaces : {},
    setNamespace : function(namespaceURI, oNamespace){
        this.namespaces[namespaceURI] = oNamespace;
        oNamespace.namespaceURI = namespaceURI;
    },

    /**
     * @private
     */
    initialize : function(xmlStr){
        
        if (apf.initialized) return;
        apf.initialized = true;
        

        

        apf.console.info("Initializing...");
        clearInterval(apf.Init.interval);

        // Run Init
        apf.Init.run(); //Process load dependencies
        
        
        
        var bodyMarginTop = parseFloat(apf.getStyle(document.body, "marginTop"));
        apf.doesNotIncludeMarginInBodyOffset = (document.body.offsetTop !== bodyMarginTop);

        
        if (apf.isParsingPartial) {
            apf.config.setDefaults();
            apf.hasSingleRszEvent = true;

            var pHtmlNode = document.body;
            var lastChild = pHtmlNode.lastChild;
            apf.AmlParser.parseMoreAml(apf.AppNode, pHtmlNode, null,
                true, false);

            var pNode, firstNode, next, info,
                lastBefore = null,
                loop       = pHtmlNode.lastChild;
            while (loop && lastChild != loop) {
                info = apf.amlParts[loop.getAttribute("jid")];
                next = loop.previousSibling;
                if (info) {
                    pNode = info[0];
                    if ("P".indexOf(pNode.tagName) > -1) {
                        lastBefore = pNode.parentNode.insertBefore(
                            apf.getNode(loop, [0]), pNode);
                    }
                    else {
                        firstNode = apf.getNode(loop, [0]);
                        while(firstNode){
                            if (firstNode) {
                                lastBefore = pNode.insertBefore(firstNode,
                                    typeof info[1] == "number" ? lastBefore : info[1]);
                            }
                            else {
                                lastBefore = typeof info[1] == "number" 
                                    ? lastBefore
                                    : info[1];
                            }
                            firstNode = apf.getNode(loop, [0]);
                        }
                    }

                    loop.parentNode.removeChild(loop);
                }
                loop = next;
            }

            
            $setTimeout("apf.layout.forceResize();");
            
        }
        else
        
        {
            apf.window.init(xmlStr);
        }
    },

    
    /**
     * @private
     */
    execDeferred: function() {
        // execute each function in the stack in the order they were added
        var len = apf.load_events.length;
        while (len--)
            (apf.load_events.shift())();
    },

    load_events: [],
    load_timer : null,
    load_done  : false,
    load_init  : null,

    /**
     * @private
     */
    addDomLoadEvent: function(func) {
        if (!this.$bdetect)
            this.browserDetect();

        if (apf.load_done)
            return func();

        // create event function stack
        //apf.done = arguments.callee.done;
        if (!apf.load_init) {
            apf.load_init = function() {
                if (apf.load_done) return;
                // kill the timer
                clearInterval(apf.load_timer);
                apf.load_timer = null;
                apf.load_done  = true;
                if (apf.started)
                    apf.execDeferred();
            };
        }

        apf.load_events.push(func);

        if (func && apf.load_events.length == 1) {
            // Catch cases where addDomLoadEvent() is called after the browser
            // event has already occurred.
            var doc = document, UNDEF = "undefined";
            if ((typeof doc.readyState != UNDEF && doc.readyState == "complete")
              || (typeof doc.readyState == UNDEF && (doc.getElementsByTagName("body")[0] || doc.body)))
                return apf.load_init();

            // for Mozilla/Opera9.
            // Mozilla, Opera (see further below for it) and webkit nightlies
            // currently support this event
            if (doc.addEventListener && !apf.isOpera) {
                // We're using "window" and not "document" here, because it results
                // in a memory leak, especially in FF 1.5:
                // https://bugzilla.mozilla.org/show_bug.cgi?id=241518
                // See also:
                // http://bitstructures.com/2007/11/javascript-method-callbacks
                // http://www-128.ibm.com/developerworks/web/library/wa-memleak/
                window.addEventListener("DOMContentLoaded", apf.load_init, false);
            }
            // If IE is used and is not in a frame
            else if (apf.isIE && window == top) {
                apf.load_timer = setInterval(function() {
                    try {
                        // If IE is used, use the trick by Diego Perini
                        // http://javascript.nwbox.com/IEContentLoaded/
                        doc.documentElement.doScroll("left");
                    }
                    catch(ex) {
                        $setTimeout(arguments.callee, 0);
                        return;
                    }
                    // no exceptions anymore, so we can call the init!
                    apf.load_init();
                }, 10);
            }
            else if (apf.isOpera) {
                doc.addEventListener("DOMContentLoaded", function() {
                    apf.load_timer = setInterval(function() {
                        for (var i = 0, l = doc.styleSheets.length; i < l; i++) {
                            if (doc.styleSheets[i].disabled)
                                return;
                        }
                        // all is fine, so we can call the init!
                        apf.load_init();
                    }, 10);
                }, false);
            }
            else if (apf.isWebkit && !apf.isIphone) {
                var aSheets = doc.getElementsByTagName("link"),
                    i       = aSheets.length,
                    iSheets;
                for (; i >= 0; i++) {
                    if (!aSheets[i] || aSheets[i].getAttribute("rel") != "stylesheet")
                        aSheets.splice(i, 0);
                }
                iSheets = aSheets.length;
                apf.load_timer  = setInterval(function() {
                    if (/loaded|complete/.test(doc.readyState)
                      && doc.styleSheets.length == iSheets)
                        apf.load_init(); // call the onload handler
                }, 10);
            }
            // for other browsers set the window.onload, but also execute the
            // old window.onload
            else {
                var old_onload = window.onload;
                window.onload  = function () {
                    apf.load_init();
                    if (old_onload)
                        old_onload();
                };
            }
        }
    },
    
    
    /**
     * @private
     */
    addListener : function(el, type, fn){
        if (el.addEventListener)
            el.addEventListener(type, fn, false);
        else if (el.attachEvent)
            el.attachEvent("on" + type, fn);
        return this;
    },
    
    /**
     * @private
     */
    removeListener : function(el, type, fn){
        if (el.removeEventListener)
            el.removeEventListener(type, fn, false);
        else if (el.detachEvent)
            el.detachEvent("on" + type, fn);
        return this;
    },

    /* Destroy */

    /**
     * Unloads the aml application.
     */
    unload : function(exclude){
        
        apf.console.info("Initiating self destruct...");
        

        this.isDestroying = true;

        
        this.popup.destroy();
        

        var node,
            i = 0,
            l = this.all.length;
        for (; i < l; i++) {
            node = this.all[i];
            if (node && node != exclude && node.destroy && !node.apf)
                node.destroy(false);
        }

        //this.dispatchEvent("DOMNodeRemovedFromDocument", {});//@todo apf3.0
        
        for (i = 0, l = this.availHTTP.length; i < l; i++)
            this.availHTTP[i] = null;
        
        this.availHTTP.length = 0;

        
        if (apf.xmldb)
            apf.xmldb.unbind(apf.window);
        

        this.isDestroying = false;
    }
};

/*
 * Replacement for getElementsByTagNameNS because some browsers don't support
 * this call yet.
 */
var $xmlns = function(xmlNode, tag, xmlns, prefix){
    if (!apf.supportNamespaces) {
        if (!prefix)
            prefix = apf.findPrefix(xmlNode, xmlns);

        if (xmlNode.style || xmlNode == document)
            return xmlNode.getElementsByTagName(tag)
        else {
            if (prefix)
                (xmlNode.nodeType == 9 ? xmlNode : xmlNode.ownerDocument)
                    .setProperty("SelectionNamespaces",
                        "xmlns:" + prefix + "='" + xmlns + "'");

            return xmlNode.selectNodes(".//" + (prefix ? prefix + ":" : "") + tag);
        }
    }
    
    return xmlNode.getElementsByTagNameNS(xmlns, tag);
};

var $setTimeout  = setTimeout;
var $setInterval = setInterval;

document.documentElement.className += " has_apf";
apf.browserDetect();
apf.Init.run("apf");





/*FILEHEAD(/var/lib/platform/source/trunk/core/class.js)SIZE(39736)TIME(1265021706)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @term propertybinding With property binding you can define the way a 
 * property is calculated. <img src="http://www.rubendaniels.com/images/propbind.gif" align="right" />
 * This statement is usually based on a javascript 
 * expression including one or more properties on other objects. The value of 
 * the property will always be kept up to date. This means that when one of the 
 * dependent properties changes, the property is recalculated. See the picture 
 * for a graphical explanation. 
 * Example:
 * Let me give you an example to make it a bit straightforward. This example 
 * sets the visibility of the slider based on the state of the checkbox.
 * <code>
 *  <a:slider visible="{myCheckbox.value}" />
 *  <a:checkbox id="myCheckbox">Toggle this</a:checkbox>
 * </code>
 *
 * Expressions:
 * The use of { and } tell Ajax.org Platform(JPF) that the visible property will 
 * be bound. By specifying myCheckbox.value JPF knows that the value of 
 * myCheckbox should be retrieved for this property. Whenever the checkbox 
 * changes, the slider will show or hide.
 *
 * Bidirectional:
 * Sometimes it's necessary to make a binding from one property to another one, 
 * and vice versa. Think of a slider that is connected to the position property
 * of a video element. When the video plays, the value of the slider should be 
 * updated. When the slider is dragged the video should be updated. This works 
 * in the same way as above, but instead of using curly braces 
 * you use brackets: [ and ]. The next example keeps the state of a dropdown in 
 * sync with the state of the tab page.
 * <code>
 *  <a:tab activepage="[myDropdown.value]">
 *     <a:page caption="Page 1" />
 *     <!-- etc -->
 *  </a:tab>
 *  <a:dropdown id="myDropdown">
 *     <a:item value="0">Page 1</a:item>
 *     <!-- etc -->
 *  </a:dropdown>
 * </code>
 *
 * For more information visit {@link http://www.rubendaniels.com/2008/07/04/property-binding/ this blog article}.</a>
 *
 * Internals:
 * Property binding in apf is a flavor of a {@link http://en.wikipedia.org/wiki/Publish/subscribe publish/subscribe}
 * system. When a binding is established the element that receives the value sets
 * a listener on the property of another element. There can be any number of 
 * elements referenced in a single expression. When any of the properties that 
 * are listened to change, the subscriber gets notified to update the value
 * of it's property.
 */

/**
 * @term baseclass A baseclass in Ajax.org Platform (apf) is a class that 
 * adds properties, methods, attributes, bindings and actions to the class that
 * inherits from it. Javascript doesn't have most object oriented concepts like
 * classes, class inheritance, interfaces, protected members and so on. When
 * using apf you will find that some of these concepts have
 * been implemented in a way that enables the core developers of apf to think in
 * those concepts. The most important one is class inheritance. Because of the
 * freedoms that javascript allows, it is possible to implement
 * {@link http://en.wikipedia.org/wiki/Inheritance_(computer_science) inheritance}
 * and even {@link http://en.wikipedia.org/wiki/Multiple_inheritance multiple inheritance}.
 * 
 * Usage:
 * In apf multiple inheritance is used on all elements to assign specific traits
 * to aml elements. Check the list of baseclasses on the right to familiarize 
 * yourself with the traits that are available (i.e. dragdrop, rename, multiselect,
 * databinding, alignment, etc). At the article of each element that inherits
 * from a baseclass you will find an inheritance tree on the right. This tree
 * will show you <strong>from which baseclasses that element has received traits</strong>.
 * Compared to Java and other strict OOP languages, the inheritance tree is
 * inverted. To give an example, in Java for instance, a Lamborghini inherits from 
 * Car which inherits from Vehicle. In apf Audi inherits from Engine, Wheels,
 * Seats and Airco. So we can make the latest Lamborghini inherit from Airco too.
 *
 * Class:
 * The apf.Class baseclass provides all basic features a apf element needs, such
 * as event system, property binding and multiple inheritance with state defined
 * by each baseclass.
 * By setting the prototype of a function to an instance of apf.Class 
 * these  <i title="an inherited characteristic (merriam-webster)">traits</i> are
 * transferred to your class.
 *
 * API:
 * The first method is the one that tells an object to implement traits from a
 * baseclass.
 * It works as follows:
 * <code>
 *  var myClass = function(){
 *      this.$init();
 *  }
 *  myClass.prototype = new apf.Class();
 * </code>
 * There is a class tree that you can use to create your own elements. For 
 * instance to create a visible element that uses skinning you can inherit from
 * apf.Presentation:
 * <code>
 *  var myElement = function(){
 *      this.$init();
 *  }
 *  myElement.prototype = new apf.Presentation();
 * </code>
 * Please find a full description of the inheritance tree below.
 *
 * To check whether an object has inherited from baseclass use the following
 * syntax:
 * <code>
 *  myObj.hasFeature(apf.__PRESENTATION__);
 * </code>
 * Where the constant is the name of the baseclass in all caps.
 *
 * Apf supports multiple inheritance. Use the implement method to add a 
 * baseclass to your class that is not part of the inheritance tree:
 * <code>
 *  var myElement = function(){
 *      this.$init();
 *
 *      this.implement(apf.Rename);
 *  }
 *  myElement.prototype = new apf.MultiSelect();
 * </code>
 * 
 * Inheritance Tree:
 * <code>
 *  - apf.Class
 *      - apf.AmlNode
 *          - apf.AmlElement
 *              - apf.Teleport
 *              - apf.GuiElement
 *                  - apf.Presentation
 *                      - apf.BaseTab
 *                      - apf.DataBinding
 *                          - apf.StandardBinding
 *                              - apf.BaseButton
 *                              - apf.BaseSimple
 *                              - apf.Media
 *                          - apf.MultiselectBinding
 *                              - apf.MultiSelect
 *                                  - apf.BaseList
 * </code>
 * Generally elements inherit from AmlElement, Presentation, StandardBinding, 
 * MultiselectBinding, or one of the leafs.
 *
 * The following classes are implemented using the implement method:
 * <code>
 * - apf.Cache
 * - apf.ChildValue
 * - apf.ContentEditable
 * - apf.DataAction
 * - apf.Media
 * - apf.MultiCheck
 * - apf.Rename
 * - apf.Xforms
 * </code>
 *
 * The following classes are automatically implemented when needed by apf.GuiElement.
 * <code>
 * - apf.Alignment
 * - apf.Anchoring
 * - apf.Docking
 * - apf.DelayedRender
 * - apf.DragDrop
 * - apf.Focussable
 * - apf.Interactive
 * - apf.Transaction
 * - apf.Validation
 * </code>
 *
 * The following class is automatically implemented by apf.MultiselectBinding
 * <code>
 * - apf.VirtualViewport
 * </code>
 */

/**
 * All elements that implemented this {@link term.baseclass baseclass} have
 * {@link term.propertybinding property binding},
 * event handling and constructor & destructor hooks. The event system is 
 * implemented following the W3C specification, similar to the 
 * {@link http://en.wikipedia.org/wiki/DOM_Events event system of the HTML DOM}.
 *
 * @constructor
 * @baseclass
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 *
 * @event propertychange Fires when a property changes.
 *   object:
 *     {String} name          the name of the changed property
 *     {Mixed}  originalvalue the value it had before the change
 *     {Mixed}  value         the value it has after the change
 *
 */
apf.Class = function(){};

apf.Class.prototype = new (function(){
    // privates
    var FUN   = "function",
        OBJ   = "object",
        UNDEF = "undefined",
        SEL   = "selected|selection"
        PROP  = "prop.",
        MODEL = "model",
        VALUE = "value";

    this.$regbase   = 0;
    /**
     * Tests whether this object has implemented a {@link term.baseclass baseclass}.
     * @param {Number} test the unique number of the {@link term.baseclass baseclass}.
     */
    this.hasFeature = function(test){
        return this.$regbase & test;
    };
    
    this.$initStack    = [];
    this.$bufferEvents = [];
    this.$init = function(callback, nodeFunc, struct){
        if (typeof callback == FUN || callback === true) {
            this.$bufferEvents = this.$bufferEvents.slice();
            
            if (callback === true)
                return this;
            
            this.$initStack = this.$initStack.slice(); //Our own private stack
            this.$initStack.push(callback);
            
            return this;
        }

        this.addEventListener = realAddEventListener;
        this.$removalQueue = [];

        if (this.nodeType != 2) //small little hack
            this.$uniqueId = apf.all.push(this) - 1;

        this.$captureStack = {};
        this.$eventsStack  = {};
        this.$funcHandlers = {};

        var i = 0, l = this.$initStack.length;
        for (; i < l; i++)
            this.$initStack[i].apply(this, arguments);
        
        for (i = 0, l = this.$bufferEvents.length; i < l; i++)
            this.addEventListener.apply(this, this.$bufferEvents[i]);
        
        delete realAddEventListener;
        delete this.$initStack;
        delete this.$bufferEvents;
        
        if (struct && struct.htmlNode) {
            this.$pHtmlNode = struct.htmlNode;
            
            
                this.ownerDocument.$domParser.$continueParsing(this);
                
                
                apf.queue.empty();
                
            
        }
        
        return this;
    };
    
    this.implement = apf.implement;

    /**** Property Binding ****/

    this.$handlePropSet = function(prop, value){
        this[prop] = value;
    };
    
    
    
    /**
     * Bind a property of another compontent to a property of this element.
     *
     * @param  {String} myProp           the name of the property of this element
     *                                   of which the value is communicated to
     *                                   <code>bObject</code>.
     * @param  {Class}  bObject          the object which will receive the property
     *                                   change message.
     * @param  {String} bProp            the property of <code>bObject</code> which
     *                                   will be set using the value of
     *                                   <code>myProp</code> optionally
     *                                   processed using <code>strDynamicProp</code>.
     * @param  {String} [strDynamicProp] a javascript statement which contains the
     *                                   value of <code>myProp</code>. The string
     *                                   is used to calculate a new value.
     * @private
     */
    this.$bindProperty = function(myProp, bObject, bProp, fParsed){
        if (!fParsed)
            return bObject.$handlePropSet(bProp, this[myProp]);

        var eventName = PROP + myProp, eFunc, isBeingCalled, isLang;
        (this.$eventsStack[eventName] || (this.$eventsStack[eventName] = [])).push(eFunc = function(e){
            if (isBeingCalled) //Prevent circular refs
                return;
            
            
            apf.$lm_has_lang = false;
            
            isBeingCalled = true;
            
            try {
                if (fParsed.asyncs) { //if async
                    return fParsed.call(bObject, bObject.xmlRoot, function(value){
                        bObject.setProperty(bProp, value, true, false, 10);
                        
                        
                        //@todo apf3.0
                        if (apf.$lm_has_lang && !isLang) {
                            isLang = true;
                            //@todo should auto remove
                            apf.language.addProperty(bObject, bProp, fParsed);
                        }
                        
                        
                        isBeingCalled = false;
                    }); 
                }
                else {
                    var value = fParsed.call(bObject, bObject.xmlRoot);
                }
            }
            catch(e) {
                apf.console.warn("[331] Could not execute binding for property "
                    + bProp + "\n\n" + e.message);
                
                isBeingCalled = false;
                
                return;
            }

            //Can't do this when using xml nodes, doesnt seem needed anyway
            //if (bObject[bProp] != value)
                bObject.setProperty(bProp, value, true, false, 10);//e.initial ? 0 : 
            
            
            //@todo apf3.0
            if (apf.$lm_has_lang && !isLang) {
                isLang = true;
                //@todo should auto remove
                apf.language.addProperty(bObject, bProp, fParsed);
            }
            
            
            isBeingCalled = false;
        });
        
        //eFunc({initial: true});
        
        return eFunc;
    };
    
    /**
     * Sets a dynamic property from a string.
     * The string used for this function is the same as used in AML to set a
     * dynamic property:
     * <code>
     *  <a:button visible="{rbTest.value == 'up'}" />
     *  <a:textbox id="rbTest" value="" />
     * </code>
     *
     * @param  {String}  prop   the name of the property of this element to set
     *                          using a dynamic rule.
     * @param  {String}  pValue the dynamic property binding rule.
     */
    this.$attrExcludePropBind = false;
    this.$setDynamicProperty = function(prop, pValue){
        var exclNr = this.$attrExcludePropBind[prop],
            options;
        //@todo apf3.0, please generalize this - cache objects, seems slow
        if (SEL.indexOf(prop) > -1) {
            options = {
                xpathmode : 2,
                parsecode : true
            }
        }
        else if (exclNr == 2) {
            options = {nostring : true};
        }
        else if (exclNr === 0) {
            options = {parsecode : true};
        }

        //Compile pValue through JSLT parser
        var fParsed = apf.lm.compile(pValue, options);

        //Special case for model due to needed extra signalling
        if (prop == MODEL)
            (this.$modelParsed = fParsed).instruction = pValue

        //if it's only text return setProperty()
        if (fParsed.type == 2) {
            this[prop] = !pValue; //@todo apf3.0 is this needed?
            return this.setProperty(prop, fParsed.str);
        }

        //if there's xpath: Add apf.DataBinding if not inherited. 
        //Add compiled binding rule. Load databinding if not loaded. 
        
        if (exclNr == 2 || fParsed.xpaths.length && exclNr != 1) {
            if (!this.hasFeature(apf.__DATABINDING__))
                this.implement(apf.StandardBinding);
            
            this.$addAttrBind(prop, fParsed, pValue);
        }
        

        //if there's prop binding: Add generated function to each obj/prop in the list
        var matches = exclNr && exclNr != 3 && prop != MODEL ? {} : fParsed.props, //@todo apf3.0 sign of broken abstraction, please fix this with a bit mask
            found   = false,
            _self   = this,
            o, node, bProp, p;

        for (p in matches) {
            
            if (typeof matches[p] == FUN)
                continue;
            

            o = p.split(".");
            if (o.length > 2) { //apf.offline.syncing
                bProp = o.pop();
                try{
                    node  = eval(o.join("."));
                }
                catch(e){
                    if (arguments[2]) {
                        apf.console.warn("[287] Could not execute binding test : "
                            + pValue.replace(/</g, "&lt;") + "\n\n" + e.message);
                    }
                    else {
                        apf.queue.add(prop + ":" + this.$uniqueId, function(){
                            _self.$clearDynamicProperty(prop);
                            _self.$setDynamicProperty(prop, pValue, true);
                        });
                    }
                    continue;
                }

                if (typeof node != OBJ || !node.$regbase) {
                    bProp = o[1];
                    node  = self[o[0]];
                }
                else {
                    o.push(bProp);
                }
            }
            else {
                bProp = o[1];
                node  = self[o[0]] || o[0] == "this" && this;
            }

            if (!node) {
                if (arguments[2]) {
                    apf.console.warn("[287] Could not execute binding test : "
                        + pValue.replace(/</g, "&lt;") + "\n\n" + o[0] + " does not exist");
                }
                else {
                    apf.queue.add(prop + ":" + this.$uniqueId, function(){
                        _self.$clearDynamicProperty(prop);
                        _self.$setDynamicProperty(prop, pValue, true);
                    });
                    return;
                }
            }

            if (!node.$bindProperty)
                continue;  //return

            if (!this.$funcHandlers[prop])
                this.$funcHandlers[prop] = [];
            this.$funcHandlers[prop].push({
                amlNode : node, 
                prop    : bProp, 
                handler : node.$bindProperty(bProp, this, prop, fParsed)
            });
            found = true;
        }

        if (found) {
            this.$funcHandlers[prop][0].handler({initial: true});
        }
        else {
            //@todo optimize this
            if (exclNr)
                return this.setProperty(prop, pValue);
            
            
            apf.$lm_has_lang = false;
            
            
            try {
                if (fParsed.asyncs) { //if async
                    return fParsed.call(this, this.xmlRoot, function(value){
                        _self.setProperty(prop, value, true);
    
                        
                        //@todo apf3.0
                        if (apf.$lm_has_lang)
                            apf.language.addProperty(this, prop, fParsed); //@todo should auto remove
                        
                    }); 
                }
                else {
                    var value = fParsed.call(this, this.xmlRoot);
                }
            }
            catch(e){
                apf.console.warn("[331] Could not execute binding test or: "
                    + pValue.replace(/</g, "&lt;") + "\n\n" + e.message);
                return;
            }
            
            this[prop] = !value; //@todo isnt this slow and unneccesary?
            this.setProperty(prop, value, true);

            
            //@todo apf3.0
            if (apf.$lm_has_lang)
                apf.language.addProperty(this, prop, fParsed); //@todo should auto remove
            
        }
    };
    
    //@todo setAttribute should delete this from apf.language when not doing
    //$setDynamicProperty
    this.$clearDynamicProperty = function(prop){
        if (this.$removeAttrBind)
            this.$removeAttrBind(prop);

        
        //@todo apf3.0
        apf.language.removeProperty(this, prop);
        
        
        if (prop == MODEL)
            this.$modelParsed = null;
        
        //Remove any bounds if relevant
        var f, i, l, h = this.$funcHandlers[prop];
        if (h && typeof h != FUN) {
            for (i = 0, l = h.length; i < l; i++) {
                (f = h[i]).amlNode.removeEventListener(PROP + f.prop, f.handler);
            }
            delete this.$funcHandlers[prop];
        }
    };

    
    /**
     * Adds a listener to listen for changes to a certain property. 
     * Implemented as Mozilla suggested see
     * {@link https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Object/watch their site}.
     */
    this.watch = function(propName, callback){
        var eventName = PROP + propName,
            wrapper   = function(e){
                callback.call(this, propName, e.oldvalue, e.value);
            };
        wrapper.callback = callback;
        
        (this.$eventsStack[eventName] || (this.$eventsStack[eventName] = []))
            .push(wrapper);
    };
    
    /**
     * Removes a listener to listen for changes to a certain property. 
     */
    this.unwatch = function(propName, callback){
        var list, eventName = PROP + propName;
        if (!(list = this.$eventsStack[eventName]))
            return;
        
        for (var i = 0, l = list.length; i < l; i++) {
            if (list[i].callback == callback) {
                list.remove(i);
                return;
            }
        }
    };
    

    

    /**
     * Gets an array of properties for this element which can be bound.
     */
    this.getAvailableProperties = function(){
        return this.$supportedProperties.slice();
    };

    /**
     * Sets the value of a property of this element.
     * Note: Only the value is set, dynamic properties will remain bound and the
     * value will be overridden.
     *
     * @param  {String}  prop        the name of the property of this element to
     *                               set using a dynamic rule.
     * @param  {String}  value       the value of the property to set.
     * @param  {Boolean} [forceOnMe] whether the property should be set even when
     *                               its the same value.
     */
    this.setProperty = function(prop, value, forceOnMe, setAttr, inherited){
        var s, r, arr, e, i, l,
            oldvalue = this[prop],
            isChanged = (typeof value == OBJ)
                ? value != (typeof oldvalue == OBJ ? oldvalue : null)
                : String(oldvalue) !== String(value),
            eventName = PROP + prop;//@todo prop event should be called too;
        
        //Check if property has changed
        if (isChanged) {
            
            
            if (!forceOnMe) { //Recursion protection
                //Check if this property is bound to data
                if (this.xmlRoot && typeof value != OBJ
                  && (!(s = this.$attrExcludePropBind[prop]))// || s == 2
                  && (r = (this.$attrBindings && this.$attrBindings[prop] 
                  || prop != VALUE && this.$bindings[prop] && this.$bindings[prop][0]))) {

                    //Check if rule has single xpath
                    if (r.cvalue.type == 3) {
                        //Set the xml value
                        return apf.setNodeValue(
                            this.$getDataNode(prop.toLowerCase(), this.xmlRoot, true),
                            value, true);
                    }
                }
                
                else if (typeof apf.offline != UNDEF) {
                    if (apf.loaded && apf.offline.state.enabled) {
                        apf.offline.state.set(this, prop, typeof value == OBJ
                            ? value.name
                            : value);
                    }
                    else if (apf.offline.enabled) {
    
                    }
                }
                
            }

            if (this.$handlePropSet(prop, value, forceOnMe) === false)
                return;
            
            value = this[prop];
            
            if (setAttr)
                this.setAttribute(prop, value, true);
        }
        
        //Optimized event calling
        if (arr = this.$eventsStack[eventName]) {
            for (i = 0, l = arr.length; i < l; i++) {
                if (arr[i].call(this, e || (e = new apf.AmlEvent(eventName, {
                    prop     : prop, 
                    value    : value, 
                    oldvalue : oldvalue
                }))) === false) {
                    e.returnValue = false;
                }
            }
        }
        
        
        /*
            States:
                    -1 Set
             undefined Pass through
                     2 Inherited
                    10 Dynamic property
        */
        //@todo fix DOM mutation icw property inheritance
        //@todo this whole section should be about attribute inheritance and moved
        //      to AmlElement
        //@todo the check on $amlLoaded is not as optimized as can be because
        //      $loadAml is not called yet
        if ((aci || (aci = apf.config.$inheritProperties))[prop] && this.$amlLoaded) {
            //@todo this is actually wrong. It should be about removing attributes.
            if (inherited != 10 && !value) {
                delete this.$inheritProperties[prop];
                if (this.$setInheritedAttribute(prop))
                    return;
            }
            else if (inherited != 10) { //Keep the current setting (for dynamic properties)
                this.$inheritProperties[prop] = inherited || -1;
            }

            //cancelable, needed for transactions
            if ((!e || e.returnValue !== false) && this.childNodes) {
                (function recur(nodes) {
                    var i, l, node, n;
                    for (i = 0, l = nodes.length; i < l; i++) {
                        node = nodes[i];
                        if (node.nodeType != 1)
                            continue;
                        
                        //Pass through
                        if (!(n = node.$inheritProperties[prop]))
                            recur(node.childNodes);
                        //Set inherited property
                        else if(n > 0)
                            node.setProperty(prop, value, false, false, 2); //This is recursive already
                    }
                })(this.childNodes);
            }
        }
        
        
        return value;
    };
    var aci;

    /**
     * Gets the value of a property of this element.
     *
     * @param  {String}  prop   the name of the property of this element for which to get the value.
     */
    this.getProperty = function(prop){
        return this[prop];
    };

    /**** Event Handling ****/

    apf.eventDepth = 0;

    /**
     * Calls all functions that are registered as listeners for an event.
     *
     * @param  {String}  eventName  the name of the event to dispatch.
     * @param  {Object}  [options]  the properties of the event object that will be created and passed through.
     *   Properties:
     *   {Boolean} bubbles  whether the event should bubble up to it's parent
     *   {Boolean} captureOnly whether only the captured event handlers should be executed
     * @return {mixed} return value of the event
     */
    var allowEvents = {"DOMNodeInsertedIntoDocument":1,"DOMNodeRemovedFromDocument":1};
    this.dispatchEvent = function(eventName, options, e){
        var arr, result, rValue, i, l;

        apf.eventDepth++;

        e = options && options.name ? options : e;

        if (this.disabled && !allowEvents[eventName]) {
            result = false;
        }
        else {
            if (!e || !e.currentTarget) {
                if (!(options || (options = {})).currentTarget)
                    options.currentTarget = this;

                //Capture support
                if (arr = this.$captureStack[eventName]) {
                    for (i = 0, l = arr.length; i < l; i++) {
                        rValue = arr[i].call(this, e || (e = new apf.AmlEvent(eventName, options)));
                        if (typeof rValue != UNDEF)
                            result = rValue;
                    }
                }
            }
            
            if (options && options.captureOnly) {
                return e && typeof e.returnValue != UNDEF ? e.returnValue : result;
            }
            else {
                if (this["on" + eventName]) {
                    result = this["on" + eventName].call(this, e 
                        || (e = new apf.AmlEvent(eventName, options))); //Backwards compatibility
                }
    
                if (arr = this.$eventsStack[eventName]) {
                    for (i = 0, l = arr.length; i < l; i++) {
                        if (!arr[i]) continue;
                        rValue = arr[i].call(this, e 
                            || (e = new apf.AmlEvent(eventName, options)));
                        if (typeof rValue != UNDEF)
                            result = rValue;
                    }
                }
            }
        }
        
        
        if ((e && e.bubbles && !e.cancelBubble || options && options.bubbles) && this != apf) {
            rValue = (this.parentNode || apf).dispatchEvent(eventName, null, e 
                || (e = new apf.AmlEvent(eventName, options)));

            if (typeof rValue != UNDEF)
                result = rValue;
        }
        
        
        var p;
        while (this.$removalQueue.length) {
            p = this.$removalQueue.shift();
            p[0].remove(p[1]); 
        }
        
        if (--apf.eventDepth == 0 && this.ownerDocument 
          && !this.ownerDocument.$domParser.$parseContext
          && !apf.isDestroying
          
          && eventName != "debug"
          
          && apf.queue
        ) {
            apf.queue.empty();
        }

        
        
        return e && typeof e.returnValue != UNDEF ? e.returnValue : result;
    };

    /**
     * Add a function to be called when a event is called.
     *
     * @param  {String}   eventName the name of the event for which to register
     *                              a function.
     * @param  {function} callback  the code to be called when event is dispatched.
     */
    this.addEventListener = function(a, b, c){
        this.$bufferEvents.push([a,b,c]);
    };
    
    var realAddEventListener = function(eventName, callback, useCapture){
        

        if (eventName.substr(0, 2) == "on")
            eventName = eventName.substr(2);

        var stack = useCapture ? this.$captureStack : this.$eventsStack;
        if (!stack[eventName])
            stack[eventName] = [];
        if (stack[eventName].indexOf(callback) == -1)
            stack[eventName].unshift(callback);
        
        var f;
        if (f = this.$eventsStack["$event." + eventName])
            f[0].call(this, callback);
    };

    /**
     * Remove a function registered for an event.
     *
     * @param  {String}   eventName the name of the event for which to unregister
     *                              a function.
     * @param  {function} callback  the function to be removed from the event stack.
     */
    this.removeEventListener = function(eventName, callback, useCapture){
        var stack = useCapture ? this.$captureStack : this.$eventsStack;
        if (stack[eventName])
            this.$removalQueue.push([stack[eventName], callback]);
    };

    /**
     * Checks if there is an event listener specified for the event.
     *
     * @param  {String}  eventName  the name of the event to check.
     * @return {Boolean} whether the event has listeners
     */
    this.hasEventListener = function(eventName){
        return (this.$eventsStack[eventName] && this.$eventsStack[eventName].length > 0);
    };

    /**
     * Destructor of a Class.
     * Calls all destructor functions and removes all mem leaking references.
     * This function is called when exiting the application or closing the window.
     * @param {Boolean} deep whether the children of this element should be destroyed.
     * @method
     */
    this.destroy = function(deep, clean){
        //Remove from apf.all
        if (typeof this.$uniqueId == UNDEF && this.nodeType != 2)
            return;
        
        this.$amlLoaded    = false;
        this.$amlDestroyed = true;
        
        if (this.$destroy)
            this.$destroy();

        this.dispatchEvent("DOMNodeRemoved");
        this.dispatchEvent("DOMNodeRemovedFromDocument");

        apf.all[this.$uniqueId] = undefined;

        if (!this.nodeFunc && this.nodeType != 2) { //If this is not a AmlNode, we're done.
            //Remove id from global js space
            try {
                if (this.id || this.name)
                    self[this.id || this.name] = null;
            }
            catch (ex) {}
            return;
        }

        if (this.$ext && !this.$ext.isNative && this.$ext.nodeType == 1 && this.localName != "a") {
            this.$ext.oncontextmenu = this.$ext.host = null;
            if (clean) {
                if (this.localName != "collection")
                    this.$ext.parentNode.removeChild(this.$ext);
            }
        }
        if (this.$int && !this.$int.isNative && this.$int.nodeType == 1 && this.localName != "a")
            this.$int.host = null;

        //if (this.$aml && this.$aml.parentNode)
            //this.$aml.parentNode.removeChild(this.$aml);
        this.$aml = null;

        //Clear all children too
        if (deep && this.childNodes) {
            var nodes = this.childNodes;
            for (i = nodes.length - 1; i >= 0; i--) {
                if (nodes[i].destroy)
                    nodes[i].destroy(true, clean && this.localName == "collection");
            }
            this.childNodes = null;
        }

        //Remove from DOM tree if we are still connected
        if (this.parentNode && this.removeNode)
            this.removeNode();
        else if (this.ownerElement && !this.ownerElement.$amlDestroyed)
            this.ownerElement.removeAttributeNode(this);

        //Remove from focus list - Should be in AmlNode
        
        if (this.$focussable && this.focussable)
            apf.window.$removeFocus(this);
        
        
        
        //Remove dynamic properties
        /*var f, i, l, h;
        for (prop in this.$funcHandlers) {
            h = this.$funcHandlers[prop];
            
            //Remove any bounds if relevant
            if (h && typeof h != FUN) {
                for (i = 0, l = h.length; i < l; i++) {
                    (f = h[i]).amlNode.removeEventListener(PROP + f.prop, f.handler);
                }
            }
        }*/
        
        
        if (this.attributes) {
            var attr = this.attributes;
            for (var i = attr.length - 1; i >= 0; i--) {
                
                this.$clearDynamicProperty(attr[i].nodeName);
                
                attr[i].destroy();
            }
        }

        
        if (deep !== false && this.childNodes && this.childNodes.length) {
            apf.console.warn("You have destroyed an Aml Node without destroying "
                           + "it's children. Please be aware that if you don't "
                           + "maintain a reference, memory might leak");
        }
        
        
        //Remove id from global js space
        try {
            if (this.id || this.name)
                self[this.id || this.name] = null;
        }
        catch (ex) {}
        
        
        apf.nameserver.remove(this.localName, this);
        
    };
})();

apf.extend(apf, new apf.Class().$init());
apf.Init.run("class");



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/color.js)SIZE(7843)TIME(1258118722)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.color = {
    colors: {
        aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aqua:"#00ffff",
        aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",
        black:"#000000",blanchedalmond:"#ffebcd",blue:"#0000ff",
        blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",
        cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",
        coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",
        crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",
        darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgrey:"#a9a9a9",
        darkgreen:"#006400",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",
        darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",
        darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",
        darkslateblue:"#483d8b",darkslategray:"#2f4f4f",
        darkslategrey:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",
        deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",
        dimgrey:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",
        floralwhite:"#fffaf0",forestgreen:"#228b22",fuchsia:"#ff00ff",
        gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",
        goldenrod:"#daa520",gray:"#808080",grey:"#808080",green:"#008000",
        greenyellow:"#adff2f",honeydew:"#f0fff0",hotpink:"#ff69b4",
        indianred:"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",
        lavender:"#e6e6fa",lavenderblush:"#fff0f5",lawngreen:"#7cfc00",
        lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",
        lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgray:"#d3d3d3",
        lightgrey:"#d3d3d3",lightgreen:"#90ee90",lightpink:"#ffb6c1",
        lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",
        lightslategray:"#778899",lightslategrey:"#778899",
        lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",lime:"#00ff00",
        limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",maroon:"#800000",
        mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",
        mediumorchid:"#ba55d3",mediumpurple:"#9370d8",mediumseagreen:"#3cb371",
        mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",
        mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",
        midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",
        moccasin:"#ffe4b5",navajowhite:"#ffdead",navy:"#000080",
        oldlace:"#fdf5e6",olive:"#808000",olivedrab:"#6b8e23",orange:"#ffa500",
        orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",
        palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#d87093",
        papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",
        plum:"#dda0dd",powderblue:"#b0e0e6",purple:"#800080",red:"#ff0000",
        rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",
        salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",
        seashell:"#fff5ee",sienna:"#a0522d",silver:"#c0c0c0",skyblue:"#87ceeb",
        slateblue:"#6a5acd",slategray:"#708090",slategrey:"#708090",
        snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",
        teal:"#008080",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",
        violet:"#ee82ee",wheat:"#f5deb3",white:"#ffffff",whitesmoke:"#f5f5f5",
        yellow:"#ffff00",yellowgreen:"#9acd32"
    },

    fixHSB: function (hsb) {
        return {
            h: Math.min(360, Math.max(0, hsb.h)),
            s: Math.min(100, Math.max(0, hsb.s)),
            b: Math.min(100, Math.max(0, hsb.b))
        };
    },

    fixRGB: function (rgb) {
        return {
            r: Math.min(255, Math.max(0, rgb.r)),
            g: Math.min(255, Math.max(0, rgb.g)),
            b: Math.min(255, Math.max(0, rgb.b))
        };
    },

    fixHex: function (hex) {
        var len = 6 - hex.length;
        if (len > 0) {
            var o = [], i = 0;
            for (; i < len; i++)
                o.push("0");
            o.push(hex);
            hex = o.join("");
        }
        return hex;
    },
    
    hexToRGB: function (hex) {
        hex = parseInt(((hex.indexOf("#") > -1) ? hex.substring(1) : hex), 16);
        return {r: hex >> 16, g: (hex & 0x00FF00) >> 8, b: (hex & 0x0000FF)};
    },

    hexToHSB: function (hex) {
        return this.RGBToHSB(this.hexToRGB(hex));
    },

    RGBToHSB: function (rgb) {
        var hsb = {
            h: 0,
            s: 0,
            b: 0
        };
        var min   = Math.min(rgb.r, rgb.g, rgb.b),
            max   = Math.max(rgb.r, rgb.g, rgb.b),
            delta = max - min;
        hsb.b = max;
        if (max != 0) { }
        hsb.s = max != 0 ? 255 * delta / max : 0;
        if (hsb.s != 0) {
            if (rgb.r == max)
                hsb.h = (rgb.g - rgb.b) / delta;
            else if (rgb.g == max)
                hsb.h = 2 + (rgb.b - rgb.r) / delta;
            else
                hsb.h = 4 + (rgb.r - rgb.g) / delta;
        }
        else
            hsb.h = -1;
        hsb.h *= 60;
        if (hsb.h < 0)
            hsb.h += 360;
        hsb.s *= 100/255;
        hsb.b *= 100/255;
        return hsb;
    },
    
    HSBToRGB: function(hsb) {
        var rgb = {},
            h   = Math.round(hsb.h),
            s   = Math.round(hsb.s * 255 / 100),
            v   = Math.round(hsb.b * 255 / 100);
        if (s == 0)
            rgb.r = rgb.g = rgb.b = v;
        else {
            var t1 = v,
                t2 = (255 - s) * v / 255,
                t3 = (t1 - t2) * (h % 60)/60;
            if (h == 360)
                h = 0;
            if (h < 60)
                rgb.r = t1, rgb.b = t2, rgb.g = t2 + t3;
            else if (h < 120)
                rgb.g = t1, rgb.b = t2, rgb.r = t1 - t3;
            else if (h < 180)
                rgb.g = t1, rgb.r = t2, rgb.b = t2 + t3;
            else if (h < 240)
                rgb.b = t1, rgb.r = t2, rgb.g = t1 - t3;
            else if (h < 300)
                rgb.b = t1, rgb.g = t2, rgb.r = t2 + t3;
            else if (h < 360)
                rgb.r = t1, rgb.g = t2, rgb.b = t1 - t3;
            else
                rgb.r = 0, rgb.g = 0, rgb.b = 0;
        }
        return {r: Math.round(rgb.r), g: Math.round(rgb.g), b: Math.round(rgb.b)};
    },

    RGBToHex: function(rgb) {
        var hex = [
                rgb.r.toString(16),
                rgb.g.toString(16),
                rgb.b.toString(16)
            ],
            i = 0;
        for (; i < 3; i++) {
            if (hex[i].length == 1)
                hex[i] = "0" + hex[i];
        }
        return hex.join("");
    },

    HSBToHex: function(hsb) {
        return this.RGBToHex(this.HSBToRGB(hsb));
    }
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/ecmaext.js)SIZE(24213)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



// start closure:
//(function(){

if (typeof isFinite == "undefined") {
    function isFinite(val){
        return val + 1 != val;
    }
}

apf.ARRAY    = 1;
apf.NUMBER   = 2;
apf.DATE     = 3;
apf.BOOLEAN  = 4;
apf.STRING   = 5;
apf.REGEXP   = 6;
apf.FUNCTION = 7;

Array.prototype.dataType    = apf.ARRAY;
Number.prototype.dataType   = apf.NUMBER;
Date.prototype.dataType     = apf.DATE;
Boolean.prototype.dataType  = apf.BOOLEAN;
String.prototype.dataType   = apf.STRING;
RegExp.prototype.dataType   = apf.REGEXP;
Function.prototype.dataType = apf.FUNCTION;

/**
 * Converts a javascript object to a cgi string.
 * @see core.convertXml
 */
apf.getCgiString = function(args, multicall, mcallname){
    var vars = [];

    function recur(o, stack) {
        var prop;
        if (apf.isArray(o)) {
            for (var j = 0; j < o.length; j++)
                recur(o[j], stack + "%5B%5D");//" + j + "
        } 
        else if (typeof o == "object") {
            for (prop in o) {
                if (apf.isSafariOld && (!o[prop] || typeof p[prop] != "object"))
                    continue;

                if (typeof o[prop] == "function")
                    continue;
                recur(o[prop], stack + "%5B" + encodeURIComponent(prop) + "%5D");
            }
        }
        else
            vars.push(stack + "=" + encodeURIComponent(o));
    };

    if (multicall) {
        vars.push("func=" + mcallname);
        for (var i = 0; i < args[0].length; i++)
            recur(args[0][i], "f%5B" + i + "%5D");
    } else {
        for (prop in args) {
            if (apf.isSafariOld && (!args[prop] || typeof args[prop] == "function"))
                continue;

            recur(args[prop], prop);
        }
    }

    return vars.join("&");
}

/**
 * Converts a cgi string to a javascript object.
 * @see core.convertXml
 */
apf.fromCgiString = function(args) {
    if (!args)
        return false;

    var obj = {};
    args = args.split("&");
    for (var data, i = 0; i < args.length; i++) {
        data = args[i].split("=");
        data[0] = decodeURIComponent(data[0]);
        var path = data[0].replace(/\]/g, "").split("[");

        var spare = obj;
        for (var j = 0; j < path.length; j++) {
            if (spare[path[j]])
                spare = spare[path[j]];
            else if (path.length == j+1) {
                if (path[j])
                    spare[path[j]] = decodeURIComponent(data[1]);
                else
                    spare.push(decodeURIComponent(data[1]));
                break; //assuming last
            }
            else{
                spare[path[j]] = !path[j+1] ? [] : {};
                spare = spare[path[j]];
            }
        }
    }

    return obj;
}




/**
 * Extends a Function object with properties from other objects, specified as
 * arguments.
 *
 * @param {mixed} obj1, obj2, obj3, etc.
 * @type Function
 * @see apf.extend
 */
Function.prototype.extend = function() {
    apf.extend.apply(this, [this].concat(Array.prototype.slice.call(arguments)));
    return this;
};

/**
 * Attach a Function object to an event as handler method. If apf.AbstractEvent
 * is available, the active event is extended with convinience accessors as
 * declared in apf.AbstractEvent
 *
 * @param {Object} The context the execute the Function within
 * @param {Boolean} Whether the passed event object should be extended with AbstractEvent
 * @param {mixed}  param1, param2, param3, etc.
 * @type Function
 * @see apf.AbstractEvent
 */
Function.prototype.bindWithEvent = function() {
    var __method = this, 
        args     = Array.prototype.slice.call(arguments),
        o        = args.shift(),
        ev       = args.shift();
    return function(event) {
        if (!event)
            event = window.event;
        
        if (ev !== false)
            event = new apf.AbstractEvent(event, window);
        
        return __method.apply(o, [event].concat(args)
            .concat(Array.prototype.slice.call(arguments)));
    }
};

/**
 * Copy an array, like this statement would: 'this.concat([])', but then do it
 * recursively.
 */
Array.prototype.copy = function(){
    var ar = [];
    for (var i = 0, j = this.length; i < j; i++)
        ar[i] = this[i] && this[i].copy ? this[i].copy() : this[i];

    return ar;
};

/**
 * Concatenate the current Array instance with one (or more) other Arrays, like
 * Array.concat(), but return the current Array instead of a new one that
 * results from the merge.
 *
 * @param {Array} array1, array2, array3, etc.
 * @type  {Array}
 */
Array.prototype.merge = function(){
    for (var i = 0, k = arguments.length; i < k; i++) {
        for (var j = 0, l = arguments[i].length; j < l; j++) {
            this.push(arguments[i][j]);
        }
    }
};

/**
 * Add the values of one or more arrays to the current instance by using the
 * '+=' operand on each value.
 *
 * @param {Array} array1, array2, array3, etc.
 * @type  {Array}
 * @see Array.copy
 */
Array.prototype.arrayAdd = function(){
    var s = this.copy();
    for (var i = 0, k = arguments.length; i < k; i++) {
        for (var j = 0, l = s.length; j < l; j++) {
            s[j] += arguments[i][j];
        }
    }

    return s;
};

/**
 * Check if an object is contained within the current Array instance.
 *
 * @param {mixed}   obj The value to check for inside the Array
 * @type  {Boolean}
 */
Array.prototype.equals = function(obj){
    for (var i = 0, j = this.length; i < j; i++)
        if (this[i] != obj[i])
            return false;
    return true;
};

/**
 * Make sure that an array instance contains only unique values (NO duplicates).
 *
 * @type {Array}
 */
Array.prototype.makeUnique = function(){
    var i, length, newArr = [];
    for (i = 0, length = this.length; i < length; i++)
        if (newArr.indexOf(this[i]) == -1)
            newArr.push(this[i]);

    this.length = 0;
    for (i = 0, length = newArr.length; i < length; i++)
        this.push(newArr[i]);

    return this;
};

/**
 * Check if this array instance contains a value 'obj'.
 *
 * @param {mixed}  obj    The value to check for inside the array
 * @param {Number} [from] Left offset index to start the search from
 * @type  {Boolean}
 * @see Array.indexOf
 */
Array.prototype.contains = function(obj, from){
    return this.indexOf(obj, from) != -1;
};

/**
 * Search for the index of the first occurence of a value 'obj' inside an array
 * instance.
 * July 29, 2008: added 'from' argument support to indexOf()
 *
 * @param {mixed}  obj    The value to search for inside the array
 * @param {Number} [from] Left offset index to start the search from
 * @type  {Number}
 */
Array.prototype.indexOf = Array.prototype.indexOf || function(obj, from){
    var len = this.length;
    for (var i = (from < 0) ? Math.max(0, len + from) : from || 0; i < len; i++) {
        if (this[i] === obj)
            return i;
    }
    return -1;
};

/**
 * Search for the index of the last occurence of a value 'obj' inside an array
 * instance.
 *
 * @param {mixed}  obj    The value to search for inside the array
 * @param {Number} [from] Left offset index to start the search from
 * @type  {Number}
 */
Array.prototype.lastIndexOf = Array.prototype.lastIndexOf || function(obj, from) {
    //same as indexOf(), but in reverse loop, JS spec 1.6
    var len = this.length;
    for (var i = (from >= len) ? len - 1 : (from < 0) ? from + len : len - 1; i >= 0; i--) {
        if (this[i] === obj)
            return i;
    }
    return -1;
};

/**
 * Like Array.push, but only invoked when the value 'item' is already present
 * inside the array instance.
 *
 * @param {mixed} item
 * @type  {Array}
 */
Array.prototype.pushUnique = function(item){
    if (this.indexOf(item) == -1)
        this.push(item);
    return this;
};

/**
 * @todo: Ruben: could you please comment on this function? Seems to serve a very
 * specific purpose...
 *
 * I also could not find an occurrence in our codebase.
 */
Array.prototype.search = function(){
    for (var i = 0, length = arguments.length; i < length; i++) {
        if (typeof this[i] != "array")
            continue;
        for (var j = 0; j < length; j++) {
            if (this[i][j] != arguments[j])
                break;
            else if (j == (length - 1))
                return this[i];
        }
    }
};

/**
 * Iterate through each value of an array instance from left to right (front to
 * back) and execute a callback Function for each value.
 *
 * @param {Function} fn
 * @type  {Array}
 */
Array.prototype.each =
Array.prototype.forEach = Array.prototype.forEach || function(fn) {
    for (var i = 0, l = this.length; i < l; i++)
        fn.call(this, this[i], i, this);
    return this;
}

/**
 * Search for a value 'obj' inside an array instance and remove it when found.
 *
 * @type {mixed} obj
 * @type {Array}
 */
Array.prototype.remove = function(obj){
    for (var i = this.length - 1; i >= 0; i--) {
        if (this[i] != obj)
            continue;

        this.splice(i, 1);
    }

    return this;
};

/**
 * Remove an item from an array instance which can be identified with key 'i'
 *
 * @param  {Number} i
 * @return {mixed}  The removed item
 */
Array.prototype.removeIndex = function(i){
    if (!this.length) return null;
    return this.splice(i, 1);
};

/**
 * Insert a new value at a specific object; alias for Array.splice.
 *
 * @param {mixed}  obj Value to insert
 * @param {Number} i   Index to insert 'obj' at
 * @type  {Number}
 */
Array.prototype.insertIndex = function(obj, i){
    this.splice(i, 0, obj);
};

/**
 * Reverses the order of the elements of an array; the first becomes the last,
 * and the last becomes the first.
 *
 * @type {Array}
 */
Array.prototype.invert =
Array.prototype.reverse = Array.prototype.reverse || function(){
    var l = this.length - 1;
    for (var temp, i = 0; i < Math.ceil(0.5 * l); i++) {
        temp        = this[i];
        this[i]     = this[l - i]
        this[l - i] = temp;
    }

    return this;
};



/*
 * Attempt to fully comply (in terms of functionality) with the JS specification,
 * up 'till version 1.7:
 * @link http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array
 */

/**
 * Creates a new array with all of the elements of this array for which the
 * provided filtering function returns true.
 *
 * @param {Function} fn   Function to test each element of the array.
 * @param {Object}   bind Object to use as this when executing callback.
 * @type  {Array}
 */
Array.prototype.filter = Array.prototype.filter || function(fn, bind){
    var results = [];
    for (var i = 0, l = this.length; i < l; i++) {
        if (fn.call(bind, this[i], i, this))
            results.push(this[i]);
    }
    return results;
};

/**
 * Returns true if every element in this array satisfies the provided testing
 * function.
 *
 * @param {Function} fn   Function to test for each element.
 * @param {Object}   bind Object to use as this when executing callback.
 * @type  {Boolean}
 */
Array.prototype.every = Array.prototype.every || function(fn, bind){
    for (var i = 0, l = this.length; i < l; i++) {
        if (!fn.call(bind, this[i], i, this))
            return false;
    }
    return true;
};

/**
 * Creates a new array with the results of calling a provided function on every
 * element in this array.
 *
 * @param {Function} fn   Function that produces an element of the new Array from an element of the current one.
 * @param {Object}   bind Object to use as this when executing callback.
 * @type  {Array}
 */
Array.prototype.map = Array.prototype.map || function(fn, bind){
    var results = [];
    for (var i = 0, l = this.length; i < l; i++)
        results[i] = fn.call(bind, this[i], i, this);
    return results;
};

/**
 * Tests whether some element in the array passes the test implemented by the
 * provided function.
 *
 * @param {Function} fn   Function to test for each element.
 * @param {Object}   bind Object to use as this when executing callback.
 * @type  {Boolean}
 */
Array.prototype.some = Array.prototype.some || function(fn, bind){
    for (var i = 0, l = this.length; i < l; i++) {
        if (fn.call(bind, this[i], i, this))
            return true;
    }
    return false;
};



/**
 * Transform a number to a string and pad it with a zero digit its length is one.
 *
 * @type {String}
 */
Number.prototype.toPrettyDigit = Number.prototype.toPrettyDigit || function() {
    var n = this.toString();
    return (n.length == 1) ? "0" + n : n;
};

RegExp.prototype.getNativeFlags = function() {
    return (this.global     ? "g" : "") +
           (this.ignoreCase ? "i" : "") +
           (this.multiline  ? "m" : "") +
           (this.extended   ? "x" : "") +
           (this.sticky     ? "y" : "");
};

/**
 * Accepts flags; returns a new XRegExp object generated by recompiling
 * the regex with the additional flags (may include non-native flags).
 * the original regex object is not altered.
 */
RegExp.prototype.addFlags = function(flags){
    return new RegExp(this.source, (flags || "") + this.getNativeFlags());
};

/**
 * Casts the first character in a string to uppercase.
 *
 * @type {String}
 */
String.prototype.uCaseFirst = function(){
    return this.substr(0, 1).toUpperCase() + this.substr(1)
};

/**
 * Removes spaces and other space-like characters from the left and right ends
 * of a string
 *
 * @type {String}
 */
String.prototype.trim = function(){
    return this.replace(/[\s\n\r]*$/, "").replace(/^[\s\n\r]*/, "");
};

/**
 * Concatenate a string with itself n-times.
 *
 * @param {Number} times Number of times to repeat the String concatenation
 * @type  {String}
 */
String.prototype.repeat = function(times){
    return Array(times + 1).join(this);
};

/**
 * Count the number of occurences of substring 'str' inside a string
 *
 * @param {String} str
 * @type  {Number}
 */
String.prototype.count = function(str){
    return this.split(str).length - 1;
};

/**
 * Remove HTML or any XML-like tags from a string
 *
 * @type {String}
 */
String.prototype.stripTags = function() {
    return this.replace(/<\/?[^>]+>/gi, "");
};

/**
 * Wrapper for the global 'escape' function for strings
 *
 * @type {String}
 */
String.prototype.escape = function() {
    return escape(this);
};

/**
 * Returns an xml document
 * @type {XMLElement}
 */
String.prototype.toXml = function(){
    var node = apf.getXml("<root>" + this + "</root>");
    if (node.childNodes.length == 1) {
        return node.childNodes[0];
    }
    else {
        var docFrag = node.ownerDocument.createDocumentFragment(),
            nodes   = node.childNodes;
        while (nodes.length)
            docFrag.appendChild(nodes[0]);
        return docFrag;
    }
};


if (typeof window != "undefined" && typeof window.document != "undefined" 
  && typeof window.document.createElement == "function") {
    /**
     * Encode HTML entities to its HTML equivalents, like '&amp;' to '&amp;amp;'
     * and '&lt;' to '&amp;lt;'.
     *
     * @type {String}
     * @todo is this fast?
     */
    String.prototype.escapeHTML = function() {
        this.escapeHTML.text.data = this;
        return this.escapeHTML.div.innerHTML;
    };

    /**
     * Decode HTML equivalent entities to characters, like '&amp;amp;' to '&amp;'
     * and '&amp;lt;' to '&lt;'.
     *
     * @type {String}
     */
    String.prototype.unescapeHTML = function() {
        var div = document.createElement("div");
        div.innerHTML = this.stripTags();
        if (div.childNodes[0]) {
            if (div.childNodes.length > 1) {
                var out = [];
                for (var i = 0; i < div.childNodes.length; i++)
                    out.push(div.childNodes[i].nodeValue);
                return out.join("");
            }
            else
                return div.childNodes[0].nodeValue;
        }
        return "";
    };

    String.prototype.escapeHTML.div  = document.createElement("div");
    String.prototype.escapeHTML.text = document.createTextNode("");
    String.prototype.escapeHTML.div.appendChild(String.prototype.escapeHTML.text);

    if ("<\n>".escapeHTML() !== "&lt;\n&gt;")
        String.prototype.escapeHTML = null;

    if ("&lt;\n&gt;".unescapeHTML() !== "<\n>")
        String.prototype.unescapeHTML = null;
}

if (!String.prototype.escapeHTML) {
    String.prototype.escapeHTML = function() {
        return this.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
    };
}

if (!String.prototype.unescapeHTML) {
    String.prototype.unescapeHTML = function() {
        return this.stripTags().replace(/&lt;/g,"<").replace(/&gt;/g,">").replace(/&amp;/g,"&");
    };
}

/**
 * Trim a string down to a specific number of characters. Optionally, append an
 * ellipsis ('...') as a suffix.
 *
 * @param {Number}  nr
 * @param {Boolean} [ellipsis] Append an ellipsis
 * @type  {String}
 */
String.prototype.truncate = function(nr, ellipsis){
    return this.length >= nr
        ? this.substring(0, nr - (ellipsis ? 4 : 1)) + (ellipsis ? "..." : "")
        : this;
};

/**
 * Pad a string at the right or left end with a string 'pad' to a specific
 * number of characters. Highly optimized version for speed, not readability.
 *
 * @param {Number}  len   Specifies the amount of characters required to pad to.
 * @param {String}  pad   Specifies the character(s) to pad the string with
 * @param {Boolean} [dir] Specifies at which end to append the 'pad' character (left or right).
 * @type  {String}
 */
String.prototype.pad = function(len, pad, dir) {
    return dir ? (this + Array(len).join(pad)).slice(0, len)
        : (Array(len).join(pad) + this).slice(-len);
};

apf.PAD_LEFT  = false;
apf.PAD_RIGHT = true;

/**
 * Special String.split; optionally lowercase a string and trim all results from
 * the left and right.
 *
 * @param {String}  separator
 * @param {Number}  limit      Maximum number of items to return
 * @param {Boolean} bLowerCase Flag to lowercase the string prior to split
 * @type  {String}
 */
String.prototype.splitSafe = function(separator, limit, bLowerCase) {
    return (bLowerCase && this.toLowerCase() || this)
        .replace(/(?:^\s+|\n|\s+$)/g, "")
        .split(new RegExp("[\\s ]*" + separator + "[\\s ]*", "g"), limit || 999);
};

/**
 * Appends a random number with a specified length to this String instance.
 *
 * @see randomGenerator
 * @param {Number} length
 * @type  {String}
 */
String.prototype.appendRandomNumber = function(length) {
    for (var arr = [], i = 1; i <= length; i++)
        arr.push(apf.randomGenerator.generate(1, 9));
    // Create a new string from the old one, don't just create a copy
    return this.toString() + arr.join("");
};

/**
 * Prepends a random number with a specified length to this String instance.
 *
 * @see randomGenerator
 * @param {Number} length
 * @type  {String}
 */
String.prototype.prependRandomNumber = function(length) {
    for (var arr = [], i = 1; i <= length; i++)
        arr.push(apf.randomGenerator.generate(1, 9));
    // Create a new string from the old one, don't just create a copy
    return arr.join("") + this.toString();
};

/**
 * Returns a string produced according to the formatting string. It replaces
 * all <i>%s</i> occurrences with the arguments provided.
 *
 * @link http://www.php.net/sprintf
 * @type {String}
 */
String.prototype.sprintf = function() {
    // Create a new string from the old one, don't just create a copy
    var str = this.toString(),
        i   = 0,
        inx = str.indexOf("%s");
    while (inx >= 0) {
        var replacement = arguments[i++] || " ";
        str = str.substr(0, inx) + replacement + str.substr(inx + 2);
        inx = str.indexOf("%s");
    }
    return str;
};

//})(); //end closure




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/iepngfix.js)SIZE(3570)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @private
 */
apf.iepngfix = (function() {
    var sNodes           = null, 
        aNodes           = null,
        applyPositioning = true,
        // Path to a transparent GIF image
        shim,

        fnLoadPngs = function() {
            if (!shim)
                shim = apf.skins.skins["default"].mediaPath + '/blank.gif';

            if (aNodes === null) {
                if (sNodes)
                    aNodes = sNodes.splitSafe(',');
                else
                    aNodes = [document];
            }

            function fixMe(obj) {
                // background pngs
                if (obj.currentStyle.backgroundImage.match(/\.png/i) !== null)
                    bg_fnFixPng(obj);
                // image elements
                if (obj.tagName == 'IMG' && obj.src.match(/\.png$/i) !== null)
                    el_fnFixPng(obj);
                // apply position to 'active' elements
                if (applyPositioning && (obj.tagName == 'A' || obj.tagName == 'INPUT')
                  && obj.style.position === '') {
                    obj.style.position = 'relative';
                }
            }

            for (var j = 0, l = aNodes.length, node; j < l; j++) {
                if (typeof aNodes[j] == "string")
                    aNodes[j] = document.getElementById(aNodes[j]);
                node = aNodes[j];
                if (!node) continue;

                if (node != document)
                    fixMe(node);

                for (var i = node.all.length - 1, obj = null; (obj = node.all[i]); i--)
                    fixMe(obj);
            }
        },

        bg_fnFixPng = function(obj) {
            var mode = 'scale',
                bg   = obj.currentStyle.backgroundImage,
                src  = bg.substring(5, bg.length - 2);

            if (obj.currentStyle.backgroundRepeat == 'no-repeat')
                mode = 'crop';
            obj.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='"
                + src + "', sizingMethod='" + mode + "')";
            obj.style.backgroundImage = "url(" + shim + ")";
        },

        el_fnFixPng = function(img) {
            var src          = img.src;
            img.style.width  = img.width  + "px";
            img.style.height = img.height + "px";
            img.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='"
                + src + "', sizingMethod='scale')";
            img.src          = shim;
        };

    return {
        limitTo: function(s) {
            sNodes = s;
            return this;
        },
        run: fnLoadPngs
    };
})();




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/json.js)SIZE(18147)TIME(1264204862)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Creates xml nodes from an JSON string/ object recursively.
 *
 * @param {String}  strJson     the JSON definition.
 * @param {Boolean} [noError]  whether an exception should be thrown by the parser when the xml is not valid.
 * @param {Boolean} [preserveWhiteSpace]  whether whitespace that is present between XML elements should be preserved
 * @return {XMLNode} the created xml document (NOT the root-node).
 */
 
apf.json2xml_Obj  = {};
apf.json2xml_Attr = {};
apf.json2xml_ObjByAttr = {};
 
apf.json2Xml = (function(){
    var jsonToXml = function (v, name, xml, notag) {
        var i, n, m, t; 
        // do an apf warn
        function cleanString(s){
            return s.replace(/&/g,"&amp;").replace(/\</g,'&lt;').replace(/\>/g,'&gt;');
        }
        if(!notag){
            if(name != (m=name.replace(/[^a-zA-Z0-9_-]/g, "_")))
                apf.console.warn("Json2XML, invalid characters found in JSON tagname '" + name, "json2Xml");
            name = m;
        }    
        if (apf.isArray(v)) {
            for (i = 0, n = v.length; i < n; i++)
                jsonToXml(v[i],name,xml);
        }
        else if (typeof v == "object") {
            var hasChild = false, objAttr = null;
            
            if(!notag)xml.push("<", name);
            for (i in v) {
                if ((n=apf.json2xml_Attr[i]) || i.charAt(0)=='@'){
                    if(!n && !objAttr) objAttr = apf.json2xml_ObjByAttr[i.slice(1)];
                    if(!notag)xml.push(" ", n?n:i.slice(1), "=\"", cleanString(v[i].toString()), "\"");
                } else 
                   hasChild = true;
            }
            if (hasChild) {
                if(!notag)xml.push(">");
                if(t=(objAttr || apf.json2xml_Obj[name])){
                    if(t==1) t = { child : name.replace(/(.*)s$/,"$1")||name, key : "name", value: "value"};
                    for (i in v) {
                        if(i.charAt(0)!='@' && !apf.json2xml_Attr[i]){
                            if( typeof(m = v[i]) =='object'){
                                if(apf.json2xml_Obj[i]){
                                    jsonToXml(m,i,xml);
                                }else {
                                    xml.push("<",t.child," ",t.key,"=\"",cleanString(i.toString()),"\" >");
                                    jsonToXml(m, i,xml,true);
                                    xml.push("</",t.child,">\n");
                                }
                            } else {
                                xml.push("<",t.child," ",t.key,"=\"",i,"\" ");
                                if(t.value){
                                    if(t.value==1)
                                        xml.push("/>");
                                    else
                                        xml.push(t.value,"=\"",cleanString(v[i].toString()),"\"/>");
                                }else
                                 xml.push(">",cleanString(v[i].toString()),"</",t.child,">");
                            }
                        }
                    }
                    if(!notag)xml.push("</",name,">\n");
                }else{
                    for (i in v) {
                        if (!apf.json2xml_Attr[i] && i.charAt(0)!='@'){
                           if(i.match(/[^a-zA-Z0-9_-]/g)){
                               apf.console.warn("Json2XML, invalid characters found in JSON tagname: '" + i, "json2Xml");
                           }else
                               jsonToXml(v[i], i, xml,false);
                        }
                    }
                    if(!notag)xml.push("</", name, ">");
                }
            }else if(!notag)xml.push("/>");
        }
        else {
            if(!notag)xml.push("<", name, ">", cleanString(v.toString()), "</", name, ">");
            else xml.push( cleanString(v.toString()));
       }
     
    }
        
    return function(strJson, noError, preserveWhiteSpace) {
        var o   = (typeof strJson == "string" && apf.isJson(strJson))
          ? JSON.parse(strJson.replace(/""/g, '" "'))//eval("(" + strJson + ")")
          : strJson,
            xml = [], i;
        jsonToXml(o,"jsondoc", xml, false);

        return apf.getXmlDom(xml.join("").replace(/\t|\n/g, ""), noError, true);//preserveWhiteSpace);//@todo apf3.0
    };
})();

apf.xml2json = function (xml, noattrs) {
    // alright! lets go and convert our xml back to json.
    var filled, out = {}, o, nodes = xml.childNodes, cn, i,j, n,m, u,v,w, s,t,cn1,u1,v1,t1,name; 

    if(!noattrs){
        if(m = (xml.attributes))for(u = 0,v = m.length; u < v; u++){
          t = apf.json2xml_Attr[w=m[u].nodeName] || ('@'+w);
          if(t.indexOf('@a_')!=0)out[t] = m[u].nodeValue, filled = true;
        }
    }

    for (var i = 0, j = nodes.length;i<j; i++) {
        if ((n = nodes[i]).nodeType != 1)
            continue;
         name = n.tagName;
        filled = true;

        // scan for our special attribute
        t = s = null,o = {};

        if(m = (n.attributes))for(u = 0,v = m.length; u < v; u++){
            o['@'+(w = m[u].nodeName)] = m[u].nodeValue;
            if(!s)s = apf.json2xml_ObjByAttr[w];
        }
        if(t = s || apf.json2xml_Obj[name]){
            if(t==1)t={key:'name',value:'value'};
            // lets enumerate the children
            for(cn = n.childNodes, u=0,v = cn.length;u<v;u++){
                if ((s = cn[u]).nodeType != 1) continue;
                
                if(t1 = apf.json2xml_Obj[s.nodeName]){
                    var o2={};
                    for(cn1 = s.childNodes, u1=0,v1 = cn1.length;u1<v1;u1++){
                        if ((s1 = cn1[u1]).nodeType != 1) continue;
                         if(w=s1.getAttribute(t1.key)){
                            o2[w] = (t1.value==1?(s1.childNodes.length?apf.xml2json(s1,1):1):(s1.getAttribute(t1.value||'value')) || apf.xml2json(s1,1));
                        }
                    }
                    o[s.nodeName]=o2;
                } else {
                    if(w=s.getAttribute(t.key)){
                        o[w] = (t.value==1?(s.childNodes.length?apf.xml2json(s,1):1):(s.getAttribute(t.value||'value')) || apf.xml2json(s,1));
                    }
               }
            }
        }else{
            o =  apf.xml2json( n );
        }
        if(out[name] !== undefined){
            if((s=out[name]).dataType!=apf.ARRAY)
                out[name]=[s,o];
            else out[name].push(o);
        }else out[name] = o;
   }
   return filled ? out : apf.queryValue(xml, "text()");
};




/**
 * Reliably determines whether a variable is a string of JSON.
 * @see http://json.org/
 *
 * @param {mixed}   value The variable to check
 * @type  {Boolean}
 */
apf.isJson = (function() {
    var escapes  = /\\["\\\/bfnrtu]/g,
        values   = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
        brackets = /(?:^|:|,)(?:\s*\[)+/g,
        invalid  = /^[\],:{}\s]*$/;

    return function(value) {
        if (!value) return false;
        return invalid.test(
            value.replace(escapes, '@').replace(values, ']').replace(brackets, '')
        );
    }
})();

if (!self["JSON"]) {
    self["JSON"] = (function() {
    // Will match a value in a well-formed JSON file.
    // If the input is not well-formed, may match strangely, but not in an
    // unsafe way.
    // Since this only matches value tokens, it does not match whitespace,
    // colons, or commas.
    // The second line of the regex string matches numbers, lines number 4,
    // 5 and 6 match a string and line number 5 specifically matches one
    // character.
    var jsonToken       = new RegExp(
'(?:false|true|null|[\\{\\}\\[\\]]|\
(?:-?\\b(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\b)\
|\
(?:\"\
(?:[^\\0-\\x08\\x0a-\\x1f\"\\\\]|\\\\(?:[\"/\\\\bfnrt]|u[0-9A-Fa-f]{4}))\
*\"))', "g"),
        // Matches escape sequences in a string literal
        escapeSequence  = new RegExp("\\\\(?:([^u])|u(.{4}))", "g"),
        // Decodes escape sequences in object literals
        escapes         = {
            "\"": "\"",
            "/": "/",
            "\\": "\\",
            "b": "\b",
            "f": "\f",
            "n": "\n",
            "r": "\r",
            "t": "\t"
        },
        unescapeOne     = function(_, ch, hex) {
            return ch ? escapes[ch] : String.fromCharCode(parseInt(hex, 16));
        },
        // A non-falsy value that coerces to the empty string when used as a key.
        EMPTY_STRING    = new String(""),
        SLASH           = "\\",
        // Constructor to use based on an open token.
        firstTokenCtors = { "{": Object, "[": Array },
        hop             = Object.hasOwnProperty,
        padd            = function(s, p){
            s = p + s;
            return s.substring(s.length - p.length);
        },
        jsonSerialize   = {
            //Object
            0: function(o){
                //XML support - NOTICE: Ajax.org Platform specific
                if (o.nodeType && o.ownerDocument && o.cloneNode(true)) // was o.nodeType && o.cloneNode
                    return "apf.xmldb.getXml("
                        + JSON.stringify(apf.getXmlString(o)) + ")"; // was this.string()

                //Normal JS object support
                var str = [];
                for (var prop in o) {
                    str.push('"' + prop.replace(/(["\\])/g, '\\$1') + '": '
                        + JSON.stringify(o[prop]));
                }

                return "{" + str.join(", ") + "}";
            },
            
            //String
            5: function(s){
                s = '"' + s.replace(/(["\\])/g, '\\$1') + '"';
                return s.replace(/(\n)/g, "\\n").replace(/\r/g, "");
            },

            //Number
            2: function(i){
                return i.toString();
            },

            //Boolean
            4: function(b){
                return b.toString();
            },

            //Date
            3: function(d){
                return '{"jsonclass":["sys.ISODate", ["'
                    + padd(d.getUTCFullYear(), "0000")
                    + padd(d.getUTCMonth() + 1, "00") 
                    + padd(d.getUTCDate(), "00") + "T" 
                    + padd(d.getUTCHours(), "00") + ":" 
                    + padd(d.getUTCMinutes(), "00") + ":" 
                    + padd(d.getUTCSeconds(), "00")
                    + '"]]}';
            },

            //Array
            1: function(a){
                for (var q = [], i = 0; i < a.length; i++)
                    q.push(JSON.stringify(a[i]));

                return "[" + q.join(", ") + "]";
            },
            
            // Method
            7: function(f){
                return;
            }
        };


    return {
        parse: function(json, opt_reviver) {
            // Split into tokens
            var toks = json.match(jsonToken),
                // Construct the object to return
                result;
            var tok  = toks[0];
            if ("{" == tok)
                result = {};
            else if ("[" == tok)
                result = [];
            else
                throw new Error(tok);

            // If undefined, the key in an object key/value record to use for the next
            // value parsed.
            var key, cont,
                stack = [result];
            // Loop over remaining tokens maintaining a stack of uncompleted objects and
            // arrays.
            for (var i = 1, n = toks.length; i < n; ++i) {
                tok = toks[i];
                switch (tok.charCodeAt(0)) {
                    default:  // sign or digit
                        cont = stack[0];
                        cont[key || cont.length] = +(tok);
                        key = void 0;
                        break;
                    case 0x22:  // '"'
                        tok = tok.substring(1, tok.length - 1);
                        if (tok.indexOf(SLASH) !== -1) {
                            tok = tok.replace(escapeSequence, unescapeOne);
                        }
                        cont = stack[0];
                        if (!key) {
                            if (cont instanceof Array) {
                                key = cont.length;
                            }
                            else {
                                key = tok || EMPTY_STRING;  // Use as key for next value seen.
                                break;
                            }
                        }
                        cont[key] = tok;
                        key = void 0;
                        break;
                    case 0x5b:  // '['
                        cont = stack[0];
                        stack.unshift(cont[key || cont.length] = []);
                        key = void 0;
                        break;
                    case 0x5d:  // ']'
                        stack.shift();
                        break;
                    case 0x66:  // 'f'
                        cont = stack[0];
                        cont[key || cont.length] = false;
                        key = void 0;
                        break;
                    case 0x6e:  // 'n'
                        cont = stack[0];
                        cont[key || cont.length] = null;
                        key = void 0;
                        break;
                    case 0x74:  // 't'
                        cont = stack[0];
                        cont[key || cont.length] = true;
                        key = void 0;
                        break;
                    case 0x7b:  // '{'
                        cont = stack[0];
                        stack.unshift(cont[key || cont.length] = {});
                        key = void 0;
                        break;
                    case 0x7d:  // '}'
                        stack.shift();
                        break;
                }
            }
            // Fail if we've got an uncompleted object.
            if (stack.length)
                throw new Error();

            if (opt_reviver) {
                // Based on walk as implemented in http://www.json.org/json2.js
                var walk = function(holder, key) {
                    var value = holder[key];
                    if (value && typeof value == "object") {
                        var toDelete = null;
                        for (var k in value) {
                            if (hop.call(value, k) && value !== holder) {
                                // Recurse to properties first.  This has the effect of causing
                                // the reviver to be called on the object graph depth-first.
                                // Since 'this' is bound to the holder of the property, the
                                // reviver can access sibling properties of k including ones
                                // that have not yet been revived.
                                // The value returned by the reviver is used in place of the
                                // current value of property k.
                                // If it returns undefined then the property is deleted.
                                var v = walk(value, k);
                                if (v !== void 0) {
                                    value[k] = v;
                                }
                                else {
                                    // Deleting properties inside the loop has vaguely defined
                                    // semantics in ES3 and ES3.1.
                                    if (!toDelete)
                                        toDelete = [];
                                    toDelete.push(k);
                                }
                            }
                        }
                        if (toDelete) {
                            for (var i = toDelete.length; --i >= 0;)
                                delete value[toDelete[i]];
                        }
                    }
                    return opt_reviver.call(holder, key, value);
                };
                result = walk({ "": result }, "");
            }
            return result;
        },
        stringify: function(o) {
            if (typeof args == "function" || apf.isNot(o))
                return "null";
            return jsonSerialize[o.dataType || 0](o);
        }
    };

    })();
}

/**
 * Creates a json string from a javascript object.
 * @param  {mixed}  o the javascript object to serialize.
 * @return {String} the json string representation of the object.
 * @todo allow for XML serialization
 */
apf.serialize = function(o){
    return self.JSON.stringify(o);
};

/**
 * Evaluate a serialized object back to JS with eval(). When the 'secure' flag
 * is set to 'TRUE', the provided string will be validated for being valid
 * JSON.
 *
 * @param  {String} str the json string to create an object from.
 * @return {Object} the object created from the json string.
 */
apf.unserialize = function(str){
    if (!str) return str;
    return self.JSON.parse(str);
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/hotkey.js)SIZE(3111)TIME(1257329189)*/


//@todo maybe generalize this to pub/sub event system??
/**
 * @private
 */
apf.hotkeys = {};

/**
 * @private
 */
apf.keyMods = {"ctrl": 1, "alt": 2, "shift": 4, "meta": 8};

/**
 * @private
 */
apf.keyNames = {
    "32" : "Spacebar",
    "13" : "Enter",
    "9"  : "Tab",
    "27" : "Esc",
    "46" : "Del",
    "36" : "Home",
    "35" : "End",
    "107": "+",
    "37" : "Left Arrow",
    "38" : "Up Arrow",
    "39" : "Right Arrow",
    "40" : "Down Arrow",
    "33" : "Page Up",
    "34" : "Page Down",
    "112": "F1",
    "113": "F2",
    "114": "F3",
    "115": "F4",
    "116": "F5",
    "117": "F6",
    "118": "F7",
    "119": "F8",
    "120": "F9",
    "121": "F10",
    "122": "F11",
    "123": "F12"
};

/**
 * Registers a hotkey handler to a key combination.
 * Example:
 * <code>
 *   apf.registerHotkey('Ctrl-Z', undoHandler);
 * </code>
 * @param {String}   hotkey  the key combination to user. This is a
 * combination of Ctrl, Alt, Shift and a normal key to press. Use + to
 * seperate the keys.
 * @param {Function} handler the code to be executed when the key
 * combination is pressed.
 */
apf.registerHotkey = function(hotkey, handler){
    var hashId = 0, key;

    var keys = hotkey.splitSafe("\\-|\\+| ", null, true),
        bHasCtrl = false,
        bHasMeta = false;
    for (var i = 0; i < keys.length; i++) {
        if (apf.keyMods[keys[i]]) {
            hashId = hashId | apf.keyMods[keys[i]];
            if (apf.isMac) {
                bHasCtrl = (apf.keyMods[keys[i]] === apf.keyMods["ctrl"]);
                bHasMeta = (apf.keyMods[keys[i]] === apf.keyMods["meta"]);
            }
        }
        else
            key = keys[i];
    }

    if (bHasCtrl && !bHasMeta) //for improved Mac hotkey support
        hashId = hashId | apf.keyMods["meta"];

    
    if (!key) {
        throw new Error("missing key for hotkey: " + hotkey);
    }
    

    (apf.hotkeys[hashId] || (apf.hotkeys[hashId] = {}))[key] = handler;

    if (!apf.initHotkey) {
        apf.initHotkey = true;
        apf.addEventListener("hotkey", function(e){
            // enable meta-hotkey support for macs, like for Apple-Z, Apple-C, etc.
            if (apf.isMac && e.metaKey)
                e.ctrlKey = true;
            var hashId = 0 | (e.ctrlKey ? 1 : 0)
                | (e.shiftKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);

            var key = apf.keyNames[e.keyCode];
            if (!hashId && !key) //Hotkeys should always have one of the modifiers
                return;

            var handler = (apf.hotkeys[hashId] || {})[(key
                || String.fromCharCode(e.keyCode)).toLowerCase()];
            if (handler) {
                handler();
                e.returnValue = false;
            }
        });
    }
};

/**
 * Removes a registered hotkey.
 * @param {String} hotkey the hotkey combination.
 */
apf.removeHotkey = function(hotkey){
    apf.registerHotkey(hotkey, null);
};


/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/abstractevent.js)SIZE(4769)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */
  


/**
 * @constructor
 * @private
 */
apf.AbstractEvent = function(event, win) {
    win = win || window;
    var doc = win.document;
    event = event || win.event;
    if (event.$extended) return event;
    this.$extended = true;

    this.event = event;

    this.type   = event.type;
    this.target = event.target || event.srcElement;
    while (this.target && this.target.nodeType == 3)
        this.target = this.target.parentNode;

    if (this.type.indexOf("key") != -1) {
        this.code = event.which || event.keyCode;
        /*this.key = apf.AbstractEvent.KEYS.fromCode(this.code);
        if (this.type == 'keydown') {
            var fKey = this.code - 111;
            if (fKey > 0 && fKey < 13)
                this.key = 'f' + fKey;
        }
        this.key = this.key || String.fromCharCode(this.code).toLowerCase();*/
    }
    else if (this.type.match(/(click|mouse|menu)/i)) {
        doc = (!doc.compatMode || doc.compatMode == 'CSS1Compat') ? doc.html : doc.body;
        this.page = {
            x: event.pageX || event.clientX + (doc ? doc.scrollLeft : 0),
            y: event.pageY || event.clientY + (doc ? doc.scrollTop  : 0)
        };
        this.client = {
            x: (event.pageX) ? event.pageX - win.pageXOffset : event.clientX,
            y: (event.pageY) ? event.pageY - win.pageYOffset : event.clientY
        };
        if (this.type.match(/DOMMouseScroll|mousewheel/)){
            this.wheel = (event.wheelDelta) ? event.wheelDelta / 120 : -(event.detail || 0) / 3;
        }
        this.rightClick = (event.which == 3) || (event.button == 2);
        this.relatedTarget = null;
        if (this.type.match(/over|out/)) {
            if (this.type == "mouseover")
                this.relatedTarget = event.relatedTarget || event.fromElement;
            else if (this.type == "mouseout")
                this.relatedTarget = event.relatedTarget || event.toElement;
            else {
                try {
                    while (this.relatedTarget && this.relatedTarget.nodeType == 3)
                        this.relatedTarget = this.relatedTarget.parentNode;
                }
                catch(e) {}
            }
        }
    }
    
    this.shift   = Boolean(event.shiftKey);
    this.control = Boolean(event.ctrlKey);
    this.alt     = Boolean(event.altKey);
    this.meta    = Boolean(event.metaKey)

    this.stop = function(){
        return this.stopPropagation().preventDefault();
    };

    this.stopPropagation = function(){
        if (this.event.stopPropagation)
            this.event.stopPropagation();
        else
            this.event.cancelBubble = true;
        return this;
    };

    this.preventDefault = function(){
        if (this.event.preventDefault)
            this.event.preventDefault();
        else
            this.event.returnValue = false;
        return this;
    };
};

apf.AbstractEvent.KEYS = {
    'enter'    : 13,
    'up'       : 38,
    'down'     : 40,
    'left'     : 37,
    'right'    : 39,
    'esc'      : 27,
    'space'    : 32,
    'backspace': 8,
    'tab'      : 9,
    'delete'   : 46,

    fromCode: function(code) {
        for (var i in this) {
            if (this[i] == code)
                return i;
            return null;
        }
    }
};

apf.AbstractEvent.stop = function(event) {
    return (new apf.AbstractEvent(event)).stop();
};

apf.AbstractEvent.addListener = function(el, type, fn){
    if (el.addEventListener)
        el.addEventListener(type, fn, false);
    else if (el.attachEvent)
        el.attachEvent('on' + type, fn);
    return this;
};

apf.AbstractEvent.removeListener = function(el, type, fn){
    if (el.removeEventListener)
        el.removeEventListener(type, fn, false);
    else if (el.detachEvent)
        el.detachEvent('on' + type, fn);
    return this;
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/style.js)SIZE(14707)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * This method sets a single css rule
 * @param {String} name         the css name of the rule (i.e. '.cls' or '#id').
 * @param {String} type         the css property to change.
 * @param {String} value        the css value of the property.
 * @param {String} [stylesheet] the name of the stylesheet to change.
 */
apf.setStyleRule = function(name, type, value, stylesheet, win){
    name = name.toLowerCase();
    
    if (!stylesheet) {
        var sheets = (win || self).document.styleSheets;
        for (var j = sheets.length - 1; j >= 0; j--) {
            try {
                var rules = sheets[j][apf.styleSheetRules];
                for (var i = 0; i < rules.length; i++) {
                    if (rules.item(i).selectorText.toLowerCase() == name) {
                        rules.item(i).style[type] = value;
                        return true;
                    }
                }
            }
            catch(e){}
        }
    }
    else {
        var rules = (win || self).document.styleSheets[stylesheet || 0][apf.styleSheetRules];
        for (var i = 0; i < rules.length; i++) {
            if (rules.item(i).selectorText.toLowerCase() == name) {
                rules.item(i).style[type] = value;
                return true;
            }
        }
    }
    
    return false;
};

/**
 * This method gets a single css rule
 * @param {String} name         the css name of the rule (i.e. '.cls' or '#id').
 * @param {String} type         the css property to change.
 * @param {String} [stylesheet] the name of the stylesheet to change.
 */
apf.getStyleRule = function(name, type, stylesheet, win){
    name = name.toLowerCase();
    
    if (!stylesheet) {
        var sheets = (win || self).document.styleSheets;
        for (var j = sheets.length - 1; j >= 0; j--) {
            try {
                var rules = sheets[j][apf.styleSheetRules];
                for (var i = 0; i < rules.length; i++) {
                    if (rules.item(i).selectorText.toLowerCase() == name) {
                        return rules.item(i).style[type];
                    }
                }
            }
            catch(e){}
        }
    }
    else {
        var rules = (win || self).document.styleSheets[stylesheet || 0][apf.styleSheetRules];
        for (var i = 0; i < rules.length; i++) {
            if (rules.item(i).selectorText.toLowerCase() == name) {
                return rules.item(i).style[type];
            }
        }
    }
    
    return false;
}

/**
 * This method adds one class name to an HTMLElement and removes none or more.
 * @param {HTMLElement} oHtml        the HTMLElement to apply the css class to.
 * @param {String}      className    the name of the css class to apply.
 * @param {Array}       [exclusion]  a list of strings specifying names of css classes to remove.
 * @returns {HTMLElement}
 */
apf.setStyleClass = function(oHtml, className, exclusion, special){
    if (!oHtml || this.disabled)
        return;

    
    if (oHtml.nodeFunc) {
        throw new Error(apf.formatErrorString(0, this,
            "Setting style class",
            "Trying to set style class on aml node. Only xml or html nodes can \
             be passed to this function"));
    }
    

    if (className) {
        if (exclusion)
            exclusion[exclusion.length] = className;
        else
            exclusion = [className];
    }

    //Create regexp to remove classes
    //var re = new RegExp("(?:(^| +)" + (exclusion ? exclusion.join("|") : "") + "($| +))", "gi");
    var re = new RegExp("(^| +)(?:" + (exclusion ? exclusion.join("|") : "") + ")", "gi");

    //Set new class
    oHtml.className != null
        ? (oHtml.className = oHtml.className.replace(re, " ") + (className ? " " + className : ""))
        : oHtml.setAttribute("class", (oHtml.getAttribute("class") || "")
            .replace(re, " ") + (className ? " " + className : ""));

    return oHtml;
};

/**
 * This method imports a css stylesheet from a string
 * @param {String} cssString  the css definition
 * @param {Object} [doc]      the reference to the document where the css is applied on
 * @param {String} [media]    the media to which this css applies (i.e. 'print' or 'screen')
 */
apf.importCssString = function(cssString, doc, media){
    doc = doc || document;
    var htmlNode = doc.getElementsByTagName("head")[0];//doc.documentElement.getElementsByTagName("head")[0];

    
    if (!apf.supportOpacity) {
        cssString = cssString.replace(/opacity[ \s]*\:[ \s]*([\d\.]+)/g,
            function(m, m1){
                return "filter:progid:DXImageTransform.Microsoft.Alpha(opacity=" + (m1*100) + ")";
            });
    }
    

    if (apf.canCreateStyleNode) {
        //var head  = document.getElementsByTagName("head")[0];
        var style = doc.createElement("style");
        style.appendChild(doc.createTextNode(cssString));
        if (media)
            style.setAttribute('media', media);
        htmlNode.appendChild(style);
    }
    else {
        htmlNode.insertAdjacentHTML("beforeend", ".<style media='"
         + (media || "all") + "'>" + cssString + "</style>");

        /*if(document.body){
            document.body.style.height = "100%";
            $setTimeout('document.body.style.height = "auto"');
        }*/
    }
};

/**
 * This method retrieves the current value of a property on a HTML element
 * recursively. If the style isn't found on the element itself, it's parent is
 * checked.
 * @param {HTMLElement} el    the element to read the property from
 * @param {String}      prop  the property to read
 * @returns {String}
 */
apf.getStyleRecur = function(el, prop) {
    var value = apf.hasComputedStyle
        ? document.defaultView.getComputedStyle(el,'').getPropertyValue(
            prop.replace(/([A-Z])/g, function(m, m1){
                return "-" + m1.toLowerCase();
            }))
        : el.currentStyle[prop]

    return ((!value || value == "transparent" || value == "inherit")
      && el.parentNode && el.parentNode.nodeType == 1)
        ? this.getStyleRecur(el.parentNode, prop)
        : value;
};

/**
 * This method imports a stylesheet defined in a multidimensional array 
 * @param {Array}    def Required Multidimensional array specifying 
 * @param {Object}    win Optional Reference to a window
 * @method
 * @deprecated
 */    
apf.importStylesheet = function (def, win){
    for (var i = 0; i < def.length; i++) {
        if (!def[i][1]) continue;
        
        if (apf.isIE)
            (win || window).document.styleSheets[0].addRule(def[i][0],
                def[i][1]);
        else
            (win || window).document.styleSheets[0].insertRule(def[i][0]
                + " {" + def[i][1] + "}", 0);
    }
}

/**
 * This method determines if specified coordinates are within the HTMLElement.
 * @param {HTMLElement} el  the element to check
 * @param {Number}      x   the x coordinate in pixels
 * @param {Number}      y   the y coordinate in pixels
 * @returns {Boolean}
 */
apf.isInRect = function(oHtml, x, y){
    var pos = this.getAbsolutePosition(oHtml);
    if (x < pos[0] || y < pos[1] || x > oHtml.offsetWidth + pos[0] - 10
      || y > oHtml.offsetHeight + pos[1] - 10)
        return false;
    return true;
};

/**
 * Retrieves the parent which provides the rectangle to which the HTMLElement is
 * bound and cannot escape. In css this is accomplished by having the overflow
 * property set to hidden or auto.
 * @param {HTMLElement} o  the element to check
 * @returns {HTMLElement}
 */
apf.getOverflowParent = function(o){
    //not sure if this is the correct way. should be tested

    o = o.offsetParent;
    while (o && (this.getStyle(o, "overflow") != "hidden"
      || "absolute|relative".indexOf(this.getStyle(o, "position")) == -1)) {
        o = o.offsetParent;
    }
    return o || document.documentElement;
};

/**
 * Retrieves the first parent element which has a position absolute or
 * relative set.
 * @param {HTMLElement} o  the element to check
 * @returns {HTMLElement}
 */
apf.getPositionedParent = function(o){
    o = o.offsetParent;
    while (o && o.tagName.toLowerCase() != "body"
      && "absolute|relative".indexOf(this.getStyle(o, "position")) == -1) {
        o = o.offsetParent;
    }
    return o || document.documentElement;
};

/**
 * Retrieves the absolute x and y coordinates, relative to the browsers
 * drawing area or the specified refParent.
 * @param {HTMLElement} oHtml       the element to check
 * @param {HTMLElement} [refParent] the reference parent
 * @param {Boolean}     [inclSelf]  whether to include the position of the element to check in the return value.
 * @returns {Array} the x and y coordinate of oHtml.
 */
apf.getAbsolutePosition = function(o, refParent, inclSelf){
    if ("getBoundingClientRect" in document.documentElement) { 
        if (apf.doesNotIncludeMarginInBodyOffset && o == document.body) {
            return [
                o.offsetLeft + (parseFloat(apf.getStyle(o, apf.descPropJs
                    ? "marginLeft"
                    : "margin-top")) || 0),
                  + (o.scrollLeft || 0),
                o.offsetTop  + (parseFloat(apf.getStyle(o, apf.descPropJs
                    ? "marginTop"
                    : "margin-top")) || 0)
                  + (o.scrollTop || 0)
            ];
        }
        
        var box  = o.getBoundingClientRect(), 
            top  = box.top,
            left = box.left,
            corr = (apf.isIE && apf.isIE < 8);

        /*if (refParent != document.body) {
            var pos = apf.getAbsolutePosition(refParent);
            top -= pos[1];
            left -= pos[0];
        }*/
        
        if (!(apf.isIE && o == document.documentElement)) {
            left += document.body.scrollLeft || document.documentElement.scrollLeft || 0;
            top  += document.body.scrollTop  || document.documentElement.scrollTop  || 0;
        }

        return [left - (corr ? 2 : 0), top - (corr ? 2 : 0)];
    }
    
    //@todo code below might be deprecated one day
    var wt = inclSelf ? 0 : o.offsetLeft, ht = inclSelf ? 0 : o.offsetTop;
    o = inclSelf ? o : o.offsetParent || o.parentNode ;

    if (apf.isIE8 && refParent) {
        bw = this.getStyle(o, "borderLeftWidth");
        wt -= (apf.isIE && o.currentStyle.borderLeftStyle != "none" 
          && bw == "medium" ? 2 : parseInt(bw) || 0);
        bh = this.getStyle(o, "borderTopWidth");
        ht -= (apf.isIE && o.currentStyle.borderTopStyle != "none" 
          && bh == "medium" ? 2 : parseInt(bh) || 0);
    }

    var bw, bh, fl;
    while (o && o != refParent) {//&& o.tagName.toLowerCase() != "html"
        //Border - Left
        bw = apf.isOpera || apf.isIE8 ? 0 : this.getStyle(o, apf.descPropJs
            ? "borderLeftWidth" : "border-left-width");

        wt += (apf.isIE && o.currentStyle.borderLeftStyle != "none" && bw == "medium"
            ? 2
            : parseInt(bw) || 0) + o.offsetLeft;

        if (apf.isIE && !apf.isIE8 && apf.getStyle(o, "styleFloat") == "none" 
          && apf.getStyle(o, "position") == "relative") {
            var q = o.previousSibling;
            while (q) {
                if (q.nodeType == 1) {
                    fl = apf.getStyle(q, "styleFloat");
                    if (fl == "left") {
                        wt -= parseInt(apf.getStyle(o, "marginLeft")) 
                            || 0;//-1 * (o.parentNode.offsetWidth - o.offsetWidth)/2; //assuming auto
                        break;
                    }
                    else if (fl == "right")
                        break;
                }
                q = q.previousSibling;
            }
        }

        //Border - Top
        bh = apf.isOpera || apf.isIE8 ? 0 : this.getStyle(o, apf.descPropJs
            ? "borderTopWidth" : "border-top-width");
        ht += (apf.isIE && o.currentStyle.borderTopStyle != "none" && bh == "medium"
            ? 2
            : parseInt(bh) || 0) + o.offsetTop;

        //Scrolling
        if (!apf.isGecko && o != refParent && (o.tagName != "HTML" || o.ownerDocument != document)) {
            wt -= o.scrollLeft;
            ht -= o.scrollTop;
        }
        
        //Table support
        if (o.tagName.toLowerCase() == "table") {
            ht -= parseInt(o.border || 0) + parseInt(o.cellSpacing || 0);
            wt -= parseInt(o.border || 0) + parseInt(o.cellSpacing || 0) * 2;
        }
        else if (o.tagName.toLowerCase() == "tr") {
            var cp;
            ht -= (cp = parseInt(o.parentNode.parentNode.cellSpacing));
            while (o.previousSibling)
                ht -= (o = o.previousSibling).offsetHeight + cp;
        }

        if (apf.isIE && !o.offsetParent && o.parentNode.nodeType == 1) {
            wt -= o.parentNode.scrollLeft;
            ht -= o.parentNode.scrollTop;
        }

        o = o.offsetParent;
    }

    return [wt, ht];
};

/**
 * Returns the viewport of the a window.
 *
 * @param  {WindowImplementation} [win] The window to take the measurements of.
 * @return {Object}                     Viewport object with fields x, y, w and h.
 * @type   {Object}
 */
apf.getViewPort = function(win) {
    win = win || window;
    var doc = (!win.document.compatMode
      || win.document.compatMode == "CSS1Compat")
        //documentElement for an iframe
        ? win.document.html || win.document.documentElement
        : win.document.body;

    // Returns viewport size excluding scrollbars
    return {
        x     : win.pageXOffset || doc.scrollLeft,
        y     : win.pageYOffset || doc.scrollTop,
        width : win.innerWidth  || doc.clientWidth,
        height: win.innerHeight || doc.clientHeight
    };
}




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/plane.js)SIZE(4361)TIME(1263427263)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * @private
 */
apf.plane = {
    init : function(){
        if (!this.plane) {
            this.plane                  = document.createElement("DIV");
            document.body.appendChild(this.plane);
            this.plane.style.background = "url(images/spacer.gif)";
            this.plane.style.position   = "absolute";
            this.plane.style.zIndex     = 100000000;
            this.plane.style.left       = 0;
            this.plane.style.top        = 0;
            //this.plane.style.backgroundColor = "red";
        }
    },

    lastCursor : null,
    show : function(o, dontAppend, copyCursor){
        this.init();

        var plane    = this.plane;
        this.current = o;
        //o.parentNode.appendChild(plane);

        if (!dontAppend) {
            this.lastZ = this.current.style.zIndex;
            this.current.style.zIndex = 100000;
        }
        else {
            this.plane.appendChild(o);
        }
        
        var pWidth = (plane.parentNode == document.body
            ? (apf.isIE //@todo apf3.0 test this: was offsetParent 
                ? document.documentElement.offsetWidth - (apf.isIE < 8 ? 2 : 4)
                : window.innerWidth)
            : plane.parentNode.offsetWidth);

        var pHeight = (plane.parentNode == document.body
            ? (apf.isIE //@todo apf3.0 test this: was offsetParent 
                ? document.documentElement.offsetHeight - (apf.isIE < 8 ? 2 : 4)
                : window.innerHeight)
            : plane.parentNode.offsetHeight);
        
        if (copyCursor) {
            if (this.lastCursor === null)
                this.lastCursor = document.body.style.cursor;
            document.body.style.cursor = apf.getStyle(o, "cursor");
        }
        
        this.plane.style.display = "block";
        //this.plane.style.left    = p.scrollLeft;
        //this.plane.style.top     = p.scrollTop;
        
        var diff = apf.getDiff(plane.parentNode);
        this.plane.style.width  = (pWidth - diff[0]) + "px";
        this.plane.style.height = (pHeight - diff[1]) + "px";

        return plane;
    },

    

    hide : function(){
        var isChild =
            
            apf.isChildOf(this.plane, document.activeElement);
            
        
        if (this.lastZ) {
            if (this.current.style.zIndex == 100000)
                this.current.style.zIndex = this.lastZ;
            this.lastZ = null;
        }

        if (this.current.parentNode == this.plane)
            this.plane.parentNode.appendChild(this.current);
        
        this.plane.style.display  = "none";
        
        if (isChild) {
            if (!apf.isIE)
                document.activeElement.focus();
            apf.document.activeElement.$focus();
        }
        
        this.current = null;
        
        if (this.lastCursor !== null) {
            document.body.style.cursor = this.lastCursor;
            this.lastCursor = null;
        }
        
        return this.plane;
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/xmldiff.js)SIZE(30022)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.xmlDiff = function (doc1, doc2){
    /*var domParser = new apf.DOMParser();
    domParser.allowAnyElement = true;
    domParser.preserveWhitespace = true;
    apf.compareDoc = domParser.parseFromXml(apf.getCleanCopy(mdlTest.data)).documentElement;

    var doc1 = apf.compareDoc,
        doc2 = apf.getCleanCopy(mdlTest2.data),*/

    var hash  = {},
        rules = [],
        appendRules = [],
        
        
        dt = new Date().getTime(),
        
        
        APPEND       = 1,
        UPDATE       = 2,
        REMOVE       = 3,
        SETATTRIBUTE = 4,

        notFoundEl = {}, notFoundAttr = {}, foundEl = {},
        foundTxt   = {}, foundAttr   = {}, curNode = {include: {}},

        arr, arrPath, l, lPath, found, path, p, t, j, i, a, item, subitem,
        arrIndex, lastRule, prop,
        emptyArr   = [], node;
    
    (function createHash(el, curPath, hash){
        var i, nodes, attr, l, a, e, p;

        curPath += "/" + el.tagName; //or mypath =  ?
        if (l = (nodes = el.childNodes).length){
            for (i = 0; i < l; i++) {
                if ((e = nodes[i]).nodeType == 1) {
                    createHash(nodes[i], curPath, hash);
                }
                else {
                    p = curPath + "/" + e.nodeType,
                    (hash[p] || (hash[p] = [])).push(e),
                    e.$isValid = false;
                }
            }
        }
        if (l = (attr = el.attributes).length){
            for (i = 0; i < l; i++) {
                p = curPath + "/@" + (a = attr[i]).nodeName,
                (hash[p] || (hash[p] = [])).push(a),
                a.$isValid = false;
            }
        }
        
        (hash[curPath] || (hash[curPath] = [])).push(el);
        el.$isValid = false;
        //el.$validChildren = 0;
    })(doc1, "", hash);

    curNode.include[doc1.parentNode.$uniqueId] = doc1;
    (function match(el, curPath, hash, pNode, curParentNode){
        var total, first, v, jl, item, include, i, nodes, attr, l, a, e, p, s, sh,
            tn, curNode, pcur, pcurl, id, count, node,
            max        = 0,
            found      = [],
            pInclude   = {length: 0},
            oldInclude = curParentNode.include;
        
        curPath += "/" + el.tagName; //or mypath =  ?
        if (!(s = hash[curPath])) {
            //rules.push([APPEND, el, curParentNode]);
            (notFoundEl[curPath] || (notFoundEl[curPath]  = [])).push({
                arr     : null,
                node    : el,
                curNode : curParentNode
            });
            return false;
        }
        else {
            //@todo optimize this
            include = (curNode = {}).include = {};
            for (i = 0, l = s.length; i < l; i++) {
                if ((item = s[i]))
                    include[item.$uniqueId] = item;
            }
            include.length = l;
        }
        
        if (l = (nodes = el.childNodes).length){
            for (i = 0; i < l; i++) {
                if ((e = nodes[i]).nodeType == 1) {
                    match(e, curPath, hash, pNode, curNode);
                }
                else {
                    if ((sh = hash[p = curPath + "/" + e.nodeType])) {
                        //Ignore the same node
                        for (total = 0, first = null, v = e.nodeValue, j = 0, jl = sh.length; j < jl; j++) {
                            //possible extra heuristic  && tn.parentNode.childNodes.length == e.parentNode.childNodes.length
                            if ((tn = sh[j]) && tn.nodeValue == v) { 
                                if (!first) {
                                    first = {
                                        node    : e,
                                        //node2   : tn,
                                        index   : j,
                                        //v       : v,
                                        arr     : sh,
                                        curNode : curNode,
                                        pcur    : [tn.parentNode.$uniqueId],
                                        found   : [j]
                                    };
                                }
                                else {
                                    first.found.push(j),
                                    first.pcur.push(tn.parentNode.$uniqueId);
                                }
                                total++;
                            }
                        }
                        
                        if (total) {
                            /*if (total == 1) {
                                (tn = first.node2).$isValid = true; //@todo might be removed
                                (tn = tn.ownerElement).$validChildren++;
                            }*/
                            
                            pcur = first.pcur, pcurl = pcur.length;
                            for (j = 0; j < pcurl; j++) {
                                if (curNode[pcur[j]]) 
                                    curNode[pcur[j]] += (1/total);
                                else 
                                    curNode[pcur[j]] = (1/total);
                            }

                            //delete sh[j];
                            (foundTxt[p] || (foundTxt[p] = [])).push(first);
                            
                            continue;
                        }
                        
                        //Update or New
                        (notFoundEl[p] || (notFoundEl[p] = [])).push({
                            arr     : sh,
                            node    : e,
                            curNode : curNode
                        });
                        
                        continue;
                    }
                    
                    //New node
                    //rules.push([APPEND, e, curNode]);
                    (notFoundEl[p] || (notFoundEl[p]  = [])).push({
                        isNew   : true,
                        arr     : null,
                        node    : e,
                        curNode : curNode
                    });
                }
            }
        }
        if (l = (attr = el.attributes).length){
            for (i = 0; i < l; i++) {
                pattr = curPath + "/@" + (a = attr[i]).nodeName;
                if (sh = hash[pattr]) {
                    //Ignore the same node
                    for (total = 0, first = null, v = a.nodeValue, j = 0, jl = sh.length; j < jl; j++) {
                        //possible extra heuristic  && tn.parentNode.childNodes.length == e.parentNode.childNodes.length
                        if ((tn = sh[j]) && tn.nodeValue == v) {
                            if (!first) {
                                first = {
                                    node    : a,
                                    //node2   : tn,
                                    index   : j,
                                    //v       : v,
                                    arr     : sh,
                                    curNode : curNode,
                                    pcur    : [tn.ownerElement.$uniqueId],
                                    found   : [j]
                                }
                            }
                            else {
                                first.found.push(j),
                                first.pcur.push(tn.ownerElement.$uniqueId);
                            }
                            total++;
                        }
                    }
                        
                    if (total) {
                        /*if (total == 1) {
                            (tn = first.node2).$isValid = true; //@todo might be removed
                            (tn = tn.ownerElement).$validChildren++;
                        }*/
                        
                        pcur = first.pcur, pcurl = pcur.length;
                        for (j = 0; j < pcurl; j++) {
                            if (curNode[pcur[j]]) 
                                curNode[pcur[j]] += (1 / total);
                            else 
                                curNode[pcur[j]]  = (1 / total);
                        }

                        //delete sh[j];
                        (foundAttr[pattr] || (foundAttr[pattr] = [])).push(first);
                        
                        continue;
                    }
                    
                    //Update or New
                    (notFoundAttr[pattr] || (notFoundAttr[pattr] = [])).push({
                        arr     : sh,
                        node    : a,
                        curNode : curNode
                    });
                    
                    continue;
                }
                
                //New node
                //rules.push([SETATTRIBUTE, a, curNode]);
                (notFoundAttr[pattr] || (notFoundAttr[pattr]  = [])).push({
                    isNew   : true,
                    arr     : null,
                    node    : a,
                    curNode : curNode
                });
            }
        }
        
        /*for (i = 0, l = s.length; i < l; i++) {
            //@todo only one? break here?, cache sum?
            if ((tn = s[i]) && tn.$validChildren == tn.childNodes.length + tn.attributes.length) {
                tn.$isValid = true;
                (tn = tn.parentNode).$validChildren++; //@todo -1 not enough?
                
                delete s[i];
            }
        }*/

        for (id in curNode) {
            if (curNode[id] > max) {
                max = curNode[id],
                //me = id;
                count = 1;
            }
            else if (curNode[id] == max) {
                count++;
            }
        }

        //We have no idea who el is
        if (!max) {
            count = s.length;
            for (i = count; i >= 0; i--){
                if (!s[i])
                    continue;
                    
                pNode = (node = s[i]).parentNode;
            
                if (node.$isValid || !include[node.$uniqueId] || !oldInclude[pNode.$uniqueId]) {
                    delete include[node.$uniqueId],//@todo is this needed?
                    count--;
                    continue;
                }
                
                //Nodes could have same parent
                if (!pInclude[pNode.$uniqueId]) {
                    pInclude[pNode.$uniqueId] = pNode,
                    pInclude.length++;
                }
                found.push(node);
            }
        }
        //We have some hints who el is
        else {
            for (id in curNode) {
                if (curNode[id] != max)
                    continue;
                
                pNode = (node = apf.all[id]).parentNode;
                
                if (node.$isValid || !include[node.$uniqueId] || !oldInclude[pNode.$uniqueId]) {
                    delete include[node.$uniqueId],//@todo is this needed?
                    count--;
                    continue;
                }
                
                //Nodes could have same parent
                if (!pInclude[pNode.$uniqueId]) {
                    pInclude[pNode.$uniqueId] = pNode,
                    pInclude.length++;
                }
                found.push(node);
            }
        }

        if (found.length) //@experimental - when a new node is found, dont determine the parent.
            curParentNode.include = pInclude;
        
        for (first = null, i = 0, l = found.length; i < l; i++) { //@todo l == count
            pNode = (item = found[i]).parentNode; 
            
            //guessing parentNode
            if (curParentNode[pNode.$uniqueId]) 
                curParentNode[pNode.$uniqueId] += 1 / count;
            else
                curParentNode[pNode.$uniqueId]  = 1 / count;
            
            if (count > 1) {
                if (!first) {
                    first = {
                        node    : el,
                        //node2   : found[0],
                        arr     : s,
                        curNode : curNode,
                        curParentNode : curParentNode,
                        found   : found
                    };
                    
                    //foundEl should be here with found array filled by this loop - we trust our scheme
                    (foundEl[curPath] || (foundEl[curPath] = [])).push(first);
                }
                
                if (count > (item.$matchedNodes || 0))
                    item.$matchedNodes = count;
            }
            else { //Code below is probably not necessary and can be removed.
                item.$isValid = true;
                
                //Clean up hash
                for (var j = s.length - 1; j >= 0; j--) {
                    if (s[j] == item) {
                        delete s[j];//this.splice(i, 1);
                        break;
                    }
                }
            }
        }
        
        if (!found.length) { //was !count
            //Update or New
            (notFoundEl[p] || (notFoundEl[p] = [])).push({
                arr     : s,
                node    : el,
                curNode : curParentNode
            });
        }
        
        curNode.curNode = found[0],
        curNode.parent  = curParentNode,
        curNode.curPath = curPath;
    })(doc2, "", hash, doc1, curNode);
        
    //if (doc1.$isValid) //docs match completely
        //return true;

    /*
        indexOf (nodes in arrPath) to find out if node still exists. 
        do remove node from .arr to say its determined
    */

    //Process all conflicting nodes on this path
    //@todo this should be optimized a lot
    function recurEl(path){
        var pathCollision = foundEl[path];
        if (!pathCollision)
            return;
    
        var curItem, curMatch, l, count, nMatch, j, i, potentialMatches,
            leastMatchNodes, pl, pNode;
        for (i = 0, pl = pathCollision.length; i < pl; i++) {
            //Make sure to do cleanup!
            //Strategy!: the parent knows best!
            
            //if (pathCollision[i].node2.$isValid)
                //continue;
            
            potentialMatches = (curItem = pathCollision[i]).found,
            leastMatchNodes  = 100000;
            for (count = j = 0, l = potentialMatches.length; j < l; j++) {
                if ((curMatch = potentialMatches[j]).$isValid)
                    continue;
                
                nMatch = curMatch.$matchedNodes;
                if (nMatch < leastMatchNodes) {
                    leastMatchNodes = nMatch,
                    count = 1;
                }
                else if (nMatch == leastMatchNodes) {
                    count++;
                }
            }
            
            //Found match
            if (count == 1) {
                for (j = 0, l = potentialMatches.length; j < l; j++) {
                    if (!(curMatch = potentialMatches[j]).$isValid
                      && curMatch.$matchedNodes == leastMatchNodes) {
                        curMatch.$isValid = true,
                        //curMatch.parentNode.$validChildren++;
                        curItem.curNode.curNode = curMatch;//set who is me
                        break;
                    }
                }
            }
            else if (count) {
                //recursion.. with pathCollion[i].curNode.parent.found -> potentialMatches for the parent;
                //if parent found and it was doubting, delete entry from foundEl[path][i].node == pathCollion[i].node.parentNode
                var include = curItem.curParentNode.include;
                //There's only one parent
                if (include.length == 1) {
                    pNode = curItem.curParentNode.curNode;//apf.all[include[0]];
                    for (j = 0, l = potentialMatches.length; j < l; j++) {
                        if (!(curMatch = potentialMatches[j]).$isValid
                          && curMatch.$matchedNodes == leastMatchNodes
                          && curMatch.parentNode == pNode) {
                            curMatch.$isValid = true,
                            //curMatch.parentNode.$validChildren++;
                            curItem.curNode.curNode = curMatch;//set who is me
                            break;
                        }
                    }
                    //@todo check here if found
                    continue;
                }
                
                //Determine who's who for the parents
                recurEl(curItem.curParentNode.curPath),
                
                pNode = curItem.curParentNode.curNode;
                for (j = 0, l = potentialMatches.length; j < l; j++) {
                    if (!(curMatch = potentialMatches[j]).$isValid
                      && curMatch.$matchedNodes == leastMatchNodes
                      && curMatch.parentNode == pNode) {
                        curMatch.$isValid = true,
                        //curMatch.parentNode.$validChildren++;
                        curItem.curNode.curNode = curMatch;//set who is me
                        break;
                    }
                }
                
                /*for (var j = 0; j < potentialMatches.length; j++) {
                    if (!potentialMatches[j].$isValid && potentialMatches[j].$matchedNodes == leastMatchNodes) {
                        recur
                    }
                }*/
            }
        }
        
        delete foundEl[path];//Will this fuck with the iterator?
    }

    //Process conflicting element nodes
    for (path in foundEl) {
        recurEl(path);
    }

    //Process conflicting text nodes
    for (path in foundTxt) {
        arr     = foundTxt[path], //found text nodes with this path
        l       = arr.length,
        arrPath = arr[0].arr;

        for (i = 0; i < l; i++) {
            t        = arr[i],
            arrIndex = t.found;
            
            //Find the right node
            if ((p = t.curNode) && (p = p.curNode)) {
                if (arrPath[t.index] && p == arrPath[t.index].parentNode) {
                    delete arrPath[t.index];
                    //p.$validChildren++;
                }
                else {
                    //cleanup hash
                    for (found = false, j = 0; j < arrIndex.length; j++) {
                        if (arrPath[arrIndex[j]] && arrPath[arrIndex[j]].parentNode == p) {
                            delete arrPath[arrIndex[j]],
                            //p.$validChildren++;
                            found = true;
                            break;
                        }
                    }
                    
                    //if not found, what does it mean?
                    if (!found)
                        (notFoundEl[path] || (notFoundEl[path] = [])).push(t);
                }
            }
            else {
                //throw new Error("hmm, new?");
                //part of a new chain?
            }
        }
    }
    
    //Process conflicting attr nodes
    for (path in foundAttr) {
        arr     = foundAttr[path], //found attributes with this path
        l       = arr.length,
        arrPath = arr[0].arr;

        for (i = 0; i < l; i++) {
            t        = arr[i],
            arrIndex = t.found;
            
            //Find the right node
            if ((p = t.curNode) && (p = p.curNode)) {
                if (arrPath[t.index] && p == arrPath[t.index].ownerElement) {
                    delete arrPath[t.index];
                    //p.$validChildren++;
                }
                else {
                    //cleanup hash
                    for (found = false, j = 0; j < arrIndex.length; j++) {
                        if (arrPath[arrIndex[j]] && arrPath[arrIndex[j]].ownerElement == p) {
                            delete arrPath[arrIndex[j]],
                            //p.$validChildren++;
                            found = true;
                            break;
                        }
                    }
                    
                    //if not found, what does it mean?
                    if (!found) {
                        //throw new Error("hmm, new?");
                        (notFoundAttr[path] || (notFoundAttr[path] = [])).push(t);
                    }
                }
            }
            else {
                //throw new Error("hmm, new?");
                //part of a new chain?
            }
        }
    }
    
    //Process not found attribute
    /*
        arr     : sh,
        node    : a,
        curNode : curNode
        
        is it update or new?
        - get the parent node from curNode.curNode;
            - check if there is a parent node in the list that matches
                - remove entry in arrPath
        - else 
            - parent is new node
    */
    for (path in notFoundAttr) {
        arr     = notFoundAttr[path], //not found attributes with this path
        l       = arr.length,
        arrPath = arr[0].arr || emptyArr,
        lPath   = arrPath.length;

        for (i = 0; i < l; i++) {
            a = arr[i];
            //Found parent
            if ((p = a.curNode) && (p = p.curNode)) {
                if (a.node.nodeName == "id")
                    p.setAttribute("id", a.node.nodeValue);
                else
                    rules.push([SETATTRIBUTE, p, a.node]);
                //p.$validChildren++;
                
                //cleanup hash
                for (j = 0; j < lPath; j++) {
                    if (arrPath[j] && arrPath[j].ownerElement == p) {
                        delete arrPath[j];
                        break;
                    }
                }
            }
            else {
                //Ignore, parent is new, so this will be added automatically (i think :S)
            }
        }
    }
    
    //Process not found nodes (all but attribute)
    for (path in notFoundEl) {
        arr     = notFoundEl[path], //not found attributes with this path
        l       = arr.length,
        arrPath = arr[0].arr || emptyArr,
        lPath   = arrPath.length;

        for (i = 0; i < l; i++) {
            t = arr[i];
            
            //Found parent
            if ((p = t.curNode) && (p = p.curNode)) {
                appendRules.push(lastRule = [APPEND, p, t.node]);
                //p.$validChildren++;
                //cleanup hash
                for (j = 0; j < lPath; j++) {
                    if (arrPath[j] && arrPath[j].parentNode == p) {
                        if (t.node.nodeType != 1) {
                            lastRule[0] = UPDATE;
                            lastRule[1] = arrPath[j];
                        }
                        else
                            appendRules.length--;

                        delete arrPath[j];
                        break;
                    }
                }
            }
            else {
                //Ignore, parent is new, so this will be added automatically (i think :S)
            }
        }
    }
    
    //Process remaining hash
    for (prop in hash){
        item = hash[prop];
        for (i = 0, l = item.length; i < l; i++) {
            subitem = item[i];
            //@todo check if the last check is actually needed:
            // && subitem.$validChildren != subitem.childNodes.length + subitem.attributes.length) {
            if (subitem && !subitem.$isValid && (subitem.parentNode || subitem.ownerElement).$isValid) {
                rules.push([REMOVE, subitem]);
            }
        }
    }

    var dt = new Date().getTime();
    //This loop could be optimized away (@rik loop and switch bad for jit?)
    var q = {}, doc = doc1.ownerDocument;
    for (i = 0, l = appendRules.length; i < l; i++) {
        switch((item = appendRules[i])[0]) {//@todo optimize
            case UPDATE:
                //item[1].nodeValue = item[2].nodeValue;
                item[1].$setValue(item[2].nodeValue);
                if (item[1].nodeType != 2) { //@todo apf3.0 optimize this
                    var childNr1 = apf.getChildNumber(item[1]),
                        childNr2 = apf.getChildNumber(item[2]);
                    if (childNr1 != childNr2)
                        item[1].parentNode.insertBefore(item[1], item[1].parentNode.childNodes[childNr2]);
                }
                //@todo need trigger for aml node
                break;
            case APPEND:
                if (!item[1].canHaveChildren) {
                    item[1].$aml = item[2].parentNode;
                    if (item[1].$redraw)
                        item[1].$redraw();
                    continue;
                }
        
                if (item[1].render != "runtime") {
                    var xml = item[1].parentNode;
                    while (xml && xml.nodeType == 1 && !xml.getAttribute("render"))
                        xml = xml.parentNode;
                    if (xml && xml.render) {// && !xml.visible) { //@todo apf3.0 add case for page
                        if (xml.$amlList)
                            xml.$amlList.push(item);
                        else {
                            xml.$amlList = [item];
                            xml.addEventListener("beforerender", function(e){
                                var nodes = this.$amlList;
                                this.$amlList = null;
        
                                for (var item, i = 0, l = nodes.length; i < l; i++) {
                                    item = nodes[i];
                                    var childNr = apf.getChildNumber(node = item[2]);
                                    item[1].insertBefore(doc.importNode(node, true), item[1].childNodes[childNr]);
                                }
                                
                                //@todo call afterrender
                                this.$rendered = true;
                                this.removeEventListener("beforerender", arguments.callee);
                                
                                return false;
                            });
                            xml.$rendered = false;
                        }
                    }
                    else {
                        (item[1].$amlList || (item[1].$amlList = []))[apf.getChildNumber(item[2])] = item;
                        q[item[1].$uniqueId] = item[1];
                    }
                }
                else {
                    item[1].$aml = item[2].parentNode;
                    item[1].$rendered = false;
                }
            break;
        }
    }
    
    //@todo apf3.0 optimize this
    var list;
    for (var id in q) {
        list = q[id].$amlList;
        for (var item, i = 0; i < list.length; i++) {
            item = list[i];
            if (!item) continue;
            item[1].insertBefore(doc.importNode(item[2], true), item[1].childNodes[i]);
        }
    }

    for (i = 0, l = rules.length; i < l; i++) {
        switch((item = rules[i])[0]) {
            case REMOVE:
                if ((node = item[1]).destroy) {
                    node.destroy(true, true);
                }
                else if (node.parentNode)
                    node.parentNode.removeChild(node);
                else
                    node.ownerElement.removeAttributeNode(node);
                break;
            case SETATTRIBUTE:
                item[1].setAttribute((item = item[2]).nodeName, item.nodeValue);
                break;
        }
    }
    
    apf.queue.empty();
    alert(new Date().getTime() - dt);
    
    //apf.console.time("Diff time:" + (time = (new Date().getTime() - dt)));
    
    /*var res1 = (apf.formatXml(doc2.xml));
    var res2 = (apf.formatXml(doc1.serialize()));
    
    if(res1 != res2) {
        throw new Error("A potentially serious xml diff problem was detected. \
            Please contact the author of this library:\n" 
            + res1 + "\n\n" + res2); //@todo make this into a proper apf3.0 error
    }*/
        
    
}



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/silverlight.js)SIZE(25659)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Helper class that aids in creating and controlling Microsoft Silverlight
 * elements (XAML stuff).
 * 
 * @author      Mike de Boer
 * @version     %I%, %G%
 * @since       1.0
 * @namespace apf
 * @private
 */
apf.silverlight = (function() {
    /**
     * {Number} silverlightCount:
     *
     * Counter of globalized event handlers
     */
    var silverlightCount = 0;
    
    /**
     * {Boolean} __onSilverlightInstalledCalled:
     *
     * Prevents onSilverlightInstalled from being called multiple times
     */
    var __onSilverlightInstalledCalled = false;
    
    /**
     * {String} fwlinkRoot:
     *
     * Prefix for fwlink URL's
     */
    var fwlinkRoot = 'http://go2.microsoft.com/fwlink/?LinkID=';
    
    /**
     * {Boolean} __installationEventFired:
     *
     * Ensures that only one Installation State event is fired.
     */
    var __installationEventFired = false;

    /**
     * {Function} onGetSilverlight
     *
     * Called by Silverlight.GetSilverlight to notify the page that a user
     * has requested the Silverlight installer
     */
    var onGetSilverlight = null;
    
    /**
     * Called by apf.silverlight.WaitForInstallCompletion when the page detects
     * that Silverlight has been installed. The event handler is not called
     * in upgrade scenarios.
     * 
     * @type {void}
     */
    function onSilverlightInstalled() {
        window.location.reload(false);
    }
    
    /**
     * Checks to see if the correct version is installed
     * 
     * @param {String} version
     * @type {Boolean}
     */
    function isInstalled(version){
        if (version == undefined)
        version = null;
            
        var isVersionSupported = false;
        var container = null;

        try {
            var control = null;
            var tryNS = false;

            if (window.ActiveXObject) {
                try {
                    control = new ActiveXObject('AgControl.AgControl');
                    if (version === null) {
                        isVersionSupported = true;
                    }
                    else if (control.IsVersionSupported(version)) {
                        isVersionSupported = true;
                    }
                    control = null;
                }
                catch (e) {
                    tryNS = true;
                }
            }
            else {
                tryNS = true;
            }
            if (tryNS) {
                var plugin = navigator.plugins["Silverlight Plug-In"];
                if (plugin) {
                    if (version === null) {
                        isVersionSupported = true;
                    }
                    else {
                        var actualVer = plugin.description;
                        if (actualVer === "1.0.30226.2")
                            actualVer = "2.0.30226.2";
                        var actualVerArray = actualVer.split(".");
                        while (actualVerArray.length > 3) {
                            actualVerArray.pop();
                        }
                        while (actualVerArray.length < 4) {
                            actualVerArray.push(0);
                        }
                        var reqVerArray = version.split(".");
                        while (reqVerArray.length > 4) {
                            reqVerArray.pop();
                        }

                        var requiredVersionPart;
                        var actualVersionPart;
                        var index = 0;
                        do {
                            requiredVersionPart = parseInt(reqVerArray[index]);
                            actualVersionPart = parseInt(actualVerArray[index]);
                            index++;
                        }
                        while (index < reqVerArray.length && requiredVersionPart === actualVersionPart);

                        if (requiredVersionPart <= actualVersionPart && !isNaN(requiredVersionPart)) {
                            isVersionSupported = true;
                        }
                    }
                }
            }
        }
        catch (e) {
            isVersionSupported = false;
        }
        
        return isVersionSupported;
    }
    
    /**
     * Occasionally checks for Silverlight installation status. If it
     * detects that Silverlight has been installed then it calls
     * apf.silverlight.onSilverlightInstalled();. This is only supported
     * if Silverlight was not previously installed on this computer.
     * 
     * @type {void}
     */
    function WaitForInstallCompletion(){
        if (!apf.silverlight.isBrowserRestartRequired && onSilverlightInstalled) {
            try {
                navigator.plugins.refresh();
            }
            catch(e) {}
            if (isInstalled(null) && !__onSilverlightInstalledCalled) {
                onSilverlightInstalled();
                __onSilverlightInstalledCalled = true;
            }
            else {
                $setTimeout(WaitForInstallCompletion, 3000);
            }    
        }
    }
    
    /**
     * Performs startup tasks
     * 
     * @type {void}
     */
    function startup() {
        navigator.plugins.refresh();
        apf.silverlight.isBrowserRestartRequired = isInstalled(null);
        if (!apf.silverlight.isBrowserRestartRequired) {
            WaitForInstallCompletion();
            if (!__installationEventFired) {
                onInstallRequired();
                __installationEventFired = true;
            }
        }
        else if (window.navigator.mimeTypes) {
            var mimeSL2 =   navigator.mimeTypes["application/x-silverlight-2"];
            var mimeSL2b2 = navigator.mimeTypes["application/x-silverlight-2-b2"];
            var mimeSL2b1 = navigator.mimeTypes["application/x-silverlight-2-b1"];
            var mimeHighestBeta = mimeSL2b1;
            if (mimeSL2b2)
                mimeHighestBeta = mimeSL2b2;
                
            if (!mimeSL2 && (mimeSL2b1 || mimeSL2b2)) {
                if (!__installationEventFired) {
                    onUpgradeRequired();
                    __installationEventFired = true;
                }
            }
            else if (mimeSL2 && mimeHighestBeta) {
                if (mimeSL2.enabledPlugin &&
                    mimeHighestBeta.enabledPlugin) {
                    if (mimeSL2.enabledPlugin.description !=
                        mimeHighestBeta.enabledPlugin.description) {
                        if (!__installationEventFired) {
                            onRestartRequired();
                            __installationEventFired = true;
                        }
                    }
                }
            }
        }
    }
    
    /**
     * Inserts a Silverlight <object> tag or installation experience into the HTML
     * DOM based on the current installed state of Silverlight.
     * 
     * @param {String} source
     * @param {HTMLDomElement} parentElement
     * @param {String} id
     * @param {Object} properties
     * @param {Object} events
     * @param {Object} initParams
     * @param {mixed} userContext
     * @type {String}
     */
    function createObject(source, parentElement, id, properties, events, initParams, userContext) {
        var slPluginHelper = {},
            slProperties   = properties,
            slEvents       = events;
        
        slPluginHelper.version = slProperties.version;
        slProperties.source    = source;    
        slPluginHelper.alt     = slProperties.alt;
        
        //rename properties to their tag property names. For bacwards compatibility
        //with Silverlight.js version 1.0
        if (initParams)
            slProperties.initParams = initParams;
        if (slProperties.isWindowless && !slProperties.windowless)
            slProperties.windowless = slProperties.isWindowless;
        if (slProperties.framerate && !slProperties.maxFramerate)
            slProperties.maxFramerate = slProperties.framerate;
        if (id && !slProperties.id)
            slProperties.id = id;
        
        // remove elements which are not to be added to the instantiation tag
        delete slProperties.ignoreBrowserVer;
        delete slProperties.inplaceInstallPrompt;
        delete slProperties.version;
        delete slProperties.isWindowless;
        delete slProperties.framerate;
        delete slProperties.data;
        delete slProperties.src;
        delete slProperties.alt;

        // detect that the correct version of Silverlight is installed, else display install
        var slPluginHTML;
        if (isInstalled(slPluginHelper.version)) {
            //move unknown events to the slProperties array
            for (var name in slEvents) {
                if (slEvents[name]) {
                    if (name == "onLoad" && typeof slEvents[name] == "function" 
                      && slEvents[name].length != 1 ) {
                        var onLoadHandler = slEvents[name];
                        slEvents[name] = function (sender) {
                            return onLoadHandler(document.getElementById(id), 
                                userContext, sender)
                        };
                    }
                    var handlerName = __getHandlerName(slEvents[name]);
                    if (handlerName != null) {
                        slProperties[name] = handlerName;
                        slEvents[name] = null;
                    }
                    else {
                        throw "typeof events."+name+" must be 'function' or 'string'";
                    }
                }
            }
            slPluginHTML = buildHTML(slProperties);
        }
        //The control could not be instantiated. Show the installation prompt
        else {
            slPluginHTML = buildPromptHTML(slPluginHelper);
        }

        // insert or return the HTML
        if (parentElement)
            parentElement.innerHTML = slPluginHTML;
        else
            return slPluginHTML;
    }
    
    /**
     *  create HTML that instantiates the control
     *  
     *  @param {Object} slProperties
     *  @type {String}
     */
    function buildHTML(slProperties) {
        var htmlBuilder = [];
        htmlBuilder.push('<object type=\"application/x-silverlight\" data="data:application/x-silverlight,"');
        if (slProperties.id != null)
            htmlBuilder.push(' id="' + HtmlAttributeEncode(slProperties.id) + '"');
        if (slProperties.width != null)
            htmlBuilder.push(' width="' + slProperties.width+ '"');
        if (slProperties.height != null)
            htmlBuilder.push(' height="' + slProperties.height + '"');
        htmlBuilder.push(' >');
        
        delete slProperties.id;
        delete slProperties.width;
        delete slProperties.height;
        
        for (var name in slProperties) {
            if (slProperties[name])
                htmlBuilder.push('<param name="' + HtmlAttributeEncode(name) 
                    + '" value="' + HtmlAttributeEncode(slProperties[name]) + '" />');
        }
        htmlBuilder.push('<\/object>');
        return htmlBuilder.join('');
    }
    
    /**
     * takes a single parameter of all createObject 
     * parameters enclosed in {}
     * 
     * @param {Object} params
     * @type {String}
     */
    function createObjectEx(params) {
        var parameters = params;
        var html = createObject(parameters.source, parameters.parentElement, 
            parameters.id, parameters.properties, parameters.events, 
            parameters.initParams, parameters.context);
        if (parameters.parentElement == null)
            return html;
    }
    
    /**
     * Builds the HTML to prompt the user to download and install Silverlight
     * 
     * @param {Object} slPluginHelper
     * @type {String}
     */
    function buildPromptHTML(slPluginHelper) {
        var slPluginHTML = "";
        var urlRoot = fwlinkRoot;
        var version = slPluginHelper.version ;
        if (slPluginHelper.alt) {
            slPluginHTML = slPluginHelper.alt;
        }
        else {
            if (!version)
                version="";
            slPluginHTML = "<a href='javascript:Silverlight.getSilverlight(\"{1}\");' style='text-decoration: none;'><img src='{2}' alt='Get Microsoft Silverlight' style='border-style: none'/></a>";
            slPluginHTML = slPluginHTML.replace('{1}', version);
            slPluginHTML = slPluginHTML.replace('{2}', urlRoot + '108181');
        }
        
        return slPluginHTML;
    }
    
    /**
     * Navigates the browser to the appropriate Silverlight installer
     * 
     * @param {String} version
     * @type {void}
     */
    function getSilverlight(version) {
        if (onGetSilverlight )
            onGetSilverlight();
        
        var shortVer = "";
        var reqVerArray = String(version).split(".");
        if (reqVerArray.length > 1) {
            var majorNum = parseInt(reqVerArray[0]);
            if (isNaN(majorNum) || majorNum < 2)
                shortVer = "1.0";
            else
                shortVer = reqVerArray[0]+'.'+reqVerArray[1];
        }
        
        var verArg = "";
        if (shortVer.match(/^\d+\056\d+$/) )
            verArg = "&v="+shortVer;
        followFWLink("114576" + verArg);
    }
    
    /**
     * Navigates to a url based on fwlinkid
     * 
     * @param {String} linkid
     * @type {void}
     */
    function followFWLink(linkid) {
        top.location = fwlinkRoot + String(linkid);
    }
    
    /**
     * Encodes special characters in input strings as charcodes
     * 
     * @param {String} strInput
     * @type {String}
     */
    function HtmlAttributeEncode(strInput) {
        var c;
        var retVal = '';
    
        if (strInput == null) return null;
          
        for (var cnt = 0; cnt < strInput.length; cnt++) {
            c = strInput.charCodeAt(cnt);

            if (((c > 96) && (c < 123)) || (( c > 64) && (c < 91)) 
              || ((c > 43) && (c < 58) && (c != 47)) || (c == 95))
                retVal = retVal + String.fromCharCode(c);
            else
                retVal = retVal + '&#' + c + ';';
        }
        return retVal;
    }
    
    /**
     *  Default error handling function
     *  
     *  @param {String} sender
     *  @param {Object} args
     *  @type {void}
     */
    function default_error_handler(sender, args) {
        var iErrorCode;
        var errorType = args.ErrorType;
    
        iErrorCode = args.ErrorCode;
    
        var errMsg = ["\nSilverlight error message     \n\
          ErrorCode: ", iErrorCode, "\n\
          ErrorType: ", errorType, "       \n\
          Message: ", args.ErrorMessage, "     \n"];
    
        if (errorType == "ParserError") {
            errMsg.push("XamlFile: ", args.xamlFile, "     \n\
              Line: ", args.lineNumber, "     \n\
              Position: ", args.charPosition, "     \n");
        }
        else if (errorType == "RuntimeError") {
            if (args.lineNumber != 0) {
                errMsg.push("Line: ", args.lineNumber, "     \n\
                    Position: ",  args.charPosition, "     \n");
            }
            errMsg.push("MethodName: ", args.methodName, "     \n");
        }
        throw new Error(apf.formatErrorString(0, this, errMsg.join('')));
    }
    
    /**
     * Releases event handler resources when the page is unloaded
     * 
     * @type {void}
     */
    function __cleanup() {
        for (var i = silverlightCount - 1; i >= 0; i--)
            window['__slEvent' + i] = null;
            
        silverlightCount = 0;
        if (window.removeEventListener)
            window.removeEventListener('unload', __cleanup , false);
        else 
            window.detachEvent('onunload', __cleanup );
    }
    
    /**
     * Generates named event handlers for delegates.
     * 
     * @param {Function} handler
     * @type {String}
     */
    function __getHandlerName(handler) {
        var handlerName = "";
        if (typeof handler == "string") {
            handlerName = handler;
        }
        else if (typeof handler == "function" ) {
            if (silverlightCount == 0) {
                if (window.addEventListener) 
                    window.addEventListener('onunload', __cleanup , false);
                else 
                    window.attachEvent('onunload', __cleanup);
            }
            var count = silverlightCount++;
            handlerName = "__slEvent"+count;
            
            window[handlerName]=handler;
        }
        else {
            handlerName = null;
        }
        return handlerName;
    }
    
    /**
     * onRequiredVersionAvailable:
     *
     * Called by version  verification control to notify the page that
     * an appropriate build of Silverlight is available. The page 
     * should respond by injecting the appropriate Silverlight control
     */
    function onRequiredVersionAvailable() {};
    
    /**
     * onRestartRequired:
     *
     * Called by version verification control to notify the page that
     * an appropriate build of Silverlight is installed but not loaded. 
     * The page should respond by injecting a clear and visible 
     * "Thanks for installing. Please restart your browser and return
     * to mysite.com" or equivalent into the browser DOM
     */
    function onRestartRequired() {};
    
    /**
     * onUpgradeRequired:
     *
     * Called by version verification control to notify the page that
     * Silverlight must be upgraded. The page should respond by 
     * injecting a clear, visible, and actionable upgrade message into
     * the DOM. The message must inform the user that they need to 
     * upgrade Silverlight to use the page. They are already somewhat
     * familiar with the Silverlight product when they encounter this.
     * Silverlight should be mentioned so the user expects to see that
     * string in the installer UI. However, the Silverlight-powered
     * application should be the focus of the solicitation. The user
     * wants the app. Silverlight is a means to the app.
     * 
     * The upgrade solicitation will have a button that directs 
     * the user to the Silverlight installer. Upon click the button
     * should both kick off a download of the installer URL and replace
     * the Upgrade text with "Thanks for downloading. When the upgarde
     * is complete please restart your browser and return to 
     * mysite.com" or equivalent.
     *
     * Note: For a more interesting upgrade UX we can use Silverlight
     * 1.0-style XAML for this upgrade experience. Contact PiotrP for
     * details.
     */
    function onUpgradeRequired() {};
    
    /**
     * onInstallRequired:
     *
     * Called by Silverlight.checkInstallStatus to notify the page
     * that Silverlight has not been installed by this user.
     * The page should respond by 
     * injecting a clear, visible, and actionable upgrade message into
     * the DOM. The message must inform the user that they need to 
     * download and install components needed to use the page. 
     * Silverlight should be mentioned so the user expects to see that
     * string in the installer UI. However, the Silverlight-powered
     * application should be the focus of the solicitation. The user
     * wants the app. Silverlight is a means to the app.
     * 
     * The installation solicitation will have a button that directs 
     * the user to the Silverlight installer. Upon click the button
     * should both kick off a download of the installer URL and replace
     * the Upgrade text with "Thanks for downloading. When installation
     * is complete you may need to refresh the page to view this 
     * content" or equivalent.
     */
    function onInstallRequired() {};

    /**
     * IsVersionAvailableOnError:
     *
     * This function should be called at the beginning of a web page's
     * Silverlight error handler. It will determine if the required 
     * version of Silverlight is installed and available in the 
     * current process.
     *
     * During its execution the function will trigger one of the 
     * Silverlight installation state events, if appropriate.
     *
     * Sender and Args should be passed through from  the calling
     * onError handler's parameters. 
     *
     * The associated Sivlerlight <object> tag must have
     * minRuntimeVersion set and should have autoUpgrade set to false.
     */
    function IsVersionAvailableOnError(sender, args) {
        var retVal = false;
        try {
            if (args.ErrorCode == 8001 && !__installationEventFired) {
                onUpgradeRequired();
                __installationEventFired = true;
            }
            else if (args.ErrorCode == 8002 && !__installationEventFired) {
                onRestartRequired();
                __installationEventFired = true;
            }
            // this handles upgrades from 1.0. That control did not
            // understand the minRuntimeVerison parameter. It also
            // did not know how to parse XAP files, so would throw
            // Parse Error (5014). A Beta 2 control may throw 2106
            else if (args.ErrorCode == 5014 || args.ErrorCode == 2106) {
                if (__verifySilverlight2UpgradeSuccess(args.getHost()))
                    retVal = true;
            }
            else {
                retVal = true;
            }
        }
        catch (e) { }
        return retVal;
    };
    
    /**
     * IsVersionAvailableOnLoad:
     *
     * This function should be called at the beginning of a web page's
     * Silverlight onLoad handler. It will determine if the required 
     * version of Silverlight is installed and available in the 
     * current process.
     *
     * During its execution the function will trigger one of the 
     * Silverlight installation state events, if appropriate.
     *
     * Sender should be passed through from  the calling
     * onError handler's parameters. 
     *
     * The associated Sivlerlight <object> tag must have
     * minRuntimeVersion set and should have autoUpgrade set to false.
     */
    function IsVersionAvailableOnLoad(sender) {
        var retVal = false;
        try {
            if (__verifySilverlight2UpgradeSuccess(sender.getHost()))
                retVal = true;
        }
        catch (e) {}
        return retVal;
    };
    
    /**
     * __verifySilverlight2UpgradeSuccess:
     *
     * This internal function helps identify installation state by
     * taking advantage of behavioral differences between the
     * 1.0 and 2.0 releases of Silverlight. 
     *
     */
    function __verifySilverlight2UpgradeSuccess(host) {
        var retVal = false,
            version = "2.0.31005",
            installationEvent = null;

        try {
            if (host.IsVersionSupported(version + ".99")) {
                installationEvent = onRequiredVersionAvailable;
                retVal = true;
            }
            else if (host.IsVersionSupported(version + ".0")) {
                installationEvent = onRestartRequired;
            }
            else {
                installationEvent = onUpgradeRequired;
            }

            if (installationEvent && !__installationEventFired) {
                installationEvent();
                __installationEventFired = true;
            }
        }
        catch (e) {}
        return retVal;
    };
    
    var aIsAvailable = {};
    /*
     * Checks whether a valid version of Silverlight is available on the clients'
     * system. Default version to check for is 1.0.
     * 
     * @param {String} sVersion Optional.
     * @type {Boolean}
     */
    function isAvailable(sVersion) {
        if (typeof sVersion == "undefined")
            sVersion = "1.0";
        if (typeof aIsAvailable[sVersion] == "undefined")
            aIsAvailable[sVersion] = isInstalled(sVersion);
        return aIsAvailable[sVersion];
    }
    
    return {
        /**
         * onGetSilverlight:
         *
         * Called by apf.silverlight.GetSilverlight to notify the page that a user
         * has requested the Silverlight installer
         */
        onGetSilverlight        : null,
        isBrowserRestartRequired: false,
        startup                 : startup,
        createObject            : createObject,
        createObjectEx          : createObjectEx,
        getSilverlight          : getSilverlight,
        default_error_handler   : default_error_handler,
        isAvailable             : isAvailable
    };
})();



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/flash.js)SIZE(22608)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Helper class that aids in creating and controlling Adobe Flash
 * elements.
 *
 * @author      Mike de Boer
 * @version     %I%, %G%
 * @since       1.0
 * @namespace apf
 * @private
 */
apf.flash = (function(){
    /**
     * Flash Player Version Detection, version 1.7
     * Detect Client Browser type
     *
     * @type {String}
     */
    function getControlVersion(){
        var version, axo;

        // NOTE : new ActiveXObject(strFoo) throws an exception if strFoo isn't in the registry
        try {
            // version will be set for 7.X or greater players
            axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.7");
            version = axo.GetVariable("$version");
        }
        catch (e) {}

        if (!version) {
            try {
                // version will be set for 6.X players only
                axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.6");
                // installed player is some revision of 6.0
                // GetVariable("$version") crashes for versions 6.0.22 through 6.0.29,
                // so we have to be careful.
                // default to the first public version
                version = "WIN 6,0,21,0";
                // throws if AllowScripAccess does not exist (introduced in 6.0r47)
                axo.AllowScriptAccess = "always";
                // safe to call for 6.0r47 or greater
                version = axo.GetVariable("$version");
            }
            catch (e) {}
        }

        if (!version) {
            try {
                // version will be set for 4.X or 5.X player
                axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.3");
                version = axo.GetVariable("$version");
            }
            catch (e) {}
        }

        if (!version) {
            try {
                // version will be set for 3.X player
                axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.3");
                version = "WIN 3,0,18,0";
            }
            catch (e) {}
        }

        if (!version) {
            try {
                // version will be set for 2.X player
                axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash");
                version = "WIN 2,0,0,11";
            }
            catch (e) {
                version = -1;
            }
        }

        return version;
    }

    /**
     * JavaScript helper, required to detect Flash Player PlugIn version
     * information.
     * @see getControlVersion() for Internet Explorer (ActiveX detection)
     *
     * @type {String}
     */
    function getSwfVersion(){
        // NS/Opera version >= 3 check for Flash plugin in plugin array
        var flashVer = -1,
            sAgent   = navigator.userAgent.toLowerCase();

        if (navigator.plugins != null && navigator.plugins.length > 0) {
            if (navigator.plugins["Shockwave Flash 2.0"] || navigator.plugins["Shockwave Flash"]) {
                var swVer2   = navigator.plugins["Shockwave Flash 2.0"] ? " 2.0" : "",
                    swfDescr = navigator.plugins["Shockwave Flash" + swVer2].description,
                    aDescr   = swfDescr.split(" "),
                    aTempMaj = aDescr[2].split("."),
                    nMajor   = aTempMaj[0],
                    nMinor   = aTempMaj[1],
                    sRev     = aDescr[3];
                if (sRev == "")
                    sRev = aDescr[4];
                if (sRev[0] == "d") {
                    sRev = sRev.substring(1);
                }
                else if (sRev[0] == "r") {
                    sRev = sRev.substring(1);
                    if (sRev.indexOf("d") > 0)
                        sRev = sRev.substring(0, sRev.indexOf("d"));
                }
                flashVer = nMajor + "." + nMinor + "." + sRev;
            }
        }
        // MSN/WebTV 2.6 supports Flash 4
        else if (sAgent.indexOf("webtv/2.6") != -1)
            flashVer = 4;
        // WebTV 2.5 supports Flash 3
        else if (sAgent.indexOf("webtv/2.5") != -1)
            flashVer = 3;
        // older WebTV supports Flash 2
        else if (sAgent.indexOf("webtv") != -1)
            flashVer = 2;
        else if (apf.isIE && !apf.isOpera)
            flashVer = getControlVersion();

        return flashVer;
    }

    /**
     * When called with reqMajorVer, reqMinorVer, reqRevision returns true if
     * that version or greater is available on the clients' system.
     *
     * @param {Number} reqMajorVer
     * @param {Number} reqMinorVer
     * @param {Number} reqRevision
     * @type {Boolean}
     */
    function detectFlashVersion(reqMajorVer, reqMinorVer, reqRevision){
        var versionStr = getSwfVersion();
        if (versionStr == -1)
            return false;
        if (versionStr != 0) {
            var aVersions;
            if (apf.isIE && !apf.isOpera) {
                // Given "WIN 2,0,0,11"
                var aTemp = versionStr.split(" "), // ["WIN", "2,0,0,11"]
                    sTemp = aTemp[1];              // "2,0,0,11"
                aVersions = sTemp.split(",");      // ['2', '0', '0', '11']
            }
            else {
                aVersions = versionStr.split(".");
            }
            var nMajor = aVersions[0],
                nMinor = aVersions[1],
                sRev   = aVersions[2];

            // is the major.revision >= requested major.revision AND the minor version >= requested minor
            if (nMajor > parseFloat(reqMajorVer))
                return true;
            if (nMajor == parseFloat(reqMajorVer)) {
                if (nMinor > parseFloat(reqMinorVer))
                    return true;
                if (nMinor == parseFloat(reqMinorVer)
                  && sRev >= parseFloat(reqRevision)) {
                    return true;
                }
            }
            return false;
        }
    }

    /**
     * Generate ActiveContent for a Flash or Shockwave movie, while ensuring
     * compatibility with the clients' browser.
     *
     * @param {Object} objAttrs
     * @param {Object} params
     * @param {Object} embedAttrs
     * @param {Boolean} stdout If TRUE, the resulting string will be passed to the output buffer through document.write()
     * @type {String}
     */
    function generateObj(objAttrs, params, embedAttrs, stdout){
        if (stdout == "undefined")
            stdout = false;
        var i, str = [];
        if (apf.isIE && !apf.isOpera) {
            str.push("<object ");
            for (i in objAttrs)
                str.push(i, "=\"", objAttrs[i], "\" ");
            str.push(">");
            for (i in params)
                str.push("<param name=\"", i, "\" value=\"", params[i], "\" />");
            str.push("</object>");
        }
        else {
            str.push("<embed ");
            for (i in embedAttrs)
                str.push(i, "=\"", embedAttrs[i], "\" ");
            str.push("></embed>");
        }
        var sOut = str.join("");

        if (stdout === true)
            document.write(sOut);

        return sOut;
    }

    /**
     * Use this function to generate the HTML tags for a Flash movie object.
     * It takes any number of arguments as parameters:
     * arguments: 'name1', 'value1', 'name2', 'value2', etc.
     *
     * @type {String}
     */
    function AC_FL_RunContent(options){
        var ret = AC_GetArgs(options,
            "movie", "clsid:d27cdb6e-ae6d-11cf-96b8-444553540000",
            "application/x-shockwave-flash");
        return generateObj(ret.objAttrs, ret.params, ret.embedAttrs);
    }

    /**
     * Generate the HTML for a Flash movie, with checks for general availability
     * of a compatible Flash Player. If not, it will redirect to the installer
     * (a seperate Flash Movie to upgrade) or diplay a link.
     *
     * @type {String}
     */
    function buildContent(options) {
        var v = isEightAvailable();
        if (isAvailable() && !v)
            return buildInstaller(options || {});
        if (v)
            return AC_FL_RunContent(options);
        return 'This content requires the \
            <a href="http://www.adobe.com/go/getflash/">Adobe Flash Player</a>.';
    }

    function embed(options) {
        var obj  = options.context,
            node = options.htmlNode,
            prop = options.property || "$player";
        delete options.context, delete options.htmlNode, delete options.property;
        
        var content = buildContent(options),
            // using timeouts INSIDE the callback, because I explicitly want to
            // wait for APF to finish drawing the elements, i.e. wait for DOM
            // elements to be drawn.
            cb      = function() {
                $setTimeout(function() {
                    node.innerHTML = content;
                    obj[prop]      = getElement(options.id);
                    //console.log("flash movie loaded: ", _self.player);

                    $setTimeout(function() {
                        var fail = null;
                        if (!obj[prop].parentNode) {
                            fail = "File Uploader error: The movie has to be enabled "
                                 + "manually because of Flashblock. No browser refresh is required.";
                        }
                        else if (obj[prop].style.display == "none") {
                            fail = "File Uploader error: Adblock Plus blocks or hides the "
                                 + "movie. Please enable it and refresh your browser.";
                        }
                        else if (!obj[prop].offsetWidth) {
                            fail = "File Uploader error: The Flash movie failed to load. "
                                 + "Please check if the file exists and the path is correct.";
                        }

                        if (fail) {
                            
                            apf.console.error(fail, "audio");
                            
                            obj.dispatchEvent("error", {message: fail});
                        }
                    }, 1000);
                }, 200);
            };

        return apf.loaded ? cb() : apf.addEventListener("load", cb);
    }

    /**
     * Build the <OBJECT> tag that will load the Adobe installer for Flash
     * upgrades.
     */
    function buildInstaller(options) {
        if (!options)
            options = {};
        var ret = AC_GetArgs(options,
            "movie", "clsid:d27cdb6e-ae6d-11cf-96b8-444553540000",
            "application/x-shockwave-flash"),
            MMPlayerType  = (apf.isIE == true) ? "ActiveX" : "PlugIn",
            MMredirectURL = window.location;
        document.title    = document.title.slice(0, 47) + " - Flash Player Installation";
        var MMdoctitle    = document.title;

        return AC_FL_RunContent({
            src              : "playerProductInstall",
            FlashVars        : "MMredirectURL=" + MMredirectURL + "&MMplayerType="
                + MMPlayerType + "&MMdoctitle=" + MMdoctitle + "",
            width            : "100%",
            height           : "100%",
            align            : "middle",
            id               : ret.embedAttrs["name"],
            quality          : "high",
            bgcolor          : "#000000",
            name             : ret.embedAttrs["name"],
            allowScriptAccess: "always",
            type             : "application/x-shockwave-flash",
            pluginspage      : "http://www.adobe.com/go/getflashplayer"
        });
    }

    var sSrc = "src|movie",
        sObj = "onafterupdate|onbeforeupdate|onblur|oncellchange|onclick|ondblclick"
             + "|ondrag|ondragend|ondragenter|ondragleave|ondragover|ondrop|onfinish"
             + "|onfocus|onhelp|onmousedown|onmouseup|onmouseover|onmousemove"
             + "|onmouseout|onkeypress|onkeydown|onkeyup|onload|onlosecapture"
             + "|onpropertychange|onreadystatechange|onrowsdelete|onrowenter"
             + "|onrowexit|onrowsinserted|onstart|onscroll|onbeforeeditfocus"
             + "|onactivate|onbeforedeactivate|ondeactivate|type|codebase|id",
        sEmb = "width|height|align|vspace|hspace|class|title|accesskey|name|tabindex";

    /**
     * Augments options from AC_FL_RunContent and AC_SW_RunContent to sane
     * object that can be used to generate <OBJECT> and <EMBED> tags (depending
     * on the clients' browser, but this function will generate both)
     *
     * @param {Object} options
     * @param {Object} srcParamName
     * @param {Object} classid
     * @param {Object} mimeType
     * @type {Object}
     */
    function AC_GetArgs(options, srcParamName, classid, mimeType){
        var i, name,
            ret  = {
                embedAttrs: {},
                params    : {},
                objAttrs  : {}
            };

        for (i in options) {
            name = i.toLowerCase();
            if (name == "classid") continue;
            
            if (name == "pluginspage") {
                ret.embedAttrs[i] = options[i];
            }
            else if (sSrc.indexOf(name) > -1) {
                ret.embedAttrs["src"]    = options[i];
                ret.params[srcParamName] = options[i];
            }
            else if (sObj.indexOf(name) > -1) {
                ret.objAttrs[i] = options[i];
            }
            else if (sEmb.indexOf(name) > -1) {
                ret.embedAttrs[i] = ret.objAttrs[i] = options[i];
            }
            else {
                ret.embedAttrs[i] = ret.params[i] = options[i];
            }
        }
        
        ret.objAttrs["classid"] = classid;
        if (mimeType)
            ret.embedAttrs["type"] = mimeType;
        return ret;
    }

    /**
     * Utility method; get an element from the browser's document object, by ID.
     *
     * @param {Object} id
     * @type {HTMLDomElement}
     */
    function getElement(id) {
        var elem;

        if (typeof id == "object")
            return id;
        if (apf.isIE) {
            return self[id];
        }
        else {
            elem = document[id] ? document[id] : document.getElementById(id);
            if (!elem)
                elem = apf.lookup(id);
            return elem;
        }
    }

    var hash     = {},
        uniqueID = 1;

    /**
     * FAVideoManager: add a FAVideo instance to the stack for callbacks later on
     * and return a unique Identifier for the FAVideo instance to remember.
     *
     * @param {Object} player
     * @type {Number}
     */
    function addPlayer(player) {
        hash[++uniqueID] = player;
        return uniqueID;
    }

    /**
     * FAVideoManager: retrieve the FAVideo instance that is paired to the
     * unique identifier (id).
     *
     * @param {Object} id
     * @type {FAVideo}
     */
    function getPlayer(id) {
        return hash[id];
    }

    /**
     * Directs a call from embedded FAVideo SWFs to the appropriate FAVideo
     * instance in Javascript
     *
     * @param {Object} id
     * @param {Object} methodName
     * @type {void}
     */
    function callMethod(id, methodName) {
        var player = hash[id];
        if (player == null)
            throw new Error(apf.formatErrorString(0, this, "Player with id: " + id + " not found"));
        if (player[methodName] == null)
            throw new Error(apf.formatErrorString(0, this, "Method " + methodName + " Not found"));

        
        apf.console.info("[FLASH] received method call for player '" + id + "', '" + methodName + "'");
        

        var args = [],
            i    = 2,
            l    = arguments.length;
        for (; i < l; i++)
            args.push(decode(arguments[i]));
        player[methodName].apply(player, args);
    }

    /**
     * Directs a call from a JS object to an embedded SWF
     *
     * @param {mixed}  o  DOM reference of the Flash movie (or its ID as a string)
     * @param {String} fn Name of the function to be called on the Flash movie, exposed by ExternalInterface
     * @type {void}
     */
    function remote(o, fn) {
        if (typeof o == "string")
            o = hash[o];
        var rs = o.CallFunction('<invoke name="' + fn + '" returntype="javascript">'
               + __flash__argumentsToXML(arguments, 2) + '</invoke>');
        return eval(rs);
    }

    /**
     * Encodes our data to get around ExternalInterface bugs that are still
     * present even in Flash 9.
     *
     * @param {Object} data
     */
    function encode(data) {
        if (!data || typeof data != "string")
            return data;
        // double encode all entity values, or they will be mis-decoded
        // by Flash when returned
        return data.replace(/\&([^;]*)\;/g, "&amp;$1;")
                   // entity encode XML-ish characters, or Flash's broken XML
                   // serializer breaks
                   .replace(/</g, "&lt;")
                   .replace(/>/g, "&gt;")
                   // transforming \ into \\ doesn't work; just use a custom encoding
                   .replace("\\", "&custom_backslash;")
                   // null character
                   .replace(/\0/g, "\\0")
                   .replace(/\"/g, "&quot;");
    }

    /**
     * Decodes our data to get around ExternalInterface bugs that are still
     * present even in Flash 9.
     *
     * @param {String} data
     */
    function decode(data) {
        // wierdly enough, Flash sometimes returns the result as an
        // 'object' that is actually an array, rather than as a String;
        // detect this by looking for a length property; for IE
        // we also make sure that we aren't dealing with a typeof string
        // since string objects have length property there
        if (data && data.length && typeof data != "string")
            data = data[0];
        if (!data || typeof data != "string")
            return data;

        // certain XMLish characters break Flash's wire serialization for
        // ExternalInterface; these are encoded into a custom encoding, rather
        // than the standard entity encoding, because otherwise we won't be able
        // to differentiate between our own encoding and any entity characters
        // that are being used in the string itself
        return data.replace(/\&custom_lt\;/g, "<")
                   .replace(/\&custom_gt\;/g, ">")
                   .replace(/\&custom_backslash\;/g, '\\')
                   // needed for IE; \0 is the NULL character
                   .replace(/\\0/g, "\0");
    }

    var aIsAvailable = {};
    /*
     * Checks whether a valid version of Adobe Flash is available on the clients'
     * system. Default version to check for is 6.0.65.
     *
     * @param {String} sVersion
     * @type {Boolean}
     */
    function isAvailable(sVersion) {
        if (typeof sVersion != "string")
            sVersion = "6.0.65";
        var aVersion = sVersion.split('.');
        while (aVersion.length < 3)
            aVersion.push('0');
        if (typeof aIsAvailable[sVersion] == "undefined")
            aIsAvailable[sVersion] = detectFlashVersion(parseInt(aVersion[0]),
                parseInt(aVersion[1]), parseInt(aVersion[2]));
        return aIsAvailable[sVersion];
    }

    /*
     * Shorthand function to call and cache isAvailable() with version
     * number 8.0.0
     *
     * @type {Boolean}
     */
    function isEightAvailable() {
        return isAvailable("8.0.0");
    }

    var oSandboxTypes = {
        remote          : "remote (domain-based) rules",
        localwithfile   : "local with file access (no internet access)",
        localwithnetwork: "local with network (internet access only, no local access)",
        localtrusted    : "local, trusted (local + internet access)"
    };

    function getSandbox(sType) {
        var oSandbox = {
            type       : null,
            description: null,
            noRemote   : false,
            noLocal    : false,
            error      : null
        };
        oSandbox.type = sType.toLowerCase();
        oSandbox.description = oSandboxTypes[(typeof oSandboxTypes[oSandbox.type] != "undefined"
            ? oSandbox.type
            : "unknown")];
        if (oSandbox.type == "localwithfile") {
            oSandbox.noRemote = true;
            oSandbox.noLocal  = false;
            oSandbox.error    = "Flash security note: Network/internet URLs will not \
                                 load due to security restrictions.\
                                 Access can be configured via Flash Player Global Security\
                                 Settings Page: \
                                 http://www.macromedia.com/support/documentation/en/flashplayer/help/settings_manager04.html";
        }
        else if (oSandbox.type == "localwithnetwork") {
            oSandbox.noRemote = false;
            oSandbox.noLocal  = true;
        }
        else if (oSandbox.type == "localtrusted") {
            oSandbox.noRemote = false;
            oSandbox.noLocal  = false;
        }

        return oSandbox;
    }

    return {
        isAvailable     : isAvailable,
        isEightAvailable: isEightAvailable,
        buildContent    : buildContent,
        embed           : embed,
        encode          : encode,
        decode          : decode,
        getElement      : getElement,
        addPlayer       : addPlayer,
        getPlayer       : getPlayer,
        callMethod      : callMethod,
        getSandbox      : getSandbox,
        remote          : remote
    };
})();



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/cookie.js)SIZE(3074)TIME(1263307109)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */
 


/**
 * Sets a name/value pair which is stored in the browser and sent to the server
 * with every request. This is also known as a cookie. Be careful setting 
 * cookies, because they can take up a lot of bandwidth, especially for Ajax
 * applications.
 * 
 * @param {String}  name     cookie name
 * @param {String}  value    cookie value
 * @param {Date}    expire   expire date representing the number of milliseconds
 *                           since 1 January 1970 00:00:00 UTC.
 * @param {String}  path     path name
 * @param {String}  domain   domain name
 * @param {Boolean} secure   cookie may benefit all the documents and CGI programs
 *                           meet the requirements as to the path and domain
 *                           compatibility
 *     Possible values:
 *     true   may benefit
 *     false  can not benefit
 *     
 * @return {String} Returns a cookie name.
 */
apf.setcookie = function(name, value, expire, path, domain, secure) {
    var ck = name + "=" + escape(value) + ";";
    if (expire) ck += "expires=" + new Date(expire
        + new Date().getTimezoneOffset() * 60).toGMTString() + ";";
    if (path)   ck += "path=" + path + ";";
    if (domain) ck += "domain=" + domain + ";";
    if (secure) ck += "secure";

    document.cookie = ck;
    return value
};

/**
 * Gets the value of a stored name/value pair called a cookie.
 * 
 * @param {String} name the name of the stored cookie.
 * @return {String} Returns a value of the cookie or the empty string if it isn't found
 */
apf.getcookie = function (name) {
  var aCookie = document.cookie.split("; ");
  for (var i = 0; i < aCookie.length; i++) {
      var aCrumb = aCookie[i].split("=");
      if (name == aCrumb[0])
          return unescape(aCrumb[1]);
  }

  return "";
};

/**
 * Deletes a stored name/value pair called a cookie.
 * 
 * @param {String} name     the name of the stored cookie
 * @param {String} domain   the name of the domain of stored cookie
 */
apf.delcookie = function (name, domain){
    document.cookie = name + "=blah; expires=Fri, 31 Dec 1999 23:59:59 GMT;"
        + (domain ? 'domain='+domain : '');
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/utilities.js)SIZE(29755)TIME(1265038748)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Syntax highlights a code string using html.
 * @param {String} strCode the code to highlight.
 * @return {String} the highlighted string.
 */
apf.highlightXml = 
apf.highlightCode = function(strCode){
    var lines = strCode.split(/\n\r?/);
    for (var min = 1000, i = 0, l = lines.length; i < l; i++){
        min = Math.min(min, lines[i].match(/^(\s+)?[^\s]/) && RegExp.$1.length || 1000);
        if (!min) break;
    }

    strCode = strCode.replace(new RegExp("^ {" + min + "}", "gm"), "")
      .replace(/<!--([\s\S]+?)-->|<\?([\w\-]+)([\s\S]+?)\?>|<\!\[CDATA\[([\s\S]*?)\]\]>|<(\w+:)?script([\s\S]*?)>([\s\S]*?)<\/(?:\w+:)?script>|<([\/\w\:\-]+)([\s\S]*?)(\/?)>/g, 
        function(m, comment, ptarget, pcontents, cdata, sprefix, sattr, scontent, tagName, attrs, bl){
            if (comment) {
                return "<span style=\"color:green\">&lt;!--" + comment + "--&gt;</span>";
            }
            else if (ptarget) {
                return "<span style=\"color:orange\">&lt;?" + ptarget + "</span>" 
                    + apf.highlightJs(pcontents, true) 
                    + "<span style=\"color:orange\">?&gt;</span>";
            }
            else if (cdata) {
                return "<span style=\"color:gray\">&lt;![CDATA[" + cdata + "]]&gt;</span>";
            }
            else if (sprefix) {
                return "<span style=\"color:#127ac6\">&lt;" + sprefix + "script" + (attrs 
                      ? "</span>" + attrs.replace(/("[\s\S]*?")|([\w\-\:]+)/g, function(m, s, w){
                            if (s) return s;
                            return "<span style=\"color:red\">" + w + "</span>";
                        }) + "<span style=\"color:#127ac6\">&gt;</span>"
                      : "&gt;</span>")
                    + apf.highlightJs(scontent, true) 
                    + "<span style=\"color:#127ac6\">&lt;/" + sprefix + "script&gt;</span>";
            }
            else if (tagName) {
                return "<span style=\"color:#127ac6\">&lt;" 
                    + (tagName.substr(0, 2) == "a:" 
                        ? "<a href='element." + tagName.substr(2) + "'>" + tagName + "</a>" 
                        : tagName)
                    + (attrs 
                      ? "</span>" + attrs.replace(/("[\s\S]*?")|([\w\-\:]+)/g, function(m, s, w){
                            if (s) return s;
                            return "<span style=\"color:red\">" + w + "</span>";
                        }) + "<span style=\"color:#127ac6\">" + bl + "&gt;</span>"
                      : "&gt;</span>");
            }
        });

    return strCode;//.replace(/&lt;/g, "&amp;lt;");
}

/**
 * @private
 */
apf.convertAmlToJson = function(strCode){
    var xml = apf.getXml("<a:app xmlns:a='" + apf.ns.apf + "'>" + strCode + "</a:app>", null, true);

    var script = [], bool = {"true":1, "false":1};
    var x = (function recur(nodes, depth, paout){
        var pre = new Array(depth+2).join("  "), output = [];
        
        for (var node, i = 0, l = nodes.length; i < l; i++) {
            node = nodes[i];
            if (node.nodeType == 3 || node.nodeType == 4) {
                if (node.nodeValue.replace(/[\s]*$/, "").replace(/^[\s]*/, "")) {
                    (paout || output).push("data", '"' + node.nodeValue.trim().replace(/"/g, "\\\"").replace(/\n/g, "\\\n") + '"');
                }
                continue;
            }
            else if (node.nodeType == 8) {
                output.push(pre + "//" + node.nodeValue);
                continue;
            }
            else if (node.nodeType != 1)
                continue; //ignore
            else if (node[apf.TAGNAME] == "script") {
                var s = node.childNodes;
                for (var j = 0, jl = s.length; j < jl; j++) {
                    if (s[j].nodeValue.trim() != "//")
                        script.push(s[j].nodeValue.replace(/^ {16}/gm, "").replace(/\/\/$/, "") + "\n");
                }
                continue;
            }
            
            var attr, childLength = node.childNodes.length + (attr = node.attributes).length;
            var max = 0, aout = [];
            output.push(pre + "new apf." + node[apf.TAGNAME] + (childLength || !depth ? "({" : "()" + (depth == 0 ? ";" : (i == l - 1 ? "" : ","))));
            if (!depth) {
                aout.push("htmlNode", "document.body");
                max = Math.max(8, max);
            }
            
            for (var a, j = 0, jl = attr.length; j < jl; j++) {
                aout.push((a = attr[j]).nodeName, a.nodeName.substr(0,2) == "on"
                    ? "function(){" + a.nodeValue + "}"
                    : (parseInt(a.nodeValue) == a.nodeValue || bool[a.nodeValue]
                        ? a.nodeValue
                        : '"' + a.nodeValue.replace(/"/g, "\\\"") + '"'));
                max = Math.max(a.nodeName.length, max);
            }
            
            var c = "";
            if (node[apf.TAGNAME] == "model" && node.childNodes.length) {
                aout.push("data", '"' + apf.serializeChildren(node).trim().replace(/"/g, "\\\"").replace(/\r?\n/g, "\\\n") + '"');
            }
            else if (childLength)
                var c = recur(node.childNodes, depth+2, aout);
            
            max = Math.max(c ? 10 : 4, max);
            
            max++;
            
            for (j = 0, jl = aout.length; j < jl; j+=2) {
                output.push(pre + "  " + aout[j].pad(max, " ", apf.PAD_RIGHT) 
                    + ": " + aout[j+1] + (j != jl - 2 || c ? "," : ""));
            }
            
            if (c) {
                output.push(pre + "  " + "childNodes".pad(max, " ", apf.PAD_RIGHT) + ": [");
                output.push(c.substr(0, c.length - 1));
                output.push(pre + "  ]");
            }

            if (childLength || !depth)
                output.push(pre + "})" + (depth == 0 ? ";" : (i == l - 1 ? "" : ",")))
        }

        return output.join("\n") + (depth == 0 ? "\n\n" + script.join("").trim() : "");
    })(xml.childNodes, 0);

    return x + "\n\n";
}

apf.highlightJs = function(x, notrim){
    if (!notrim) {
        var lines = x.split(/\n\r?/);
        for (var min = 1000, i = 0, l = lines.length; i < l; i++){
            min = Math.min(min, lines[i].match(/^(\s+)?[^\s]/) && RegExp.$1.length || 1000);
            if (!min) break;
        }
        x = x.replace(new RegExp("^ {" + min + "}", "gm"), "");
    }
    
    return x.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/(\/\*[\s\S]+\*\/)|(\/\/.*)$|("(?:[^"\\]+|\\[\s\S])*")|('(?:[^'\\]+|\\[\s\S])*')|(\W)(apf|break|continue|do|for|import|new|this|void|case|default|else|function|in|return|typeof|while|comment|delete|export|if|label|switch|var|with|abstract|implements|protected|boolean|instanceOf|public|byte|int|short|char|interface|static|double|long|synchronized|false|native|throws|final|null|transient|float|package|true|goto|private|catch|enum|throw|class|extends|try|const|finally|debugger|super)(\W)|(\W)(\w+)(\s*\()/gm,
        function(m, colong, co, str1, str2, nw, kw, nw2, fW, f, fws) {
            if (f)
                return fW + '<span style="color:#ff8000">' + f + '</span>' + fws;
            else if (co || colong)
                return '<span style="color:green">' + (co || colong) + '</span>';
            else if (str1 || str2)
                return '<span style="color:#808080">' + (str1 || str2) + '</span>';
            else if (nw)
                return nw + '<span style="color:#127ac6">' + kw + '</span>' + nw2;
        });
}

/**
 * Syntax highlights a code string using html.
 * @param {String} strCode the code to highlight.
 * @return {String} the highlighted string.
 */
apf.highlightCode2 = function(strCode){
  var comment=[],str=[];
  return strCode
        .replace(/(\/\*[\s\S]*?\*\/|\/\/.*)/g, function(a){ comment.push(a); return '###n'+(comment.length-1)+'###';})   
         .replace(/\"([\s\S]*?)\"/g, function(a,b){ str.push(b); return '###s'+(str.length-1)+'###';})         
         .replace(/\'([\s\S]*?)\'/g, function(a,b){ str.push(b); return '###q'+(str.length-1)+'###';}) 
         .replace(/(\<)|(\>)/g,function(n,a,b){ return "<span stylecolorwhite>"+(a?'@lt@':'@gt@')+"</span>"})
         .replace(/(\W)-?([\d\.]+)(\W)/g, "$1<span stylecolor#127ac6>$2</span>$3")
         .replace(/([\|\&\=\;\,\:\?\+\*\-]+)/g, "<span stylecolorwhite>$1</span>")
         .replace(/(\W)(break|continue|do|for|import|new|this|void|case|default|else|function|in|return|typeof|while|comment|delete|export|if|label|switch|var|with|abstract|implements|protected|boolean|instanceOf|public|byte|int|short|char|interface|static|double|long|synchronized|false|native|throws|final|null|transient|float|package|true|goto|private|catch|enum|throw|class|extends|try|const|finally|debugger|super)(\W)/g,
    "$1<span stylecolorgreen>$2</span>$3")
         .replace(/([\(\)\{\}\[\]])/g, "<span stylecoloryellow>$1</span>")
         .replace(/###n(\d+)###/g,function(a,b){ return "<span stylecolorpurple>"+comment[b].escapeHTML()+"</span>"; } )
         .replace(/###s(\d+)###/g,function(a,b){ return "<span stylecolorgray>\""+str[b].escapeHTML()+"\"</span>"; } )
         .replace(/###q(\d+)###/g,function(a,b){ return "<span stylecolorgray>'"+str[b].escapeHTML()+"'</span>"; } )
         .replace(/stylecolor(.*?)\>/g,"style='color:$1'>")
         .replace(/@(.*?)@/g,"&$1;");
}

/**
 * Formats a javascript string with good indentation. Also known as pretty printing.
 * @param {String} strJs the javascript to format.
 * @return {String} the formatted string.
 */
apf.formatJS = function(strJs){
    var d = 0, r = 0;
    var comment=[],str=[];
    return strJs
        .replace(/(\/\*[\s\S]*?\*\/|\/\/.*)/g, function(a){ comment.push(a); return '###n'+(comment.length-1)+'###';}) 
        .replace(/\"([\s\S]*?)\"/g, function(a,b){ str.push(b); return '###s'+(str.length-1)+'###';})         
        .replace(/\'([\s\S]*?)\'/g, function(a,b){ str.push(b); return '###q'+(str.length-1)+'###';}) 
        .replace(/;+/g, ';').replace(/{;/g, '{').replace(/({)|(})|(\()|(\))|(;)/g,
        function(m, co, cc, ro, rc, e){
            if (co) d++;
            if (cc) d--;
            if (ro){ r++; return ro;}
            if (rc){ r--; return rc;}

            var o = '';
            for (var i = 0; i < d; i++)
                o += '\t';
            if (co) return '{\n' + o;
            if (cc) return '\n' + o + '}';
            if (e) return (r>0)?e:(';\n' + o);
        }).replace(/;\s*\n\s*\n/g, ';\n').replace(/}var/g, '}\nvar')
        .replace(/([\n\s]*)###n(\d+)###[\n\s]*/g,function(a,b,c){ return b+comment[c]+b; } )
        .replace(/###s(\d+)###/g,function(a,b,c){ return "\""+str[b]+"\""; } )
        .replace(/###q(\d+)###/g,function(a,b,c){ return "'"+str[b]+"'"; } );
};

/**
 * Opens a window with the string in it
 * @param {String} str the html string displayed in the new window.
 */
apf.pasteWindow = function(str){
    var win = window.open("about:blank");
    win.document.write(str);
};



/**
 * @private
 */
apf.xmlEntityMap = {
    "quot": "34", "amp": "38", "apos": "39", "lt": "60", "gt": "62",
    "nbsp": "160", "iexcl": "161", "cent": "162", "pound": "163", "curren": "164",
    "yen": "165", "brvbar": "166", "sect": "167", "uml": "168", "copy": "169",
    "ordf": "170", "laquo": "171", "not": "172", "shy": "173", "reg": "174",
    "macr": "175", "deg": "176", "plusmn": "177", "sup2": "178", "sup3": "179",
    "acute": "180", "micro": "181", "para": "182", "middot": "183", "cedil": "184",
    "sup1": "185", "ordm": "186", "raquo": "187", "frac14": "188", "frac12": "189",
    "frac34": "190", "iquest": "191", "agrave": "192", "aacute": "193",
    "acirc": "194", "atilde": "195", "auml": "196", "aring": "197", "aelig": "198",
    "ccedil": "199", "egrave": "200", "eacute": "201", "ecirc": "202",
    "euml": "203", "igrave": "204", "iacute": "205", "icirc": "206", "iuml": "207",
    "eth": "208", "ntilde": "209", "ograve": "210", "oacute": "211", "ocirc": "212",
    "otilde": "213", "ouml": "214", "times": "215", "oslash": "216", "ugrave": "217",
    "uacute": "218", "ucirc": "219", "uuml": "220", "yacute": "221", "thorn": "222",
    "szlig": "223", "agrave": "224", "aacute": "225", "acirc": "226", "atilde": "227",
    "auml": "228", "aring": "229", "aelig": "230", "ccedil": "231", "egrave": "232",
    "eacute": "233", "ecirc": "234", "euml": "235", "igrave": "236", "iacute": "237",
    "icirc": "238", "iuml": "239", "eth": "240", "ntilde": "241", "ograve": "242",
    "oacute": "243", "ocirc": "244", "otilde": "245", "ouml": "246", "divide": "247",
    "oslash": "248", "ugrave": "249", "uacute": "250", "ucirc": "251", "uuml": "252",
    "yacute": "253", "thorn": "254", "yuml": "255", "oelig": "338", "oelig": "339",
    "scaron": "352", "scaron": "353", "yuml": "376", "fnof": "402", "circ": "710",
    "tilde": "732", "alpha": "913", "beta": "914", "gamma": "915", "delta": "916",
    "epsilon": "917", "zeta": "918", "eta": "919", "theta": "920", "iota": "921",
    "kappa": "922", "lambda": "923", "mu": "924", "nu": "925", "xi": "926",
    "omicron": "927", "pi": "928", "rho": "929", "sigma": "931", "tau": "932",
    "upsilon": "933", "phi": "934", "chi": "935", "psi": "936", "omega": "937",
    "alpha": "945", "beta": "946", "gamma": "947", "delta": "948", "epsilon": "949",
    "zeta": "950", "eta": "951", "theta": "952", "iota": "953", "kappa": "954",
    "lambda": "955", "mu": "956", "nu": "957", "xi": "958", "omicron": "959",
    "pi": "960", "rho": "961", "sigmaf": "962", "sigma": "963", "tau": "964",
    "upsilon": "965", "phi": "966", "chi": "967", "psi": "968", "omega": "969",
    "thetasym": "977", "upsih": "978", "piv": "982", "ensp": "8194", "emsp": "8195",
    "thinsp": "8201", "zwnj": "8204", "zwj": "8205", "lrm": "8206", "rlm": "8207",
    "ndash": "8211", "mdash": "8212", "lsquo": "8216", "rsquo": "8217",
    "sbquo": "8218", "ldquo": "8220", "rdquo": "8221", "bdquo": "8222",
    "dagger": "8224", "dagger": "8225", "bull": "8226", "hellip": "8230",
    "permil": "8240", "prime": "8242", "prime": "8243", "lsaquo": "8249",
    "rsaquo": "8250", "oline": "8254", "frasl": "8260", "euro": "8364",
    "image": "8465", "weierp": "8472", "real": "8476", "trade": "8482",
    "alefsym": "8501", "larr": "8592", "uarr": "8593", "rarr": "8594",
    "darr": "8595", "harr": "8596", "crarr": "8629", "larr": "8656", "uarr": "8657",
    "rarr": "8658", "darr": "8659", "harr": "8660", "forall": "8704", "part": "8706",
    "exist": "8707", "empty": "8709", "nabla": "8711", "isin": "8712",
    "notin": "8713", "ni": "8715", "prod": "8719", "sum": "8721", "minus": "8722",
    "lowast": "8727", "radic": "8730", "prop": "8733", "infin": "8734",
    "ang": "8736", "and": "8743", "or": "8744", "cap": "8745", "cup": "8746",
    "int": "8747", "there4": "8756", "sim": "8764", "cong": "8773", "asymp": "8776",
    "ne": "8800", "equiv": "8801", "le": "8804", "ge": "8805", "sub": "8834",
    "sup": "8835", "nsub": "8836", "sube": "8838", "supe": "8839", "oplus": "8853",
    "otimes": "8855", "perp": "8869", "sdot": "8901", "lceil": "8968",
    "rceil": "8969", "lfloor": "8970", "rfloor": "8971", "lang": "9001",
    "rang": "9002", "loz": "9674", "spades": "9824", "clubs": "9827",
    "hearts": "9829", "diams": "9830"
};

/**
 * see string#escapeHTML
 * @param {String} str the html to be escaped.
 * @return {String} the escaped string.
 */
apf.htmlentities = function(str){
    return str.escapeHTML();
};

/**
 * Escape an xml string making it ascii compatible.
 * @param {String} str the xml string to escape.
 * @return {String} the escaped string.
 *
 * @todo This function does something completely different from htmlentities, 
 *       the name is confusing and misleading.
 */
apf.xmlentities = function(str) {
    return str.replace(/&([a-z]+);/gi, function(a, m) {
        if (apf.xmlEntityMap[m = m.toLowerCase()])
            return '&#' + apf.xmlEntityMap[m] + ';';
        return a;
    });
};

/**
 * Unescape an html string.
 * @param {String} str the string to unescape.
 * @return {String} the unescaped string.
 */
apf.html_entity_decode = function(str){
    return (str || "").replace(/\&\#38;/g, "&").replace(/&lt;/g, "<")
        .replace(/&gt;/g, ">").replace(/&amp;/g, "&").replace(/&nbsp;/g, " ");
};



/**
 * Determines whether the keyboard input was a character that can influence
 * the value of an element (like a textbox).
 * @param {Number} charCode The ascii character code.
 */
apf.isCharacter = function(charCode){
    return (charCode < 112 || charCode > 122)
      && (charCode == 32 || charCode > 42 || charCode == 8);
};

/**
 * This random number generator has been added to provide a more robust and
 * reliable random number spitter than the native Ecmascript Math.random()
 * function.
 * is an implementation of the Park-Miller algorithm. (See 'Random Number
 * Generators: Good Ones Are Hard to Find', by Stephen K. Park and Keith W.
 * Miller, Communications of the ACM, 31(10):1192-1201, 1988.)
 * @author David N. Smith of IBM's T. J. Watson Research Center.
 * @author Mike de Boer (mike AT javeline DOT com)
 * @class randomGenerator
 */
apf.randomGenerator = {
    d: new Date(),
    seed: null,
    A: 48271,
    M: 2147483647,
    Q: null,
    R: null,
    oneOverM: null,

    /**
     * Generates a random Number between a lower and upper boundary.
     * The algorithm uses the system time, in minutes and seconds, to 'seed'
     * itself, that is, to create the initial values from which it will generate
     * a sequence of numbers. If you are familiar with random number generators,
     * you might have reason to use some other value for the seed. Otherwise,
     * you should probably not change it.
     * @param {Number} lnr Lower boundary
     * @param {Number} unr Upper boundary
     * @result A random number between <i>lnr</i> and <i>unr</i>
     * @type Number
     */
    generate: function(lnr, unr) {
        if (this.seed == null)
            this.seed = 2345678901 + (this.d.getSeconds() * 0xFFFFFF) + (this.d.getMinutes() * 0xFFFF);
        this.Q = this.M / this.A;
        this.R = this.M % this.A;
        this.oneOverM = 1.0 / this.M;
        return Math.floor((unr - lnr + 1) * this.next() + lnr);
    },

    /**
     * Returns a new random number, based on the 'seed', generated by the
     * <i>generate</i> method.
     * @type Number
     */
    next: function() {
        var hi = this.seed / this.Q;
        var lo = this.seed % this.Q;
        var test = this.A * lo - this.R * hi;
        if (test > 0)
            this.seed = test;
        else
            this.seed = test + this.M;
        return (this.seed * this.oneOverM);
    }
};

/**
 * Adds a time stamp to the url to prevent the browser from caching it.
 * @param {String} url the url to add the timestamp to.
 * @return {String} the url with timestamp.
 */
apf.getNoCacheUrl = function(url){
    return url
        + (url.indexOf("?") == -1 ? "?" : "&")
        + "nocache=" + new Date().getTime();
};

/**
 * Checks if the string contains curly braces at the start and end. If so it's
 * processed as javascript, else the original string is returned.
 * @param {String} str the string to parse.
 * @return {String} the result of the parsing.
 */
apf.parseExpression = function(str){
    if (!apf.parseExpression.regexp.test(str))
        return str;

    
    try {
    
        return eval(RegExp.$1);
    
    }
    catch(e) {
        throw new Error(apf.formatErrorString(0, null,
            "Parsing Expression",
            "Invalid expression given '" + str + "'"));
    }
    
};
apf.parseExpression.regexp = /^\{([\s\S]*)\}$/;

/**
 * @private
 */
apf.formatNumber = function(num, prefix){
    var nr = parseFloat(num);
    if (!nr) return num;

    var str = new String(Math.round(nr * 100) / 100).replace(/(\.\d?\d?)$/, function(m1){
        return m1.pad(3, "0", apf.PAD_RIGHT);
    });
    if (str.indexOf(".") == -1)
        str += ".00";

    return prefix + str;
};

/**
 * Execute a script in the global scope.
 *
 * @param {String} str  the javascript code to execute.
 * @return {String} the javascript code executed.
 */
apf.exec = function(str, win){
    if (!str)
        return str;
    if (!win)
        win = self;

    if (apf.isO3)
        eval(str, self);
    else if (apf.hasExecScript) {
        win.execScript(str);
    }
    else {
        var head = win.document.getElementsByTagName("head")[0];
        if (head) {
            var script = win.document.createElement('script');
            script.setAttribute('type', 'text/javascript');
            script.text = str;
            head.appendChild(script);
            head.removeChild(script);
        } else
            eval(str, win);
    }

    return str;
};

/**
 * Shorthand for an empty function.
 */
apf.K = function(){};



/**
 * Reliably determines whether a variable is a Number.
 *
 * @param {mixed}   value The variable to check
 * @type  {Boolean}
 */
apf.isNumber = function(value){
    return parseFloat(value) == value;
};

/**
 * Reliably determines whether a variable is an array.
 * @see http://thinkweb2.com/projects/prototype/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
 *
 * @param {mixed}   value The variable to check
 * @type  {Boolean}
 */
apf.isArray = function(value) {
    return Object.prototype.toString.call(value) === "[object Array]";
};

/**
 * Determines whether a string is true in the html attribute sense.
 * @param {mixed} value the variable to check
 *   Possible values:
 *   true   The function returns true.
 *   'true' The function returns true.
 *   'on'   The function returns true.
 *   1      The function returns true.
 *   '1'    The function returns true.
 * @return {Boolean} whether the string is considered to imply truth.
 */
apf.isTrue = function(c){
    return (c === true || c === "true" || c === "on" || typeof c == "number" && c > 0 || c === "1");
};

/**
 * Determines whether a string is false in the html attribute sense.
 * @param {mixed} value the variable to check
 *   Possible values:
 *   false   The function returns true.
 *   'false' The function returns true.
 *   'off'   The function returns true.
 *   0       The function returns true.
 *   '0'     The function returns true.
 * @return {Boolean} whether the string is considered to imply untruth.
 */
apf.isFalse = function(c){
    return (c === false || c === "false" || c === "off" || c === 0 || c === "0");
};

/**
 * Determines whether a value should be considered false. This excludes amongst
 * others the number 0.
 * @param {mixed} value the variable to check
 * @return {Boolean} whether the variable is considered false.
 */
apf.isNot = function(c){
    // a var that is null, false, undefined, Infinity, NaN and c isn't a string
    return (!c && typeof c != "string" && c !== 0 || (typeof c == "number" && !isFinite(c)));
};

/**
 * Creates a relative url based on an absolute url.
 * @param {String} base the start of the url to which relative url's work.
 * @param {String} url  the url to transform.
 * @return {String} the relative url.
 */
apf.removePathContext = function(base, url){
    if (!url)  return "";

    if (url.indexOf(base) > -1)
        return url.substr(base.length);

    return url;
};

/**
 * @private
 * @todo why is this done like this?
 */
apf.cancelBubble = function(e, o){
    e.cancelBubble = true;
    
    if (o.$focussable && !o.disabled)
        apf.window.$focus(o);
    
};



/**
 * Attempt to fix memory leaks
 * @private
 */
apf.destroyHtmlNode = function (element) {
    if (!element) return;

    if (!apf.isIE || element.ownerDocument != document) {
        if (element.parentNode)
            element.parentNode.removeChild(element);
        return;
    }

    var garbageBin = document.getElementById('IELeakGarbageBin');
    if (!garbageBin) {
        garbageBin    = document.createElement('DIV');
        garbageBin.id = 'IELeakGarbageBin';
        garbageBin.style.display = 'none';
        document.body.appendChild(garbageBin);
    }

    // move the element to the garbage bin
    garbageBin.appendChild(element);
    garbageBin.innerHTML = '';
};


/**
 * @private
 */
apf.getRules = function(node){
    var rules = {};

    for (var w = node.firstChild; w; w = w.nextSibling){
        if (w.nodeType != 1)
            continue;
        else {
            if (!rules[w[apf.TAGNAME]])
                rules[w[apf.TAGNAME]] = [];
            rules[w[apf.TAGNAME]].push(w);
        }
    }

    return rules;
};


/**
 * @private
 */
apf.getBox = function(value, base){
    if (!base) base = 0;

    if (value == null || (!parseInt(value) && parseInt(value) != 0))
        return [0, 0, 0, 0];

    var x = value.split(" ");
    for (var i = 0; i < x.length; i++)
        x[i] = parseInt(x[i]) || 0;
    switch (x.length) {
        case 1:
            x[1] = x[0];
            x[2] = x[0];
            x[3] = x[0];
            break;
        case 2:
            x[2] = x[0];
            x[3] = x[1];
            break;
        case 3:
            x[3] = x[1];
            break;
    }

    return x;
};

/**
 * @private
 */
apf.getNode = function(data, tree){
    var nc = 0;//nodeCount
    //node = 1
    if (data != null) {
        for (var i = 0; i < data.childNodes.length; i++) {
            if (data.childNodes[i].nodeType == 1) {
                if (nc == tree[0]) {
                    data = data.childNodes[i];
                    if (tree.length > 1) {
                        tree.shift();
                        data = this.getNode(data, tree);
                    }
                    return data;
                }
                nc++
            }
        }
    }

    return null;
};

/**
 * Retrieves the first xml node with nodeType 1 from the children of an xml element.
 * @param {XMLElement} xmlNode the xml element that is the parent of the element to select.
 * @return {XMLElement} the first child element of the xml parent.
 * @throw error when no child element is found.
 */
apf.getFirstElement = function(xmlNode){
    
    try {
        xmlNode.firstChild.nodeType == 1
            ? xmlNode.firstChild
            : xmlNode.firstChild.nextSibling
    }
    catch (e) {
        throw new Error(apf.formatErrorString(1052, null,
            "Xml Selection",
            "Could not find element:\n"
            + (xmlNode ? xmlNode.xml : "null")));
    }
    

    return xmlNode.firstChild.nodeType == 1
        ? xmlNode.firstChild
        : xmlNode.firstChild.nextSibling;
};

/**
 * Retrieves the last xml node with nodeType 1 from the children of an xml element.
 * @param {XMLElement} xmlNode the xml element that is the parent of the element to select.
 * @return {XMLElement} the last child element of the xml parent.
 * @throw error when no child element is found.
 */
apf.getLastElement = function(xmlNode){
    
    try {
        xmlNode.lastChild.nodeType == 1
            ? xmlNode.lastChild
            : xmlNode.lastChild.nextSibling
    }
    catch (e) {
        throw new Error(apf.formatErrorString(1053, null,
            "Xml Selection",
            "Could not find last element:\n"
            + (xmlNode ? xmlNode.xml : "null")));
    }
    

    return xmlNode.lastChild.nodeType == 1
        ? xmlNode.lastChild
        : xmlNode.lastChild.previousSibling;
};

/**
 * Selects the content of an html element. Currently only works in
 * internet explorer.
 * @param {HTMLElement} oHtml the container in which the content receives the selection.
 */
apf.selectTextHtml = function(oHtml){
    if (!apf.hasMsRangeObject) return;// oHtml.focus();

    var r = document.selection.createRange();
    try {r.moveToElementText(oHtml);} catch(e){}
    r.select();
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/xml.js)SIZE(28968)TIME(1264809662)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Determines whether a node is a child of another node.
 *
 * @param {DOMNode} pNode      the potential parent element.
 * @param {DOMNode} childnode  the potential child node.
 * @param {Boolean} [orItself] whether the method also returns true when pNode is the childnode.
 * @return  {Number} the child position of the node. Or false if it's not a child.
 */
apf.isChildOf = function(pNode, childnode, orItself){
    if (!pNode || !childnode)
        return false;
    
    if (childnode.nodeType == 2)
        childnode = childnode.selectSingleNode("..");
    
    if (orItself && pNode == childnode)
        return true;

    var loopnode = childnode.parentNode;
    while(loopnode){
        if(loopnode == pNode)
            return true;
        loopnode = loopnode.parentNode;
    }

    return false;
};

/**
 * Determines whether a node is it's parent's only child.
 * @param {DOMNode} node     the potential only child.
 * @param {Array}   nodeType list of the node types that this child can be.
 * @returns {Boolean} whether the node is only child and optionally of one of the specified nodeTypes.
 */
apf.isOnlyChild = function(node, nodeType){
    if (!node || !node.parentNode || nodeType && nodeType.indexOf(node.nodeType) == -1)
        return false;

    var i, l, cnode, nodes = node.parentNode.childNodes;
    for (i = 0, l = nodes.length; i < l; i++) {
        cnode = nodes[i];
        if (cnode.nodeType == 1 && cnode != node)
            return false;
        if (cnode.nodeType == 3 && !cnode.nodeValue.trim())
            return false;
    }

    return true;
};

/**
 * Gets the position of a dom node within the list of child nodes of it's
 * parent.
 *
 * @param {DOMNode} node the node for which the child position is determined.
 * @return {Number} the child position of the node.
 */
apf.getChildNumber = function(node, sameTagname){
    var p = node.parentNode, j = 0;
    if (!p) return 0;
    for (var i = 0; i < p.childNodes.length; i++) {
        if (p.childNodes[i] == node)
            return j;
        if (!sameTagname || node.nodeType == 1 && node.tagName == p.childNodes[i].tagName)
            j++;
    }
    return j;
};

/**
 * Integrates nodes as children of a parent. Optionally attributes are
 * copied as well.
 *
 * @param {XMLNode} xmlNode the data to merge.
 * @param {XMLNode} parent  the node to merge on.
 * @param {Object}  options
 *   Properties:
 *   {Boolean} [copyAttributes] whether the attributes of xmlNode are copied as well.
 *   {Boolean} [clearContents]  whether the contents of parent is cleared.
 *   {Number}  [start]          This feature is used for the virtual viewport. More information will follow.
 *   {Number}  [length]         This feature is used for the virtual viewport. More information will follow.
 *   {Number}  [documentId]     This feature is used for the virtual viewport. More information will follow.
 *   {XMLElement} [marker]      This feature is used for the virtual viewport. More information will follow.
 * @return  {XMLNode}  the created xml node
 */
apf.mergeXml = function(XMLRoot, parentNode, options){
    if (typeof parentNode != "object")
        parentNode = getElementById(parentNode);

    if (options && options.clearContents) {
        //Signal listening elements
        var node, j, i, nodes = parentNode.selectNodes("descendant::node()[@" + apf.xmldb.xmlListenTag + "]");
        for (i = nodes.length - 1; i >= 0; i--) {
            var s = nodes[i].getAttribute(apf.xmldb.xmlListenTag).split(";");
            for (j = s.length - 1; j >= 0; j--) {
                node = apf.all[s[j]];
                if (node.dataParent && node.dataParent.xpath)
                    node.dataParent.parent.signalXmlUpdate[node.$uniqueId] = true;
                else if (node.$model)
                    node.$model.$waitForXml(node);
            }
        }
        
        //clean parent
        var nodes = parentNode.childNodes;
        for (var i = nodes.length - 1; i >= 0; i--)
            parentNode.removeChild(nodes[i]);
    }

    
    if (options && options.start) { //Assuming each node is in count
        var reserved, beforeNode, nodes, doc, i, l, marker = options.marker;
        if (!marker){
            //optionally find marker
        }

        //This code assumes that the dataset fits inside this marker

        //Start of marker
        if (marker.getAttribute("start") - options.start == 0) {
            marker.setAttribute("start", options.start + options.length);
            reserved = parseInt(marker.getAttribute("reserved"));
            marker.setAttribute("reserved", reserved + options.length);
            beforeNode = marker;
        }
        //End of marker
        else if (options.start + options.length == marker.getAttribute("end")) {
            marker.setAttribute("end", options.start + options.length);
            beforeNode = marker.nextSibling;
            reserved = parseInt(marker.getAttribute("reserved")) + parseInt(marker.getAttribute("end")) - options.length;
        }
        //Middle of marker
        else {
            var m2 = marker.parentNode.insertBefore(marker.cloneNode(true), marker);
            m2.setAttribute("end", options.start - 1);
            marker.setAttribute("start", options.start + options.length);
            reserved = parseInt(marker.getAttribute("reserved"));
            marker.setAttribute("reserved", reserved + options.length);
            beforeNode = marker;
        }

        nodes = XMLRoot.childNodes;

        if (parentNode.ownerDocument.importNode) {
            doc = parentNode.ownerDocument;
            for (i = 0, l = nodes.length; i < l; i++) {
                parentNode.insertBefore(doc.importNode(nodes[i], true), beforeNode)
                  .setAttribute(apf.xmldb.xmlIdTag, options.documentId + "|" + (reserved + i));
            }
        }
        else {
            for (i = nodes.length - 1; i >= 0; i--) {
                parentNode.insertBefore(nodes[0], beforeNode)
                  .setAttribute(apf.xmldb.xmlIdTag, options.documentId + "|" + (reserved + i));
            }
        }
    }
    else
    
    {
        beforeNode = options.beforeNode || apf.getNode(parentNode, [0]);
        nodes      = XMLRoot.childNodes;

        if (parentNode.ownerDocument.importNode) {
            doc = parentNode.ownerDocument;
            for (i = 0, l = nodes.length; i < l; i++)
                parentNode.insertBefore(doc.importNode(nodes[i], true), beforeNode);
        }
        else
            for (i = nodes.length - 1; i >= 0; i--)
                parentNode.insertBefore(nodes[0], beforeNode);
    }

    if (options && options.copyAttributes) {
        var attr = XMLRoot.attributes;
        for (i = 0; i < attr.length; i++)
            if (attr[i].nodeName != apf.xmldb.xmlIdTag)
                parentNode.setAttribute(attr[i].nodeName, attr[i].nodeValue);
    }

    return parentNode;
};

/**
 * Sets the nodeValue of a dom node.
 *
 * @param {XMLElement} xmlNode       the xml node that should receive the nodeValue. When an element node is passed the first text node is set.
 * @param {String}     nodeValue     the value to set.
 * @param {Boolean}    applyChanges  whether the changes are propagated to the databound elements.
 * @param {UndoObj}    undoObj       the undo object that is responsible for archiving the changes.
 */
apf.setNodeValue = function(xmlNode, nodeValue, applyChanges, options){
    if (!xmlNode)
        return;
    
    var undoObj, xpath, newNodes;
    if (options) {
        undoObj  = options.undoObj;
        xpath    = options.xpath;
        newNodes = options.newNodes;
        
        undoObj.extra.oldValue = options.forceNew
            ? ""
            : apf.queryValue(xmlNode, xpath);

        undoObj.xmlNode        = xmlNode;
        if (xpath)
            xmlNode = apf.createNodeFromXpath(xmlNode, xpath, newNodes, options.forceNew);

        undoObj.extra.appliedNode = xmlNode;
    }
    
    if (xmlNode.nodeType == 1) {
        if (!xmlNode.firstChild)
            xmlNode.appendChild(xmlNode.ownerDocument.createTextNode("-"));

        xmlNode.firstChild.nodeValue = apf.isNot(nodeValue) ? "" : nodeValue;

        if (applyChanges)
            apf.xmldb.applyChanges("synchronize", xmlNode, undoObj);
    }
    else {
        xmlNode.nodeValue = apf.isNot(nodeValue) ? "" : nodeValue;

        if (applyChanges)
            apf.xmldb.applyChanges("synchronize", xmlNode.parentNode
                || xmlNode.ownerElement || xmlNode.selectSingleNode(".."),
                undoObj);
    }
};

/**
 * Sets a value of an XMLNode based on an xpath statement executed on the data of this model.
 *
 * @param  {String}  xpath  the xpath used to select a XMLNode.
 * @param  {String}  value  the value to set.
 * @return  {XMLNode}  the changed XMLNode
 */
apf.setQueryValue = function(xmlNode, xpath, value){
    var node = apf.createNodeFromXpath(xmlNode, xpath);
    if (!node)
        return null;

    apf.setNodeValue(node, value, true);
    //apf.xmldb.setTextNode(node, value);
    return node;
};

/**
 * Queries an xml node using xpath for a string value.
 * @param {XMLElement} xmlNode the xml element to query.
 * @param {String}     xpath   the xpath query.
 * @return {String} the value of the query result or empty string.
 */
apf.queryValue = function (xmlNode, xpath){
    if (!xmlNode) 
        return "";
    if (xmlNode.nodeType == 2) 
        return xmlNode.nodeValue;

    if (xpath) {
        xmlNode = xmlNode.selectSingleNode(xpath);
        if (!xmlNode) 
            return "";
    }
   return xmlNode.nodeType == 1
        ? (!xmlNode.firstChild ? "" : xmlNode.firstChild.nodeValue)
        : xmlNode.nodeValue;
};

/**
 * Queries an xml node using xpath for a string value.
 * @param {XMLElement} xmlNode the xml element to query.
 * @param {String}     xpath   the xpath query.
 * @return {Arary} list of values which are a result of the query.
 */
apf.queryValues = function(xmlNode, xpath){
    var out = [];
    if (!xmlNode) return out;

    var nodes = xmlNode.selectNodes(xpath);
    if (!nodes.length) return out;

    for (var i = 0; i < nodes.length; i++) {
        var n = nodes[i];
        if (n.nodeType == 1)
            n = n.firstChild;
        out.push(n.nodeValue || "");
    }
    return out;
};

/**
 * Executes an xpath expression on any dom node. This is especially useful
 * for dom nodes that don't have a good native xpath processor such as html
 * in some versions of internet explorer and xml in webkit.
 *
 * @param {String}  sExpr        the xpath expression.
 * @param {DOMNode} contextNode  the xml node that is subject to the query.
 * @returns {Array} list of xml nodes found. The list can be empty.
 */
apf.queryNodes = function(sExpr, contextNode){
    if (contextNode && (apf.hasXPathHtmlSupport && contextNode.selectSingleNode || !contextNode.style))
        return contextNode.selectNodes(sExpr); //IE55
    //if (contextNode.ownerDocument != document)
    //    return contextNode.selectNodes(sExpr);

    return apf.XPath.selectNodes(sExpr, contextNode)
};

/**
 * Executes an xpath expression on any dom node. This is especially useful
 * for dom nodes that don't have a good native xpath processor such as html
 * in some versions of internet explorer and xml in webkit. This function
 * Only returns the first node found.
 *
 * @param {String}  sExpr        the xpath expression.
 * @param {DOMNode} contextNode  the dom node that is subject to the query.
 * @returns {XMLNode} the dom node found or null if none was found.
 */
apf.queryNode = function(sExpr, contextNode){
    if (contextNode && (apf.hasXPathHtmlSupport && contextNode.selectSingleNode || !contextNode.style))
        return contextNode.selectSingleNode(sExpr); //IE55
    //if (contextNode.ownerDocument != document)
    //    return contextNode.selectSingleNode(sExpr);

    var nodeList = apf.queryNodes(sExpr + (apf.isIE ? "" : "[1]"),
        contextNode ? contextNode : null);
    return nodeList.length > 0 ? nodeList[0] : null;
};

/**
 * Retrieves the attribute of an xml node or the first parent node that has
 * that attribute set. If no attribute is set the value is looked for on
 * the appsettings element.
 *
 * @param {XMLElement} xml    the xml node that is the starting point of the search.
 * @param {String}     attr   the name of the attribute.
 * @param {Function}   [func] callback that is run for every node that is searched.
 * @return {String} the found value, or empty string if none was found.
 */
apf.getInheritedAttribute = function(xml, attr, func){
    var result, avalue;

    //@todo optimize this and below
    if (xml.nodeValue != 1)
        xml = xml.parentNode;

    while (xml && (xml.nodeType != 1 || !(result = attr 
      && ((avalue = xml.getAttribute(attr)) || typeof avalue == "string") 
      || func && func(xml)))) {
        xml = xml.parentNode;
    }
    if (avalue == "")
        return "";

    return !result && attr && apf.config
        ? apf.config[attr]
        : result;
};

/**
 * Creates an xml node based on an xpath statement.
 *
 * @param {DOMNode} contextNode  the dom node that is subject to the query.
 * @param {String}  xPath        the xpath query.
 * @param {Array}   [addedNodes] this array is filled with the nodes added.
 * @param {Boolean} [forceNew]   whether a new node is always created.
 * @return {DOMNode} the last element found.
 * @todo generalize this to include attributes in if format []
 */
apf.createNodeFromXpath = function(contextNode, xPath, addedNodes, forceNew){
    var xmlNode, foundpath = "", paths = xPath.replace(/('.*?')|(".*?")|\|/g, function(m, m1, m2){
        if (m1 || m2) return m1 || m2;
        return "-%-|-%-";
    }).split("-%-|-%-")[0].split("/");
    if (!forceNew && (xmlNode = contextNode.selectSingleNode(xPath)))
        return xmlNode;
    
    var len = paths.length -1;
    if (forceNew) {
        if (paths[len].trim().match(/^\@(.*)$|^text\(\)$/))
            len--;
    }
    
    for (var addedNode, isAdding = false, i = 0; i < len; i++) {
        if (!isAdding && contextNode.selectSingleNode(foundpath
          + (i != 0 ? "/" : "") + paths[i])) {
            foundpath += (i != 0 ? "/" : "") + paths[i];// + "/";
            continue;
        }
        
        //Temp hack 
        var isAddId = paths[i].match(/(\w+)\[@([\w-]+)=(\w+)\]/);
        
        if (!isAddId && paths[i].match(/\@|\[.*\]|\(.*\)/)) {
            throw new Error(apf.formatErrorString(1041, this, 
                "Select via xPath", 
                "Could not use xPath to create xmlNode: " + xPath));
        }
        if (!isAddId && paths[i].match(/\/\//)) {
            throw new Error(apf.formatErrorString(1041, this, 
                "Select via xPath", 
                "Could not use xPath to create xmlNode: " + xPath));
        }
        

        if (isAddId)
            paths[i] = isAddId[1];

        isAdding = true;
        addedNode = contextNode.selectSingleNode(foundpath || ".")
            .appendChild(contextNode.ownerDocument.createElement(paths[i]));

        if (isAddId) {
            addedNode.setAttribute(isAddId[2], isAddId[3]);
            foundpath += (foundpath ? "/" : "") + isAddId[0];// + "/";
        }
        else
            foundpath += (foundpath ? "/" : "") + paths[i];// + "/";

        if (addedNodes)
            addedNodes.push(addedNode);
    }

    if (!foundpath)
        foundpath = ".";

    var newNode, lastpath = paths[len], 
        doc = contextNode.nodeType == 9 ? contextNode : contextNode.ownerDocument;
    do {
        if (lastpath.match(/^\@(.*)$/)) {
            (newNode || contextNode.selectSingleNode(foundpath))
                .setAttributeNode(newNode = contextNode.ownerDocument.createAttribute(RegExp.$1));
        }
        else if (lastpath.trim() == "text()") {
            newNode = (newNode || contextNode.selectSingleNode(foundpath))
                .appendChild(contextNode.ownerDocument.createTextNode(""));
        }
        else {
            var hasId = lastpath.match(/(\w+)\[@([\w-]+)=(\w+)\]/);
            if (hasId) lastpath = hasId[1];
            newNode = (newNode || contextNode.selectSingleNode(foundpath))
                .appendChild(doc.createElement(lastpath));
            if (hasId)
                newNode.setAttribute(hasId[2], hasId[3]);
            
            if (addedNodes)
                addedNodes.push(newNode);
        }
        
        foundpath += (foundpath ? "/" : "") + paths[len];
    } while((lastpath = paths[++len]));

    return newNode;
};

/**
 * @private
 */
apf.convertMethods = {
    /**
     * Gets a JSON object containing all the name/value pairs of the elements
     * using this element as it's validation group.
     *
     * @return  {String}  the string representation of a the json object
     */
    "json": function(xml){
        return JSON.stringify(apf.xml2json(xml));
        /*
        var result = {}, filled = false, nodes = xml.childNodes;
        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].nodeType != 1)
                continue;
            var name = nodes[i].tagName;
            filled = true;

            //array
            var sameNodes = xml.selectNodes(x);
            if (sameNodes.length > 1) {
                var z = [];
                for (var j = 0; j < sameNodes.length; j++) {
                    z.push(this.json(sameNodes[j], result));
                }
                result[name] = z;
            }
            else //single value
                result[name] = this.json(sameNodes[j], result);
        }

        return filled ? result : apf.queryValue(xml, "text()");*/
    },

    "cgivars": function(xml, basename){
        if (!basename) 
            basename = "";
        
        var str = [], value, nodes = xml.childNodes, done = {};
        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].nodeType != 1)
                continue;
            var name = nodes[i].tagName;
            if (done[name])
                continue;

            //array
            var sameNodes = xml.selectNodes(name);
            if (sameNodes.length > 1) {
                done[name] = true;
                for (var j = 0; j < sameNodes.length; j++) {
                    value = this.cgivars(sameNodes[j],
                        basename + name + "[" + j + "]");
                    if (value)
                        str.push(value);
                }
            }
            else { //single value
                value = this.cgivars(nodes[i], basename + name);
                if (value)
                    str.push(value);
            }
        }

        var attr = xml.attributes;
        for (i = 0; i < attr.length; i++) {
            if (attr[i].nodeValue) {
                if (basename) 
                    str.push(basename + "[" + attr[i].nodeName + "]="
                        + escape(attr[i].nodeValue));
                else
                    str.push(attr[i].nodeName + "="
                        + escape(attr[i].nodeValue));
            }
        }

        if (str.length)
            return str.join("&");

        value = apf.queryValue(xml, "text()");
        if (basename && value)
            return basename + "=" + escape(value);
    },

    "cgiobjects": function(xml, basename, isSub){
        if (!basename)
            basename = "";
        
        var str = [], value, nodes = xml.childNodes, done = {};
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (node.nodeType != 1)
                continue;

            var name = node.tagName; //@hack
            if (name == "revision")
                continue;

            var isOnlyChild = apf.isOnlyChild(node.firstChild, [3,4]);
            var count       = 0;

            //array
            if (!node.attributes.length && !isOnlyChild) {
                var lnodes = node.childNodes;
                for (var nm, j = 0, l = lnodes.length; j < l; j++) {
                    if (lnodes[j].nodeType != 1)
                        continue;
                    
                    nm = basename + (isSub ? "[" : "") + name + (isSub ? "]" : "") + "[" + i + "]";
                    value = this.cgiobjects(lnodes[j], nm, true);
                    if (value)
                        str.push(value);
                        
                    if (apf.isOnlyChild(lnodes[j].firstChild, [3,4]))
                        str.push(nm + "[" + lnodes[j].tagName + "]" + "=" 
                            + escape(lnodes[j].firstChild.nodeValue));
                    
                    var k, a, attr = lnodes[j].attributes;
                    for (k = 0; k < attr.length; k++) {
                        if (!(a = attr[k]).nodeValue)
                            continue;
                        
                        str.push(nm + "[" + a.nodeName + "]=" 
                            + escape(a.nodeValue));
                    }
                }
            }
            //single value
            else {
                if (isOnlyChild)
                    str.push(basename + (isSub ? "[" : "") + name + (isSub ? "]" : "") + "=" 
                        + escape(node.firstChild.nodeValue));
                
                var a, attr = node.attributes;
                for (j = 0; j < attr.length; j++) {
                    if (!(a = attr[j]).nodeValue)
                        continue;
                    
                    str.push(basename + (isSub ? "[" : "") + name + "_" + a.nodeName + (isSub ? "]" : "") + "=" 
                        + escape(a.nodeValue));
                }
            }
        }
        
        if (!isSub && xml.getAttribute("id"))
            str.push("id=" + escape(xml.getAttribute("id")));

        if (str.length)
            return str.join("&");
    }
};

/**
 * Converts xml to another format.
 *
 * @param {XMLElement} xml  the {@link term.datanode data node} to convert.
 * @param {String}     to   the format to convert the xml to.
 *   Possible values:
 *   json       converts to a json string
 *   cgivars    converts to cgi string.
 *   cgiobjects converts to cgi objects
 * @return {String} the result of the conversion.
 */
apf.convertXml = function(xml, to){
    return apf.convertMethods[to](xml);
};

/**
 * Returns the first text or cdata child of an {@link term.datanode data node}.
 *
 * @param {XMLElement} x the xml node to search.
 * @return {XMLNode} the found xml node, or null.
 */
apf.getTextNode = function(x){
    for (var i = 0; i < x.childNodes.length; i++) {
        if (x.childNodes[i].nodeType == 3 || x.childNodes[i].nodeType == 4)
            return x.childNodes[i];
    }
    return false;
};

/**
 * @private
 */
apf.getBoundValue = function(amlNode, xmlRoot, applyChanges){
    if (!xmlRoot && !amlNode.xmlRoot)
        return "";

    var xmlNode = amlNode.$getDataNode("value", amlNode.xmlRoot);

    return xmlNode ? apf.queryValue(xmlNode) : "";
};

/**
 * @private
 */
apf.getArrayFromNodelist = function(nodelist){
    for (var nodes = [], j = 0; j < nodelist.length; j++)
        nodes.push(nodelist[j]);
    return nodes;
};

apf.serializeChildren = function(xmlNode){
    var s = [], nodes = xmlNode.childNodes;
    for (var node, i = 0, l = nodes.length; i < l; i++) {
        s[i] = (node = nodes[i]).nodeType == 1 
            ? node.xml || node.serialize()
            : (node.nodeType == 8 ? "" : node.nodeValue);
    }
    return s.join("");
}

/**
 * Returns a string version of the {@link term.datanode data node}.
 *
 * @param {XMLElement} xmlNode the {@link term.datanode data node} to serialize.
 * @return {String} the serilized version of the {@link term.datanode data node}.
 */
apf.getXmlString = function(xmlNode){
    var xml = apf.xmldb.cleanNode(xmlNode.cloneNode(true));
    return xml.xml || xml.serialize();
};

/**
 * Creates xml nodes from an xml string recursively.
 *
 * @param {String}  strXml     the xml definition.
 * @param {Boolean} [noError]  whether an exception should be thrown by the parser when the xml is not valid.
 * @param {Boolean} [preserveWhiteSpace]  whether whitespace that is present between XML elements should be preserved
 * @return {XMLNode} the created xml node.
 */
apf.getXml = function(strXml, noError, preserveWhiteSpace){
    return apf.getXmlDom(strXml, noError, preserveWhiteSpace).documentElement;
};

/**
 * Formats an xml string with good indentation. Also known as pretty printing.
 * @param {String} strXml the xml to format.
 * @return {String} the formatted string.
 */
apf.formatXml = function(strXml){
    strXml = strXml.trim();

    var lines = strXml.split("\n");
    for (var i = 0; i < lines.length; i++)
        lines[i] = lines[i].trim();
    lines = lines.join("\n").replace(/\>\n/g, ">").replace(/\>/g, ">\n")
        .replace(/\n\</g, "<").replace(/\</g, "\n<").split("\n");
    lines.removeIndex(0);//test if this is actually always fine
    lines.removeIndex(lines.length);

    for (var depth = 0, i = 0; i < lines.length; i++)
        lines[i] = "    ".repeat((lines[i].match(/^\s*\<\//)
            ? (depth==0)?0:--depth
            : (lines[i].match(/^\s*\<[^\?][^>]+[^\/]\>/) ? depth++ : depth))) + lines[i];
    if (!strXml) return "";

    return lines.join("\n");
};

//@todo this function needs to be 100% proof, it's the core of the system
//for RSB: xmlNode --> Xpath statement
apf.xmlToXpath = function(xmlNode, xmlContext, useJid){
    if (!xmlNode) //@todo apf3.0
        return "";
    
    if (useJid === true && xmlNode.nodeType == 1 && xmlNode.getAttribute(apf.xmldb.xmlIdTag)) {
        return "//node()[@" + apf.xmldb.xmlIdTag + "='" 
            + xmlNode.getAttribute(apf.xmldb.xmlIdTag) + "']";
    }

    if (apf != this && this.lookup && this.select) {
        var def = this.lookup[xmlNode.tagName];
        if (def) {
            //unique should not have ' in it... -- can be fixed...
            var unique = xmlNode.selectSingleNode(def).nodeValue;
            return "//" + xmlNode.tagName + "[" + def + "='" + unique + "']";
        }
        
        for (var i = 0; i < this.select.length; i++) {
            if (xmlNode.selectSingleNode(this.select[i][0])) {
                var unique = xmlNode.selectSingleNode(this.select[i][1]).nodeValue;
                return "//" + this.select[i][0] + "[" + this.select[i][1]
                    + "='" + unique + "']";
            }
        }
    }

    if (xmlNode == xmlContext)
        return ".";

    if (!xmlNode.parentNode) {
        
        throw new Error(apf.formatErrorString(0, null, 
            "Converting XML to Xpath", 
            "Error xml node without parent and non matching context cannot\
             be converted to xml.", xmlNode));
        
        
        return false;
    }

    var str = [], lNode = xmlNode;
    if (lNode.nodeType == 2) {
        str.push("@" + lNode.nodeName);
        lNode = lNode.ownerElement || xmlNode.selectSingleNode("..");
    }
    
    var id;
    do {
        str.unshift((lNode.nodeType == 1 ? lNode.tagName : "text()") 
            + "[" + (useJid && (id = lNode.nodeType == 1 && lNode.getAttribute(apf.xmldb.xmlIdTag))
                ? "@" + apf.xmldb.xmlIdTag + "='" + id + "'"
                : (apf.getChildNumber(lNode, true) + 1))
             + "]");
        lNode = lNode.parentNode;
    } while(lNode && lNode.nodeType == 1 && lNode != xmlContext);

    return str.join("/");
};
    
//for RSB: Xpath statement --> xmlNode
apf.xpathToXml = function(xpath, xmlNode){
    if (!xmlNode) {
        
        throw new Error(apf.formatErrorString(0, null, 
            "Converting Xpath to XML", 
            "Error context xml node is empty, thus xml node cannot \
             be found for '" + xpath + "'"));
        
        
        return false;
    }
    
    return xmlNode.selectSingleNode(xpath);
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/textdiff.js)SIZE(89290)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @fileoverview Computes the difference between two texts to create a patch.
 * Applies the patch onto another text, allowing for errors.
 * @author fraser AT google DOT com (Neil Fraser)
 */

/**
 * Class containing the diff, match and patch methods.
 * @constructor
 */
apf.diff_match_patch = new (function() {

    // Defaults.
    // Redefine these in your program to override the defaults.

    // Number of seconds to map a diff before giving up (0 for infinity).
    this.diffTimeout          = 1.0;
    // Cost of an empty edit operation in terms of edit characters.
    this.diffEditCost         = 4;
    // The size beyond which the double-ended diff activates.
    // Double-ending is twice as fast, but less accurate.
    this.diffDualThreshold    = 32;
    // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
    this.matchThreshold       = 0.5;
    // How far to search for a match (0 = exact location, 1000+ = broad match).
    // A match this many characters away from the expected location will add
    // 1.0 to the score (0.0 is a perfect match).
    this.matchDistance        = 1000;
    // When deleting a large block of text (over ~64 characters), how close does
    // the contents have to match the expected contents. (0.0 = perfection,
    // 1.0 = very loose).  Note that matchThreshold controls how closely the
    // end points of a delete need to match.
    this.patchDeleteThreshold = 0.5;
    // Chunk size for context length.
    this.patchMargin          = 4;

    /**
     * The data structure representing a diff is an array of tuples:
     * [[DIFF_DELETE, "Hello"], [DIFF_INSERT, "Goodbye"], [DIFF_EQUAL, " world."]]
     * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
     */
    var DIFF_DELETE = -1,
        DIFF_INSERT = 1,
        DIFF_EQUAL  = 0,
        /*
         * Compute the number of bits in an int.
         * The normal answer for JavaScript is 32.
         * @return {number} Max bits
         */
        getMaxBits = function() {
            var maxbits = 0,
                oldi    = 1,
                newi    = 2;
            while (oldi != newi) {
                maxbits++;
                oldi = newi;
                newi = newi << 1;
            }
            return maxbits;
        },
        /**
         * Class representing one patch operation.
         * @constructor
         */
        patch_obj = function () {
            /** @type {Array.<Array.<number|string>>} */
            this.diffs   = [];
            /** @type {number?} */
            this.start1  = null;
            /** @type {number?} */
            this.start2  = null;
            /** @type {number} */
            this.length1 = 0;
            /** @type {number} */
            this.length2 = 0;
        },
        opMap = [];
    opMap[DIFF_INSERT] = "+";
    opMap[DIFF_DELETE] = "-";
    opMap[DIFF_EQUAL]  = " ";

    /**
     * Emmulate GNU diff's format.
     * Header: @@ -382,8 +481,9 @@
     * Indicies are printed as 1-based, not 0-based.
     * @return {string} The GNU diff string.
     */
    patch_obj.prototype.toString = function() {
        var coords1 = (this.length1 === 0)
                ? this.start1 + ",0"
                : (this.length1 == 1)
                    ? this.start1 + 1
                    : (this.start1 + 1) + "," + this.length1,

            coords2 = (this.length2 === 0) 
                ? this.start2 + ",0"
                : (this.length2 == 1)
                    ?  this.start2 + 1
                    :  (this.start2 + 1) + "," + this.length2,

            text = ["@@ -" + coords1 + " +" + coords2 + " @@\n"],
            x    = 0,
            l    = this.diffs.length;
        // Escape the body of the patch with %xx notation.
        for (; x < l; x++)
            text[x + 1] = opMap[this.diffs[x][0]] + encodeURI(this.diffs[x][1]) + "\n";
        // Opera doesn't know how to encode char 0.
        return text.join("").replace(/\x00/g, "%00").replace(/%20/g, " ");
    };

    // How many bits in a number?
    this.matchMaxBits = getMaxBits();


    /**
     * Find the differences between two texts.  Simplifies the problem by stripping
     * any common prefix or suffix off the texts before diffing.
     * @param {string} text1 Old string to be diffed.
     * @param {string} text2 New string to be diffed.
     * @param {boolean} opt_checklines Optional speedup flag.  If present and false,
     *     then don't run a line-level diff first to identify the changed areas.
     *     Defaults to true, which does a faster, slightly less optimal diff
     * @return {Array.<Array.<number|string>>} Array of diff tuples.
     */
    this.diff_main = function(text1, text2, opt_checklines) {
        // Check for equality (speedup)
        if (text1 == text2)
            return [[DIFF_EQUAL, text1]];

        if (typeof opt_checklines == "undefined")
            opt_checklines = true;
        
        var checklines = opt_checklines,
            // Trim off common prefix (speedup)
            commonlength = this.diff_commonPrefix(text1, text2),
            commonprefix = text1.substring(0, commonlength);

        text1 = text1.substring(commonlength);
        text2 = text2.substring(commonlength);

        // Trim off common suffix (speedup)
        commonlength = this.diff_commonSuffix(text1, text2);
        var commonsuffix = text1.substring(text1.length - commonlength);
        text1 = text1.substring(0, text1.length - commonlength);
        text2 = text2.substring(0, text2.length - commonlength);

        // Compute the diff on the middle block
        var diffs = diff_compute.call(this, text1, text2, checklines);

        // Restore the prefix and suffix
        if (commonprefix)
            diffs.unshift([DIFF_EQUAL, commonprefix]);
        if (commonsuffix)
            diffs.push([DIFF_EQUAL, commonsuffix]);
        this.diff_cleanupMerge(diffs);
        return diffs;
    };


    /**
     * Find the differences between two texts.  Assumes that the texts do not
     * have any common prefix or suffix.
     * @param {string} text1 Old string to be diffed.
     * @param {string} text2 New string to be diffed.
     * @param {boolean} checklines Speedup flag.  If false, then don't run a
     *     line-level diff first to identify the changed areas.
     *     If true, then run a faster, slightly less optimal diff
     * @return {Array.<Array.<number|string>>} Array of diff tuples.
     * @private
     */
    var diff_compute = function(text1, text2, checklines) {
        var diffs;

        if (!text1) // Just add some text (speedup)
            return [[DIFF_INSERT, text2]];

        if (!text2) // Just delete some text (speedup)
            return [[DIFF_DELETE, text1]];

        var longtext  = text1.length > text2.length ? text1 : text2,
            shorttext = text1.length > text2.length ? text2 : text1,
            i         = longtext.indexOf(shorttext);
        if (i != -1) {
            // Shorter text is inside the longer text (speedup)
            diffs = [[DIFF_INSERT, longtext.substring(0, i)],
                     [DIFF_EQUAL,  shorttext],
                     [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
            // Swap insertions for deletions if diff is reversed.
            if (text1.length > text2.length)
                diffs[0][0] = diffs[2][0] = DIFF_DELETE;
            return diffs;
        }
        longtext = shorttext = null;  // Garbage collect

        // Check to see if the problem can be split in two.
        var a, linearray,
            hm = this.diff_halfMatch(text1, text2);
        if (hm) {
            // A half-match was found, sort out the return data.
            //text1_a    = hm[0],
            //text1_b    = hm[1],
            //text2_a    = hm[2],
            //text2_b    = hm[3],
            //mid_common = hm[4],
            // Send both pairs off for separate processing.
            //var diffs_a = this.diff_main(hm[0], hm[2], checklines),
            //    diffs_b = this.diff_main(hm[1], hm[3], checklines);
            // Merge the results.
            return this.diff_main(hm[0], hm[2], checklines)
                .concat([[DIFF_EQUAL, hm[4]]], this.diff_main(hm[1], hm[3], checklines));
        }

        // Perform a real diff.
        if (checklines && (text1.length < 100 || text2.length < 100)) // Too trivial for the overhead.
            checklines = false;

        if (checklines) {
            // Scan the text on a line-by-line basis first.
            a         = this.diff_linesToChars(text1, text2);
            text1     = a[0];
            text2     = a[1];
            linearray = a[2];
        }
        diffs = this.diff_map(text1, text2);
        if (!diffs) // No acceptable result.
            diffs = [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
        if (checklines) {
            // Convert the diff back to original text.
            this.diff_charsToLines(diffs, linearray);
            // Eliminate freak matches (e.g. blank lines)
            this.diff_cleanupSemantic(diffs);

            // Rediff any replacement blocks, this time character-by-character.
            // Add a dummy entry at the end.
            diffs.push([DIFF_EQUAL, ""]);
            var pointer      = 0,
                count_delete = 0,
                count_insert = 0,
                text_delete  = "",
                text_insert  = "";
            while (pointer < diffs.length) {
                switch (diffs[pointer][0]) {
                    case DIFF_INSERT:
                        count_insert++;
                        text_insert += diffs[pointer][1];
                        break;
                    case DIFF_DELETE:
                        count_delete++;
                        text_delete += diffs[pointer][1];
                        break;
                    case DIFF_EQUAL:
                        // Upon reaching an equality, check for prior redundancies.
                        if (count_delete >= 1 && count_insert >= 1) {
                            // Delete the offending records and add the merged ones.
                            a = this.diff_main(text_delete, text_insert, false);
                            diffs.splice(pointer - count_delete - count_insert,
                            count_delete + count_insert);
                            pointer = pointer - count_delete - count_insert;
                            for (var j = a.length - 1; j >= 0; j--) {
                                diffs.splice(pointer, 0, a[j]);
                            }
                            pointer = pointer + a.length;
                        }
                        count_insert = 0;
                        count_delete = 0;
                        text_delete = "";
                        text_insert = "";
                        break;
                }
                pointer++;
            }
            diffs.pop();  // Remove the dummy entry at the end.
        }
        return diffs;
    };

    /**
     * Split two texts into an array of strings.  Reduce the texts to a string of
     * hashes where each Unicode character represents one line.
     * @param {string} text1 First string.
     * @param {string} text2 Second string.
     * @return {Array.<string|Array.<string>>} Three element Array, containing the
     *     encoded text1, the encoded text2 and the array of unique strings.  The
     *     zeroth element of the array of unique strings is intentionally blank.
     * @private
     */
    this.diff_linesToChars = function(text1, text2) {
        // '\x00' is a valid character, but various debuggers don't like it.
        // So we'll insert a junk entry to avoid generating a null character.
        var lineArray = [""], // e.g. lineArray[4] == "Hello\n"
            lineHash  = {};   // e.g. lineHash["Hello\n"] == 4
        
        /**
         * Split a text into an array of strings.  Reduce the texts to a string of
         * hashes where each Unicode character represents one line.
         * Modifies linearray and linehash through being a closure.
         * @param {string} text String to encode
         * @return {string} Encoded string
         * @private
         */
        function diff_linesToCharsMunge(text) {
            var chars           = "",
                // Walk the text, pulling out a substring for each line.
                // text.split("\n") would would temporarily double our memory footprint.
                // Modifying text would create many large strings to garbage collect.
                lineStart       = 0,
                lineEnd         = -1,
                // Keeping our own length variable is faster than looking it up.
                lineArrayLength = lineArray.length;
            while (lineEnd < text.length - 1) {
                lineEnd = text.indexOf("\n", lineStart);
                if (lineEnd == -1)
                    lineEnd = text.length - 1;
                var line  = text.substring(lineStart, lineEnd + 1);
                lineStart = lineEnd + 1;

                if (lineHash.hasOwnProperty
                  ? lineHash.hasOwnProperty(line)
                  : (lineHash[line] !== undefined)) {
                    chars += String.fromCharCode(lineHash[line]);
                }
                else {
                    chars += String.fromCharCode(lineArrayLength);
                    lineHash[line] = lineArrayLength;
                    lineArray[lineArrayLength++] = line;
                }
            }
            return chars;
        }

        return [diff_linesToCharsMunge(text1), diff_linesToCharsMunge(text2),
            lineArray];
    };

    /**
     * Rehydrate the text in a diff from a string of line hashes to real lines of
     * text.
     * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
     * @param {Array.<string>} lineArray Array of unique strings.
     * @private
     */
    this.diff_charsToLines = function(diffs, lineArray) {
        var x = 0,
            chars, text, y;
        for (; x < diffs.length; x++) {
            chars = diffs[x][1];
            text  = [];
            for (y = 0; y < chars.length; y++)
                text[y] = lineArray[chars.charCodeAt(y)];
            diffs[x][1] = text.join("");
        }
    };

    /**
     * Explore the intersection points between the two texts.
     * @param {string} text1 Old string to be diffed.
     * @param {string} text2 New string to be diffed.
     * @return {Array.<Array.<number|string>>?} Array of diff tuples or null if no
     *     diff available.
     * @private
     */
    this.diff_map = function(text1, text2) {
        // Don't run for too long.
        var ms_end         = (new Date()).getTime() + this.diffTimeout * 1000,
            // Cache the text lengths to prevent multiple calls.
            text1_length   = text1.length,
            text2_length   = text2.length,
            d              = 0,
            max_d          = text1_length + text2_length - 1,
            doubleEnd      = this.diffDualThreshold * 2 < max_d,
            v_map1         = [],
            v_map2         = [],
            v1             = {},
            v2             = {},
            footsteps      = {},
            done           = false,
            // Safari 1.x doesn't have hasOwnProperty
            hasOwnProperty = !!(footsteps.hasOwnProperty),
            // If the total number of characters is odd, then the front path will collide
            // with the reverse path.
            front          = (text1_length + text2_length) % 2,
            x, y, k, a, footstep;  // Used to track overlapping paths.
        v1[1] = 0;
        v2[1] = 0;
        for (; d < max_d; d++) {
            // Bail out if timeout reached.
            if (this.diffTimeout > 0 && (new Date()).getTime() > ms_end)
                return null;

            // Walk the front path one step.
            v_map1[d] = {};
            for (k = -d; k <= d; k += 2) {
                if (k == -d || k != d && v1[k - 1] < v1[k + 1])
                    x = v1[k + 1];
                else
                    x = v1[k - 1] + 1;
                y = x - k;
                if (doubleEnd) {
                    footstep = x + "," + y;
                    if (front && (hasOwnProperty
                      ? footsteps.hasOwnProperty(footstep)
                      : (footsteps[footstep] !== undefined))) {
                        done = true;
                    }
                    if (!front)
                        footsteps[footstep] = d;
                }
                while (!done && x < text1_length && y < text2_length &&
                  text1.charAt(x) == text2.charAt(y)) {
                    x++;
                    y++;
                    if (doubleEnd) {
                        footstep = x + "," + y;
                        if (front && (hasOwnProperty
                          ? footsteps.hasOwnProperty(footstep)
                          : (footsteps[footstep] !== undefined))) {
                            done = true;
                        }
                        if (!front)
                            footsteps[footstep] = d;
                    }
                }
                v1[k] = x;
                v_map1[d][x + "," + y] = true;
                if (x == text1_length && y == text2_length) {
                    // Reached the end in single-path mode.
                    return this.diff_path1(v_map1, text1, text2);
                }
                else if (done) {
                    // Front path ran over reverse path.
                    v_map2 = v_map2.slice(0, footsteps[footstep] + 1);
                    a      = this.diff_path1(v_map1, text1.substring(0, x),
                    text2.substring(0, y));
                    return a.concat(this.diff_path2(v_map2, text1.substring(x),
                        text2.substring(y)));
                }
            }

            if (doubleEnd) {
                // Walk the reverse path one step.
                v_map2[d] = {};
                for (k = -d; k <= d; k += 2) {
                    x = (k == -d || k != d && v2[k - 1] < v2[k + 1])
                        ? v2[k + 1]
                        : v2[k - 1] + 1;
                    y = x - k;
                    footstep = (text1_length - x) + "," + (text2_length - y);
                    if (!front && (hasOwnProperty
                      ? footsteps.hasOwnProperty(footstep)
                      : (footsteps[footstep] !== undefined))) {
                        done = true;
                    }
                    if (front)
                        footsteps[footstep] = d;
                    while (!done && x < text1_length && y < text2_length
                      && text1.charAt(text1_length - x - 1) == text2.charAt(text2_length - y - 1)) {
                        x++;
                        y++;
                        footstep = (text1_length - x) + "," + (text2_length - y);
                        if (!front && (hasOwnProperty
                          ? footsteps.hasOwnProperty(footstep)
                          : (footsteps[footstep] !== undefined))) {
                            done = true;
                        }
                        if (front)
                            footsteps[footstep] = d;
                    }
                    v2[k] = x;
                    v_map2[d][x + "," + y] = true;
                    if (done) {
                        // Reverse path ran over front path.
                        v_map1 = v_map1.slice(0, footsteps[footstep] + 1);
                        a      = this.diff_path1(v_map1, text1.substring(0, text1_length - x),
                        text2.substring(0, text2_length - y));
                        return a.concat(this.diff_path2(v_map2,
                            text1.substring(text1_length - x),
                            text2.substring(text2_length - y)));
                    }
                }
            }
        }
        // Number of diffs equals number of characters, no commonality at all.
        return null;
    };

    /**
     * Work from the middle back to the start to determine the path.
     * @param {Array.<Object>} v_map Array of paths.
     * @param {string} text1 Old string fragment to be diffed.
     * @param {string} text2 New string fragment to be diffed.
     * @return {Array.<Array.<number|string>>} Array of diff tuples.
     * @private
     */
    this.diff_path1 = function(v_map, text1, text2) {
        var path    = [],
            x       = text1.length,
            y       = text2.length,
            /** @type {number?} */
            last_op = null,
            d       = v_map.length - 2;
        for (; d >= 0; d--) {
            while (1) {
                if (v_map[d].hasOwnProperty
                  ? v_map[d].hasOwnProperty((x - 1) + "," + y)
                  : (v_map[d][(x - 1) + "," + y] !== undefined)) {
                    x--;
                    if (last_op === DIFF_DELETE)
                        path[0][1] = text1.charAt(x) + path[0][1];
                    else
                        path.unshift([DIFF_DELETE, text1.charAt(x)]);
                    last_op = DIFF_DELETE;
                    break;
                }
                else if (v_map[d].hasOwnProperty 
                  ? v_map[d].hasOwnProperty(x + "," + (y - 1))
                  : (v_map[d][x + "," + (y - 1)] !== undefined)) {
                    y--;
                    if (last_op === DIFF_INSERT)
                        path[0][1] = text2.charAt(y) + path[0][1];
                    else
                        path.unshift([DIFF_INSERT, text2.charAt(y)]);
                    last_op = DIFF_INSERT;
                    break;
                }
                else {
                    x--;
                    y--;
                    //if (text1.charAt(x) != text2.charAt(y)) {
                    //    throw new Error("No diagonal.  Can't happen. (diff_path1)");
                    //}
                    if (last_op === DIFF_EQUAL)
                        path[0][1] = text1.charAt(x) + path[0][1];
                    else
                        path.unshift([DIFF_EQUAL, text1.charAt(x)]);
                    last_op = DIFF_EQUAL;
                }
            }
        }
        return path;
    };

    /**
     * Work from the middle back to the end to determine the path.
     * @param {Array.<Object>} v_map Array of paths.
     * @param {string} text1 Old string fragment to be diffed.
     * @param {string} text2 New string fragment to be diffed.
     * @return {Array.<Array.<number|string>>} Array of diff tuples.
     * @private
     */
    this.diff_path2 = function(v_map, text1, text2) {
        var path       = [],
            pathLength = 0,
            x          = text1.length,
            y          = text2.length,
            /** @type {number?} */
            last_op    = null,
            d          = v_map.length - 2;
        for (; d >= 0; d--) {
            while (1) {
                if (v_map[d].hasOwnProperty
                  ? v_map[d].hasOwnProperty((x - 1) + "," + y)
                  : (v_map[d][(x - 1) + "," + y] !== undefined)) {
                    x--;
                    if (last_op === DIFF_DELETE) {
                        path[pathLength - 1][1] += text1.charAt(text1.length - x - 1);
                    }
                    else {
                        path[pathLength++] =
                            [DIFF_DELETE, text1.charAt(text1.length - x - 1)];
                    }
                    last_op = DIFF_DELETE;
                    break;
                }
                else if (v_map[d].hasOwnProperty 
                  ? v_map[d].hasOwnProperty(x + "," + (y - 1))
                  : (v_map[d][x + "," + (y - 1)] !== undefined)) {
                    y--;
                    if (last_op === DIFF_INSERT) {
                        path[pathLength - 1][1] += text2.charAt(text2.length - y - 1);
                    }
                    else {
                        path[pathLength++] =
                            [DIFF_INSERT, text2.charAt(text2.length - y - 1)];
                    }
                    last_op = DIFF_INSERT;
                    break;
                }
                else {
                    x--;
                    y--;
                    //if (text1.charAt(text1.length - x - 1) !=
                    //    text2.charAt(text2.length - y - 1)) {
                    //  throw new Error("No diagonal.  Can't happen. (diff_path2)");
                    //}
                    if (last_op === DIFF_EQUAL) {
                        path[pathLength - 1][1] += text1.charAt(text1.length - x - 1);
                    }
                    else {
                        path[pathLength++] =
                            [DIFF_EQUAL, text1.charAt(text1.length - x - 1)];
                    }
                    last_op = DIFF_EQUAL;
                }
            }
        }
        return path;
    };

    /**
     * Determine the common prefix of two strings
     * @param {string} text1 First string.
     * @param {string} text2 Second string.
     * @return {number} The number of characters common to the start of each
     *     string.
     */
    this.diff_commonPrefix = function(text1, text2) {
        // Quick check for common null cases.
        if (!text1 || !text2 || text1.charCodeAt(0) !== text2.charCodeAt(0))
            return 0;
        // Binary search.
        // Performance analysis: http://neil.fraser.name/news/2007/10/09/
        var pointermin   = 0,
            pointermax   = Math.min(text1.length, text2.length),
            pointermid   = pointermax,
            pointerstart = 0;
        while (pointermin < pointermid) {
            if (text1.substring(pointerstart, pointermid)
              == text2.substring(pointerstart, pointermid)) {
                pointermin   = pointermid;
                pointerstart = pointermin;
            }
            else {
                pointermax = pointermid;
            }
            pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
        }
        return pointermid;
    };

    /**
     * Determine the common suffix of two strings
     * @param {string} text1 First string.
     * @param {string} text2 Second string.
     * @return {number} The number of characters common to the end of each string.
     */
    this.diff_commonSuffix = function(text1, text2) {
        // Quick check for common null cases.
        if (!text1 || !text2 || text1.charCodeAt(text1.length - 1)
          !== text2.charCodeAt(text2.length - 1)) {
            return 0;
        }
        // Binary search.
        // Performance analysis: http://neil.fraser.name/news/2007/10/09/
        var pointermin = 0,
            pointermax = Math.min(text1.length, text2.length),
            pointermid = pointermax,
            pointerend = 0;
        while (pointermin < pointermid) {
            if (text1.substring(text1.length - pointermid, text1.length - pointerend)
              == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
                pointermin = pointermid;
                pointerend = pointermin;
            }
            else {
                pointermax = pointermid;
            }
            pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
        }
        return pointermid;
    };

    /**
     * Do the two texts share a substring which is at least half the length of the
     * longer text?
     * @param {string} text1 First string.
     * @param {string} text2 Second string.
     * @return {Array.<string>?} Five element Array, containing the prefix of
     *     text1, the suffix of text1, the prefix of text2, the suffix of
     *     text2 and the common middle.  Or null if there was no match.
     */
    this.diff_halfMatch = function(text1, text2) {
        var longtext  = text1.length > text2.length ? text1 : text2,
            shorttext = text1.length > text2.length ? text2 : text1,
            _self     = this;
        if (longtext.length < 10 || shorttext.length < 1)
            return null;  // Pointless.

        /**
         * Does a substring of shorttext exist within longtext such that the substring
         * is at least half the length of longtext?
         * Closure, but does not reference any external variables.
         * @param {string} longtext Longer string.
         * @param {string} shorttext Shorter string.
         * @param {number} i Start index of quarter length substring within longtext
         * @return {Array.<string>?} Five element Array, containing the prefix of
         *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
         *     of shorttext and the common middle.  Or null if there was no match.
         * @private
         */
        function diff_halfMatchI(longtext, shorttext, i) {
            // Start with a 1/4 length substring at position i as a seed.
            var seed        = longtext.substring(i, i + Math.floor(longtext.length / 4)),
                j           = -1,
                best_common = "",
                best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b,
                prefixLength, suffixLength;
            while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
                prefixLength = _self.diff_commonPrefix(longtext.substring(i),
                    shorttext.substring(j));
                suffixLength = _self.diff_commonSuffix(longtext.substring(0, i),
                    shorttext.substring(0, j));
                if (best_common.length < suffixLength + prefixLength) {
                    best_common = shorttext.substring(j - suffixLength, j) 
                                + shorttext.substring(j, j + prefixLength);
                    best_longtext_a  = longtext.substring(0, i - suffixLength);
                    best_longtext_b  = longtext.substring(i + prefixLength);
                    best_shorttext_a = shorttext.substring(0, j - suffixLength);
                    best_shorttext_b = shorttext.substring(j + prefixLength);
                }
            }
            if (best_common.length >= longtext.length / 2) {
                return [best_longtext_a, best_longtext_b, best_shorttext_a,
                        best_shorttext_b, best_common];
            }
            else {
                return null;
            }
        }

        // First check if the second quarter is the seed for a half-match.
        var hm1 = diff_halfMatchI(longtext, shorttext, Math.ceil(longtext.length / 4)),
            // Check again based on the third quarter.
            hm2 = diff_halfMatchI(longtext, shorttext, Math.ceil(longtext.length / 2)),
            hm;
        if (!hm1 && !hm2)
            return null;
        else if (!hm2)
            hm = hm1;
        else if (!hm1)
            hm = hm2;
        else // Both matched.  Select the longest.
            hm = hm1[4].length > hm2[4].length ? hm1 : hm2;

        // A half-match was found, sort out the return data.
        var text1_a, text1_b, text2_a, text2_b;
        if (text1.length > text2.length) {
            text1_a = hm[0];
            text1_b = hm[1];
            text2_a = hm[2];
            text2_b = hm[3];
        }
        else {
            text2_a = hm[0];
            text2_b = hm[1];
            text1_a = hm[2];
            text1_b = hm[3];
        }
        //var mid_common = hm[4];
        return [text1_a, text1_b, text2_a, text2_b, hm[4]];
    };

    /**
     * Reduce the number of edits by eliminating semantically trivial equalities.
     * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
     */
    this.diff_cleanupSemantic = function(diffs) {
        var changes          = false,
            equalities       = [],   // Stack of indices where equalities are found.
            equalitiesLength = 0,    // Keeping our own length var is faster in JS.
            lastequality     = null, // Always equal to equalities[equalitiesLength-1][1]
            pointer          = 0,    // Index of current position.
            // Number of characters that changed prior to the equality.
            length_changes1  = 0,
            // Number of characters that changed after the equality.
            length_changes2  = 0;
        while (pointer < diffs.length) {
            if (diffs[pointer][0] == DIFF_EQUAL) {  // equality found
                equalities[equalitiesLength++] = pointer;
                length_changes1 = length_changes2;
                length_changes2 = 0;
                lastequality    = diffs[pointer][1];
            }
            else {  // an insertion or deletion
                length_changes2 += diffs[pointer][1].length;
                if (lastequality !== null && (lastequality.length <= length_changes1)
                  && (lastequality.length <= length_changes2)) {
                    // Duplicate record
                    diffs.splice(equalities[equalitiesLength - 1], 0,
                        [DIFF_DELETE, lastequality]);
                    // Change second copy to insert.
                    diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
                    // Throw away the equality we just deleted.
                    equalitiesLength--;
                    // Throw away the previous equality (it needs to be reevaluated).
                    equalitiesLength--;
                    pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
                    length_changes1 = 0;  // Reset the counters.
                    length_changes2 = 0;
                    lastequality    = null;
                    changes         = true;
                }
            }
            pointer++;
        }
        if (changes)
            this.diff_cleanupMerge(diffs);
        this.diff_cleanupSemanticLossless(diffs);
    };

    /**
     * Look for single edits surrounded on both sides by equalities
     * which can be shifted sideways to align the edit to a word boundary.
     * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
     * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
     */
    this.diff_cleanupSemanticLossless = function(diffs) {
        // Define some regex patterns for matching boundaries.
        var punctuation    = /[^a-zA-Z0-9]/,
            whitespace     = /\s/,
            linebreak      = /[\r\n]/,
            blanklineEnd   = /\n\r?\n$/,
            blanklineStart = /^\r?\n\r?\n/;

        /**
         * Given two strings, compute a score representing whether the internal
         * boundary falls on logical boundaries.
         * Scores range from 5 (best) to 0 (worst).
         * Closure, makes reference to regex patterns defined above.
         * @param {string} one First string
         * @param {string} two Second string
         * @return {number} The score.
         */
        function diff_cleanupSemanticScore(one, two) {
            if (!one || !two) // Edges are the best.
                return 5;

            // Each port of this function behaves slightly differently due to
            // subtle differences in each language's definition of things like
            // 'whitespace'.  Since this function's purpose is largely cosmetic,
            // the choice has been made to use each language's native features
            // rather than force total conformity.
            var score = 0;
            // One point for non-alphanumeric.
            if (one.charAt(one.length - 1).match(punctuation) 
              || two.charAt(0).match(punctuation)) {
                score++;
                // Two points for whitespace.
                if (one.charAt(one.length - 1).match(whitespace)
                  || two.charAt(0).match(whitespace)) {
                    score++;
                    // Three points for line breaks.
                    if (one.charAt(one.length - 1).match(linebreak)
                      || two.charAt(0).match(linebreak)) {
                        score++;
                        // Four points for blank lines.
                        if (one.match(blanklineEnd) || two.match(blanklineStart))
                            score++;
                    }
                }
            }
            return score;
        }

        var pointer = 1,
            equality1, edit, equality2, commonOffset, commonString, bestEquality1,
            bestEdit, bestEquality2, bestScore, score;
        // Intentionally ignore the first and last element (don't need checking).
        while (pointer < diffs.length - 1) {
            if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
                // This is a single edit surrounded by equalities.
                equality1 = diffs[pointer - 1][1];
                edit      = diffs[pointer][1];
                equality2 = diffs[pointer + 1][1];

                // First, shift the edit as far left as possible.
                commonOffset = this.diff_commonSuffix(equality1, edit);
                if (commonOffset) {
                    commonString = edit.substring(edit.length - commonOffset);
                    equality1    = equality1.substring(0, equality1.length - commonOffset);
                    edit         = commonString + edit.substring(0, edit.length - commonOffset);
                    equality2    = commonString + equality2;
                }

                // Second, step character by character right, looking for the best fit.
                bestEquality1 = equality1;
                bestEdit      = edit;
                bestEquality2 = equality2;
                bestScore     = diff_cleanupSemanticScore(equality1, edit) +
                    diff_cleanupSemanticScore(edit, equality2);
                while (edit.charAt(0) === equality2.charAt(0)) {
                    equality1 += edit.charAt(0);
                    edit = edit.substring(1) + equality2.charAt(0);
                    equality2 = equality2.substring(1);
                    score = diff_cleanupSemanticScore(equality1, edit) +
                    diff_cleanupSemanticScore(edit, equality2);
                    // The >= encourages trailing rather than leading whitespace on edits.
                    if (score >= bestScore) {
                        bestScore = score;
                        bestEquality1 = equality1;
                        bestEdit = edit;
                        bestEquality2 = equality2;
                    }
                }

                if (diffs[pointer - 1][1] != bestEquality1) {
                    // We have an improvement, save it back to the diff.
                    if (bestEquality1) {
                        diffs[pointer - 1][1] = bestEquality1;
                    }
                    else {
                        diffs.splice(pointer - 1, 1);
                        pointer--;
                    }
                    diffs[pointer][1] = bestEdit;
                    if (bestEquality2) {
                        diffs[pointer + 1][1] = bestEquality2;
                    }
                    else {
                        diffs.splice(pointer + 1, 1);
                        pointer--;
                    }
                }
            }
            pointer++;
        }
    };

    /**
     * Reduce the number of edits by eliminating operationally trivial equalities.
     * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
     */
    this.diff_cleanupEfficiency = function(diffs) {
        var changes          = false,
            equalities       = [], // Stack of indices where equalities are found.
            equalitiesLength = 0,  // Keeping our own length var is faster in JS.
            lastequality     = "", // Always equal to equalities[equalitiesLength-1][1]
            pointer          = 0,  // Index of current position.
            // Is there an insertion operation before the last equality.
            pre_ins          = false,
            // Is there a deletion operation before the last equality.
            pre_del          = false,
            // Is there an insertion operation after the last equality.
            post_ins         = false,
            // Is there a deletion operation after the last equality.
            post_del         = false;
        while (pointer < diffs.length) {
            if (diffs[pointer][0] == DIFF_EQUAL) {  // equality found
                if (diffs[pointer][1].length < this.diffEditCost
                  && (post_ins || post_del)) {
                    // Candidate found.
                    equalities[equalitiesLength++] = pointer;
                    pre_ins = post_ins;
                    pre_del = post_del;
                    lastequality = diffs[pointer][1];
                }
                else {
                    // Not a candidate, and can never become one.
                    equalitiesLength = 0;
                    lastequality     = "";
                }
                post_ins = post_del = false;
            }
            else {  // an insertion or deletion
                if (diffs[pointer][0] == DIFF_DELETE)
                    post_del = true;
                else
                    post_ins = true;
                /*
                 * Five types to be split:
                 * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
                 * <ins>A</ins>X<ins>C</ins><del>D</del>
                 * <ins>A</ins><del>B</del>X<ins>C</ins>
                 * <ins>A</del>X<ins>C</ins><del>D</del>
                 * <ins>A</ins><del>B</del>X<del>C</del>
                 */
                if (lastequality && ((pre_ins && pre_del && post_ins && post_del) 
                  || ((lastequality.length < this.diffEditCost / 2)
                  && (pre_ins + pre_del + post_ins + post_del) == 3))) {
                    // Duplicate record
                    diffs.splice(equalities[equalitiesLength - 1], 0,
                        [DIFF_DELETE, lastequality]);
                    // Change second copy to insert.
                    diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
                    equalitiesLength--;  // Throw away the equality we just deleted;
                    lastequality = "";
                    if (pre_ins && pre_del) {
                        // No changes made which could affect previous entry, keep going.
                        post_ins = post_del = true;
                        equalitiesLength = 0;
                    }
                    else {
                        equalitiesLength--;  // Throw away the previous equality;
                        pointer = equalitiesLength > 0 
                            ? equalities[equalitiesLength - 1]
                            : -1;
                        post_ins = post_del = false;
                    }
                    changes = true;
                }
            }
            pointer++;
        }

        if (changes)
            this.diff_cleanupMerge(diffs);
    };

    /**
     * Reorder and merge like edit sections.  Merge equalities.
     * Any edit section can move as long as it doesn't cross an equality.
     * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
     */
    this.diff_cleanupMerge = function(diffs) {
        diffs.push([DIFF_EQUAL, ""]);  // Add a dummy entry at the end.
        var pointer      = 0,
            count_delete = 0,
            count_insert = 0,
            text_delete  = "",
            text_insert  = "",
            commonlength;
        while (pointer < diffs.length) {
            switch (diffs[pointer][0]) {
                case DIFF_INSERT:
                    count_insert++;
                    text_insert += diffs[pointer][1];
                    pointer++;
                    break;
                case DIFF_DELETE:
                    count_delete++;
                    text_delete += diffs[pointer][1];
                    pointer++;
                    break;
                case DIFF_EQUAL:
                    // Upon reaching an equality, check for prior redundancies.
                    if (count_delete !== 0 || count_insert !== 0) {
                        if (count_delete !== 0 && count_insert !== 0) {
                            // Factor out any common prefixies.
                            commonlength = this.diff_commonPrefix(text_insert, text_delete);
                            if (commonlength !== 0) {
                                if ((pointer - count_delete - count_insert) > 0 
                                  && diffs[pointer - count_delete - count_insert - 1][0]
                                  == DIFF_EQUAL) {
                                    diffs[pointer - count_delete - count_insert - 1][1] +=
                                    text_insert.substring(0, commonlength);
                                }
                                else {
                                    diffs.splice(0, 0, [DIFF_EQUAL,
                                    text_insert.substring(0, commonlength)]);
                                    pointer++;
                                }
                                text_insert = text_insert.substring(commonlength);
                                text_delete = text_delete.substring(commonlength);
                            }
                            // Factor out any common suffixies.
                            commonlength = this.diff_commonSuffix(text_insert, text_delete);
                            if (commonlength !== 0) {
                                diffs[pointer][1] = text_insert.substring(text_insert.length 
                                    - commonlength) + diffs[pointer][1];
                                text_insert = text_insert.substring(0, text_insert.length 
                                    - commonlength);
                                text_delete = text_delete.substring(0, text_delete.length 
                                    - commonlength);
                            }
                        }
                        // Delete the offending records and add the merged ones.
                        if (count_delete === 0) {
                            diffs.splice(pointer - count_delete - count_insert,
                                count_delete + count_insert, [DIFF_INSERT, text_insert]);
                        }
                        else if (count_insert === 0) {
                            diffs.splice(pointer - count_delete - count_insert,
                                count_delete + count_insert, [DIFF_DELETE, text_delete]);
                        }
                        else {
                            diffs.splice(pointer - count_delete - count_insert,
                                count_delete + count_insert, [DIFF_DELETE, text_delete],
                                [DIFF_INSERT, text_insert]);
                        }
                        pointer = pointer - count_delete - count_insert 
                            + (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
                    }
                    else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
                        // Merge this equality with the previous one.
                        diffs[pointer - 1][1] += diffs[pointer][1];
                        diffs.splice(pointer, 1);
                    }
                    else {
                        pointer++;
                    }
                    count_insert = 0;
                    count_delete = 0;
                    text_delete  = "";
                    text_insert  = "";
                    break;
            }
        }
        if (diffs[diffs.length - 1][1] === "")
            diffs.pop();  // Remove the dummy entry at the end.

        // Second pass: look for single edits surrounded on both sides by equalities
        // which can be shifted sideways to eliminate an equality.
        // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
        var changes = false;
        pointer = 1;
        // Intentionally ignore the first and last element (don't need checking).
        while (pointer < diffs.length - 1) {
            if (diffs[pointer - 1][0] == DIFF_EQUAL
              && diffs[pointer + 1][0] == DIFF_EQUAL) {
                // This is a single edit surrounded by equalities.
                if (diffs[pointer][1].substring(diffs[pointer][1].length
                  - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
                    // Shift the edit over the previous equality.
                    diffs[pointer][1] = diffs[pointer - 1][1] 
                        + diffs[pointer][1].substring(0, diffs[pointer][1].length
                        - diffs[pointer - 1][1].length);
                    diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
                    diffs.splice(pointer - 1, 1);
                    changes = true;
                }
                else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length)
                  == diffs[pointer + 1][1]) {
                    // Shift the edit over the next equality.
                    diffs[pointer - 1][1] += diffs[pointer + 1][1];
                    diffs[pointer][1] = diffs[pointer][1]
                        .substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
                    diffs.splice(pointer + 1, 1);
                    changes = true;
                }
            }
            pointer++;
        }
        // If shifts were made, the diff needs reordering and another shift sweep.
        if (changes)
            this.diff_cleanupMerge(diffs);
    };

    /**
     * loc is a location in text1, compute and return the equivalent location in
     * text2.
     * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
     * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
     * @param {number} loc Location within text1.
     * @return {number} Location within text2.
     */
    this.diff_xIndex = function(diffs, loc) {
        var chars1      = 0,
            chars2      = 0,
            last_chars1 = 0,
            last_chars2 = 0,
            x           = 0,
            l           = diffs.length;
        for (; x < l; x++) {
            if (diffs[x][0] !== DIFF_INSERT)  // Equality or deletion.
                chars1 += diffs[x][1].length;
            if (diffs[x][0] !== DIFF_DELETE)  // Equality or insertion.
                chars2 += diffs[x][1].length;
            if (chars1 > loc)  // Overshot the location.
                break;
            last_chars1 = chars1;
            last_chars2 = chars2;
        }
        // Was the location was deleted?
        if (diffs.length != x && diffs[x][0] === DIFF_DELETE)
            return last_chars2;
        // Add the remaining character length.
        return last_chars2 + (loc - last_chars1);
    };

    /**
     * Convert a diff array into a pretty HTML report.
     * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
     * @return {string} HTML representation.
     */
    this.diff_prettyHtml = function(diffs) {
        var html = [],
            i    = 0,
            x    = 0,
            l    = diffs.length,
            op, data, text;
        for (; x < l; x++) {
            op   = diffs[x][0];  // Operation (insert, delete, equal)
            data = diffs[x][1];  // Text of change.
            text = data.replace(/&/g, "&amp;").replace(/</g, "&lt;")
                       .replace(/>/g, "&gt;").replace(/\n/g, "&para;<BR>");
            switch (op) {
                case DIFF_INSERT:
                    html[x] = "<INS STYLE=\"background:#E6FFE6;\" TITLE=\"i=" + i
                            + "\">" + text + "</INS>";
                    break;
                case DIFF_DELETE:
                    html[x] = "<DEL STYLE=\"background:#FFE6E6;\" TITLE=\"i=" + i
                            + "\">" + text + "</DEL>";
                    break;
                case DIFF_EQUAL:
                    html[x] = "<SPAN TITLE=\"i=" + i + "\">" + text + "</SPAN>";
                    break;
            }
            if (op !== DIFF_DELETE)
                i += data.length;
        }
        return html.join("");
    };

    /**
     * Compute and return the source text (all equalities and deletions).
     * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
     * @return {string} Source text.
     */
    this.diff_text1 = function(diffs) {
        var text = [],
            x    = 0,
            l    = diffs.length;
        for (; x < l; x++) {
            if (diffs[x][0] !== DIFF_INSERT)
                text[x] = diffs[x][1];
        }
        return text.join("");
    };

    /**
     * Compute and return the destination text (all equalities and insertions).
     * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
     * @return {string} Destination text.
     */
    this.diff_text2 = function(diffs) {
        var text = [],
            x    = 0,
            l    = diffs.length;
        for (; x < l; x++) {
            if (diffs[x][0] !== DIFF_DELETE)
                text[x] = diffs[x][1];
        }
        return text.join("");
    };

    /**
     * Compute the Levenshtein distance; the number of inserted, deleted or
     * substituted characters.
     * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
     * @return {number} Number of changes.
     */
    this.diff_levenshtein = function(diffs) {
        var levenshtein = 0,
            insertions  = 0,
            deletions   = 0,
            x           = 0,
            l           = diffs.length,
            op, data;
        for (; x < l; x++) {
            op   = diffs[x][0];
            data = diffs[x][1];
            switch (op) {
                case DIFF_INSERT:
                    insertions += data.length;
                    break;
                case DIFF_DELETE:
                    deletions += data.length;
                    break;
                case DIFF_EQUAL:
                    // A deletion and an insertion is one substitution.
                    levenshtein += Math.max(insertions, deletions);
                    insertions  = 0;
                    deletions   = 0;
                    break;
            }
        }
        return levenshtein + Math.max(insertions, deletions);
    };

    /**
     * Crush the diff into an encoded string which describes the operations
     * required to transform text1 into text2.
     * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
     * Operations are tab-separated.  Inserted text is escaped using %xx notation.
     * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
     * @return {string} Delta text.
     */
    this.diff_toDelta = function(diffs) {
        var text = [],
            x    = 0,
            l    = diffs.length;
        for (; x < l; x++) {
            switch (diffs[x][0]) {
                case DIFF_INSERT:
                    text[x] = "+" + encodeURI(diffs[x][1]);
                    break;
                case DIFF_DELETE:
                    text[x] = "-" + diffs[x][1].length;
                    break;
                case DIFF_EQUAL:
                    text[x] = "=" + diffs[x][1].length;
                    break;
            }
        }
        // Opera doesn't know how to encode char 0.
        return text.join("\t").replace(/\x00/g, "%00").replace(/%20/g, " ");
    };


    /**
     * Given the original text1, and an encoded string which describes the
     * operations required to transform text1 into text2, compute the full diff.
     * @param {string} text1 Source string for the diff.
     * @param {string} delta Delta text.
     * @return {Array.<Array.<number|string>>} Array of diff tuples.
     * @throws {Error} If invalid input.
     */
    this.diff_fromDelta = function(text1, delta) {
        var diffs       = [],
            diffsLength = 0,  // Keeping our own length var is faster in JS.
            pointer     = 0;  // Cursor in text1
        // Opera doesn't know how to decode char 0.
        delta = delta.replace(/%00/g, "\0");
        var tokens = delta.split(/\t/g),
            x      = 0,
            l      = tokens.length,
            param, n, text;
        for (; x < l; x++) {
            // Each token begins with a one character parameter which specifies the
            // operation of this token (delete, insert, equality).
            param = tokens[x].substring(1);
            switch (tokens[x].charAt(0)) {
                case "+":
                    try {
                        diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];
                    }
                    catch (ex) {
                        // Malformed URI sequence.
                        throw new Error("Illegal escape in diff_fromDelta: " + param);
                    }
                    break;
                case "-":
                // Fall through.
                case "=":
                    n = parseInt(param, 10);
                    if (isNaN(n) || n < 0)
                        throw new Error("Invalid number in diff_fromDelta: " + param);

                    text = text1.substring(pointer, pointer += n);
                    if (tokens[x].charAt(0) == "=")
                        diffs[diffsLength++] = [DIFF_EQUAL, text];
                    else
                        diffs[diffsLength++] = [DIFF_DELETE, text];
                    break;
                default:
                    // Blank tokens are ok (from a trailing \t).
                    // Anything else is an error.
                    if (tokens[x]) {
                        throw new Error("Invalid diff operation in diff_fromDelta: " +
                        tokens[x]);
                    }
            }
        }
        if (pointer != text1.length) {
            throw new Error("Delta length (" + pointer
                + ") does not equal source text length (" + text1.length + ").");
        }
        return diffs;
    };


    //  MATCH FUNCTIONS

    /**
     * Locate the best instance of 'pattern' in 'text' near 'loc'.
     * @param {string} text The text to search.
     * @param {string} pattern The pattern to search for.
     * @param {number} loc The location to search around.
     * @return {number} Best match index or -1.
     */
    this.match_main = function(text, pattern, loc) {
        loc = Math.max(0, Math.min(loc, text.length));
        // Shortcut (potentially not guaranteed by the algorithm)
        if (text == pattern)
            return 0;
        else if (!text.length) // Nothing to match.
            return -1;
        // Perfect match at the perfect spot!  (Includes case of null pattern)
        else if (text.substring(loc, loc + pattern.length) == pattern)
            return loc;
        else // Do a fuzzy compare.
            return this.match_bitap(text, pattern, loc);
    };

    /**
     * Locate the best instance of 'pattern' in 'text' near 'loc' using the
     * Bitap algorithm.
     * @param {string} text The text to search.
     * @param {string} pattern The pattern to search for.
     * @param {number} loc The location to search around.
     * @return {number} Best match index or -1.
     * @private
     */
    this.match_bitap = function(text, pattern, loc) {
        if (pattern.length > this.matchMaxBits)
            throw new Error("Pattern too long for this browser.");

        // Initialise the alphabet.
        var s     = this.match_alphabet(pattern),
            _self = this;

        /*
         * Compute and return the score for a match with e errors and x location.
         * Accesses loc and pattern through being a closure.
         * @param {number} e Number of errors in match.
         * @param {number} x Location of match.
         * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
         * @private
         */
        function match_bitapScore(e, x) {
            var accuracy  = e / pattern.length,
                proximity = Math.abs(loc - x);
            if (!_self.matchDistance) // Dodge divide by zero error.
                return proximity ? 1.0 : accuracy;
            return accuracy + (proximity / _self.matchDistance);
        }

        // Highest score beyond which we give up.
        var score_threshold = this.matchThreshold,
            // Is there a nearby exact match? (speedup)
            best_loc = text.indexOf(pattern, loc);
        if (best_loc != -1)
            score_threshold = Math.min(match_bitapScore(0, best_loc), score_threshold);
        // What about in the other direction? (speedup)
        best_loc = text.lastIndexOf(pattern, loc + pattern.length);
        if (best_loc != -1)
            score_threshold = Math.min(match_bitapScore(0, best_loc), score_threshold);
        best_loc = -1;

        // Initialise the bit arrays.
        var matchmask = 1 << (pattern.length - 1),
            bin_max   = pattern.length + text.length,
            d         = 0,
            l         = pattern.length,
            bin_min, bin_mid, last_rd, start, finish, rd, j, charMatch, score;
        for (; d < l; d++) {
            // Scan for the best match; each iteration allows for one more error.
            // Run a binary search to determine how far from 'loc' we can stray at this
            // error level.
            bin_min = 0;
            bin_mid = bin_max;
            while (bin_min < bin_mid) {
                if (match_bitapScore(d, loc + bin_mid) <= score_threshold)
                    bin_min = bin_mid;
                else
                    bin_max = bin_mid;
                bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
            }
            // Use the result from this iteration as the maximum for the next.
            bin_max = bin_mid;
            start   = Math.max(1, loc - bin_mid + 1);
            finish  = Math.min(loc + bin_mid, text.length) + pattern.length;

            rd      = Array(finish + 2);
            rd[finish + 1] = (1 << d) - 1;
            for (j = finish; j >= start; j--) {
                // The alphabet (s) is a sparse hash, so the following line generates
                // warnings.
                charMatch = s[text.charAt(j - 1)];
                if (d === 0) {  // First pass: exact match.
                    rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
                }
                else {  // Subsequent passes: fuzzy match.
                    rd[j] = ((rd[j + 1] << 1) | 1) & charMatch 
                          | (((last_rd[j + 1] | last_rd[j]) << 1) | 1)
                          | last_rd[j + 1];
                }
                if (rd[j] & matchmask) {
                    score = match_bitapScore(d, j - 1);
                    // This match will almost certainly be better than any existing match.
                    // But check anyway.
                    if (score <= score_threshold) {
                        // Told you so.
                        score_threshold = score;
                        best_loc = j - 1;
                        // When passing loc, don't exceed our current distance from loc.
                        if (best_loc > loc)
                            start = Math.max(1, 2 * loc - best_loc);
                        else // Already passed loc, downhill from here on in.
                            break;
                    }
                }
            }
            // No hope for a (better) match at greater error levels.
            if (match_bitapScore(d + 1, loc) > score_threshold)
                break;
            last_rd = rd;
        }
        return best_loc;
    };

    /**
     * Initialise the alphabet for the Bitap algorithm.
     * @param {string} pattern The text to encode.
     * @return {Object} Hash of character locations.
     * @private
     */
    this.match_alphabet = function(pattern) {
        var s = {},
            i = 0,
            l = pattern.length;
        for (; i < l; i++)
            s[pattern.charAt(i)] = 0;
        for (i = 0; i < pattern.length; i++)
            s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
        return s;
    };

    //  PATCH FUNCTIONS

    /**
     * Increase the context until it is unique,
     * but don't let the pattern expand beyond matchMaxBits.
     * @param {patch_obj} patch The patch to grow.
     * @param {string} text Source text.
     * @private
     */
    this.patch_addContext = function(patch, text) {
        var pattern = text.substring(patch.start2, patch.start2 + patch.length1),
            padding = 0;
        while (text.indexOf(pattern) != text.lastIndexOf(pattern) 
          && pattern.length < this.matchMaxBits - this.patchMargin
          - this.patchMargin) {
            padding += this.patchMargin;
            pattern  = text.substring(patch.start2 - padding,
                patch.start2 + patch.length1 + padding);
        }
        // Add one chunk for good luck.
        padding += this.patchMargin;
        // Add the prefix.
        var prefix = text.substring(patch.start2 - padding, patch.start2);
        if (prefix)
            patch.diffs.unshift([DIFF_EQUAL, prefix]);
        // Add the suffix.
        var suffix = text.substring(patch.start2 + patch.length1,
            patch.start2 + patch.length1 + padding);
        if (suffix)
            patch.diffs.push([DIFF_EQUAL, suffix]);

        // Roll back the start points.
        patch.start1  -= prefix.length;
        patch.start2  -= prefix.length;
        // Extend the lengths.
        patch.length1 += prefix.length + suffix.length;
        patch.length2 += prefix.length + suffix.length;
    };

    /**
     * Compute a list of patches to turn text1 into text2.
     * Use diffs if provided, otherwise compute it ourselves.
     * There are four ways to call this function, depending on what data is
     * available to the caller:
     * Method 1:
     * a = text1, b = text2
     * Method 2:
     * a = diffs
     * Method 3 (optimal):
     * a = text1, b = diffs
     * Method 4 (deprecated, use method 3):
     * a = text1, b = text2, c = diffs
     *
     * @param {string|Array.<Array.<number|string>>} a text1 (methods 1,3,4) or
     * Array of diff tuples for text1 to text2 (method 2).
     * @param {string|Array.<Array.<number|string>>} opt_b text2 (methods 1,4) or
     * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
     * @param {string|Array.<Array.<number|string>>} opt_c Array of diff tuples for
     * text1 to text2 (method 4) or undefined (methods 1,2,3).
     * @return {Array.<patch_obj>} Array of patch objects.
     */
    this.patch_make = function(a, opt_b, opt_c) {
        var text1, diffs;
        if (typeof a == "string" && typeof opt_b == "string"
          && typeof opt_c == "undefined") {
            // Method 1: text1, text2
            // Compute diffs from text1 and text2.
            text1 = a;
            diffs = this.diff_main(text1, opt_b, true);
            if (diffs.length > 2) {
                this.diff_cleanupSemantic(diffs);
                this.diff_cleanupEfficiency(diffs);
            }
        }
        else if (typeof a == "object" && typeof opt_b == "undefined"
          && typeof opt_c == "undefined") {
            // Method 2: diffs
            // Compute text1 from diffs.
            diffs = a;
            text1 = this.diff_text1(diffs);
        }
        else if (typeof a == "string" && typeof opt_b == "object"
          && typeof opt_c == "undefined") {
            // Method 3: text1, diffs
            text1 = a;
            diffs = opt_b;
        }
        else if (typeof a == "string" && typeof opt_b == "string"
          && typeof opt_c == "object") {
            // Method 4: text1, text2, diffs
            // text2 is not used.
            text1 = a;
            diffs = opt_c;
        }
        else {
            throw new Error("Unknown call format to patch_make.");
        }

        if (diffs.length === 0)
            return [];  // Get rid of the null case.

        var patches         = [],
            patch           = new patch_obj(),
            patchDiffLength = 0,  // Keeping our own length var is faster in JS.
            char_count1     = 0,  // Number of characters into the text1 string.
            char_count2     = 0,  // Number of characters into the text2 string.
            // Start with text1 (prepatch_text) and apply the diffs until we arrive at
            // text2 (postpatch_text).  We recreate the patches one by one to determine
            // context info.
            prepatch_text   = text1,
            postpatch_text  = text1,
            x               = 0,
            l               = diffs.length,
            diff_type, diff_text;
        for (; x < l; x++) {
            diff_type = diffs[x][0];
            diff_text = diffs[x][1];

            if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
                // A new patch starts here.
                patch.start1 = char_count1;
                patch.start2 = char_count2;
            }

            switch (diff_type) {
                case DIFF_INSERT:
                    patch.diffs[patchDiffLength++] = diffs[x];
                    patch.length2 += diff_text.length;
                    postpatch_text = postpatch_text.substring(0, char_count2)
                                   + diff_text
                                   + postpatch_text.substring(char_count2);
                    break;
                case DIFF_DELETE:
                    patch.length1 += diff_text.length;
                    patch.diffs[patchDiffLength++] = diffs[x];
                    postpatch_text = postpatch_text.substring(0, char_count2) 
                                   + postpatch_text.substring(char_count2 
                                   + diff_text.length);
                    break;
                case DIFF_EQUAL:
                    if (diff_text.length <= 2 * this.patchMargin
                      && patchDiffLength && l != x + 1) {
                        // Small equality inside a patch.
                        patch.diffs[patchDiffLength++] = diffs[x];
                        patch.length1 += diff_text.length;
                        patch.length2 += diff_text.length;
                    }
                    else if (diff_text.length >= 2 * this.patchMargin) {
                        // Time for a new patch.
                        if (patchDiffLength) {
                            this.patch_addContext(patch, prepatch_text);
                            patches.push(patch);
                            patch           = new patch_obj();
                            patchDiffLength = 0;
                            // Unlike Unidiff, our patch lists have a rolling context.
                            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff
                            // Update prepatch text & pos to reflect the application of the
                            // just completed patch.
                            prepatch_text   = postpatch_text;
                            char_count1     = char_count2;
                        }
                    }
                    break;
            }

            // Update the current character count.
            if (diff_type !== DIFF_INSERT)
                char_count1 += diff_text.length;
            if (diff_type !== DIFF_DELETE)
                char_count2 += diff_text.length;
        }
        // Pick up the leftover patch if not empty.
        if (patchDiffLength) {
            this.patch_addContext(patch, prepatch_text);
            patches.push(patch);
        }

        return patches;
    };

    /**
     * Given an array of patches, return another array that is identical.
     * @param {Array.<patch_obj>} patches Array of patch objects.
     * @return {Array.<patch_obj>} Array of patch objects.
     * @private
     */
    var patch_deepCopy = function(patches) {
        // Making deep copies is hard in JavaScript.
        var patchesCopy = [],
            x           = 0,
            l           = patches.length,
            patch, patchCopy, y;
        for (; x < l; x++) {
            patch           = patches[x];
            patchCopy       = new patch_obj();
            patchCopy.diffs = [];
            for (y = 0; y < patch.diffs.length; y++)
                patchCopy.diffs[y] = patch.diffs[y].slice();
            patchCopy.start1  = patch.start1;
            patchCopy.start2  = patch.start2;
            patchCopy.length1 = patch.length1;
            patchCopy.length2 = patch.length2;
            patchesCopy[x]    = patchCopy;
        }
        return patchesCopy;
    };

    /**
     * Merge a set of patches onto the text.  Return a patched text, as well
     * as a list of true/false values indicating which patches were applied.
     * @param {Array.<patch_obj>} patches Array of patch objects.
     * @param {string} text Old text.
     * @return {Array.<string|Array.<boolean>>} Two element Array, containing the
     *      new text and an array of boolean values.
     */
    this.patch_apply = function(patches, text) {
        if (patches.length == 0)
            return [text, []];

        // Deep copy the patches so that no changes are made to originals.
        patches = patch_deepCopy(patches);

        var nullPadding = this.patch_addPadding(patches);
        text = nullPadding + text + nullPadding;

        this.patch_splitMax(patches);
        // delta keeps track of the offset between the expected and actual location
        // of the previous patch.  If there are patches expected at positions 10 and
        // 20, but the first patch was found at 12, delta is 2 and the second patch
        // has an effective expected position of 22.
        var delta   = 0,
            results = [],
            x       = 0,
            l       = patches.length,
            patch, expected_loc, text1, start_loc, end_loc, text2, diffs, index1,
            index2, y, mod, l2;
        for (; x < l; x++) {
            patch        = patches[x];
            expected_loc = patch.start2 + delta;
            text1        = this.diff_text1(patch.diffs);
            end_loc      = -1;
            if (text1.length > this.matchMaxBits) {
                // patch_splitMax will only provide an oversized pattern in the case of
                // a monster delete.
                start_loc = this.match_main(text, text1.substring(0, this.matchMaxBits),
                    expected_loc);
                if (start_loc != -1) {
                    end_loc = this.match_main(text,
                        text1.substring(text1.length - this.matchMaxBits),
                        expected_loc + text1.length - this.matchMaxBits);
                    // Can't find valid trailing context.  Drop this patch.
                    if (end_loc == -1 || start_loc >= end_loc)
                        start_loc = -1;
                }
            }
            else {
                start_loc = this.match_main(text, text1, expected_loc);
            }

            if (start_loc == -1) {
                // No match found.  :(
                results[x] = false;
                // Subtract the delta for this failed patch from subsequent patches.
                delta -= patch.length2 - patch.length1;
            }
            else {
                // Found a match.  :)
                results[x] = true;
                delta = start_loc - expected_loc;
                if (end_loc == -1)
                    text2 = text.substring(start_loc, start_loc + text1.length);
                else
                    text2 = text.substring(start_loc, end_loc + this.matchMaxBits);

                if (text1 == text2) {
                    // Perfect match, just shove the replacement text in.
                    text = text.substring(0, start_loc) +
                    this.diff_text2(patch.diffs) +
                    text.substring(start_loc + text1.length);
                }
                else {
                    // Imperfect match.  Run a diff to get a framework of equivalent
                    // indices.
                    diffs = this.diff_main(text1, text2, false);
                    if (text1.length > this.matchMaxBits
                      && this.diff_levenshtein(diffs) / text1.length
                       > this.patchDeleteThreshold) {
                        // The end points match, but the content is unacceptably bad.
                        results[x] = false;
                    }
                    else {
                        this.diff_cleanupSemanticLossless(diffs);
                        index1 = 0;
                        for (y = 0, l2 = patch.diffs.length; y < l2; y++) {
                            mod = patch.diffs[y];
                            if (mod[0] !== DIFF_EQUAL)
                                index2 = this.diff_xIndex(diffs, index1);
                            if (mod[0] === DIFF_INSERT) {  // Insertion
                                text = text.substring(0, start_loc + index2) 
                                     + mod[1] + text.substring(start_loc + index2);
                            }
                            else if (mod[0] === DIFF_DELETE) {  // Deletion
                                text = text.substring(0, start_loc + index2) 
                                     + text.substring(start_loc
                                     + this.diff_xIndex(diffs, index1 + mod[1].length));
                            }
                            if (mod[0] !== DIFF_DELETE)
                                index1 += mod[1].length;
                        }
                    }
                }
            }
        }
        // Strip the padding off.
        text = text.substring(nullPadding.length, text.length - nullPadding.length);
        return [text, results];
    };

    /**
     * Add some padding on text start and end so that edges can match something.
     * Intended to be called only from within patch_apply.
     * @param {Array.<patch_obj>} patches Array of patch objects.
     * @return {string} The padding string added to each side.
     */
    this.patch_addPadding = function(patches) {
        var paddingLength = this.patchMargin,
            nullPadding   = "",
            x             = 1,
            l             = patches.length;
        for (; x <= paddingLength; x++)
            nullPadding += String.fromCharCode(x);

        // Bump all the patches forward.
        for (x = 0; x < l; x++) {
            patches[x].start1 += paddingLength;
            patches[x].start2 += paddingLength;
        }

        // Add some padding on start of first diff.
        var patch = patches[0],
            diffs = patch.diffs,
            extraLength;
        if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
            // Add nullPadding equality.
            diffs.unshift([DIFF_EQUAL, nullPadding]);
            patch.start1  -= paddingLength;  // Should be 0.
            patch.start2  -= paddingLength;  // Should be 0.
            patch.length1 += paddingLength;
            patch.length2 += paddingLength;
        }
        else if (paddingLength > diffs[0][1].length) {
            // Grow first equality.
            extraLength     = paddingLength - diffs[0][1].length;
            diffs[0][1]     = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
            patch.start1   -= extraLength;
            patch.start2   -= extraLength;
            patch.length1  += extraLength;
            patch.length2  += extraLength;
        }

        // Add some padding on end of last diff.
        patch = patches[patches.length - 1];
        diffs = patch.diffs;
        if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
            // Add nullPadding equality.
            diffs.push([DIFF_EQUAL, nullPadding]);
            patch.length1 += paddingLength;
            patch.length2 += paddingLength;
        }
        else if (paddingLength > diffs[diffs.length - 1][1].length) {
            // Grow last equality.
            extraLength = paddingLength - diffs[diffs.length - 1][1].length;
            diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
            patch.length1 += extraLength;
            patch.length2 += extraLength;
        }

        return nullPadding;
    };

    /**
     * Look through the patches and break up any which are longer than the maximum
     * limit of the match algorithm.
     * @param {Array.<patch_obj>} patches Array of patch objects.
     */
    this.patch_splitMax = function(patches) {
        var x = 0,
            bigpatch, patch_size, start1, start2, precontext, patch, empty,
            diff_type, diff_text, postcontext;
        for (; x < patches.length; x++) {
            if (patches[x].length1 <= this.matchMaxBits) continue;

            bigpatch   = patches[x];
            // Remove the big old patch.
            patches.splice(x--, 1);
            patch_size = this.matchMaxBits;
            start1     = bigpatch.start1;
            start2     = bigpatch.start2;
            precontext = "";
            while (bigpatch.diffs.length !== 0) {
                // Create one of several smaller patches.
                patch = new patch_obj();
                empty = true;
                patch.start1 = start1 - precontext.length;
                patch.start2 = start2 - precontext.length;
                if (precontext !== "") {
                    patch.length1 = patch.length2 = precontext.length;
                    patch.diffs.push([DIFF_EQUAL, precontext]);
                }
                while (bigpatch.diffs.length !== 0 
                  && patch.length1 < patch_size - this.patchMargin) {
                    diff_type = bigpatch.diffs[0][0];
                    diff_text = bigpatch.diffs[0][1];
                    if (diff_type === DIFF_INSERT) {
                        // Insertions are harmless.
                        patch.length2 += diff_text.length;
                        start2 += diff_text.length;
                        patch.diffs.push(bigpatch.diffs.shift());
                        empty = false;
                    }
                    else if (diff_type === DIFF_DELETE
                      && patch.diffs.length == 1
                      && patch.diffs[0][0] == DIFF_EQUAL
                      && diff_text.length > 2 * patch_size) {
                        // This is a large deletion.  Let it pass in one chunk.
                        patch.length1 += diff_text.length;
                        start1 += diff_text.length;
                        empty = false;
                        patch.diffs.push([diff_type, diff_text]);
                        bigpatch.diffs.shift();
                    }
                    else {
                        // Deletion or equality.  Only take as much as we can stomach.
                        diff_text = diff_text.substring(0, patch_size 
                            - patch.length1 - this.patchMargin);
                        patch.length1 += diff_text.length;
                        start1        += diff_text.length;
                        if (diff_type === DIFF_EQUAL) {
                            patch.length2 += diff_text.length;
                            start2        += diff_text.length;
                        }
                        else {
                            empty = false;
                        }
                        patch.diffs.push([diff_type, diff_text]);
                        if (diff_text == bigpatch.diffs[0][1]) {
                            bigpatch.diffs.shift();
                        }
                        else {
                            bigpatch.diffs[0][1] =
                                bigpatch.diffs[0][1].substring(diff_text.length);
                        }
                    }
                }
                // Compute the head context for the next patch.
                precontext = this.diff_text2(patch.diffs)
                    .substring(precontext.length - this.patchMargin);
                // Append the end context for this patch.
                postcontext = this.diff_text1(bigpatch.diffs)
                    .substring(0, this.patchMargin);
                if (postcontext !== "") {
                    patch.length1 += postcontext.length;
                    patch.length2 += postcontext.length;
                    if (patch.diffs.length !== 0 &&
                        patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
                        patch.diffs[patch.diffs.length - 1][1] += postcontext;
                    }
                    else {
                        patch.diffs.push([DIFF_EQUAL, postcontext]);
                    }
                }
                if (!empty)
                    patches.splice(++x, 0, patch);
            }
        }
    };

    /**
     * Take a list of patches and return a textual representation.
     * @param {Array.<patch_obj>} patches Array of patch objects.
     * @return {string} Text representation of patches.
     */
    this.patch_toText = function(patches) {
        var text = [],
            x    = 0,
            l    = patches.length;
        for (; x < l; x++)
            text[x] = patches[x];
        return text.join("");
    };

    /**
     * Parse a textual representation of patches and return a list of patch objects.
     * @param {string} textline Text representation of patches.
     * @return {Array.<patch_obj>} Array of patch objects.
     * @throws {Error} If invalid input.
     */
    this.patch_fromText = function(textline) {
        var patches = [];
        if (!textline)
            return patches;
        // Opera doesn"t know how to decode char 0.
        textline = textline.replace(/%00/g, "\0");
        var text        = textline.split("\n"),
            textPointer = 0,
            len         = text.length,
            re          = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/,
            m, patch, sign, line;
        while (textPointer < len) {
            m = text[textPointer].match(re);
            if (!m)
                throw new Error("Invalid patch string: " + text[textPointer]);

            patch = new patch_obj();
            patches.push(patch);
            patch.start1 = parseInt(m[1], 10);
            if (m[2] === "") {
                patch.start1--;
                patch.length1 = 1;
            }
            else if (m[2] == "0") {
                patch.length1 = 0;
            }
            else {
                patch.start1--;
                patch.length1 = parseInt(m[2], 10);
            }

            patch.start2 = parseInt(m[3], 10);
            if (m[4] === "") {
                patch.start2--;
                patch.length2 = 1;
            }
            else if (m[4] == "0") {
                patch.length2 = 0;
            }
            else {
                patch.start2--;
                patch.length2 = parseInt(m[4], 10);
            }
            textPointer++;

            while (textPointer < len) {
                sign = text[textPointer].charAt(0);
                try {
                    line = decodeURI(text[textPointer].substring(1));
                } catch (ex) {
                    // Malformed URI sequence.
                    throw new Error("Illegal escape in patch_fromText: " + line);
                }
                if (sign == "-") // Deletion.
                    patch.diffs.push([DIFF_DELETE, line]);
                else if (sign == "+") // Insertion.
                    patch.diffs.push([DIFF_INSERT, line]);
                else if (sign == " ") // Minor equality.
                    patch.diffs.push([DIFF_EQUAL, line]);
                else if (sign == "@") // Start of next patch.
                    break;
                else if (sign === "")
                    ;// Blank line?  Whatever.
                else // WTF?
                    throw new Error("Invalid patch mode '" + sign + "' in: " + line);
                textPointer++;
            }
        }
        return patches;
    };
})();




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/o3.js)SIZE(8157)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/popup.js)SIZE(9223)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @private
 */
apf.popup = {
    cache      : {},
    focusFix   : {"INPUT":1,"TEXTAREA":1,"SELECT":1},
    
    setContent : function(cacheId, content, style, width, height){
        if (!this.popup) this.init();

        this.cache[cacheId] = {
            content : content,
            style   : style,
            width   : width,
            height  : height
        };
        content.style.position = "absolute";
        //if(content.parentNode) content.parentNode.removeChild(content);
        //if(style) apf.importCssString(style, this.popup.document);
        
        content.onmousedown  = function(e) {
            if (!e) e = event;

            
            if (apf.hasFocusBug 
              && !apf.popup.focusFix[(e.srcElement || e.target).tagName]) {
                apf.window.$focusfix();
            }
            
            
            (e || event).cancelBubble = true;
        };
        
        return content.ownerDocument;
    },
    
    removeContent : function(cacheId){
        this.cache[cacheId] = null;
        delete this.cache[cacheId];
    },
    
    init : function(){
        //consider using iframe
        this.popup = {};
        
        apf.addEventListener("hotkey", function(e){
            if (e.keyCode == "27" || e.altKey) 
                apf.popup.forceHide();
        });
    },
    
    show : function(cacheId, options){
        options = apf.extend({
            x            : 0,
            y            : 0,
            animate      : false,
            ref          : null,
            width        : null,
            height       : null,
            callback     : null,
            draggable    : false,
            resizable    : false,
            allowTogether: false,
            autoCorrect  : true
        }, options);
        if (!this.popup)
           this.init();
        if ((!options.allowTogether || options.allowTogether != this.last) && this.last != cacheId)
            this.hide();

        var o = this.cache[cacheId];
        o.options = options;
        //if(this.last != cacheId) 
        //this.popup.document.body.innerHTML = o.content.outerHTML;

        var popup = o.content, moveUp = false;
        if (!o.content.style.zIndex)
            o.content.style.zIndex = 10000000;
        if (o.content.style.display && o.content.style.display.indexOf('none') > -1)
            o.content.style.display = "";

        if (options.ref) {
            var pos    = apf.getAbsolutePosition(options.ref, 
                            o.content.offsetParent || o.content.parentNode),//[ref.offsetLeft+2,ref.offsetTop+4];//
                top    = (options.y || 0) + pos[1],
                    //+ (apf.isWebkit ? window.pageYOffset : 0), <-- appears to be needed in NEW safari...
                p      = apf.getOverflowParent(o.content);
        
            if (options.width || o.width)
                popup.style.width = ((options.width || o.width) - 3) + "px";

            moveUp = options.autoCorrect && (top
                + (options.height || o.height || o.content.offsetHeight))
                > (p == document.documentElement
                  ? (apf.isIE ? p.offsetHeight : (window.innerHeight + window.pageYOffset))  + p.scrollTop
                  : p.offsetHeight + p.scrollTop);

            popup.style.top = (moveUp 
                ? (top - (options.height || o.height || o.content.offsetHeight))
                : top) + "px"
            popup.style.left = ((options.x || 0) + pos[0]) + "px";
        }

        
        // set a className that specifies the direction, to help skins with
        // specific styling options.
        apf.setStyleClass(popup, moveUp ? "upward" : "downward", [moveUp ? "downward" : "upward"]);
        

        if (options.animate) {
            if (options.animate == "fade") {
                apf.tween.single(popup, {
                    type  : 'fade',
                    from  : 0,
                    to    : 1,
                    anim  : apf.tween.NORMAL,
                    steps : apf.isIE ? 5 : 10
                });
            }
            else {
                var iVal, steps = apf.isIE8 ? 5 : 7, i = 0;
                iVal = setInterval(function(){
                    var value = ++i * ((options.height || o.height) / steps);

                    popup.style.height = value + "px";
                    if (moveUp)
                        popup.style.top = (top - value - options.y) + "px";
                    else
                        popup.scrollTop = -1 * (i - steps) * ((options.height || o.height) / steps);
                    popup.style.display = "block";

                    if (i >= steps) {
                        clearInterval(iVal)
                        
                        if (options.callback)
                            options.callback(popup);
                    }
                }, 10);
            }
        }
        else {
            if (options.height || o.height)
                popup.style.height = (options.height || o.height) + "px";
            popup.style.top = (top) + "px";
            popup.style.display = "block";
            
            if (options.callback)
               options.callback(popup);
        }

        $setTimeout(function(){
            apf.popup.last = cacheId;
        });

        if (options.draggable) {
            options.id = cacheId;
            this.makeDraggable(options);
        }
    },
    
    hide : function(){
        if (this.isDragging) return;

        var o = this.cache[this.last];
        if (o) {
            if (o.content)
                o.content.style.display = "none";

            if (o.options && o.options.onclose) {
                o.options.onclose(apf.extend(o.options, {htmlNode: o.content}));
                o.options.onclose = false;
            }
        }
    },
    
    isShowing : function(cacheId){
        return this.last && this.last == cacheId 
            && this.cache[this.last]
            && this.cache[this.last].content.style.display != "none";
    },

    isDragging   : false,

    makeDraggable: function(options) {
        if (!apf.Interactive || this.cache[options.id].draggable) 
            return;

        var oHtml = this.cache[options.id].content;
        this.cache[options.id].draggable = true;
        var o = {
            $propHandlers : {},
            minwidth      : 10,
            minheight     : 10,
            maxwidth      : 10000,
            maxheight     : 10000,
            dragOutline   : false,
            resizeOutline : false,
            draggable     : true,
            resizable     : options.resizable,
            $ext          : oHtml,
            oDrag         : oHtml.firstChild
        };

        oHtml.onmousedown =
        oHtml.firstChild.onmousedown = function(e){
            if (!e) e = event;
            
            
            if (apf.hasFocusBug
              && !apf.popup.focusFix[(e.srcElement || e.target).tagName]) {
                apf.window.$focusfix();
            }
            
            
            (e || event).cancelBubble = true;
        }

        apf.implement.call(o, apf.Interactive);

        o.$propHandlers["draggable"].call(o, true);
        o.$propHandlers["resizable"].call(o, true);
    },
    
    forceHide : function(){
        if (this.last 
            
            && !apf.plane.current
            
            && this.isShowing(this.last)) {
            var o = apf.lookup(this.last);
            if (!o)
                this.last = null;
                
            else if (o.dispatchEvent("popuphide") !== false)
                this.hide();
        }
    },

    destroy : function(){
        for (var cacheId in this.cache) {
            if (this.cache[cacheId]) {
                this.cache[cacheId].content.onmousedown = null;
                apf.destroyHtmlNode(this.cache[cacheId].content);
                this.cache[cacheId].content = null;
                this.cache[cacheId] = null;
            }
        }
        
        if (!this.popup) return;
        //this.popup.document.body.c = null;
        //this.popup.document.body.onmouseover = null;
    }
}



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/nameserver.js)SIZE(5428)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @private
 */
apf.nameserver = {
    lookup : {},
    
    add : function(type, item){
        if (!this.lookup[type])
            this.lookup[type] = [];
        
        
        if(this.onchange)
            this.onchange(type, item);
        
        
        return this.lookup[type].push(item) - 1;
    },
    
    register : function(type, id, item){
        if (!this.lookup[type])
            this.lookup[type] = {};

        
        if (this.onchange)
            this.onchange(type, item, id);
        

        return (this.lookup[type][id] = item);
    },
    
    remove : function(type, item){
        var list = this.lookup[type];
        if (list) {
            for (var prop in list) {
                if (list[prop] == item) {
                    delete list[prop];
                }
            }
        }
    },
    
    get : function(type, id){
        return this.lookup[type] ? this.lookup[type][id] : null;
    },
    
    getAll : function(type){
        var name, arr = [], l = this.lookup[type];
        if (!l) return arr;
        
        if (l.dataType == apf.ARRAY) {
            for (var i = 0; i < l.length; i++) {
                arr.push(l[i]);
            }
        }
        else {
            for (name in l) {
                
                
                if (apf.isSafariOld && (!l[name] || typeof l[name] != "object"))
                    continue;
                
                
                arr.push(l[name]);
            }
        }
        
        return arr;
    }, 
    
    getAllNames : function(type){
        var name, arr = [];
        for (name in this.lookup[type]){
            if (parseInt(name) == name) continue;
            arr.push(name);
        }
        return arr;
    }
};




/**
 * Object which provides a means to store key values pairs in a named context.
 * This objects primary purpose is to provide a way to serialize the state
 * of all the custom state you introduce when building the application. This way
 * you can use {@link element.offline apf.offline} to start the application in 
 * the exact state it was when your user closed the app.
 *
 * @see core.storage
 */
apf.registry = apf.extend({
    /**
     * Stores a key value pair.
     * @param {String} key       the identifier of the information.
     * @param {mixed}  value     the information to store.
     * @param {String} namespace the named context into which to store the key value pair.
     */
    put : function(key, value, namespace){
        this.register(namespace, key, value);
    },
    
    /**
     * @private
     */
    getNamespaces : function(){
        
    },
    
    /**
     * Retrieves all the keys of a namespace.
     * @param {String} namespace the named context of the keys to retrieve.
     * @return {Array} the list of keys in the namespace.
     */
    getKeys : function(namespace){
        return this.getAllNames(namespace);
    },
    
    /**
     * Removes a key in a namespace.
     * @param {String} key       the identifier of the information.
     * @param {String} namespace the named context of the keys to remove.
     */
    remove : function(key, namespace){
        delete this.lookup[namespace][key];
    },
    
    /**
     * @private
     */
    clear : function(namespace){
        this.lookup = {}; //@todo
    },
    
    
    
    $export : function(storage){
        var namespace, key;

        for (namespace in this.lookup) {
            for (key in this.lookup[namespace]) {
                storage.put(key, this.lookup[key][namespace], namespace);
            }
        }
    }
}, apf.nameserver);

/**
 * @private
 */
apf.registry.lookup = {};

apf.registry.get = function(key, namespace){
    return this.lookup[namespace] ? this.lookup[namespace][key] : null;
};

apf.Init.run("nameserver");




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/history.js)SIZE(10011)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Implementation of hash change listener. The 'hash' is the part of the
 * location string in your browser that takes care of pointing to a section
 * within the current application.
 * Example:
 * <code>
 *  www.example.com/index.php#products
 * </code>
 * Remarks:
 * In future browsers (> 2009) the location hash can be set by script and
 * {@link element.history.event.hashchange} is called when it's changed by using the back or forward
 * button of the browsers. In most of the current (2009) browsers this is not the case.
 * This object handles that logic for those browsers in such a way that the user
 * of the application can use the back and forward buttons in an intuitive manner.
 *
 * Note on Internet Explorer 8. When switching between the IE7 compatibility mode
 * and IE8 mode the history navigation will break. A browser restart is then 
 * required to fix it. Individually history navigation works fine in each mode.
 *
 * @event hashchange Fires when the hash changes. This can be either by setting
 * a new hash value or when a user uses the back or forward button. Typing a
 * new hash value in the location bar will also trigger this function.
 * Example:
 * <code>
 *  apf.addEventListener("hashchange", function(e){
 *      var info = e.page.split(":");
 *
 *      switch(info[0]) {
 *          case "product": //hash is for instance 'product:23849'
 *              //Sets the application state to display product info
 *              //For more information see {@link element.state}
 *              stProduct.activate(); 
 *              //Loads a product by id
 *              loadProduct(info[1]); 
 *              break;
 *          case "news":
 *              stNews.activate();
 *              break;
 *      }
 *  });
 * </code>
 *
 * @default_private
 */
apf.history = {
    inited: false,
    page  : null,
    past  : [],
    future: [],

    init  : function(defName, getVar, delay){
        if (this.inited)
            return;

        if (delay)
            this.delay = delay;
        var name = location.href.match(/#(.*)$/) && decodeURI(RegExp.$1) 
          || apf._GET[getVar || -1] || defName;

        this.inited = true;
        
        location.hash = name;
        this.hasChanged(name || null);

        if (apf.supportHashChange) {
            window.onhashchange = function(){
                var page = location.hash.replace("#", "");
                apf.history.hasChanged(decodeURI(page));
            };
        }
        else if (apf.isIE) {
            var str =
                "<style>\
                    BODY, HTML{margin : 0;}\
                    h1{height : 100px;margin : 0;padding : 0;}\
                </style>\
                <body>\
                    <h1 id='" + name + "'>0</h1>\
                </body>\
                <script>\
                    var lastURL = -1;\
                    if(document.all){\
                        document.body.onscroll = checkUrl;\
                    }else{\
                        setInterval('checkUrl()', 200);\
                    }\
                    function checkUrl(){\
                        if (top.apf.isIE7Emulate && top.apf.history.lastHtml)\
                            document.body.innerHTML = top.apf.history.lastHtml;\
                        var nr=Math.round((document.all ? document.body : document.documentElement).scrollTop/100);\
                        if (top.apf.isIE7Emulate) {\
                            clearTimeout(top.apf.history.ie7timer);\
                            top.apf.history.ie7timer = setTimeout(function(){\
                                top.apf.history.hasChanged(document.getElementsByTagName('h1')[nr].id);\
                            }, 100);\
                        }\
                        else {\
                            top.apf.history.hasChanged(document.getElementsByTagName('h1')[nr].id);\
                        }\
                        lastURL = document.body.scrollTop;\
                    }\
                    checkUrl();\
                </script>";

            if (top == self) {
                document.body.insertAdjacentHTML("beforeend",
                    "<iframe name='nav' style2='position:absolute;left:10px;top:10px;height:100px;width:100px;z-index:1000'\
                       style='width:1px;height:1px;' src='about:blank'></iframe>");
                document.frames["nav"].document.open();
                document.frames["nav"].document.write(str);
                document.frames["nav"].document.close();
            }

            this.iframe = document.frames["nav"];// : document.getElementById("nav").contentWindow;
            //Check to see if url has been manually changed
            this.timer2 = setInterval(function(){
                //status = apf.history.changingHash;
                if (!apf.history.changingHash && location.hash != "#" + apf.history.page) {
                    var name = location.hash.replace(/^#/, "");
                    var page = apf.history.page;
                    apf.history.setHash(name, true, true);
                    apf.history.page = page;
                    apf.history.hasChanged(name);
                }
            }, apf.history.delay || 1);
        }
        else {
            apf.history.lastUrl = location.href.toString();
            this.timer2 = setInterval(function(){
                if (apf.history.lastUrl == location.href.toString())
                    return;

                apf.history.lastUrl = location.href.toString();
                //var page            = location.href.replace(/^.*#(.*)$/, "$1")
                var page = location.hash.replace("#", "");//.replace(/^.*#(.*)$/,"$1");
                apf.history.hasChanged(decodeURI(page));
            }, 20);
        }
    },
    to_name : null,
    
    /**
     * Sets the hash value of the location bar in the browser. This is used
     * to represent the state of the application for use by the back and forward
     * buttons as well as for use when bookmarking or sharing url's.
     * @param {String}  name    the new hash value.
     * @param {Boolean} timed   whether to add a delay to setting the value.
     */
    setHash : function(name, timed, force){
        if (this.changing || this.page == name || !force && location.hash == "#" + name) {
            this.to_name = name;
            return;
        }

        if (apf.isIE && !apf.isIE8 && !timed) {
            this.to_name = name;
            return $setTimeout(function(){
                apf.history.setHash(apf.history.to_name, true);
            }, 200);
        }

        this.changePage(name);
        if (!this.inited)
            return this.init(name);

        if (apf.isIE && !apf.isIE8) {
            var h       = this.iframe.document.body
                .appendChild(this.iframe.document.createElement('h1'));
            h.id        = name;
            h.innerHTML = this.length;
            this.lastHtml = this.iframe.document.body.innerHTML;
        };

        (apf.isIE && !apf.isIE8 ? this.iframe : window).location.href = "#" + name;
        
        if (!apf.isIE && !apf.isIphone)
            apf.history.lastUrl = location.href.toString();
        else if (apf.isIE8)
            this.page = name;
    },

    timer : null,
    changePage: function(page){
        if (apf.isIE && !apf.isIE8) {
            this.page = page;
            this.changingHash = true;
            clearTimeout(this.timer);
            this.timer = $setTimeout(function(){
                location.hash = page;
                apf.history.changingHash = false;
            }, 1);
        }
    },

    update: function(page) {
        var i, l, idx = 0;

        // check past:
        for (i = 0, l = this.past.length; i < l && idx === 0; i++) {
            if (this.past[i] == page)
                idx = i + 1;
        }
        if (idx > 0) {
            // part of past up till page (Array.slice), EXCLUDING page
            this.future = this.past.slice(idx, this.past.length - 1)
                                   .concat(this.future).makeUnique();
            this.past.splice(idx, this.past.length - (idx));
            idx = -idx;
        }
        else {
            // check future:
            for (i = 0, l = this.future.length; i < l && idx === 0; i++) {
                if (this.future[i] == page) {
                    idx = i + 1;
                    // current past + part of the future up till page
                    // (Array.splice), INCLUDING page
                    this.past = this.past.concat(this.future
                        .splice(0, this.future.length - idx)).makeUnique();
                }
            }
            if (idx === 0) {
                this.past.push(page);
                idx = 1;
            }
        }

        return idx;
    },

    hasChanged: function(page){
        if (page == this.page) return;
        this.changePage(page);

        this.changing = true;
        apf.dispatchEvent("hashchange", {page: page, index: this.update(page)});
        this.changing = false;
    }
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/config.js)SIZE(7435)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.config = new apf.Class().$init();
apf.extend(apf.config, {
    //Defaults
    disableRightClick  : false,
    allowSelect        : false,
    allowBlur          : true,
    autoDisableActions : true,
    autoDisable        : false, /** @todo fix this to only autodisable when createmodel is not true */
    disableF5          : true,
    autoHideLoading    : true,
    disableSpace       : true,
    defaultPage        : "home",
    disableBackspace   : true,
    undokeys           : false,
    outline            : false,
    dragOutline        : false,
    resizeOutline      : false,
    autoDisableNavKeys : true,
    disableTabbing     : false,
    resourcePath       : null,
    initdelay          : true,
    liveText           : false,
    
    iePngFix           : false,
    
    
    iphoneFullscreen   : true,
    iphoneStatusbar    : 'default', //other options: black-translucent, black
    iphoneIcon         : null,
    iphoneIconIsGlossy : false,
    iphoneFixedViewport: true,
    
    skinset            : "default",
    name               : self.window && window.location.href.replace(/[^0-9A-Za-z_]/g, "_"),

    tags               : {},
    defaults           : {},
    baseurl            : "",
    
    "model"            : "@default",
    "empty-message"    : "No items",
    "loading-message"  : "Loading...",
    "offline-message"  : "You are currently offline.",

    setDefaults : function(){
        
        if (apf.isParsingPartial) {
            this.disableRightClick  = false;
            this.allowSelect        = true;
            this.autoDisableActions = true;
            this.autoDisable        = false;
            this.disableF5          = false;
            this.autoHideLoading    = true;
            this.disableSpace       = false;
            this.disableBackspace   = false;
            this.undokeys           = false;
            this.disableTabbing     = true;
            this.allowBlur          = true;
        }
        
    },

    getDefault : function(type, prop){
        var d = this.defaults[type];
        if (!d)
            return;

        for (var i = d.length - 1; i >= 0; i--) {
            if (d[i][0] == prop)
                return d[i][1];
        }
    },

    setProperty : function(name, value){
        //this[name] = value;
        //@todo I dont want to go through all the code again, maybe later
        this[name.replace(/-(\w)/g, function(m, m1){
            return m1.toUpperCase()
        })] = this[name] = value;
        
        (this.$propHandlers && this.$propHandlers[name]
          || apf.GuiElement.propHandlers[name] || apf.K).call(this, value);
    },
    
    $inheritProperties : {},
    
    $propHandlers : {
        "baseurl" : function(value){
            this.baseurl = apf.parseExpression(value);
        },
        "language" : function(value){
            
            apf.queue.add("language", function(){
                apf.setModel(apf.config.language, apf.language);
            });
            
        },
        //Activate Layout Rules [Maybe change idef to something more specific]
        
        "layout" : function(value){
            apf.queue.add("layout", function(){
                apf.setModel(apf.config.layout, apf.layout);
                //apf.layout.$loadFrom(value); //@todo apf3.0 test
            });
        },
        
        "resource-path" : function(value){
            this.resourcePath = apf.parseExpression(value || "")
              .replace(/resources\/?|\/$/g, '');
        },
        
        "iepngfix" : function(value, x){
            this.iePngFix           = (!apf.supportPng24 
                && (apf.isTrue(value)
                || x.getAttribute("iepngfix-elements")));
            
            if (this.iePngFix) {
                // run after the init() has finished, otherwise the body of the 
                // document will still be empty, thus no elements found.
                $setTimeout(function() {
                    apf.iepngfix.limitTo(x.getAttribute("iepngfix-elements") || "").run();
                });
            }
        },
        
        
        "skinset" : function(value) {
            if (this.$amlLoaded)
                apf.skins.changeSkinset(value);
        },
        
        
        "outline" : function(value) {
            this.dragOutline    =
            this.resizeOutline  =
            this.outline        = apf.isTrue(value);
        },
        "drag-outline" : function(value){
            this.dragOutline    = value
              ? apf.isTrue(value)
              : false;
        },
        "resize-outline" : function(value){
            this.resizeOutline  = value
              ? !apf.isFalse(value)
              : false;
        },
        
        
        "login" : function(value, x) {
            apf.auth.init(x);
        },
        
        
        "storage" : function(value) {
            if (value)
                apf.storage.init(value);
        },
        
        
        "offline" : function(value){
            if (value && typeof apf.offline != "undefined")
                apf.offline.init(value);
        },
        
        
        "disable-f5" : function(value){
            if (apf.isDeskrun && value)
                shell.norefresh = true;
        },
        
        "debug" : function(value) {
            
            if (value) {
                apf.addEventListener("load", function(){
                    $setTimeout("apf.debugwin.activate();", 200) //@todo has a bug in gecko, chrome
                    apf.removeEventListener("load", arguments.callee);
                });
            }
            
            apf.debug = value;
        }
    }
});


if (apf.history)
    apf.addEventListener("load", function(){
        apf.history.init(apf.config.defaultPage, "page");
    });





/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/offline.js)SIZE(20151)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @define offline
 * Adds offline support for aml applications. It can store and restore the state
 * of the application, the models, any transaction that occurred whilst being
 * offline, queuing actions (ActionTracker state) and state of the runtime
 * application itself (all properties of each element). This allows the
 * application to return to the exact state the user left it, when needed. This
 * means that when enabled you can at any moment turn of your computer (i.e.
 * remove the battery) and when your computer starts up whilst sitting in the
 * train start the application and continue working as if the application
 * was never closed.
 * Example:
 * <code>
 *  <a:appsettings>
 *      <a:offline providers="gears"
 *        resources     = "application|models|transactions|queue|state"
 *        rsb-timeout   = "10000"
 *        detect-url    = "network.txt"
 *        detection     = "auto"
 *        realtime      = "true"
 *        onrestore     = "return confirm('Continue your previous session?');"
 *        onlosechanges = "" />
 *  </a:appsettings>
 * </code>
 *
 * @event losechanges   Fires before the offline state is removed.
 *   cancelable: Prevents the application from losing it's recorded offline state.
 * @event beforeoffline Fires before bringing the application offline.
 *   cancelable: Prevents the application from going offline
 * @event afteroffline  Firest after the application is brought offline.
 * @event beforeonline  Fires before bringing the application online.
 *   cancelable: Prevents the application from going online
 * @event afteronline   Fires after the application is brought online.
 * @event beforeload    Fires before loading the offline state into this application.
 *   cancelable: Prevents the application from reloading it's offline state.
 * @event sync          Fires at each sync item's completion.
 *   object:
 *   {Number} position the number of the item in the list that is currently processed.
 *   {Number} length   the total number of items in the list.
 *
 * @inherits apf.Class
 *
 * @attribute {Number}  progress  the progress of the sync. A number between 0 and 1.
 * Example:
 * <code>
 * <a:modalwindow title="Synchronizing" visible="{offline.syncing}">
 *    <a:Label>Synchronizing your changes</a:label>
 *    <a:progressbar value="{offline.progress}" />
 *    <a:button onclick="apf.offline.stopSync()">Cancel</a:button>
 *    <a:button onclick="this.parentNode.hide()">Hide Window</a:button>
 * </a:modalwindow>
 * </code>
 * @attribute {Number}  position  the progress of the sync. 
 * @attribute {Number}  length    the total length of items to sync.
 * @attribute {Boolean} syncing   whether the application is syncing while coming online.
 * @attribute {Boolean} onLine    whether the application is online. This property is false during sync.
 * @attribute {String} resources the resources that should be
 * kept offline and synced later. This is a pipe '|' seperated list.
 *   Possible values:
 *   application    deals with making the actual application offline avaible.
 *   models         takes care of having the data of the models offline available.
 *   transactions   records the state of the actiontrackers so that these are available offline.
 *   queue          handles queuing of actions that can only be executed whilst online.
 *   state          records the state of all elements in this application on a property level.
 * @attribute {Number} rsb-timeout the number of milliseconds
 * after the remote smartbindings server considers a client
 * offline and destroys all saved offline messages.
 * 
 * @default_private
 */
apf.offline = {
    /**
     * whether offline support is enabled.
     * @type {Boolean}
     */
    enabled     : false,

    /**
     * whether the application is online.
     * @type {Boolean}
     */
    onLine      : -1,
    resources   : ["application", "models", "transactions", "queue", "state"],
    autoInstall : false,
    storage     : null,
    inited      : false,
    rsbTimeout  : 600000,//After 10 minutes, we assume the RSB messaged will be destroyed

    init : function(aml){
        apf.makeClass(this);

        //Read configuration
        if (aml) {
            this.$aml = aml;

            if (typeof aml == "string") {

            }
            else if (aml.nodeType) {
                if (aml.getAttribute("resources"))
                    this.providers = aml.getAttribute("resources").split("|");

                /**
                 * @private
                 */
                if (aml.getAttribute("rsb-timeout"))
                    this.rsbTimeout = parseInt(aml.getAttribute("rsb-timeout"));

                //Events
                var a, i, attr = aml.attributes;
                for (i = 0; i < attr.length; i++) {
                    a = attr[i];
                    if (a.nodeName.indexOf("on") == 0)
                        this.addEventListener(a.nodeName, 
                          
                          apf.lm.compile(a.nodeValue, {event: true, parsecode: true})
                          
                        );
                }
            }
            else {
                apf.extend(this, aml);
            }
        }

        
        var provider = apf.offline.application.init(aml)
        

        //Check for storage provider
        if (provider) {
            this.storage = apf.storage.getProvider(provider);

            
            if (this.storage)
                apf.console.info("Installed storage provider '" + provider + "'");
            
        }

        if (!this.storage) {
            this.storage = apf.storage.initialized
                ? apf.storage
                : apf.storage.init(); //autodetect
        }

        if (!this.storage) {
            
            throw new Error("Offline failed to attain access \
                               to a storage provider");
            

            return;
        }

        if (!this.storage.isPermanent()) {
            apf.addEventListener("exit", function(){
                return apf.offline.dispatchEvent("losechanges");
            });
        }

        if (this.storage.asyncInit) {
            apf.document.$domParser.$shouldWait++; //@todo apf3.0 make this work again
            this.storage.ready(function(){
                apf.offline.storage.onready = null; //Prevent being called twice
                apf.offline.continueInit();
                apf.document.$domParser.$continueParsing(apf.document.documentElement);
            });

            return;
        }

        this.continueInit();
    },

    continueInit : function(){
        // Check if all specified resources are available
        for (var i = this.resources.length - 1; i >= 0; i--) {
            if (!this[this.resources[i]])
                this.resources.removeIndex(i);
            else
                this[this.resources[i]].init(this.$aml);
        }

        this.enabled = true;

        
        this.detector.init(this.$aml);
        

        this.offlineTime = parseInt(this.storage.get("offlinetime", this.namespace));

        //If we were offline lets stay offline
        if (this.offlineTime)
            this.goOffline();
        else //Else we try to go online
            this.goOnline();

        apf.offline.dispatchEvent("load");
    },

    $destroy : function(){
        
        apf.console.info("Cleaning offline");
        

        if (this.provider && this.provider.destroy)
            this.provider.destroy();

        if (this.storage && this.storage.destroy)
            this.storage.destroy();

        for (var i = this.resources.length - 1; i >= 0; i--) {
            if (this[this.resources[i]] && this[this.resources[i]].destroy)
                this[this.resources[i]].destroy();
        }
    },

    IDLE       : 0, //idle
    TO_OFFLINE : 1, //going offline
    TO_ONLINE  : 2, //going online
    STOPPING   : 3, //stopping going online

    /**
     * Indicates what's happening right now
     */
    inProcess : 0,

    $supportedProperties : ["syncing", "position", "length", "progress", "onLine"],
    handlePropSet : function(prop, value, force){
        this[prop] = value;
        //All read-only properties
    },

    /**
     * Brings the application offline.
     */
    goOffline : function(){
        if (!this.enabled || this.onLine === false
          || this.inProcess == this.TO_OFFLINE)
            return false;

        //We can't go offline yet, we'll terminate current process and wait
        if (this.inProcess) {
            this.inProcess = this.STOPPING;
            return false;
        }

        if (this.dispatchEvent("beforeoffline") === false)
            return false;

        //We're offline, let's dim the light
        this.setProperty("onLine", false);
        this.inProcess = this.TO_OFFLINE;

        if (!this.offlineTime) {
            this.offlineTime = new Date().getTime();
            this.storage.put("offlinetime", this.offlineTime, this.namespace);
        }

        
        //if (apf.auth.retry) //Don't want to ruin the chances of having a smooth ride on a bad connection
        //    apf.auth.loggedIn = false; //we're logged out now, we'll auto-login when going online
        

        
        //Turn off detection if needed
        if (this.detector.enabled && this.detector.detection != "manual")
            this.detector.start();
        

        
        if (!this.initial) {
            /**
             * @private
             */
            this.initial = {
                disableRSB : apf.xmldb.disableRSB //@todo record this in storage
            }
        }
        apf.xmldb.disableRSB = true;
        

        this.inProcess = this.IDLE;

        this.dispatchEvent("afteroffline");

        
        apf.console.info("The application is now working offline.")
        

        return true;//success
    },

    /**
     * Brings the application online.
     */
    goOnline : function(){
        if (!this.enabled || this.onLine === true
          || this.inProcess == this.TO_ONLINE)
            return false;

        if (this.dispatchEvent("beforeonline") === false)
            return false;

        //We're online, let's show the beacon
        this.setProperty("onLine", true); //@todo Think about doing this in the callback, because of processes that will now intersect
        this.inProcess  = this.TO_ONLINE;
        this.onlineTime = new Date().getTime();
        this.reloading  = false;

        
        apf.console.info("Trying to go online.")
        

        
        //Turn off detection if needed
        if (this.detector.enabled && this.detector.detection == "error")
            this.detector.stop();
        

        
        //Check if we have to reload all models
        this.$checkRsbTimeout();

        //Reset RSB in original state
        if (this.initial)
            apf.xmldb.disableRSB = this.initial.disableRSB;
        

        var callback = function(){
            /*
                @todo syncing should probably be patched to take a random
                time before starting to prevent blasting a server during a
                glitch, of course decent loadbalancing would solve this as well.
            */
            this.startSync();

            this.dispatchEvent("afteronline");
        }

        
        var auth = apf.document.getElementsByTagNameNS(apf.ns.apf, "auth")[0];
        if (!auth)
            return;
        //First let's log in to the services that need it before syncing changes
        if (auth.needsLogin && auth.loggedIn) { // && !auth.loggedIn
            auth.authRequired({
                object : this,
                retry  : callback
            });
        }
        else
        
        {
            callback.call(this);
        }

        return true;//success
    },

    
    /**
     *  If we've been offline for a long time,
     *  let's clear the models, we can't trust the data anymore
     */
    $checkRsbTimeout : function(){
        if (!this.rsbTimeout)
            return;

        var i, j, rsbs = apf.nameserver.getAll("remote");
        for (i = 0; i < rsbs.length; i++) {
            var rsb = rsbs[i];
            if (this.reloading
              || this.onlineTime - this.offlineTime > this.rsbTimeout) {
                if (!this.reloading) {
                    if (this.dispatchEvent("beforereload") === false) {
                        
                        apf.console.warn("Warning, potential data corruption\
                            because you've cancelled reloading the data of all \
                            remote smartbinding synchronized models.");
                        

                        break;
                    }

                    this.reloading = true;
                }

                rsb.discardBefore = this.onlineTime;

                for (j = 0; k < rsb.models.length; j++) {
                    rsb.models[j].clear();

                    
                    apf.offline.models.addToInitQueue(rsb.models[j])
                    
                }
            }
        }

        if (this.reloading) {
            
            apf.console.warn("The application has been offline longer than the \
                              server timeout. To maintain consistency the models\
                              are reloaded. All undo stacks will be purged.");
            

            
            apf.offline.transactions.clear("undo|redo");
            

            var ats = apf.nameserver.getAll("actiontracker");
            for (var i = 0; i < ats.length; i++) {
                ats[i].reset();
            }
        }
    },
    

    $goOnlineDone : function(success){
        //this.reloading = true;
        this.inProcess = this.IDLE; //We're done
        this.setProperty("syncing", false);

        if (success) {
            this.offlineTime = null;
            this.initial     = null;
            this.storage.remove("offlinetime", this.namespace);

            
            apf.console.info("Syncing done.")
            apf.console.info("The application is now working online.")
            
        }
        else {
            
            apf.console.info("Syncing was cancelled. Going online failed")
            

            //Going online has failed. Going offline again
            this.goOffline();
        }
    },

    /**
     * Clears all offline data.
     */
    clear : function(){
        if (!this.enabled)
            return false;

        
        apf.console.info("Clearing all offline and state cache");
        

         for (var i = this.resources.length - 1; i >= 0; i--) {
            if (this[this.resources[i]].clear)
                this[this.resources[i]].clear();
        }
    },

    /**
     * Does cleanup after we've come online
     * @private
     */
    startSync : function(){
        if (this.syncing)
            return;

        this.setProperty("syncing", true);

        
        apf.console.info("Start syncing offline changes.")
        

        var syncResources = [],
            syncLength    = 0,
            syncPos       = 0,
            syncRes       = null,
            len, i;

        //Start finding all resources to sync
        for (i = this.resources.length - 1; i >= 0; i--) {
            if (this[this.resources[i]].sync) {
                len = this[this.resources[i]].getSyncLength();

                if (len) {
                    syncResources.push(this[this.resources[i]]);
                    syncLength += len;
                }
            }
        }

        var fln      = apf.offline;
        var callback = function(extra){
            if (fln.inProcess == fln.STOPPING) {
                if (!extra.finished && extra.length - 1 != extra.position) {
                    syncRes.stopSync(function(){ //@todo if(syncRes) ??
                        fln.$goOnlineDone(false);
                    });
                }
                else {
                    fln.$goOnlineDone(false);
                }

                return;
            }

            if (extra.finished) {
                if (syncResources.length) {
                    syncRes = syncResources.pop();
                    syncRes.sync(callback);
                }
                else {
                    //@todo check if we need to sync more..

                    fln.$goOnlineDone(true);
                }

                return;
            }

            if (!extra.start)
                syncPos++;

            fln.setProperty("progress", parseInt(syncPos/syncLength*100));
            fln.setProperty("position", syncPos);
            fln.setProperty("length", syncLength);

            fln.dispatchEvent("sync", apf.extend(extra, {
                position : syncPos,
                length   : syncLength
            }));
        }

        if (syncLength) {
            callback({start    : true});
            callback({finished : true});
        }
        else {
            
            apf.console.info("Nothing to synchronize.")
            

            this.$goOnlineDone(true);
        }

        
        /*
            When going online check $loadedWhenOffline of
            the multiselect widgets and reload() them
        */
        var nodes = apf.all; //@todo maintaining a list is more efficient, is it necesary??
        for (i = 0; i < nodes.length; i++) {
            if (nodes[i].$loadedWhenOffline)
                nodes[i].reload();
        }
        
    },

    stopSync : function(){
        if (this.syncing)
            this.inProcess = this.STOPPING;
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/offline/application.js)SIZE(11733)TIME(1257329186)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Object handling the offline state of the application resources. This includes
 * the files that contain application logic themselve. In most cases the
 * functionality of this object will be managed from within the offline
 * element in AML.
 * Example:
 * <code>
 *  <a:offline
 *      version-get  = "version.php"
 *      providers    = "gears|air"
 *      auto-install = "true" />
 * </code>
 *
 * @define offline
 * @event beforeinstall Fires before installation of an offline provider
 *   cancelable: Cancels the installation of the offline provider
 * @event afterinstall  Fires after installation of an offline provider
 *
 * @attribute {String} [version-get]    a datainstruction for getting a version number of the current application
 * @attribute {String} [providers]      a pipe seperated list of possible providers.
 *   Possible values:
 *   gears  Uses the Google Gears plugin for storage of application files
 * @attribute {Boolean} [auto-install]  whether the required plugin is installed when it's not installed yet.
 *
 * @default_private
 * @todo a later version should also clear models and thus undo state
 */
apf.offline.application = {
    enabled   : false,
    urls      : [],
    providers : ["deskrun", "gears"],

    init : function(aml){
        if (this.enabled)
            return;

        this.namespace = apf.config.name + ".apf.offline.application";

        if (typeof aml == "string") {
            this.providers = aml.split("|");
        }
        else if (aml.nodeType) {
            if (aml.getAttribute("version-get"))
                this.application.versionGet = aml.getAttribute("version-get");

            if (aml.getAttribute("providers"))
                this.providers = aml.getAttribute("providers").split("|");

            if (aml.getAttribute("auto-install"))
                this.autoInstall = apf.isTrue(aml.getAttribute("auto-install"));
        }

        //Check for an available offline provider
        for (var i = 0; i < this.providers.length; i++) {
            if (!this[this.providers[i]]) {
                
                apf.console.warn("Module not loaded for offline provider: "
                                    + this.providers[i]);
                
                continue;
            }

            if (this[this.providers[i]].isAvailable()) {
                this.provider = this[this.providers[i]].init(this.storeName);

                if (this.provider !== false) {
                    this.provider.name = this.providers[i];
                    break;
                }
            }
        }

        //@todo if online please check if the latest version is loaded here

        if (!this.provider) {
            if (this.autoInstall) {
                if (this.install() === false) {
                    
                    apf.console.warn("Could not install any of the preferred \
                                         offline providers:"
                                        + this.providers.join(", "));
                    

                    apf.offline.application = null; //Can't put the app offline
                    return this.providers[0];
                }
            }
            else {
                
                apf.console.warn("Could not find any of the specified \
                                     offline providers:"
                                    + this.providers.join(", "));
                

                apf.offline.application = null; //Can't put the app offline
                return this.providers[0];
            }
        }

        if (!apf.loaded) { //@todo you might want to consider creating single run events
            apf.addEventListener("load", function(){
                if (apf.offline.application.enabled)
                    apf.offline.application.save();
                apf.removeEventListener("load", arguments.callee);
            });
        }
        else {
            apf.offline.addEventListener("load", function(){
                apf.offline.application.save();
            });
        }

        this.enabled = true;

        return this.provider.name;
    },

    install : function(){
        if (apf.offline.dispatchEvent("beforeinstall") === false) {
            
            apf.console.warn("Installation cancelled");
            
            return false;
        }

        for (var i = 0; i < this.providers.length; i++) {
            if (!this[this.providers[i]])
                continue;

            if (this[this.providers[i]].install()) {
                this.provider = this[this.providers[i]].init(this.storeName);

                if (this.provider !== false)
                    break;
            }
        }

        apf.offline.dispatchEvent("afterinstall");

        if (!this.provider)
            return false;
    },

    clear : function(){
        if (this.provider)
            this.provider.clear();
    },

    cache : function(url){
        //if(!new apf.url(url).isSameLocation())
            //return;
        if (url.indexOf(":") > -1 && url.indexOf("http://" + location.host) == -1)
            return;

        this.urls.pushUnique(url.replace(/\#.*$/, ""));
    },

    remove : function(url){
        this.urls.remove(url)
    },

    refresh : function(callback){
        var storage = apf.offline.storage;

        if(this.versionGet){
            var oldVersion = storage.get("oldVersion", this.namespace);
            var newVersion = null;
            var _self      = this;

            apf.getData(this.versionGet, {callback:
                function(newVersion, state, extra){
                    if (state == apf.TIMEOUT)
                        return extra.tpModule.retryTimeout(extra, state, apf.offline);

                    if (state == apf.OFFLINE)
                        return;

                    if (state == apf.ERROR)
                        storage.remove("oldVersion", _self.namespace);

                    if (apf.debug || !newVersion || !oldVersion
                        || oldVersion != newVersion){

                        
                        apf.console.info("Refreshing offline file list");
                        

                        
                        if (apf.offline.state.enabled) {
                            apf.offline.state.clear();

                            if (apf.offline.state.realtime)
                                apf.offline.state.search();
                        }
                        

                        _self.search();
                        _self.provider.store(_self.urls,
                            callback, newVersion);
                    }
                    else{
                        
                        apf.console.info("No need to refresh offline file list");
                        

                        callback({
                            finished : true
                        });
                    }
                }
            });
        }
        else{
            
            apf.console.info("Refreshing offline file list");
            

            this.search();
            this.provider.store(this.urls, callback);
        }
    },

    //forEach???
    search : function(){
        //Html based sources
        this.cache(window.location.href);

        var i, nodes = document.getElementsByTagName("script");
        for (i = 0; i < nodes.length; i++)
            this.cache(nodes[i].getAttribute("src"));

        nodes = document.getElementsByTagName("link");
        for (i = 0; i < nodes.length; i++){
            if((nodes[i].getAttribute("rel") || "").toLowerCase() == "stylesheet")
                continue;

            this.cache(nodes[i].getAttribute("href"));
        }

        nodes = document.getElementsByTagName("img");
        for (i = 0; i < nodes.length; i++)
            this.cache(nodes[i].getAttribute("src"));

        nodes = document.getElementsByTagName("a");
        for (i = 0; i < nodes.length; i++)
            this.cache(nodes[i].getAttribute("href"));

        // @todo handle 'object' and 'embed' tag

        // parse our style sheets for inline URLs and imports
        var _self = this, j, rule, sheet, sheets = document.styleSheets;
        for (i = 0; i < sheets.length; i++) {
            sheet = sheets[i];
            if (apf.isIE) { //@todo multibrowser test this
                if (sheet.readOnly) {
                    sheet.cssText.replace(/url\(\s*([^\) ]*)\s*\)/gi, function(m, url){
                        _self.cache(url);
                        return "";
                    });
                }
            }
            else {
                if (sheet.ownerNode.tagName == "STYLE")
                    continue;

                for (j = 0; j < sheet.cssRules.length; j++) {
                    rule = sheet.cssRules[j].cssText;
                    if(!rule)
                        continue;

                    rule.replace(/url\(\s*([^\) ]*)\s*\)/gi, function(m, url){
                        _self.cache(url);
                        return "";
                    });
                }
            }
        }

        //Cache Skin CSS
        apf.skins.loadedCss.replace(/url\(\s*([^\) ]*)\s*\)/gi, function(m, url){
            _self.cache(url);
            return "";
        });

        //Aml based sources
        //@todo apf3.x this needs to be rewritten
        /*if (apf.AmlParser.$aml) { 
            function callback(item){
                if(!item.nodeType) return;

                var nodes = item.selectNodes("//include/@src|//skin/@src");
                for (var i = 0; i < nodes.length; i++) {
                    _self.cache(nodes[i].nodeValue);
                }
            }

            callback(apf.AmlParser.$aml);
            apf.includeStack.forEach(callback);
        }*/

        //Cached resources??
    },

    save : function(callback){
        if (!apf.offline.onLine) {
            var func = function(){
                apf.offline.application.save();
                apf.offline.removeEventListener("afteronline", func)
            }
            apf.offline.addEventListener("afteronline", func);

            return;
        }

        this.refresh(callback);
    }
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/offline/gears.js)SIZE(4720)TIME(1257329186)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Offline provider that uses Google gears.
 * @default_private
 */
apf.offline.application.gears = {
    localServer : null,
    lastStore   : null,
    cancelID    : null,
    refreshing  : false,
    fileIndex   : 0,
    
    init : function(){
        // clip at 64 characters, the max length of a resource store name
        this.name = this.storeName.truncate(64);
        this.storeName = apf.config.name + ".apf.offline";
        
        try{
            this.localServer = apf.nameserver.get("google", "gears").create("beta.localserver", "1.0");
        }
        catch(e){
            apf.console.warn("Error loading gears: " + e.message);
            return false;
        }
        
        return this;
    },
    
    install : function(){
        //@todo make a script to install gears here
        
        apf.isGears = true;
    },
    
    isAvailable : function(){
        return apf.isGears && location.protocol != "file:";
    },
    
    clear : function(){
        this.localServer.removeStore(this.name);
    },
    
    store : function(listOfURLs, callback, newVersion){
        // refresh everything by simply removing
        // any older stores
        this.localServer.removeStore(this.name);
        
        // open/create the resource store
        this.localServer.openStore(this.name);
        
        try {
            var store = this.lastStore = this.localServer.createStore(this.name);
        }
        catch(e) {
            
            apf.console.warn("Gears failed to start local storage: " + e.message);
            
            
            return false;
        }

        // add our list of files to capture
        var _self       = this;
        this.refreshing = true;
        this.fileIndex  = 0;
        this.cancelID   = store.capture(listOfURLs, 
            function(url, success, captureId){
                if (!success && _self.refreshing) {
                    _self.cancelID   = null;
                    _self.refreshing = false;
                    
                    if (callback) {
                        callback({
                            error   : true,
                            message : "Unable to capture " + url
                        });
                    }
                    
                    return;
                }
                else if (success) {
                    _self.fileIndex++;
                    
                    if (callback) {
                        callback({
                            position : _self.fileIndex,
                            length   : listOfURLS.length // @fixme: where is listOfURLS ???
                        });
                    }
                }
                
                if (success && _self.fileIndex >= listOfURLs.length) {
                    _self.cancelID   = null;
                    _self.refreshing = false;
                    
                    if(newVersion)
                        apf.storage.put("oldVersion", newVersion, null,
                            apf.offline.application.storeName);
                    
                    if (callback) {
                        callback({
                            finished : true
                        });
                    }
                }
            });
    },
    
    abort: function(){
        // summary:
        //    For advanced usage; most developers can ignore this.
        //    Aborts and cancels a refresh.
        if (!this.refreshing)
            return;
        
        this.lastStore.abortCapture(this.cancelID);
        this.refreshing = false;
    }
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/offline/transactions.js)SIZE(9618)TIME(1257329186)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Object recording the state of actiontrackers. When an application goes 
 * offline, the state is maintained such that it can be synced at a later date.
 * The actiontracker state can be maintained even when the application restarts.
 * In most cases the functionality of this object will be managed from within 
 * the offline element in AML.
 * Example:
 * <code>
 *  <a:offline ontransactioncancel="alert('You are currently offline')" />
 * </code>
 *
 * @define offline
 * @event transactioncancel Fires before installation of an offline provider
 *   enableable Cancels the installation of the offline provider
 *
 * @default_private
 * @todo remove serialize here
 */
apf.offline.transactions = {
    enabled   : false,
       
    init : function(){
        this.namespace = apf.config.name + ".apf.offline.transactions";
        this.enabled   = true;
        
        
        apf.addEventListener("load", function(){
            apf.offline.transactions.rebuildActionQueues();
            apf.removeEventListener("load", arguments.callee);
        });
        
    },
        
    /*
     * data GET requests aren't synced but disallowed, 
     * such as load/insert bindings and model load=""
     * This function will sent the ontransactioncancel event which 
     * can be used to notify the user that we're offline.
     */
    actionNotAllowed : function(){
        apf.offline.dispatchEvent("transactioncancel", {
            message : "Transaction is not allowed",
            bubbles : true
        });
        
        return;
    },
    
    //@todo you might want to error on dotts in the at name
    addAction : function(at, qItem, type){
        
        if (!at.name || !apf.storage.base.isValidKey(at.name)) {
            //@todo
            throw new Error("Invalid or missing name for actiontracker \
                used for offline transactions '" + at.name + "'.");
        }
        
        
        var namespace = this.namespace + "." + at.name + "." + type;
        var storage   = apf.offline.storage;
        var len       = parseInt(storage.get("length", namespace)) || 0;
        
        storage.put(len, apf.serialize(type == "queue"
            ? {
                undo    : qItem.undo,
                undoObj : qItem.undoObj.$export()
            }
            : qItem.$export()), namespace);
        storage.put("length", ++len, namespace);
    },
    
    removeAction : function(at, fromTop, type){
        var namespace = this.namespace + "." + at.name + "." + type;
        var storage   = apf.offline.storage;
        
        //@todo add checks for stack sanity
        if (fromTop) {
            var len = parseInt(storage.get("length", namespace)) - 1;
            var start = parseInt(storage.get("start", namespace)) || 0;
            
            
            if (len < 0) {//@todo
                throw new Error("something went terribly wrong"); 
            }
            
            
            if (start == len || len < 0) {
                storage.clear(namespace);
                return;
            }
            
            storage.remove(len, namespace);
            storage.put("length", len, namespace);
        }
        else {
            var start = parseInt(storage.get("start", namespace)) || 0;
            var len = parseInt(storage.get("length", namespace)) || 0;
            
            if (start + 1 == len) {
                storage.clear(namespace);
                return;
            }
            
            storage.remove(start, namespace)
            storage.put("start", ++start, namespace);
        }
    },
    
    rebuildActionQueues : function(){
        var storage    = apf.offline.storage;
        var namespaces = storage.getNamespaces();
        if (!namespaces) return;
        var lookup, re = new RegExp(this.namespace + "\\.([^\\.]*)\\.([^\\.]*)");

        for (var ats = [], i = 0; i < namespaces.length; i++) {
            if (namespaces[i].match(re))
                ats.push([RegExp.$1, RegExp.$2]);
        }
        
        var i, j, qItem, stack, namespace, at, start, len, type;
        for (i = 0; i < ats.length; i++) {
            at        = apf.nameserver.get("actiontracker", ats[i][0]);
            type      = ats[i][1];
            
            
            if (!at) { //@todo
                throw new Error(apf.formatErrorString(0, null,
                    "Rebuilding Action Queue",
                    "An actiontracker could not be found by the name of '" 
                    + ats[i][0] + "'"));
            }
            
            
            lookup    = {};
            namespace = this.namespace + "." + at.name + "." + type;
            storage.getAllPairs(namespace, lookup);
            
            start     = parseInt(lookup["start"]) || 0;
            len       = parseInt(lookup["length"]) || 0;
            stack     = [];
            
            
            apf.console.info("Restoring " + type + " stack for " 
                             + (at.name == "default"
                                ? "the default actiontracker"
                                : "the '" + at.name + "' actiontracker")
                             + " of " + len + " items.");
            

            if (type == "queue") {
                for (j = len - 1; j >= start; j--) {
                    qItem            = apf.unserialize(lookup[j]);
                    qItem.undoObj    = new apf.UndoData(qItem.undoObj, at).$import();
                    stack.unshift(qItem);
                }
            }
            else {
                for (j = len - 1; j >= start; j--) {
                    qItem    = apf.unserialize(lookup[j]);
                    stack.unshift(new apf.UndoData(qItem, at).$import());
                }
            }
            
            at.$loadQueue(stack, type);
            
            apf.offline.sLookup = null;
        }
    },
    
    clearActions : function(at, type){
        apf.offline.storage.clear(this.namespace + "." + at.name + "." + type);
    },
    
    clear : function(queues){
        if (!queues)
            queues = "undo|redo|queue";
        
        var storage    = apf.offline.storage;
        var namespaces = storage.getNamespaces();
        var re         = new RegExp(this.namespace + "\\.([^\\.]*)\\.(" + queues + ")");
        
        for (var i = 0; i < namespaces.length; i++) {
            if (namespaces[i].match(re))
                storage.clear(namespaces[i]);
        }
    },
    
    stopSync : function(callback){
        //No stopping here.. the queue will fill itself automatically
        callback();
    },

    getSyncLength : function(){
        var ats = apf.nameserver.getAll("actiontracker");
        
        var len = 0;
        for (var i = 0; i < ats.length; i++)
            len += ats[i].$getQueueLength();
        
        return len;
    },

    sync : function(callback){
        var ats = apf.nameserver.getAll("actiontracker");
        
        var qNr = 0, len = 0;
        for (var i = 0; i < ats.length; i++) {
            if (ats[i].$getQueueLength()) {
                len += ats[i].$getQueueLength();
                ats[i].$startQueue(function(last){
                    if (qNr >= len - 1)
                        return false; //silently ignore later changes... (might be wrong)
                    
                    if (last)
                        qNr = len;
                    
                    callback({
                        position : ++qNr,
                        length   : len
                    });
                    
                    if(qNr >= len - 1)
                        callback({finished: true});
                });
            }
        }
    }
};

/**
 * Determines whether it's possible to start a new action.
 * @private
 * @method
 */
apf.offline.canTransact = function(){
    if(!apf.offline.enabled || this.onLine || this.transactions.enabled)
        return true;
    
    //Transactions can be enabled from this event
    if(this.dispatchEvent("transactioncancel", {
        message : "Could not execute transaction whilst being offline,\
                   silently doing nothing",
        bubbles : true
    }) === true)
        return true;
    
    return false;
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/offline/detector.js)SIZE(4827)TIME(1259708671)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Object detecting if the application has network, the detection moments can
 * be manual, automatic or only when a communication error occurs. In most
 * cases the functionality of this object will be managed from within the
 * offline element in AML.
 * Example:
 * <code>
 *  <a:offline
 *      detect-url  = "netork.txt"
 *      detection   = "auto"
 *      interval    = "2000" />
 * </code>
 *
 * @define offline
 * @attribute {String} [detect-url] a datainstruction for getting a version number of the current application
 * @attribute {String} [detection]  a pipe seperated list of possible providers.
 *   Possible values:
 *   auto   Automatically detect whether the network is available by retrieving the file specified in the detect-url attribute
 *   manual Disable automatic or error based detection
 *   error  Only detect network state when a communication timeout occurs.
 * @attribute {Boolean} [interval]  whether the required plugin is installed when it's not installed yet.
 *
 * @default_private
 */
apf.offline.detector = {
    
    detectUrl : apf.basePath + "core/lib/offline/network_check.txt",
    
    detection : "auto", //manual|auto|error
    interval  : 5000,

    init : function(aml){
        if (aml.nodeType) {
            if (aml.getAttribute("detect-url"))
                this.detectUrl = aml.getAttribute("detect-url");
            
            else
                this.detectUrl = (apf.config.resourcePath || apf.basePath)
                    + "resources/network_check.txt";
            

            this.detection = apf.isTrue(aml.getAttribute("detection"))
                ? "auto"
                : aml.getAttribute("detection") || "auto";

            if (aml.getAttribute("interval"))
                this.interval = parseInt(aml.getAttribute("interval"));
        }

        if ("error|auto".indexOf(this.detection) > -1) {
            apf.addEventListener("error", function(e){
                //Timeout detected.. Network is probably gone
                if (e.state == apf.TIMEOUT) {
                    //Let's try to go offline and return false to cancel the error
                    return !apf.offline.goOffline();//callback //@todo callback???
                }
            });
        }

        this.oHttp = new apf.http();
        this.oHttp.timeout = this.interval;

        //Check if we have connection right now
        this.isSiteAvailable();

        if (this.detection == "auto")
            this.start();
    },

    isSiteAvailable : function(callback){
        this.oHttp.get(apf.getNoCacheUrl(this.detectUrl), {
            callback: function(data, state, extra){
                if(state != apf.SUCCESS || !window.navigator.onLine){
                    apf.offline.goOffline(callback); //retry here??
                }
                else{
                    apf.offline.goOnline(callback);
                }
            },
            ignoreOffline  : true,
            hideLogMessage : true
        });
    },

    /**
     * Start automatic network availability detection
     */
    start : function(){
        clearInterval(this.timer);

        
        apf.console.info("Automatic detection of network state is activated");
        

        var _self = this;
        this.timer = setInterval(function(){
            _self.isSiteAvailable();
        }, this.interval);
    },

    /**
     * Stop automatic network availability detection
     */
    stop : function(){
        clearInterval(this.timer);

        
        apf.console.info("Detection of network state is deactivated");
        
    }
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/offline/models.js)SIZE(5419)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Object dealing with the storing the state of models for use offline. In
 * most cases the functionality of this object will be managed from within the
 * offline element in AML.
 * Example:
 * <code>
 *  <a:offline realtime="true" />
 * </code>
 *
 * @define offline
 * @attribute {Boolean} [realtime]  whether changes are stored realtime.
 *
 * @default_private
 */
apf.offline.models = {
    enabled   : false,
    timer     : null,
    models    : {},
    initQueue : [],
    realtime  : true,

    init      : function(aml){
        this.namespace = apf.config.name + ".apf.offline.models";

        if (aml.nodeType && aml.getAttribute("realtime"))
            this.realtime = !apf.isFalse(aml.getAttribute("realtime"));

        if (!this.realtime) {
            apf.addEventListener("exit", function(){
                apf.offline.models.search();
            });
        }

        //@todo what to do if we're not realtime

        this.enabled = true;
    },

    markForUpdate : function(model){
       this.models[model.$uniqueId] = model;

        if(!this.timer){
            var _self = this;
            this.timer = $setTimeout(function(){
                _self.timer = null;
                var models  = _self.models;

                for (var mId in models) {
                    _self.updateModel(models[mId]);
                }

                _self.models = {};
            }, 2000);
        }
    },

    clear : function(){
        apf.offline.storage.clear(this.namespace);
    },

    removeModel : function(model){
        var name = model.name || model.$uniqueId + ".model";

        //Remove recorded data of this model
        apf.offline.storage.remove(name, this.namespace);

        //Remove the model from the init queue
        this.initQueue.remove(model);
    },

    updateModel : function(model){
        var name = model.name || model.$uniqueId + ".model";

        
        apf.console.info("Updating model '" + name + "'");
        

        /*
            This could be optimized by only recording the changes to the
            data. At load/exit these could be purged.
        */

        var docId = model.data.getAttribute(apf.xmldb.xmlDocTag);
        model.data.setAttribute(apf.xmldb.xmlDocTag + "_length",
            apf.xmldb.nodeCount[docId]);

        apf.offline.storage.put(name, model.data.xml || model.data.serialize(), this.namespace);
    },

    loadModel : function(model){
        var name = model.name || model.$uniqueId + ".model";

        var data = apf.offline.storage.get(name, this.namespace);
        if (!data) return false;

        
        apf.console.info("Loading model '" + name + "' from local storage");
        

        var xmlNode = apf.getXmlDom(data).documentElement;
        var docId   = xmlNode.getAttribute(apf.xmldb.xmlDocTag);
        apf.xmldb.nodeCount[docId]
            = parseInt(xmlNode.getAttribute(apf.xmldb.xmlDocTag + "_length"));

        model.load(xmlNode);
        return true;
    },

    search : function(){
        //Save all the models

        var done = {}, models = apf.nameserver.getAll("model");
        for (var i = 0; i < models.length; i++) {
            if (done[models[i].$uniqueId])
                continue;

            done[models[i].$uniqueId] = true;
            this.updateModel(models[i]);
        }

        return true;
    },

    addToInitQueue : function(model){
        this.initQueue.pushUnique(model);
        model.session = false;
    },

    stopSync : function(callback){
        //No stopping here.. the queue will fill itself automatically
        callback();
    },

    getSyncLength : function(){
        return this.initQueue.length;
    },

    sync : function(callback){
        //We assume we're online now, but just in case we clear the queue
        var queue = this.initQueue.slice();
        this.initQueue.length = 0;

        var qNr = 0, len = queue.length;
        for (var i = 0; i < queue.length; i++) {
            queue[i].init(function(){
                callback({
                    position : ++qNr,
                    length   : len
                });

                if(qNr == len - 1)
                    callback({finished: true});
            });
        }
    }
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/offline/queue.js)SIZE(7008)TIME(1257329186)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Object handling queuing of actions that can only be executed whilst online.
 * These actions are stored in the queue and executed in serie when the 
 * application comes online again. This is done after apf.auth has logged the
 * user into the application again, if necesary. This object is used for HTTP
 * XMPP and Webdav, but is general purpose and can be used to store any 
 * action that should only be executed while online. 
 *
 * @default_private
 */
apf.offline.queue = {
    enabled : false,
    stack   : [],
    
    init : function(){
        this.namespace = apf.config.name + ".apf.offline.queue";
        this.enabled   = true;
    },
    
    add : function(commInfo){
        var namespace = this.namespace;
        var storage   = apf.offline.storage;
        var len       = parseInt(storage.get("length", namespace)) || 0;
        
        //Add the commInfo to the stack
        this.stack[len] = commInfo; //retry this on sync
        
        //Check here for xml nodes in storeInfo??
        
        //Store http info
        storage.put(len, apf.serialize(commInfo), namespace);
        storage.put("length", ++len, namespace);

        /*
            If there's a callback, we'll inform it that we're not
            executing the call because we're offline. 
        */
        var callback = commInfo.callback;
        if (!commInfo.undoObj && callback) {
            
            var strWarn = "The application is currently offline. Your \
                           request will be retried when the application \
                           goes online again. Please be aware that when the\
                           request is finally made, this callback might\
                           not be available anymore. Therefore the state of\
                           the data should already represent the state of\
                           the application that a succesfull execution of\
                           the request communicates. You might want to look\
                           at using an actiontracker.";
            
            apf.console.warn(strWarn);
            
            
            callback(null, apf.OFFLINE, apf.extend({
                offline : true
                
                , message : strWarn
                
            }, commInfo));
        }
    },
    
    stopSync : function(callback){
        this.stop = callback;
    },
    
    getSyncLength : function(){
        return parseInt(apf.offline.storage.get("length", this.namespace)) || 0;
    },
    
    //Sync all transactions, let offline decide when
    sync : function(callback, isStarted){
        if (this.stop) {
            this.stop();
            this.stop = null;
            return 
        }

        var namespace = this.namespace;
        var storage   = apf.offline.storage;
        var len       = parseInt(storage.get("length", namespace)) || 0;
        var start     = parseInt(storage.get("start", namespace)) || 0;
        var commInfo;

        if (this.stack[start]) {
            commInfo = this.stack[start];
        }
        else {
            commInfo = this.$getCommInfo(storage.get(start, namespace));
            if (!commInfo) {
                
                apf.console.error("Error syncing queue items. This is a serious\
                error. The queue stack has become corrupted. It will now be \
                cleared and the queued offline messages will be lost!"); //@todo
                
                
                this.clear();
                apf.offline.stopSync();
                
                return callback({finished: true});
            }
            
            this.stack[start] = commInfo;
        }
        
        if (!commInfo.callback2) {
            commInfo.callback2 = commInfo.callback;

            commInfo.callback  = function(data, state, extra){
                //We'll let the main callback decide if this one should be retries
                if (commInfo.callback2 && 
                  commInfo.callback2.apply(window, arguments) === true) {
                    //@todo: Warning here??
                    
                    return true;
                }
                
                // We're done with this one
                storage.remove(start, namespace);
                storage.put("start", start+1, namespace);
                apf.offline.queue.stack[start] = null;
                
                callback({
                    position : start,
                    length   : len,
                    info     : commInfo
                });
                
                if (start == len - 1) {
                    //Sync is completely done
                    storage.clear(namespace);
                    
                    callback({
                        finished : true
                    });
                }
                else {
                    //Next!
                    apf.offline.queue.sync(callback, true);
                }
            }
        }
        
        this.stack[start].retry();
    },
    
    clear : function(){
         apf.offline.storage.clear(this.namespace);
    },
    
    $getCommInfo : function(strCommItem){
        if (!strCommItem)
            return false;
        
        var commObject, commInfo = apf.unserialize(strCommItem);
        for (var i = 0; i < commInfo.$object.length; i++) {
            commObject = self[commInfo.$object[i]] || eval(commInfo.$object[i]);
            if (commObject)
                break;
        }
        
        
        if (!commObject) {
            //@todo
        }
        
        
        commInfo.object = commObject;
        commInfo.retry  = new Function(commInfo.$retry);
        
        return commInfo;
    }
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/offline/state.js)SIZE(8067)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */







/**
 * Object recording the state of all elements. If the realtime attribute is
 * set the state of the elements is recorded realtime. Otherwise it is 
 * recorded only when the application exits. During startup the state of the 
 * application can be restored by cancelling the 'restore' event. In most cases 
 * the functionality of this object will be managed from within the offline 
 * element in AML.
 * Example:
 * <code>
 *  <a:offline 
 *    realtime  = "true" 
 *    set       = "store_session.jsp" 
 *    onrestore = "return confirm('Would you like to continue where you left of?')" />
 * </code>
 *
 * @event restore Fires before restoring the application to the predefined state.
 *   cancelable: Loads the stored state into the applicaton.
 *
 * @define offline
 * @attribute {String} [set]    a datainstruction that stores the state of the application to an external data store.
 *
 * @default_private
 * @todo optimize by not getting the default values from the aml
 */
apf.offline.state = {
    enabled   : false,
    states    : {},
    realtime  : true,
    lookup    : {},

    init : function(aml){
        this.namespace = apf.config.name + ".apf.offline.state";
        
        if (aml.nodeType) {
            if (aml.getAttribute("realtime"))
                this.realtime = !apf.isFalse(aml.getAttribute("realtime"));
            
            if (aml.getAttribute("set"))
                this.setInstruction = aml.getAttribute("set");
        }
        
        apf.addEventListener("exit", function(){
            if (!apf.offline.state.realtime) {
                //apf.offline.state.search();
                var lookup  = apf.offline.state.lookup;
                var storage = apf.offline.storage;
                var ns      = apf.offline.state.namespace;
                
                for (var key in lookup) {
                    var ns = apf.offline.state.namespace;
                    storage.put(key, lookup[key], ns);
                }
            }
            
            if (apf.offline.state.setInstruction)
                apf.offline.state.send();
        });
        
        
        var registry       = apf.extend({}, apf.offline.storage || apf.storage);
        registry.namespace = apf.config.name + ".apf.registry";
        apf.registry.$export(registry);
        apf.registry       = registry;
        

        //@todo This could be optimized if needed
        if (apf.offline.storage.getAllPairs(this.namespace, this.lookup)) {
            /*
                This is the moment the developer should do something like:
                return confirm("Would you like to continue your previous session?");
            */
            if (apf.offline.dispatchEvent("restore") === false) {
                this.clear();
                this.lookup = {};
                
                
                apf.offline.transactions.clear("undo|redo");
                
            }
        }
        
        

        apf.offline.transactions.doStateSync = true;
        
        
        this.enabled = true;
    },

    warned  : false,
    timeout : {},
    set : function(obj, key, value){
        
        if (!obj.name && !this.warned) {
            this.warned = true;
            apf.console.warn("Components found without name. This means that \
                              when the application changes the state \
                              serialization can break.");
        }
        

        if (!obj.tagName)
            return;
        
        var name    = obj.name || obj.$uniqueId + "_" + obj.tagName;
        var storage = apf.offline.storage;
        
        
        if (!name || !storage.isValidKey(name)) { //@todo
            throw new Error("invalid")
        }
        
        if (!storage.isValidKey(key)) { //@todo
            throw new Error("invalid")
        }
        
        
        /*
            Using a timeout here, is an optimization for fast changing 
            properties such as slider values. 
        */
        key = name + "." + key;
        this.lookup[key] = value;
        
        if (!this.realtime)
            return;
        
        var ns = this.namespace;
        clearTimeout(this.timeout[key]);
        this.timeout[key] = $setTimeout(function(){
            storage.put(key, value, ns);
        }, 200);
    },
    
    get : function(obj, key, value){
        return this.lookup[(obj.name || obj.$uniqueId + "_" + obj.tagName) + "." + key];
        
        /*return apf.offline.storage.get(
            (obj.name || obj.$uniqueId + "." + obj.tagName) + "." + key, 
            this.namespace);*/
    },
    
    //blrgh.. unoptimized
    getAll : function(obj) {
        var prop, res = {}, x,
            name = obj.name || obj.$uniqueId + "_" + obj.tagName;
        for (prop in this.lookup) {
            x = prop.split(".");
            if (x[0] == name)
                res[x[1]] = this.lookup[prop];
        }
        
        return res;
    },
    
    clear : function(){
        apf.offline.storage.clear(this.namespace);
        
        var ns = apf.registry.getNamespaces();
        for (var i = 0; i < ns.length; i++) {
            apf.registry.clear(ns[i]);
        }
        
        
        apf.offline.transactions.clear("undo|redo");
        
    },

    search : function(){
        var storage = apf.offline.storage;
        
        //Search for dynamic properties
        var props, i, j, nodes = apf.all;
        for (i = 0; i < nodes.length; i++) {
            if (nodes[i].name && nodes[i].getAvailableProperties) {
                props = nodes[i].getAvailableProperties();
                for (j = 0; j < props.length; j++) {
                    if (nodes[i][props[j]])
                        this.set(nodes[i], props[j], nodes[i][props[j]]);
                }
            }
        }
        
        //@todo Search for actiontracker stacks
        
        //@todo Search for selection states
    },
    
    send : function(){
        var storage = apf.offline.storage;
        
        var data = {};
        var keys = storage.getKeys(this.namespace);
        
        for (var i = 0; i < keys.length; i++) {
            data[keys[i]] = storage.get(keys[i], this.namespace);
        }
        
        apf.saveData(this.setInstruction, {
            ignoreOffline : true,
            data          : apf.serialize(data),
            callback      : function(data, state, extra){
                if (extra.tpModule.retryTimeout(extra, state, apf.offline) === true)
                    return true;
            }
        });
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/uirecorder.js)SIZE(40121)TIME(1265032028)*/





/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/printer.js)SIZE(4398)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @private
 */
apf.printer = {
    tagName  : "printer",
    nodeFunc : apf.NODE_HIDDEN,
    
    lastContent : "",
    inited      : false,
    
    init : function(aml){
        this.inited = true;
        this.$aml    = aml;
        
        this.contentShower = document.body.appendChild(document.createElement("DIV"));
        this.contentShower.id = "print_content"
        
        with (this.contentShower.style) {
            width           = "100%";
            height          = "100%";
            backgroundColor = "white";
            zIndex          = 100000000;
        }
        
        apf.importCssString("#print_content{display:none}");
        apf.importCssString((apf.hasCSSChildOfSelector
          ? "body #print_content{display:block} body>*{display:none}"
          : "body #print_content, body #print_content *{display:block} body *{display:none}")
            , "print");

        //body #print_content, body #print_content *{display:block} 
        
        if (aml) {
            //Events
            var a, i, attr = aml.attributes;
            for (i = 0; i < attr.length; i++) {
                a = attr[i];
                if (a.nodeName.indexOf("on") == 0)
                    apf.addEventListener(a.nodeName, 
                      
                      apf.lm.compile(a.nodeValue, {event: true, parsecode: true})
                      
                    );
            }
        }

        
        function printPNGFix(disable) {
            if (apf.supportPng24) return;
            
            if (!apf.config.iePngFix) return;
            
            for (var e, i = 0, j = document.all.length; i < j; i++) {
                e = document.all[i];
                if (e.filters['DXImageTransform.Microsoft.AlphaImageLoader'] || e._png_print) {
                    if (disable) {
                        e._png_print   = e.style.filter;
                        e.style.filter = '';
                    }
                    else {
                        e.style.filter = e._png_print;
                        e._png_print   = '';
                    }
                }
            }
        }
        
        
        window.onbeforeprint = function(){
            
            printPNGFix(true);
            
            apf.dispatchEvent("beforeprint");
        };
        
        window.onafterprint = function(){
            
            printPNGFix(false);
            
            apf.dispatchEvent("afterprint");
        };
    },
    
    preview : function(strHtml){
        if (!this.inited)
            this.init();
        
        if (typeof strHtml != "string")
            strHtml = strHtml.outerHTML || strHtml.xml || strHtml.serialize();
        
        this.lastContent = strHtml;
        this.contentShower.innerHTML = strHtml;
    }
};

/**
 * Sents html to a printer in formatted form.
 * @param {String} strHtml the html to be printed.
 */
apf.print = function(strHtml){
    if (!apf.printer.inited)
        apf.printer.init();
    
    apf.printer.preview(strHtml);
    window.print();
}




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/tween.js)SIZE(25459)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * The animation library that is used for the animations inside elements
 * @default_private
 */
apf.tween = {
    //Animation Modules
    left: function(oHtml, value){
        oHtml.style.left = value + "px";
    },
    right: function(oHtml, value){
        oHtml.style.left  = "";
        oHtml.style.right = value + "px";
    },
    top: function(oHtml, value){
        oHtml.style.top = value + "px";
    },
    bottom: function(oHtml, value){
        oHtml.style.top    = "";
        oHtml.style.bottom = value + "px";
    },
    width: function(oHtml, value, center){
        oHtml.style.width = value + "px";
    },
    height: function(oHtml, value, center){
        oHtml.style.height = value + "px";
    },
    scrollTop: function(oHtml, value, center){
        oHtml.scrollTop = value;
    },
    scrollLeft: function(oHtml, value, center){
        oHtml.scrollLeft = value;
    },
    "height-rsz": function(oHtml, value, center){
        oHtml.style.height = value + "px";
        if (apf.hasSingleResizeEvent)
            window.onresize();
    },
    mwidth: function(oHtml, value, info) {
        var diff = apf.getDiff(oHtml);
        oHtml.style.width = value + "px";
        oHtml.style.marginLeft = -1 * (value / 2 + (parseInt(apf.getStyle(oHtml,
            "borderLeftWidth")) || diff[0]/2) + (info.margin || 0)) + "px";
    },
    mheight: function(oHtml, value, info) {
        var diff = apf.getDiff(oHtml);
        oHtml.style.height = value + "px";
        oHtml.style.marginTop = (-1 * value / 2 - (parseInt(apf.getStyle(oHtml,
            "borderTopWidth")) || diff[1]/2) + (info.margin || 0)) + "px";
    },
    scrollwidth: function(oHtml, value){
        oHtml.style.width = value + "px";
        oHtml.scrollLeft  = oHtml.scrollWidth;
    },
    scrollheight_old: function(oHtml, value){
        try {
            oHtml.style.height = value + "px";
            oHtml.scrollTop    = oHtml.scrollHeight;
        }
        catch (e) {
            alert(value)
        }
    },
    scrollheight: function(oHtml, value, info){
        var diff = apf.getHeightDiff(oHtml),
            oInt = info.$int || oHtml;
            
        oHtml.style.height = Math.max((value + (info.diff || 0)), 0) + "px";
        oInt.scrollTop     = oInt.scrollHeight - oInt.offsetHeight - diff + (info.diff || 0);
    },
    scrolltop: function(oHtml, value){
        oHtml.style.height = value + "px";
        oHtml.style.top    = (-1 * value - 2) + "px";
        oHtml.scrollTop    = 0;//oHtml.scrollHeight - oHtml.offsetHeight;
    },
    clipright: function(oHtml, value, center){
        oHtml.style.clip       = "rect(auto, auto, auto, " + value + "px)";
        oHtml.style.marginLeft = (-1 * value) + "px";
    },
    fade: function(oHtml, value){
        if (apf.hasStyleFilters)
            oHtml.style.filter  = "alpha(opacity=" + parseInt(value * 100) + ")";
        //else if(false && apf.isGecko) oHtml.style.MozOpacity = value-0.000001;
        else
            oHtml.style.opacity = value;
    },
    bgcolor: function(oHtml, value){
        oHtml.style.backgroundColor = value;
    },
    textcolor: function(oHtml, value){
        oHtml.style.color = value;
    },
    htmlcss : function(oHtml, value, obj){
        if (apf.hasStyleFilters && obj.type == "filter")
            oHtml.style.filter = "progid:DXImageTransform.Microsoft.Alpha(opacity=" + value + ")";
        else
            oHtml.style[obj.type] = value + (obj.needsPx ? "px" : "");
    },

    /** Linear tweening method */
    NORMAL: 0,
    /** Ease-in tweening method */
    EASEIN: 1,
    /** Ease-out tweening method */
    EASEOUT: 2,

    CSSTIMING: ["linear", "ease-in", "ease-out", "ease", "ease-in-out", "cubic-bezier"],
    CSSPROPS : {
        "left"        : "left",
        "right"       : "right",
        "top"         : "top",
        "bottom"      : "bottom",
        "width"       : "width",
        "height"      : "height",
        "scrollTop"   : false,
        "scrollLeft"  : false,
        "mwidth"      : false,
        "mheight"     : false,
        "scrollwidth" : false,
        "scrollheight": false,
        "fade"        : "opacity",
        "bgcolor"     : "background-color",
        "textcolor"   : "color"
    },

    queue : {},

    current: null,

    setQueue : function(oHtml, stepFunction){
        if (!oHtml.getAttribute("id"))
            apf.setUniqueHtmlId(oHtml);

        if (!this.queue[oHtml.getAttribute("id")])
            this.queue[oHtml.getAttribute("id")] = [];

        this.queue[oHtml.getAttribute("id")].push(stepFunction);

        if (this.queue[oHtml.getAttribute("id")].length == 1)
            stepFunction(0);
    },

    nextQueue : function(oHtml){
        var q = this.queue[oHtml.getAttribute("id")];
        if (!q) return;

        q.shift(); //Remove current step function

        if (q.length)
            q[0](0);
    },

    clearQueue : function(oHtml, bStop){
        var q = this.queue[oHtml.getAttribute("id")];
        if (!q) return;

        if (bStop && this.current && this.current.control)
            this.current.control.stop = true;
        q.length = 0;
    },

    /**
     * Calculates all the steps of an animation between a
     * begin and end value based on 3 tween strategies
     */
    $calcSteps : function(animtype, fromValue, toValue, nrOfSteps){
        var i, value;
        var steps     = [fromValue]; //Compile steps
        var step      = 0;
        var scalex    = (toValue - fromValue) / ((Math.pow(nrOfSteps, 2)
            + 2 * nrOfSteps + 1) / (4 * nrOfSteps));

        for (i = 0; i < nrOfSteps; i++) {
            if (!animtype && !value)
                value = (toValue - fromValue) / nrOfSteps;
            else if (animtype == 1)
                value = scalex * Math.pow(((nrOfSteps - i)) / nrOfSteps, 3);
            else if (animtype == 2)
                value = scalex * Math.pow(i / nrOfSteps, 3);

            steps.push(steps[steps.length - 1]
                + value);// - (i == 0 ? 1 : 0));//Math.max(0, )
        }
        steps[steps.length - 1] = toValue;// - 1;//Math.max(1, );

        return steps;
    },

    /**
     * Calculates all the steps of an animation between a
     * begin and end value for colors
     */
    $calcColorSteps : function(animtype, fromValue, toValue, nrOfSteps){
        var c = apf.color.colors,
            a = parseInt((c[fromValue]||fromValue).slice(1),16),
            b = parseInt((c[toValue]||toValue).slice(1),16),
            i = 0,
            __round = Math.round,
            out = [], d1;
            
        for (; i < nrOfSteps; i++){
            d1 = i / (nrOfSteps - 1), d2 = 1-d1;
            out[out.length] = "#" + ("000000"+
                ((__round((a&0xff)*d2+(b&0xff)*d1)&0xff)|
                (__round((a&0xff00)*d2+(b&0xff00)*d1)&0xff00)|
                (__round((a&0xff0000)*d2+(b&0xff0000)*d1)&0xff0000)).toString(16)).slice(-6);
        }
        
        return out;
    },

    /**
     * Tweens a single property of a single element or html element from a
     * start to an end value.
     * Example:
     * <code>
     *  apf.tween.single(myDiv, {
     *      type : "left",
     *      from : 10,
     *      to   : 100,
     *      anim : apf.tween.EASEIN
     *  });
     * </code>
     * Example:
     * Multiple animations can be run after eachother
     * by calling this function multiple times.
     * <code>
     *  apf.tween.single(myDiv, options).single(myDiv2, options2);
     * </code>
     * @param {Element}  oHtml the object to animate.
     * @param {Object}   info  the animation settings.
     *   Properties:
     *   {String}   type        the property to be animated. These are predefined property handlers and can be added by adding a method to apf.tween with the name of the property modifier. Default there are several handlers available.
     *      Possible values:
     *      left            Sets the left position
     *      right           Sets the right position
     *      top             Sets the top position
     *      bottom          Sets the bottom position
     *      width           Sets the horizontal size
     *      height          Sets the vertical size
     *      scrollTop       Sets the scoll position
     *      mwidth          Sets the width and the margin-left to width/2
     *      mheight         Sets the height ant the margin-top to height/2
     *      scrollwidth     Sets the width an sets the scroll to the maximum size
     *      scrollheight    Sets the height an sets the scroll to the maximum size
     *      scrolltop       Sets the height and the top as the negative height value
     *      fade            Sets the opacity property
     *      bgcolor         Sets the background color
     *      textcolor       Sets the text color
     *   {Number, String} from  the start value of the animation
     *   {Number, String} to    the end value of the animation
     *   {Number}   [steps]     the number of steps to divide the tween in
     *   {Number}   [interval]  the time between each step
     *   {Number}   [anim]      the distribution of change between the step over the entire animation
     *   {Boolean}  [color]     whether the specified values are colors
     *   {Mixed}    [userdata]  any data you would like to have available in your callback methods
     *   {Function} [onfinish]  a function that is called at the end of the animation
     *   {Function} [oneach]    a function that is called at each step of the animation
     *   {Object}   [control]   an object that can stop the animation at any point
     *     Properties:
     *     {Boolean} stop       whether the animation should stop.
     */
    single : function(oHtml, info){
        info = apf.extend({steps: 3, interval: 20, anim: apf.tween.NORMAL, control: {}}, info);

        if (oHtml.nodeFunc > 100) {
            info.$int = oHtml.$int;
            oHtml = oHtml.$ext;
        }

        if ("fixed|absolute|relative".indexOf(apf.getStyle(oHtml, "position")) == -1)
            oHtml.style.position = "relative";

        var useCSSAnim = (apf.supportCSSAnim && apf.tween.CSSPROPS[info.type]);
        info.method = useCSSAnim ? info.type : apf.tween[info.type];

        
        if (!info.method)
            throw new Error(apf.formatErrorString(0, this,
                "Single Value Tween",
                "Could not find method for tweening operation '"
                + info.type + "'"));
        

        if (useCSSAnim) {
            var type = apf.tween.CSSPROPS[info.type];
            if (type === false)
                return this;
            info.type = type || info.type;
            oHtml.style[info.type] = info.from + (apf.tween.needsPix[info.type] ? "px" : "");
            $setTimeout(function() {
                oHtml.style[info.type]       = info.to + (apf.tween.needsPix[info.type] ? "px" : "");
                oHtml.style.webkitTransition = info.type + " " + ((info.steps
                    * info.interval) / 1000) + "s "
                    + apf.tween.CSSTIMING[info.anim || 0];
                var f = function() {
                    if (info.onfinish)
                        info.onfinish(oHtml, info.userdata);
                    oHtml.style.webkitTransition = "";
                    oHtml.removeEventListener('webkitTransitionEnd', f);
                };
                oHtml.addEventListener('webkitTransitionEnd', f);
            });
            return this;
        }

        var timer,
            steps        = info.color
                ? apf.tween.$calcColorSteps(info.anim, info.from, info.to, info.steps)
                : apf.tween.$calcSteps(info.anim, parseFloat(info.from), parseFloat(info.to), info.steps),
            _self        = this,
            stepFunction = function(step){
                _self.current = info;
                if (info.control && info.control.stop) {
                    info.control.stop = false;

                    apf.tween.clearQueue(oHtml);
                    if (info.onstop)
                        info.onstop(oHtml, info.userdata);
                    return;
                }

                if (info.onbeforeeach
                  && info.onbeforeeach(oHtml, info.userdata) === false)
                    return;

                try {
                   info.method(oHtml, steps[step], info);
                }
                catch (e) {}

                if (info.oneach)
                    info.oneach(oHtml, info.userdata);

                if (step < info.steps)
                    timer = $setTimeout(function(){stepFunction(step + 1)}, info.interval);
                else {
                    _self.current = null;
                    if (info.control)
                        info.control.stopped = true;
                    if (info.onfinish)
                        info.onfinish(oHtml, info.userdata);

                    apf.tween.nextQueue(oHtml);
                }
            };

        this.setQueue(oHtml, stepFunction);

        return this;
    },

    /**
     * Tweens multiple properties of a single element or html element from a
     * start to an end value.
     * Example:
     * Animating both the left and width at the same time.
     * <code>
     *  apf.tween.multi(myDiv, {
     *      anim   : apf.tween.EASEIN
     *      tweens : [{
     *          type : "left",
     *          from : 10,
     *          to   : 100,
     *      },
     *      {
     *          type : "width",
     *          from : 100,
     *          to   : 400,
     *      }]
     *  });
     * </code>
     * Example:
     * Multiple animations can be run after eachother
     * by calling this function multiple times.
     * <code>
     *  apf.tween.multi(myDiv, options).multi(myDiv2, options2);
     * </code>
     * @param {Element}  oHtml the object to animate.
     * @param {Object} info the settings of the animation.
     *   Properties:
     *   {Number}   [steps]     the number of steps to divide the tween in
     *   {Number}   [interval]  the time between each step
     *   {Number}   [anim]      the distribution of change between the step over the entire animation
     *   {Function} [onfinish]  a function that is called at the end of the animation
     *   {Function} [oneach]    a function that is called at each step of the animation
     *   {HTMLElement} [oHtml]  another html element to animate.
     *   {Object}   [control]   an object that can stop the animation at any point
     *     Properties:
     *     {Boolean} stop       whether the animation should stop.
     *   {Array}    [tweens]    a collection of simple objects specifying the single value animations that are to be executed simultaneously. (for the properties of these single tweens see the single tween method).
     */
    multi : function(oHtml, info){
        info = apf.extend({steps: 3, interval: 20, anim: apf.tween.NORMAL, control: {}}, info);

        if (oHtml.nodeFunc > 100) {
            info.$int = oHtml.$int;
            oHtml = oHtml.$ext;
        }

        var useCSSAnim  = apf.supportCSSAnim,
            hasCSSAnims = false,
            cssDuration = ((info.steps * info.interval) / 1000),
            cssAnim     = apf.tween.CSSTIMING[info.anim || 0];

        for (var steps = [], stepsTo = [], i = 0; i < info.tweens.length; i++) {
            var data = info.tweens[i];
            
            if (data.oHtml && data.oHtml.nodeFunc > 100) {
                data.$int = data.oHtml.$int;
                data.oHtml = data.oHtml.$ext;
            }

            useCSSAnim = (apf.supportCSSAnim && apf.tween.CSSPROPS[data.type]);

            data.method = useCSSAnim
                ? data.type
                : apf.tween[data.type] || apf.tween.htmlcss;

            
            if (!data.method)
                throw new Error(apf.formatErrorString(0, this,
                    "Multi Value Tween",
                    "Could not find method for tweening operation '"
                    + data.type + "'"));
            

            if (useCSSAnim) {
                var type = apf.tween.CSSPROPS[data.type];
                data.type = type || data.type;

                oHtml.style[data.type] = data.from
                    + (apf.tween.needsPix[data.type] ? "px" : "");
                stepsTo.push([data.type, data.to
                    + (apf.tween.needsPix[data.type] ? "px" : "")]);
                steps.push(data.type + " " + cssDuration + "s " + cssAnim + " 0");

                hasCSSAnims = true;
            }
            else {
                steps.push(data.color
                    ? apf.tween.$calcColorSteps(info.anim, data.from, data.to, info.steps)
                    : apf.tween.$calcSteps(info.anim, parseFloat(data.from), parseFloat(data.to), info.steps));
            }
        }

        if (hasCSSAnims) {
            oHtml.style.webkitTransition = steps.join(',');
            var count = 0,
                f     = function() {
                    count++;
                    if (count == stepsTo.length) {
                        if (info.onfinish)
                            info.onfinish(oHtml, info.userdata);
                        oHtml.style.webkitTransition = "";
                        oHtml.removeEventListener('webkitTransitionEnd', f);
                    }
                };
            oHtml.addEventListener('webkitTransitionEnd', f);
            for (var k = 0, j = stepsTo.length; k < j; k++)
                oHtml.style[stepsTo[k][0]] = stepsTo[k][1];
            // from here on, webkit will do the rest for us...
            return this;
        }

        var timer,
            tweens       = info.tweens,
            _self        = this,
            stepFunction = function(step){
                _self.current = info;
                if (info.control && info.control.stop) {
                    info.control.stop = false;
                    apf.tween.clearQueue(oHtml);
                    if (info.onstop)
                        info.onstop(oHtml, info.userdata);
                    return;
                }

                try {
                    for (var i = 0; i < steps.length; i++) {
                        tweens[i].method(tweens[i].oHtml || oHtml,
                          steps[i][step], tweens[i]);
                    }
                } catch (e) {}

                if (info.oneach)
                    info.oneach(oHtml, info.userdata);

                if (step < info.steps)
                    timer = $setTimeout(function(){stepFunction(step + 1)}, info.interval);
                else {
                    _self.current = null;
                    if (info.control)
                        info.control.stopped = true;
                    if (info.onfinish)
                        info.onfinish(oHtml, info.userdata);

                    apf.tween.nextQueue(oHtml);
                }
            };

        this.setQueue(oHtml, stepFunction);

        return this;
    },

    /**
     * Tweens an element or html element from it's current state to a css class.
     * Example:
     * Multiple animations can be run after eachother by calling this function
     * multiple times.
     * <code>
     *  apf.tween.css(myDiv, 'class1').multi(myDiv2, 'class2');
     * </code>
     * @param {Element}  oHtml the object to animate.
     * @param {String} className the classname that defines the css properties to be set or removed.
     * @param {Object} info the settings of the animation.
     *   Properties:
     *   {Number}   [steps]     the number of steps to divide the tween in
     *   {Number}   [interval]  the time between each step
     *   {Number}   [anim]      the distribution of change between the step over the entire animation
     *   {Function} [onfinish]  a function that is called at the end of the animation
     *   {Function} [oneach]    a function that is called at each step of the animation
     *   {Object}   [control]   an object that can stop the animation at any point
     *     Properties:
     *     {Boolean} stop       whether the animation should stop.
     * @param {Boolean} remove whether the class is set or removed from the element or html element
     */
    css : function(oHtml, className, info, remove){
        (info = info || {}).tweens = [];

        if (oHtml.nodeFunc > 100)
            oHtml = oHtml.$ext;

        if (remove)
            apf.setStyleClass(oHtml, "", [className]);

        var resetAnim = function(remove, callback){
            if (remove)
                apf.setStyleClass(oHtml, "", [className]);
            else
                apf.setStyleClass(oHtml, className);

            //Reset CSS values
            for (var i = 0; i < info.tweens.length; i++){
                if (info.tweens[i].type == "filter")
                    continue;

                oHtml.style[info.tweens[i].type] = "";
            }

            if (callback)
                callback.apply(this, arguments);
        }

        var onfinish  = info.onfinish;
        var onstop    = info.onstop;
        info.onfinish = function(){resetAnim(remove, onfinish);}
        info.onstop   = function(){resetAnim(!remove, onstop);}

        var result, newvalue, curvalue, j, isColor, style, rules, i, tweens = {};
        for (i = 0; i < document.styleSheets.length; i++) {
            rules = document.styleSheets[i][apf.styleSheetRules];
            for (j = rules.length - 1; j >= 0; j--) {
                var rule = rules[j];

                if (!rule.style || !rule.selectorText.match('\.' + className + '$'))
                    continue;

                for (style in rule.style) {
                    if (!rule.style[style] || this.cssProps.indexOf("|" + style + "|") == -1)
                        continue;

                    if (style == "filter") {
                        if (!rule.style[style].match(/opacity\=([\d\.]+)/))
                            continue;
                        newvalue = RegExp.$1;

                        result   = (apf.getStyleRecur(oHtml, style) || "")
                            .match(/opacity\=([\d\.]+)/);
                        curvalue = result ? RegExp.$1 : 100;
                        isColor  = false;

                        if (newvalue == curvalue) {
                            if (remove) curvalue = 100;
                            else newvalue = 100;
                        }
                    }
                    else {
                        newvalue = remove && oHtml.style[style] || rule.style[style];
                        if (remove) oHtml.style[style] = "";
                        curvalue = apf.getStyleRecur(oHtml, style);
                        isColor = style.match(/color/i) ? true : false;
                    }

                    tweens[style] = {
                        type    : style,
                        from    : (isColor ? String : parseFloat)(remove
                                    ? newvalue
                                    : curvalue),
                        to      : (isColor ? String : parseFloat)(remove
                                    ? curvalue
                                    : newvalue),
                        color   : isColor,
                        needsPx : apf.tween.needsPix[style.toLowerCase()] || false
                    };
                }
            }
        }
        
        for (var prop in tweens)
            info.tweens.push(tweens[prop]);

        if (remove)
            apf.setStyleClass(oHtml, className);

        return this.multi(oHtml, info);
    },
    
    cssRemove : function(oHtml, className, info){
        this.css(oHtml, className, info, true);
    },

    needsPix : {
        "left"       : true,
        "top"        : true,
        "bottom"     : true,
        "right"      : true,
        "width"      : true,
        "height"     : true,
        "fontSize"   : true,
        "lineHeight" : true,
        "textIndent" : true
    },

    cssProps : "|backgroundColor|backgroundPosition|color|width|filter|\
                |height|left|top|bottom|right|fontSize|\
                |letterSpacing|lineHeight|textIndent|opacity|\
                |paddingLeft|paddingTop|paddingRight|paddingBottom|\
                |borderLeftWidth|borderTopWidth|borderRightWidth|borderBottomWidth|\
                |borderLeftColor|borderTopColor|borderRightColor|borderBottomColor|\
                |marginLeft|marginTop|marginRight|marginBottom|"
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/draw.js)SIZE(67157)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * @private
 */
apf.draw = {
    
    initDriver : function(){
        // initialize by copying either canvas of VML into my object.
        if(!this.initLayer){
            var k,o=apf.supportVML?apf.draw.vml:apf.draw.canvas;
            for(k in o){
                this[k]=o[k];
            } 
        }
    },

    //----------------------------------------------------------------------
    
    // vars
    
    //----------------------------------------------------------------------
     
    basevars : function(){
        return ["var  _math_,v,t=0,n=(new Date()).getTime()*0.001",
                ",e=Math.E, p=Math.PI, p2=2*p, p12=0.5*p",
                ",x, y, z, _x,_y,_z, zt, i, j, k, _opt_;"].join('');
    },
     
    vars : function(ml,mt,mr,mb){
        return ["var  _math_,vx1 = v.vx1, vy1 = v.vy1,_rseed=1",
                ",vx2 = v.vx2, vy2 = v.vy2, vw = vx2-vx1, vh = vy1-vy2",
                ",vz2 = v.vz2, vz1 = v.vz1, vd = vz2-vz1",
                ",zoom = 1/v.zoom",
                ",a=v.a,b=v.b,c=v.c,d=v.d",
                ",dw = l.dw",ml?"-"+(ml+mr):"",
                ",dh = l.dh",mt?"-"+(mt+mb):"",
                ",dw12 = dw*0.5, dh12 = dh*0.5",
                ",dzw = dw/v.zoomx, dzh = -dh/v.zoomy",
                ",dx = ",ml?ml:0,
                ",dy = ",mt?mt:0,
                ",mx = m&&m.x, my = m&&m.y",
                ",db = dy+dh, dr = dx+dw",
                ",tw = dw/vw, th = dh/vh, ty = -vy2*th+dy, tx = -vx1*tw+dx",
                ",v,t=0,nt=0,n=(new Date()).getTime()*0.001, dt=-(l._n?l._n:n)+(l._n=n)",
                ",e=Math.E, p=Math.PI, p2=2*p, p12=0.5*p",
                ",x, y = 0, z = 0, _x,_y,_z, zt, i, j, k, _opt_, _anim = 0,",
                "_storelut,_storelist,_translut,_speedlut,_overlaylut;"].join('');
    },
    defCamVec : function(){
        // lets do a proper 3x3 inverse and mul it with our camera pos
        return  "var inv=1/m00*(m11*m22-m12*m21)-m01*(m10*m22-m12*m20)+m02*(m10*m21-m11*m20);"+
                "var mcx = inv*(m11*m22-m12*m21)*m03 + inv*(m02*m21-m01*m22)*m13 + inv*(m01*m12-m02*m11)*m23,"+
                "    mcy = inv*(m12*m20-m10*m22)*m03 + inv*(m00*m22-m02*m20)*m13 + inv*(m02*m10-m00*m12)*m23,"+
                "    mcz = inv*(m10*m21-m11*m20)*m03 + inv*(m01*m20-m00*m21)*m13 + inv*(m00*m11-m01*m10)*m23;"
            //        "    mcz         m10*m13+m20*m23,mcy=m01*m03+m11*m13+m21*m23,mcz=m02*m03+m12*m13+m22*m23;";
    },
    setMatrix3D : function(m){
		
        var l = this.l;
        var s = ["var m00=",m[0],",m01=",m[1],",m02=",m[2], ",m03=",m[3],
                    ",m10=",m[4],",m11=",m[5],",m12=",m[6], ",m13=",m[7],
                    ",m20=",m[8],",m21=",m[9],",m22=",m[10],",m23=",m[11],";"];
        if(l.p3d<0){ // we have ortho perspective
            this.ortho = 1;
            s.push("var persp = dw / v.p3d/-v.tz, perspd = persp / ",l.ds,";");
        } else {
            this.ortho = 0;
            s.push("var persp = dw / v.p3d, perspd = persp / ",l.ds,";");
        }
        return s.join('');
    },

    sincos3 : function(pre,rx,ry,rz){
      return[ "var ",pre,"cx = __cos(",rx,"),",pre,"sx = __sin(",rx,"),",
                     pre,"cy = __cos(",ry,"),",pre,"sy = __sin(",ry,"),",
                     pre,"cz = __cos(",rz,"),",pre,"sz = __sin(",rz,");" ].join('');
    },
    matrix4S : function(sx,sy,sz){
      return [ sx,0,0,0,
               0,sy,0,0,
               0,0,sz,0, 
               0,0,0,1 ];
    },
    matrix4T : function(tx,ty,tz){
      return [ 1,0,0,tx,
               0,1,0,ty,
               0,0,1,tz, 
               0,0,0,1 ];
    },
    matrix4RP : function(pre){
        return this.matrix4R(pre+'cx',pre+'sx',pre+'cy',pre+'sy',pre+'cz',pre+'sz');
    },
    matrix4R : function(cx,sx,cy,sy,cz,sz){
        return [ [cy,'*',cz].join(''), 
                 ['(-',sz,'*',cy,')'].join(''), 
                 sy,  
                 0,
                 ['(',cz,'*',sx,'*',sy,'+',sz,'*',cx,')'].join(''),
                 ['(-',sx,'*',sy,'*',sz,'+',cx,'*',cz,')'].join(''),
                 ['(-',sx,'*',cy,')'].join(''), 
                 0,
                 ['(-',cx,'*',sy,'*',cz,'+',sx,'*',sz,')'].join(''),
                 ['(',cx,'*',sy,'*',sz,'+',cz,'*',sx,')'].join(''),
                 ['(',cx,'*',cy,')'].join(''), 
                 0,
                 0,0,0,1];
    },
    matrixMul : function(){
        // lets multiply matrices on our arglist with conceptually ordered transform
        var m = arguments[arguments.length-1];
        for(var i = arguments.length-2;i>=0;i--)
            m = this.matrixAB(m,arguments[i]);
        return m;
    },
    matrixAB : function(a,b){
        var out = [], x, y, i, j, t, v;
        for(y = 0;y<16;y+=4){
            for(x = 0;x<4;x++){
                v = [];
                if((i=a[y])  &&(j=b[x])   ) v[v.length] = i==1?j:(j==1?i:(i+'*'+j));
                if((i=a[y+1])&&(j=b[x+4]) ) v[v.length] = i==1?j:(j==1?i:(i+'*'+j));
                if((i=a[y+2])&&(j=b[x+8]) ) v[v.length] = i==1?j:(j==1?i:(i+'*'+j));
                if((i=a[y+3])&&(j=b[x+12])) v[v.length] = i==1?j:(j==1?i:(i+'*'+j));
                out[out.length] = v.length?((v.length>1)?'('+v.join('+')+')':v[0]):0;
            }
        }
        return out;
    },

    // check for backface for a certain plane
    backface3D : function(pts,cm,zmode){
        var a = pts[0], b = pts[1], c = pts[2], x = 0, y = 1, z = 2;
        if(cm) x = cm[0], y = cm[1], z = cm[2];
        return this.ortho?[
            "-((m00*",b[x],"+m01*",b[y],"+m02*",b[z],"+m03)-(__ax=m00*",a[x],"+m01*",a[y],"+m02*",a[z],"+m03))*",
        "((m10*",c[x],"+m11*",c[y],"+m12*",c[z],"+m13)-(__ay=m10*",a[x],"+m11*",a[y],"+m12*",a[z],"+m13))+",
        "((m10*",b[x],"+m11*",b[y],"+m12*",b[z],"+m13)-__ay)*((m00*",c[x],"+m01*",c[y],"+m02*",c[z],"+m03)-__ax)"].join(''):
        [
        "(((__by=m10*",b[x],"+m11*",b[y],"+m12*",b[z],"+m13) - (__ay=m10*",a[x],"+m11*",a[y],"+m12*",a[z],"+m13)) *",
        "((__cz=m20*",c[x],"+m21*",c[y],"+m22*",c[z],"+m23) - (__az=m20*",a[x],"+m21*",a[y],"+m22*",a[z],"+m23)) -",
        "((__bz=m20*",b[x],"+m21*",b[y],"+m22*",b[z],"+m23) - __az) * ((__cy=m10*",c[x],"+m11*",c[y],"+m12*",c[z],"+m13) - __ay) ) * ",
        "(__ax=m00*",a[x],"+m01*",a[y],"+m02*",a[z],"+m03) + ",
        "((__bz - __az) * ((__cx=m00*",c[x],"+m01*",c[y],"+m02*",c[z],"+m03) - __ax) -",
        "((__bx=m00*",b[x],"+m01*",b[y],"+m02*",b[z],"+m03) - __ax) * (__cz - __az) ) * __ay + ",
        "((__bx - __ax) * (__cy - __ay) - (__by - __ay) * (__cx - __ax) ) * __az "].join('');
    },

    //----------------------------------------------------------------------
        
    text3D : function( p, cm, zc, text) {
        var i = 0, d, pt, q, s = ["__n=0;"], x = 0, y = 1, z = 2, sx, sy, vx, vy, vxi, vyi;
        if(cm) x = cm[0], y = cm[1], z = cm[2];        

        // lets project, clip and print
        return [
            "if((__z = m20*",p[x],"+m21*",p[y],"+m22*",p[z],"+m23) < ",zc,"){",
               this.text(["dw12+(m00*",p[x],"+m01*",p[y],"+m02*",p[z],"+m03)*",this.ortho?"persp":"(persp/__z)"].join(''),
                       ["dh12+(m10*",p[x],"+m11*",p[y],"+m12*",p[z],"+m13)*",this.ortho?"persp":"(persp/__z)"].join(''),text),
            "}"
        ].join('');
   },
    
    // 3D API
    // draw a 3D polygon clipped against a z-plane
    poly3DClip : function(idx,pt,cm,zc,open){
        var i = 0, d, p, pt, q, s = ["__n=0;"], x = 0, y = 1, z = 2, sx, sy, vx, vy, vxi, vyi;
        if(cm) x = cm[0], y = cm[1], z = cm[2];            

        //calculate z-clipping info for each vertex
        for(var i = 0;i<idx.length;i++){    
            p = pt[idx[i]];
            s.push(["if(__n",i,"=(__z",i," = m20*",p[x],"+m21*",p[y],"+m22*",p[z],"+m23) < ",zc,")__n++;"].join(''))
        }
         s.push("if(__n){",
                "if(__n==",idx.length,"){");
        // the nonclipped draw
        for(var i = 0;i<idx.length;i++){    
            p = pt[idx[i]];
            vx = ["dw12+(m00*",p[x],"+m01*",p[y],"+m02*",p[z],"+m03)*",this.ortho?"persp":"(persp/__z"+i+")"].join('');
            vy = ["dh12+(m10*",p[x],"+m11*",p[y],"+m12*",p[z],"+m13)*",this.ortho?"persp":"(persp/__z"+i+")"].join('');
            if(i==0)s.push(this.moveTo(vx,vy));
            else s.push(this.lineTo(vx,vy));
        }
        if(!open)s.push(this.close());
        s.push("}else{");
        
        // the clipped draw
        for(var i = 0;i<idx.length;i++){
            p = pt[idx[i]];
            // if we are number index 0 we only move to 
            if(i==0){ // first vertex
              s.push([
                "__x0=m00*",p[x],"+m01*",p[y],"+m02*",p[z],"+m03;",
                "__y0=m10*",p[x],"+m11*",p[y],"+m12*",p[z],"+m13;",
                "if( __o=__n0){",
                    this.moveTo("dw12+__x0*"+(this.ortho?"persp":"(persp/__z0)"),"dh12+__y0*"+(this.ortho?"persp":"(persp/__z0)")),
                "}"].join(''));
            } else { // all other vertices
                s.push([
                "__xn=dw12+(__x",i,"=m00*",p[x],"+m01*",p[y],"+m02*",p[z],"+m03)*",(this.ortho?"persp;":"(persp/__z"+i+");"),
                "__yn=dh12+(__y",i,"=m10*",p[x],"+m11*",p[y],"+m12*",p[z],"+m13)*",(this.ortho?"persp;":"(persp/__z"+i+");"),
                "if( __n",i," && !__n",i-1," || !__n",i,"&& __n",i-1,"){", // we visible and prev not or prev inv and we not
                    "__z=(__zc=(",zc,"-__z",i-1,")/(__z",i,"-__z",i-1,")) * __z",i,"+(__ze=1-__zc)* __z",i-1,";",
                    "__xi=dw12+(__zc*__x",i,"+__ze* __x",i-1,")*",(this.ortho?"persp":"(persp/__z)"),";",
                    "__yi=dh12+(__zc*__y",i,"+__ze* __y",i-1,")*",(this.ortho?"persp":"(persp/__z)"),";",
                    "if(!__o){__o=true;",
                        this.moveTo("__xi","__yi"),
                    "}else{",
                        this.lineTo("__xi","__yi"),
                    "}",
                "}",
                "if( __n",i,"){",
                    this.lineTo("__xn","__yn"),
                "}"].join(''));
            }
            if(i==idx.length-1){
                s.push([ // termination step
                    "if(!__n0 && __n",i," || __n0 && ! __n",i,"){",
                        // do a lineto to the interp pos between last element and us
                        "__z=(__zc=(",zc,"-__z",i,")/(__z0-__z",i,")) * __z0+(__ze=1-__zc)* __z",i,";",
                        this.lineTo(["dw12+(__zc*__x0+__ze* __x",i,")*",(this.ortho?"persp":"(persp/__z)")].join(''),
                                    ["dh12+(__zc*__y0+__ze* __y",i,")*",(this.ortho?"persp":"(persp/__z)") ].join('')),
                    "}",
                open?"":this.close()].join(''));
            } 
        }
        s.push("}};");
        return s.join('').replace(/m\d\d\*\(?0\)?\+/g,"");
    },
    // draw a 3D polygon
    poly3D : function(indices,pts,fl){
        // we want rects between:
        // first we count the doubles
        var v,f=1,i,j = 0,d,pt,q,s = [],
            cc = new Array(pts.length),
            cf = new Array(pts.length), 
            f0, f1, f2;
        if(fl) f0 = fl[0], f1 = fl[1], f2 = fl[2];
        else f0 = 0, f1 = 1, f2 = 2;
        // calculate which values are used more than once to cache them
        for( i = 0;i<indices.length;i++){
            d = indices[i];    if(d>=0) cc[d]++;
        }
        for( i = 0;i<pts.length;i++){
            if(cc[i]>1)cc[i] = j++;
            else cc[i]=0;
        }
        for(var i = 0;i<indices.length;i++){
            d = indices[i];
            if(d>=0){
                pt = pts[d];
                q=[this.ortho?"":
                    "zt = persp / ((zt=(m20*"+pt[f0]+"+m21*"+pt[f1]+"+m22*"+pt[f2]+"+m23)<-0.01)?zt:-0.01);",
                    "dw12+(m00*"+pt[f0]+"+m01*"+pt[f1]+"+m02*"+pt[f2]+"+m03)*"+
                        (this.ortho?"persp":"zt"),
                    "dh12+(m10*"+pt[f0]+"+m11*"+pt[f1]+"+m12*"+pt[f2]+"+m13)*"+
                        (this.ortho?"persp":"zt")];
                d = f?0:i;
                if(cc[d])q[1]= "__t"+cc[d]+(cf[d]?"":"="+q[1]), 
                         q[2]= "__t"+cc[d]+(cf[d]++?"":"="+q[2]);
            }; 
            switch(d){
                case -1: f=1;s.push( this.close() );break;
                case 0: f=0;s.push( q[0], this.moveTo(q[1],q[2]) ); break;
                case indices.length-1: s.push( q[0], this.lineTo(q[1],q[2]), 
                    this.close() );break;
                default: s.push( q[0], this.lineTo(q[1],q[2]) ); break;
            }
        }
        return s.join('').replace(/m\d\d\*\(?0\)?\+/g,"");
    },
    lineTo3D : function(x,y,z,sx,sy,fl){
        return this.$do3D("lineTo",x,y,z,sx,sy,fl);
    },
    moveTo3D : function(x,y,z,sx,sy,fl){
        return this.$do3D("moveTo",x,y,z,sx,sy,fl);
    },
    
    $store3D : function(x,y){
      return x+";"+y+";";
    },
    store3D : function(x,y,z,sx,sy,fl){
        return this.$do3D("$store3D",x,y,z,sx,sy,fl);
    },
    $do3D : function(f,x,y,z,sx,sy,fl){
        var _x,_y,_z;
        if(typeof x == 'string' && x.match(/[\[\]\*\+\-\/]/))x="(_x="+x+")",_x="_x";
        else x="("+x+")",_x=x;
        if(typeof y == 'string' && y.match(/[\[\]\*\+\-\/]/))y="(_y="+y+")",_y="_y";
        else y="("+y+")",_y=y;
        if(typeof z == 'string' && z.match(/[\[\]\*\+\-\/]/))z="(_z="+z+")",_z="_z";
        else z="("+z+")",_z=z;
        if(fl){
            var v = [x,y,z], _v = [_x,_y,_z];
            x = v[_x=fl[0]], y = v[_y=fl[1]], z = v[_z=fl[2]];
            _x = _v[_x], _y = _v[_y], _z = _v[_z];
        }
        var r = [];
        if(!this.ortho)r.push("zt =persp/((zt=m20*"+x+"+m21*"+y+"+m22*"+z+"+m23)<-0.01?zt:-0.01);");
        r.push(this[f]( (sx===undefined?"":sx)+
              "dw12+(m00*"+_x+"+m01*"+_y+"+m02*"+_z+"+m03)*"+(this.ortho?"persp":"zt"),
              (sy===undefined?"":sy)+
              "dh12+(m10*"+_x+"+m11*"+_y+"+m12*"+_z+"+m13)*"+(this.ortho?"persp":"zt") ) );
        return r.join('').replace(/m\d\d\*\(?0\)?\+/g,"");
    },
    
    //----------------------------------------------------------------------
    // Style parsing
    //----------------------------------------------------------------------
     
    parseStyle : function( def, ovl, err ) {
        var style = {}, o, v, k, s, t, i, j, n, m;
        
        //var o = {}, k1, v1, k2, v2, t, s, i, j, len, _self = this;
        //var k, v, n ,m, w, p, h, q, u, o, x, y, z, r, g;
        
        var _self = this;

        // initialise transition table
        if(!(t=_self.stateTransition)[0x40001]){
            s = {};
            for(v in t)for(i = 0;i<32;i++)s[v|i]=t[v]|i;
            _self.stateTransition = s;
            // 
            // alert( (n[p]|i).toString(16) );
        }

        // parse styles
        ovl = ovl?this.parseJSS(ovl.item?ovl.join(''):ovl,err):{};
        //    logw(apf.dump(ovl));
        // we need to integrate style into o.
        function stylecopy(dst, src, key){
            // copy into the destination 
            var t,k,v,o;
            for(k in src)if(dst[k] === undefined)
                    dst[k] = _self.isDynamic(v=src[k])?_self.parseJSS(v):v;
            if(t=src.inherit) stylecopy( dst, def[t]||_self['$'+t], t );
            if(o = ovl[key])for(k in o)dst[k] = o[k];
		}

        for(k in def){
            if( typeof(v=def[k]) == 'object' && v!==null && v['$']==1){
                stylecopy(style[k] = {}, v, k);
            }
        }
        function styleinherit(dst,b,c,s){
            // we should walk up the state-list
            var o,v,k;
            do{
                if(!c && !s) o = style[b];
                else o = ovl[b+(c?"."+c:"")+(s?":"+s:"")];
                if(typeof(o)=='object')
                        for(k in o) if( k.indexOf('$')==-1 && 
                            dst[k] === undefined ) dst[k] = o[k];
                if(s)s = _self.$stateInherit[v];
            }while(s);
        }
        
        // now lets run through all objects with a class and / or state:
        for(k in ovl) if(typeof(v=ovl[k]) == 'object'){
            t = k.match(/([\w\_-]+)\.?([\w\_-]+)?\:?([\w\_-]+)?/);
            var base = t[1], cls = t[2], state = t[3];
            if(cls || state){
                o = style[k] = {};
                if(state){
                    if(cls)styleinherit( o, base, cls, state );
                    styleinherit( o, base, 0, state );
                }
                if(cls)styleinherit( o, base , cls, 0 );
                styleinherit( o, base, 0, 0 );
                o.$cls  = cls?cls:'', o.$state = state?state:'';
                o.$base = s = style[base];

                if(!s) {
                    alert("ERROR, baseless style found: "+base);
                    return;
                }
                (s.$stylelist?s.$stylelist:(s.$stylelist=[])).push(o);
                if(!cls)
                    (s.$baselist?s.$baselist:(s.$baselist={}))[state]=1;
                else 
                    (s.$clslist?s.$clslist:(s.$clsc = 1,s.$clslist={}))[cls]=s.$clsc++;
            }
        }

        function initShape(s){
            if(s.stroke === null || s.stroke=='null' || s.stroke==0) delete s.stroke;
            if(s.fill === null || s.fill=='null' || s.fill==0) delete s.fill;
            if(s.family === null || s.family=='null' || s.family==0) delete s.family;

            if( (s.isshape && s.fill === undefined && 
                s.stroke === undefined && s.tile === undefined) || 
                (s.isfont && s.family === undefined) ) return false; 
            if(s.isshape){
                s.opacity = s.opacity!==undefined ? s.opacity : 1;
                s.fillopacity = s.fillopacity!==undefined ? s.fillopacity:s.opacity;
                s.gradopacity = s.gradopacity!==undefined ? s.gradopacity:s.fillopacity;
                s.strokeopacity = s.strokeopacity!==undefined ? s.strokeopacity:s.opacity;
                s.angle = s.angle!==undefined ? s.angle : 0;
                s.weight = s.weight!==undefined ? s.weight : 1
            }
            return true;
        }
        // generate all required tables and luts
        for(k in style) if(typeof(s=style[k]) == 'object'){
            // add missing class states automatically
           
            if(s.$baselist && s.$clslist){
                delete s.$clsc;
                for(i in s.$clslist){
                    for(j in s.$baselist){
                        if(!style[t = k+'.'+i+':'+j]){
                            // if this is an overlay, dont autogen
                            if((m = style[k+':'+j]) && m.overlay){
                                (m.$clsovl?m.$clsovl:m.$clsovl=[]).push(i);
                            }else{
                                style[t] = o = {};
                                for(v in (t=style[k+'.'+i]))o[v] = t[v];
                                for(v in (t=ovl[k+':'+j]))o[v] = t[v];
                                o.$cls   = i, o.$state = j, o.$base = s;
                                initShape(o);
                                s.$stylelist.push(o);
                            }
                        }
                    }
                }
            }
            if(s.$stylelist){ // lets go create our style luts
                s.$storelut = {};
                s.$speedlut = {};
                //s.$storelist = [];
                s.$overlaylut = {};
                var cls, state, ovl, idx;
                j = s.$stylelist;
                for(i = 0;i<j.length;i++){
                    o = j[i];
                    //s.$storelist.push(n = []);
                    //idx = i;//s.$storelist.length - 1;
                    //calculate the ID for this class/style
                    cls   = s.$clslist?(s.$clslist[o.$cls]||0):0;
                    state = apf.draw.stateBit[o.$state]||0;
                    o.$lutvalue = state|cls;
                    o.$store = n;
                    if(t=o.overlay){ // compute overlay target
                        if(t == 'base') ovl = cls?cls:0x10000000;
                        else  ovl = (s.$clslist?(s.$clslist[t]||0):0)|(apf.draw.stateBit[t]||0);
                    }else ovl = 0;
                    // check if we have any $clsovls to add aswell
                    s.$storelut[ state|cls ] = i;//s.$storelist.length-1;
                    s.$speedlut[ state|cls ] = o.speed || 1;
                    if(ovl) s.$overlaylut[ state|cls ] = ovl;
                    // store lut elements for overlay class too.
                    if(o.$clsovl)for(m = o.$clsovl.length-1;m>=0;m--){
                        cls = s.$clslist?(s.$clslist[o.$clsovl[m]]||0):0;
                        s.$storelut[ state|cls ] = i;//n;
                        s.$speedlut[ state|cls ] = o.speed || 1;
                        if(ovl)s.$overlaylut[ state|cls ] = (ovl==0x10000000)?cls:ovl;
                    }
                    // check if we have an overlay, ifso decode our overlay state|cls 
                }
            }
            if(!initShape(s)){
                delete style[k];
            }   
        }
        return style;
    },
    stateBit : {
        0                   : 0,
        'init'              : 0x01000000, // 0x00ff0000 == statetype
        'hidden'            : 0x00010000, // 0x0f000000 == dynamic type 0 = no dyn, 1 = in, 2 = out
        'deinit'            : 0x02000000, 
        'hover'             : 0x00020000,
        'hoverin'           : 0x01020000,
        'hoverout'          : 0x02020000,
        'select'            : 0x00030000,
        'selectin'          : 0x01030000,
        'selectout'         : 0x02030000,
        'selecthover'       : 0x00040000,
        'selecthoverin'     : 0x01040000,
        'selecthoverout'    : 0x02040000,
        'animating'         : 0x03050000
    },

    stateTransition : {
        0x01000000 : 0,
        0x02000000 : 0x00010000,
        0x01020000 : 0x00020000,
        0x02020000 : 0,
        0x01030000 : 0x00030000,
        0x02030000 : 0,
        0x01040000 : 0x00040000,
        0x02040000 : 0x00030000,
        0x01050000 : 0x01050000
    },
    
    stateMask : {
        'selected' : 0x01000000|0x00800000|0x00200000|0x00100000|0x00080000,
        'normal'   : 0x20000000|0x08000000|0x04000000|0x02000000|0x00040000,
        'dynamic'  : 0x20000000|0x10000000|0x04000000|0x02000000|0x00800000|
                     0x00400000|0x00100000|0x00080000|0x00040000,
        'hover'    : 0x08000000|0x04000000|0x00200000|0x00100000
    },
    
    $stateInherit : {
        'hidden'           : 0,       
        'init'             : 0,
        'deinit'           : 0,
        'hover'            : 0,
        'hoverin'          : 'hover',
        'hoverout'         : 'hover',
        'select'           : 0,
        'selectin'         : 'select',
        'selectout'        : 'select',
        'selecthover'      : 'hover',
        'selecthoverin'    : 'selecthover',
        'selecthoverout'   : 'selecthover',
        'animating'        : 0
    },

    $stateFallback : {
        'init'              : 1,
        'hover'             : 1,
        'hoverin'           : 'hover',
        'hoverout'          : 1,
        'select'            : 1,
        'selectin'          : 'select',
        'selectout'         : 1,
        'selecthover'       : 'hover',
        'selecthoverin'     : 'selecthover',
        'selecthoverout'    : 'select',
        'hidden'            : 1
    },
    
    getXYWH : function( m, p, noflatten ){
        var t;
        if(!( (t=this.$getXYWH_NT[p]) || (p=this.$getXYWH_TN[t=p]) ))return '0';
        if(m==null)return '0';
        if(typeof(m)=='object'){
            if(m.sort) return --p>=m.length?'0':( (t=m[p]) && t.sort && !noflatten ? t.join(''): t);
            return (t=m[t])===undefined||p>1?'0':(t && t.sort && !noflatten ? t.join('') : t);
        }
        return p==1?m:'0';
    },
    $getXYWH_NT : {1:'x',2:'y',3:'z',4:'w'},
    $getXYWH_TN : {'x':1,'y':2,'z':3,'w':4},

    getTRBL : function( m, p, noflatten ){
        var t;
        if(!( (t=this.$getTRBL_NT[p]) || (p=this.$getTRBL_TN[t=p]) ))return '0';
        if(m==null)return '0';
        if(typeof(m)=='object'){
            if(m.sort) return --p>=m.length?'0':( (t=m[p]) && t.sort && !noflatten ? t.join(''): t);
            return (t=m[t])===undefined||p>1?'0':(t && t.sort && !noflatten ? t.join('') : t);
        }
        return p==1?m:'0';
    },
    $getTRBL_NT : {1:'t',2:'r',3:'b',4:'l'},
    $getTRBL_TN : {'t':1,'y1':1,'r':2,'x2':2,'b':3,'y2':3,'l':4,'x1':4},
    
    getFlat : function( m ){
        if(typeof(m)=='object' && m.sort) return m.join('');
			return m;
		},
		
		getColor : function (a) {
			if(a.match(/\(/)) return a;
			if(a.match(/^#/)) return "'"+a+"'";
			var b = a.toLowerCase();
			return (this.colors[b])?"'"+this.colors[b]+"'":a;
		},
		getX : function( s, pre, val, post, def){    
			var v; return (typeof(v=s[val+'-x'])=='undefined' && 
               (typeof(v=s[val])!='object' || typeof(v=v[0])=='undefined'))?
               (typeof(def)!='undefined'?def:''):(pre+v+post);
    },
    getY : function( s, pre, val, post, def, ovl){    
        var v; return (typeof(v=s[val+'-y'])=='undefined' && 
               (typeof(v=s[val])!='object' || typeof(v=v[1])=='undefined'))?
               (typeof(def)!='undefined'?def:''):(pre+v+post);
    },
   checkX : function( s, val, ovl, no){    
        var v; return (typeof(v=s[val+'-x'])=='undefined' && 
               (typeof(v=s[val])!='object' || typeof(v=v[0])=='undefined'))?
               (typeof(no)=='undefined'?'':no):ovl;
    },
   checkY : function( s, val, ovl, no){    
        var v; return (typeof(v=s[val+'-y'])=='undefined' && 
               (typeof(v=s[val])!='object' || typeof(v=v[1])=='undefined'))?
               (typeof(no)=='undefined'?'':no):ovl;
    },

    isDynamic : function( a ) {
        // check if we have a dynamic property.. how?
        return a && typeof(a)=='string' && 
              !(a.indexOf('.')!=-1 && a.match(/^[\s:a-zA-Z0-9\/\\\._-]+$/)) && 
               a.match(/[\(+*\/-]/)!=null;
    },
    
    baseMacro : function ( code ) {
        // lets compile our macros
        for(var j = code.length,i=0,v;i<j;i++){
            if(typeof(v=code[i])=='object'){
                code[i] = this.parseJSS(v[0]);
            }
        }
        var r= this.optimize([   
            this.basevars(),
            code.join(''),
        ])
        return r;
    },
    
    optimize : function( code ){
        var c2,c3,s=[],cnt={},n=0;
        // first we need to join all nested arrays to depth 2
        if(typeof(code) == 'object'){
            code = code.join('');
        /*     for(var i = code.length-1;i>=0;i--)
                if(typeof(c2=code[i]) == 'object'){
                    for(var j=c2.length-1;j>=0;j--)
                        if(typeof(c3=c2[j]) == 'object')
                            c2[j] = c3.join('');
                    code[i] = c2.join('');
                }*/
        }
        // find used math functions and create local var
        code.replace(/\_\_(\w+)/g,function(m,a){
            if(!cnt[a]) {
                if(a.length<=2)s.push("__"+a);
                else s.push("__"+a+"=Math."+a);
                cnt[a]=1;
            }
        });
       
        // optimize out const parseInt and const math-operations
        code = code.replace(/(__(\w+))\((\-?\d+\.?\d*)\)/g,
            function(m,a,b,c){
            if(a=='__round')return Math.round(c);
            return Math[b](c);
        });
        
        
        //code = code.replace(/__round\((_d[xy])\)/g,"$1"); 
        //code = code.replace(/\(0\)\+/g,""); 
        
        //TODO pull out 0 multiplication
        //code = code.replace(/\+0\s*([\;\,\)])/g,"$1"); 
        
        if(code.match('_rndtab'))s.push('_rndtab=apf.draw.$rndtab');
        //code = code.replace(/\(([a-z0-9\_]+)\)/g,"$1");
         
        code = s.length ? code.replace(/\_math\_/,s.join(',')): code;
       
        cnt = {},n = 0, s=[];
        /*
        code = code.replace(/(m\d\d\*)\(?(\-?\d+(?:\.\d+))?\)/g,function(m,a,b){
            var t = a+b;
            if(cnt[t] === undefined){
                s.push("_mo"+n+"="+t);
                return cnt[t]="_mo"+(n++);
            }
            return cnt[t];
        });
        */
        code = s.length ? code.replace(/\_opt\_/,s.join(',')): code;
        code = code.replace(/__round\((d[wh])\)/g,"$1"); 
        
        return code;
    },
    
    parseJSS : function(s,err,inobj,debug){
        if(!s)return{};
        var mulinsert = true;
        var lp = 0, sm = 0, t, i, len, fn = 0, sfn  = [],  arg = [], sarg = [], 
            ac = [], sac = [], sn=[], obj = inobj||{}, prop = 0, sobj = [],
             _self = this, mn={1:'}',2:')',3:']',4:')',5:'}'}, rn={'{':1,'(':2,'[':3}, ln=6;
        try{
                s=s.replace(/\/\*[\S\s]*?\*\/|\/\/.*?;/g,'');
                s.replace(/(["'])|(\^)|([\w\.\_]+\:?[\w\_\s-]*)\s*\{\s*|([\w\_]+)\s*[:]+\s*|([\w\.\_]+)\s*\(\s*|(\#[0-9a-zA-Z]+|0x[0-9a-zA-Z]+)|(\d+\.?\d*[\_a-zA-Z]+)|([({\[])|([)}\]])|(\\["'{}\[\](),;\:]|\s*[\<\>\=*+\%@&\/]\s*|\s*\-\s+)|([,\s]+)|(;)|$/g, 
                    function(m,str,exp,openobj,openval,openmac,hexobj,numobj,open,close,skip,sep,split,pos){
                    /*logw( ln+' - '+(str?' str:'+str:'')+(openobj?' openobj:'+openobj:'')+(openval?' openval:'+openval:'')+
                    (openmac?' openmac:'+openmac:'')+(numobj?' numobj:'+numobj:'')+(hexobj?' hexobj:'+hexobj:'')+(open?' open:'+open:'')+(close?' close:'+close:'')+(skip?' skip:##'+skip+'#':'')+(sep?' sep:##'+sep+'#':'')+
                    (split?' split:'+split:'')+'  pos:'+pos+'\n');*/
                if(skip||hexobj)return m;
                if(sm || str) {
                    if(str && !sm)sm = str;
                    else if(sm==str)sm = 0;
                    return m;
                }
                if( sep ){
                    ac.push(s.slice(lp,pos));arg.push(ac.join(''));lp=pos+sep.length,ac=[]; 
                    return m;
                }
                if( openval ){
                    if(ln>=5){
                        ln = 6, prop = openval, lp = pos+m.length;arg=[],ac=[];
                    }
                    return m;
                }
                if(numobj){
                    ac.push(s.slice(lp,pos));
                    t = m.match(/(\d\.?\d*)(.+)/);
                    ac.push(t[1],'*',t[2]);
                    lp = pos+m.length;
                    return m;
                }
                if( openmac){
                    sn.push(ln=4);
                    if(pos>lp)ac.push( s.slice(lp,pos) );
                    if(ac.length && ac[ac.length-1].match(/\)\s*$/))ac.push('*');
                    if(t = openmac.match(/(\d\.?\d*)(.+)/)){
                        ac.push(t[1]+'*');
                        openmac = t[2];
                    }
                    // check if our macro starts with numbers push up a number*
                    // if its only a number inject * and fall through to normal ()
                    // 
                    sac.push(ac); sarg.push(arg);
                    sfn.push(fn); fn = openmac;
                    
                    arg = [], ac = [], lp = pos+m.length;
                    return m;
                }
                if(openobj){
                    if(ln<5)throw({t:"JSS Error - object scope found inside macro",p:pos});
                    lp = pos+m.length; sn.push(ln=5);

					//logw(apf.dump(openobj)+openobj.split(' ').length);
                    (openobj = openobj.replace(/^\s*/,'').replace(/\s*$/,'').split(' ')).length>1?(openobj=openobj[1]+'@'+openobj[0]):openobj=openobj[0];
                    sobj.push(obj); obj = (typeof(t=obj[openobj])=='object')?t:(obj[openobj]={});
                    return m;
                }
                if( open ){ 
                    sn.push(ln=rn[open]);
                    if(ln==1 && prop){
                        sn.pop();
                        lp = pos+m.length; sn.push(ln=5);
                        sobj.push(obj); obj = (typeof(t=obj[prop])=='object')?t:(obj[prop]={});
                    }else if(ln==3){
                        if(pos>lp)ac.push( s.slice(lp,pos) );
                        sac.push(ac); sarg.push(arg);
                        arg = [], ac = [], lp = pos+open.length;
                    } 
                    return m;
                }
                if( close ){
                    if( !sn.length || mn[ln=sn.pop()] != close){
                        throw({t:"JSS Error - closed "+ln+" with "+close,p:pos});
                        log();
                    }
                    switch(ln){
                        case 3: // closed an array
                            ac.push(s.slice(lp,pos));arg.push(ac.join(''));
                            if(sarg.length!=1){ // append as string
                                (ac=sac.pop()).push( '[',arg.join(','),']' );
                                arg = sarg.pop();
                            }
                            else { // append as array
                                sac.pop();t = sarg.pop();ac=[];
                                for(i = 0,len=arg.length;i<len;i++)t.push(arg[i]);
                                arg = t;
                            }
                            lp = pos+close.length;
                            break;
                        case 4: // closed a macro
                            ac.push(s.slice(lp,pos));arg.push(ac.join(''));
                            (ac=sac.pop()).push( (t=_self[fn])?t.apply( _self, 
                            arg ) : fn+'*'+'('+arg.join(',')+')' );
                            arg = sarg.pop(), fn = sfn.pop(), lp = pos+1;
                            break;
                         case 5: // closed an object
                            ac.push(s.slice(lp,pos));arg.push(ac.join(''));lp = pos+close.length, ac = []; 
                            if(prop)obj[prop] = arg.length>1?arg:arg[0];
                            arg=[], prop=null, obj = sobj.pop();
                            break;
                    }
                    if(!sarg.length)ln=6;
                    return m;
                }
                if( ln>=5 ){
                    ac.push(s.slice(lp,pos));
                    if((t=ac.join('')).length)arg.push(t);
                    lp = pos+m.length, ac = [];
                    if(prop)obj[prop] = arg.length>1?arg:arg[0];
                    else if(t && sn.length==0)obj = arg.length>1?arg:arg[0];
                    arg=[],prop=null;
                }
                return m;
            });
            if(sm)throw({t:"JSS Error - Unclosed string found "+sm,p:lp});
            if(sn.length>0)throw({t:"JSS Error - Unclosed object found "+sn[sn.length-1],p:lp});
        }catch(e){
            apf.alert_r(e);
            if(err)err.v = e.p>=0 ? e.t+" at: "+e.p+" ->"+s.slice((t=e.p-4)<0?0:t,7)+"<-" : e.t;
            return null;
        }
        return obj;
    },
     
	sin : function(a){return "__sin("+a+")";},
	cos : function(a){return "__cos("+a+")";},
	tan : function(a){return "__tan("+a+")";},
	asin : function(a){return "__asin("+a+")";},
	acos : function(a){return "__acos("+a+")";},
	atan : function(a){return "__atan("+a+")";},
	atan2 : function(a){return "__atan2("+a+")";},
	floor : function(a){return "__floor("+a+")";},
	exp : function(a){return "__exp("+a+")";},
	log : function(a){return "__log("+a+")";},
	pow : function(a,b){return "__pow("+a+","+b+")";},
	random : function(a){return "__random("+a+")";},
	round : function(a){return "__round("+a+")";},
	sqrt : function(a){return "__sqrt("+a+")";},
	$pal : function(imode,n){
		// alright this is a color interpolation function, we got n arguments 
		// which are string colors, hexcolors or otherwise and we need to write an interpolator
		var s=[
		"'#'+('000000'+(__round(",
		"((__a=parseInt((__t=["];
		for(var i = 2, len=arguments.length;i<len;i++){
			var t = arguments[i];
			// check what t is and insert
			s.push(i>2?",":"");
			if(apf.draw.colors[t])
				s.push( "'", apf.draw.colors[t], "'" );
			else if(t.match(/\(/))
				s.push(t);
			else if(t.match(/^#/))
				s.push( "'", t, "'" );
			else
				s.push(t);
		}
        if(imode&2) s.push(
			"])[ (__g=__floor( __c=(__f=(",n,")",(imode&1)?"*"+(len-3):"",
			")<0?0:__f))>",len-3,"?",len-3,":__g].slice(1),16))&0xff)",
			"*(__d=1-(__c-__floor(__c)))",
			"+((__b=parseInt(__t[ (__g=__ceil(__c))>",len-3,"?",len-3,":__g",
			"].slice(1),16))&0xff)*(__e=1-__d) )",
			"+(__round(__d*(__a&0xff00)+__e*(__b&0xff00))&0xff00)",
			"+(__round(__d*(__a&0xff0000)+__e*(__b&0xff0000))&0xff0000)",
			").toString(16)).slice(-6)");
        else s.push(
			"])[ __floor( __c=(__f=(",n,")",imode?"*"+(len-3):"",
			")<0?-__f:__f)%",len-2,"].slice(1),16))&0xff)",
			"*(__d=1-(__c-__floor(__c)))",
			"+((__b=parseInt(__t[ __ceil(__c)%",len-2,
			"].slice(1),16))&0xff)*(__e=1-__d) )",
			"+(__round(__d*(__a&0xff00)+__e*(__b&0xff00))&0xff00)",
			"+(__round(__d*(__a&0xff0000)+__e*(__b&0xff0000))&0xff0000)",
			").toString(16)).slice(-6)");      
		return s.join('');
	},
	$lut : function(imode,n){
		var s=["(["],a, i = 2, len = arguments.length;
		for(;i<len;i++){
			a = arguments[i];s.push(i>2?",":"");
			if(typeof(a)=='string' && a.match(/\(/) || a.match(/^['"]/))
				s.push(a);
			else s.push("'",a,"'");
		}
		s.push("])[__floor((__b=((",n,")",imode?"*"+(len-3):"",
			")%",len-2,")<0?-__b:__b)]");
		return s.join('');
	},
	
	$lin : function(imode,n){
		var s=["((__t=["],a, i = 2,len=arguments.length;
		for(;i<len;i++){
			a = arguments[i]; s.push(i>2?",":"");
			if(typeof(a)=='string' && a.match(/\(/) || a.match(/^['"]/))
				s.push(a);
			else s.push("'",a,"'");
		}
		s.push("])[__floor( __c=(__f=(",n,")",imode?"*"+(len-3):"",
			")<0?-__f:__f)%",len-2,"]",
			"*(__d=1-(__c-__floor(__c)))",
			"+__t[ __ceil(__c)%",len-2,
			"]*(__e=1-__d) )");
		return s.join('');
	},

	fixed : function(a,v,nz){
		v = "parseFloat(("+a+").toFixed("+v+"))";
		return parseInt(nz)?this.nozero(a,v):v;
	},
	padded : function(a,v,nz){
		v = "("+a+").toFixed("+v+")";
		return parseInt(nz)?this.nozero(a,v):v;
	},
	abs : function(a){
		if(parseFloat(a)==a)return Math.abs(a);
		if(typeof(a) == 'number' || a.match(/$[a-z0-9_]+^/))
			return "("+a+"<0?-"+a+":"+a+")";
		return "((__t="+a+")<0?-__t:__t)";
	},
	min : function(a,b){
		if(b===null)return a; 
		if(parseFloat(a)==a && parseFloat(b)==b)return Math.min(a,b);
		var a1=a,b1=b,a2=a,b2=b;
		if(typeof(a) == 'string' && !a.match(/$-?[a-z0-9\_]+^/))a1="(__a="+a+")", a2="__a";
		if(typeof(b) == 'string' && !b.match(/$-?[a-z0-9\_]+^/))b1="(__b="+b+")", b2="__b";
		return "(("+a1+")<("+b1+")?"+a2+":"+b2+")";
	},
	max : function(a,b){
		if(b===null)return a; 
		if(parseFloat(a)==a && parseFloat(b)==b)return Math.max(a,b);
		var a1=a,b1=b,a2=a,b2=b;
		if(typeof(a) == 'string' && !a.match(/$-?[a-z0-9\_]+^/))a1="(__c="+a+")", a2="__c";
		if(typeof(b) == 'string' && !b.match(/$-?[a-z0-9\_]+^/))b1="(__d="+b+")", b2="__d";
		return "(("+a1+")>("+b1+")?"+a2+":"+b2+")";
	},
	clamp : function(a,b,c){
		if(b===null||c==null)return a; 
		return this.max(this.min(a,c),b);
	},  
	pal : function(){
		var arg = Array.prototype.slice.call(arguments,0);arg.unshift(1);
		return this.$pal.apply(this,arg);
	},
	pali : function(){
		var arg = Array.prototype.slice.call(arguments,0);arg.unshift(0);
		return this.$pal.apply(this,arg);
	},
	palc : function(){
		var arg = Array.prototype.slice.call(arguments,0);arg.unshift(3);
		return this.$pal.apply(this,arg);
	},
	palci : function(){
		var arg = Array.prototype.slice.call(arguments,0);arg.unshift(2);
		return this.$pal.apply(this,arg);
	},    
	lin : function(){
		var arg = Array.prototype.slice.call(arguments,0);arg.unshift(1);
		return this.$lin.apply(this,arg);
	},
	lini : function(){
		var arg = Array.prototype.slice.call(arguments,0);arg.unshift(0);
		return this.$lin.apply(this,arg);
	},
	lut : function(){
		var arg = Array.prototype.slice.call(arguments,0);arg.unshift(1);
		return this.$lut.apply(this,arg);
	},
	luti : function(){
		var arg = Array.prototype.slice.call(arguments,0);arg.unshift(0);
		return this.$lut.apply(this,arg);
	},
	$rgbpack : function( r,g,b){
		return ('#'+('000000'+(((r<0?0:(r>255?255:parseInt(r)))<<16)+
				((g<0?0:(g>255?255:parseInt(g)))<<8)+
				((b<0?0:(b>255?255:parseInt(b))))).toString(16)).slice(-6));
	},
	rgb : function(r,g,b){
		if(parseFloat(r)==r && parseFloat(g)==g && parseFloat(b)==b)
			return this.$rgbpack(r,g,b);
		return ["('#'+('000000'+(",
				   (parseFloat(r)==r?((r<0?0:(r>255?255:parseInt(r)))<<16):
				   "(((__t="+r+")<0?0:(__t>255?255:parseInt(__t)))<<16)"),"+",
				   (parseFloat(g)==g?((g<0?0:(g>255?255:parseInt(g)))<<8):
				   "(((__t="+g+")<0?0:(__t>255?255:parseInt(__t)))<<8)+"),"+",
				   (parseFloat(b)==b?((b<0?0:(b>255?255:parseInt(b)))):
				   "(((__t="+b+")<0?0:(__t>255?255:parseInt(__t))))"),
				   ").toString(16)).slice(-6))"].join('');
	},
	$hsvpack : function(h,s,v){
		 var i, m=v*(1-s), 
			 n=v*(1-s*((i=Math.floor(((h<0?-h:h)%1)*6))?h-i:1-(h-i)));  
		 
		 switch (i) 
		 {  
		  case 6:  
		  case 0: return this.$rgbpack(v, n, m);  
		  case 1: return this.$rgbpack(n, v, m);  
		  case 2: return this.$rgbpack(m, v, n);
		  case 3: return this.$rgbpack(m, n, v);  
		  case 4: return this.$rgbpack(n, m, v);  
		  default:
		  case 5: return this.$rgbpack.rgb(v, m, n);  
		}
	},
	hsv : function(h,s,v){
		if(parseFloat(r)==r && parseFloat(g)==g && parseFloat(b)==b)
			return this.$hsvpack(r,g,b);
		return "apf.draw.$hsvpack("+h+","+s+","+v+");";
	},
	rgbf : function(r,g,b){
		return this.rgb(parseFloat(r)==r?r*255:"255*("+r+")",
						parseFloat(g)==g?g*255:"255*("+g+")",
						parseFloat(b)==b?b*255:"255*("+b+")");
	},
	nozero : function(a,v,z){
		return "(("+a+")>-0.0000000001 && ("+a+")<0.0000000001)?"+
			(z!==undefined?z:"''")+":("+(v!==undefined?v:a)+")";
	},    
	$rndtab : null,
	rnd : function(a){
		if(a){
			if( !this.$rndtab ){
				var i, t = this.$rndtab = Array( 256 );
				for(i = -256;i<256;i++)t[i] = Math.random();
			}
			return "_rndtab[__round(("+a+")*255)%255]";
		}
		return "((_rseed=(_rseed * 16807)%2147483647)/2147483647)"
	},
    ang : function(a){
        if(a == parseFloat(a))return a * (Math.PI / 180);
        //alert("("+a+"(p/180))");
        return "(("+a+")*p/180)";
    },
	snap : function(a,b){
		return "(__round(("+a+")/(__t=("+b+")))*__t)";
	},
	rnds : function(a,b){
		return this.rnd(this.snap(a,b));
	},
	tsin : function(a){
		return "(0.5+0.5*__sin("+a+"))"; 
	},
	tcos : function(a){
		return "(0.5+0.5*__cos("+a+"))"; 
	},
	usin : function(a){
		return "(0.5-0.5*__sin("+a+"))"; 
	},
	ucos : function(a){
		return "(0.5-0.5*__cos("+a+"))"; 
	},        
	two : function(a){
		return "(0.5+0.5*("+a+"))"; 
	},
    easein : function(t,pow){
        if(!pow)pow = '3';
        return ['__pow(',t,',',pow,')'].join('');
    },
    easeout : function(t,pow){
        if(!pow)pow = '3';
        return ['(1-__pow(1-(',t,'),',pow,'))'].join('');
    },
    ease : function(t,powin,powout){
        if(!powin)powin = '3';
        if(!powout)powout = powin;
        return ["(0.5*((__a=2*(",t,"))<1?",
                      "__pow(__a,",powin,"):",
                      "(2-__pow(2-__a,",powout,"))))"].join('');
    },
    fontz : function(a,b) {
        // we multiply b*l.ds and then 
        return (-a/b)+(this.ortho?"*perspd":"*(perspd/__z)");
    },

    $canJoin : function( a, b){
        if(a.isfont && b.isfont)
            return  a.join!=null && b.join!=null && 
                    a.family === b.family &&
                    a.join === b.join &&
                    a.height == b.height &&
                    a.width == b.width && 
                    a.align === b.align && 
                    a.color === b.color && 
                    a.size === b.size &&
                    a.style === b.style;
        if(a.isshape && b.isshape)
            return  a.join!=null && b.join!=null && 
                   a.stroke === b.stroke && 
                   a.join === b.join &&
                   a.weight == b.weight &&
                   a.fill === b.fill &&
                   a.fillopacity === b.fillopacity && 
                   a.strokeopacity === b.strokeopacity &&
                   a.angle === b.angle;
        return false;
    },

    $shape : {
        isshape : true,
        stroke : null,
        fill : null,
        tilex:'(this.$tilex)',
        tiley:'(this.$tiley)'
    },

    $font : {
        isfont : true,
        height : 12,
        family : "verdana",
        weight : "normal",
        color : "#00000",
        size : 10
    },    

    //----------------------------------------------------------------------
    
    // Generic rendering
    
    //----------------------------------------------------------------------
    
    draw3D : function(x,y,z,w,h,d){
        return '';
    },

    //----------------------------------------------------------------------
    
    beginMouseState : function( style, sthis, func, nargs ){
        var s = [], l = this.l;

        this.mousestyle = style;
        this.mousethis = sthis;
        this.mousefunc = func;
        this.mousestates = [];
        var v = style.$statelist, i, j, t, u;
        if(!v || !v.length) return '';
        
        v = this.mousestates = v.slice(0);
        if(v[0]!=style)
            v.unshift(style);

        if(!l._mousestyles)l._mousestyles = [];
        for(i = 0, j = v.length;i<j;i++){
           u = (t=v[i])._mid = l._mousestyles.push(t)-1;
           if(t.$store)t.$store._mid = u;
        }
        
        s.push("_s = l._mousestyles[",style._mid,"], _sh = _s.$statehash, _sp = _s.$speedhash;");
        
        return s.join('');
    },
    
    checkMouseState:function(state,time) {
        var a=[],t,i,j,v = this.mousestates, s;

        if(!v || !v.length){
            for(i = 2, j = arguments.length;i<j;i++)a.push(arguments[i]);
            a.push(true);
            this.style = this.mousestyle;
            s = this.mousefunc.apply(this.mousethis,a);
            this.style = 0;
            return s;
        }
        s = ["t=(n-",time,")*(_sp[_t=_sh[",state,"]]||100000);"];
        for(i = 2, j = arguments.length;i<j;i++){
            a.push( t = "_s"+(i-1) );
            s.push( t,"=",arguments[i],(i!=j-1)?",":";");
        }
        a.push(true);
        
        s.push("switch(_t?_t._mid:0){" );
        for(i = 0, j = v.length;i<j;i++){
            var style = v[i];
            //alert(apf.vardump(style).replace(/\t/g,'@').replace(/\n/g,'#'));
            this.style = style;
            if(v[i])
                s[s.length]=[
                "case ",style._mid,":{","/*"+apf.vardump(style,0,1)+"*/\n",
                     this.mousefunc.apply(this.mousethis,a),
                "}break;"].join('');
        }
        s.push("};");
        this.style = 0;
        return s.join('');
    },
    
    $endMouseState : function(){
        this.mousestyle = 0;
        return '';
    },
    
    //----------------------------------------------------------------------
    
    shapedPart : function(x,y,w,h,rs,rw,m){
        var t = this.style;
        var ds = '0', dw = '1';
        var gx = this.getX, gy = this.getY, cx = this.checkX, cy = this.checkY;
        switch(t.shape){
            default:
            case 'pie':
                if(gx(t,'','scale','','1')!='1'){
                    rs=['_x5=(',gx(t,'(','offset',')+'),'(',rs,')','+',
                        gx(t,'(','center',')','0.5'),'*(_x3=',rw,')',
                        gx(t,'*(1-(_x4=','scale','))'),')*p2'].join('');
                    rw='_x5+(_x3*_x4)*p2';
                }else{
                    rs = ['_x5=(',gx(t,'(','offset',')+'),'(',rs,')',')*p2'].join('');
                    rw = '_x5+('+rw+')*p2';
                }   
                if(gy(t,'','scale','','1')!='1'){
                    ds=[gy(t,'(','offset',')+'),gy(t,'(','center',')','0.5'),
                       gy(t,'*(1-(_y4=','scale','))')].join('');
                    dw='_y4';
                }else{
                    ds = [gy(t,'(','offset',')','0')].join('');
                    dw = '1';
                }
                // lets draw an ellipse with rs and rw phases
                // now we have an offset y and a size y how do we deal with that?
                if(ds!='0'){
                    x = "_x6=__sin(_y8=((_x9="+rs+")+(_y9="+rw+"))*0.5)*(_x8="+
                                    ds+")*(_x7="+w+")+("+x+")"+gx(t,'+_x7*(','move',')');
                    y = "_y6=__cos(_y8)*_x8*(_y7="+h+")+("+y+")"+gy(t,'+_y7*(','move',')');
                    w = '_x7*(_x3='+dw+')';
                    h = '_y7*_x3';
                    rs = '_x9';
                    rw = '_y9';
                }else{
                    x = "_x6=("+x+")";
                    y = "_y6=("+y+")";
                    w = dw=='1'?'('+w+')':'('+w+')*(_x3='+dw+')';
                    h = dw=='1'?'('+h+')':'('+h+')*_x3';
                }
                if(m){
                    return [
                        "if( ((_x1=((",x,")-mx)/(",w,"))*_x1+(_y1=((",y,")-my)/(",h,"))*_y1) < 1 ){",
                            "_x1=(p+__atan2(_x1,_y1));",
                            "if( ((_x2=(",rs,")%p2)<0?(_x2=p2-_x2):_x2) >",
                                "((_y2=(",rw,")%p2)<0?(_y2=p2-_y2):_y2) ){",
                                "if(_x1 >= _x2 || _x1<=_y2 )return x;",
                            "}else{",
                                "if(_x1 >= _x2 && _x1<=_y2 )return x;",
                            "}",
                        "}"
                    ].join('');
                }else{
                    return [
                        this.moveTo(x,y),
                        this.ellipse('_x6','_y6',w,h,rs,rw,1),
                        this.close()].join('');
                }
                /*
                if(gx(t,'','scale','','1')!='1'){
                    rs=['_x5=(',gx(t,'(','offset',')+'),'(',rs,')','+',
                        gx(t,'(','center',')','0.5'),'*(_x3=',rw,')',
                        gx(t,'*(1-(_x4=','scale','))'),
                        gx(t,'+_x3*(','move',')'),')*p2'].join('');
                    rw='_x5+(_x3*_x4)*p2';
                }else{
                    rs = ['_x5=(',gx(t,'(','offset',')+'),'(',rs,')',
                          gx(t,'+(_x3='+rw+')*(','move',')'),')*p2'].join('');
                    rw = '_x5+('+cx(t,'move','_x3',rw)+')*p2';
                }   
                if(gy(t,'','scale','','1')!='1'){
                    ds=[gy(t,'(','offset',')+'),gy(t,'(','center',')','0.5'),
                       gy(t,'*(1-(_y4=','scale','))'),gy(t,'+(','move',')')].join('');
                    dw='_y4';
                }else{
                    ds = [gy(t,'(','offset',')','0'),gy(t,'+(','move',')')].join('');
                    dw = '1';
                }
                // lets draw an ellipse with rs and rw phases
                // now we have an offset y and a size y how do we deal with that?
                if(ds!='0'){
                    return [
this.moveTo("_x6=__cos(_y8=((_x9="+rs+")+(_y9="+rw+"))*0.5)*(_x8="+ds+")*(_x7="+w+")+("+x+")",
                                    "_y6=__sin(_y8)*_x8*(_y7="+h+")+("+y+")"),
                        this.ellipse( '_x6','_y6','_x7*(_x3='+dw+')','_y7*_x3','_x9','_y9',1),
                        this.close()].join('');
                }else{
                    return [
                        this.moveTo("_x6=("+x+")","_y6=("+y+")"),
                        this.ellipse( '_x6','_y6',dw=='1'?'('+w+')':'('+w+')*(_x3='+dw+')',
                                     dw=='1'?'('+h+')':'('+h+')*_x3',rs,rw,1),
                        this.close()].join('');
                }*/
        }
    },
    
    //----------------------------------------------------------------------
    
    shapedRect : function(x,y,w,h,m){
        // css stylable drawing
        var t = this.style;
        var gx = this.getX, gy = this.getY, cx = this.checkX, cy = this.checkY;
        function rect(){
            if(gx(t,'','scale','','1')!='1'){
                x=[gx(t,'dzw*(','offset',')+'),'(',x,')','+',gx(t,'(','center',')','0.5'),'*(_x3=',w,')',
                   gx(t,'*(1-(_x4=','scale','))'),gx(t,'+_x3*(','move',')')].join('');
                w='_x3*_x4';
            }else{
                x = [gx(t,'dzw*(','offset',')+'),'(',x,')',gx(t,'+(_x3='+w+')*(','move',')')].join('');
                w = cx(t,'move','_x3',w);
            }   
            if(gy(t,'','scale','','1')!='1'){
                y=[gy(t,'dzh*(','offset',')+'),'(',y,')','+',gy(t,'(','center',')','0.5'),'*(_y3=',h,')',
                   gy(t,'*(1-(_y4=','scale','))'),gy(t,'+_y3*(','move',')')].join('');
                h='_y3*_y4';
            }else{
                y = [gy(t,'dzh*(','offset',')+'),'(',y,')',gy(t,'+(_y3='+h+')*(','move',')')].join('');
                h = cy(t,'move','_y3',h);
            }   
        }
        switch(t.shape){
            case 'rect':
            default:
                if(!t.rotate){
                    rect();
                    if(m){
                        return [
                            "if( (_x9 = mx - (",x,"))>=0 && _x9<(",w,")&&",
                            "    (_y9 = my - (",y,"))>=0 && _y9<(",h,")) return x;",
                        ].join('');
                    }
                    return this.rect(x,y,w,h);
                }else{
                    return  [
                     '_x9=(_x8=(_x6=',gx(t,'(','center',')','0.5'),'*(_x3=',w,'))*(',gx(t,
                          '(1-(_x4=','scale','))','0'),'-1))+_x3',cx(t,'scale','*_x4'),';',
                     '_y9=(_y8=(_y6=',gy(t,'(','center',')','0.5'),'*(_y3=',h,'))*(',gy(t,
                          '(1-(_y4=','scale','))','0'),'-1))+_y3',cy(t,'scale','*_y4'),';',
                     this.moveTo('(_cr=__cos(_t='+t.rotate+'))*_x8-(_sr=__sin(_t))*_y8+(_x5='+
                                 gx(t,'(','offset',')+')+x+'+_x6)','_sr*_x8+_cr*_y8+(_y5='+
                                 gy(t,'(','offset',')+')+y+'+_y6)'),
                     this.lineTo('_cr*_x9-_sr*_y8+_x5','_sr*_x9+_cr*_y8+_y5'),
                     this.lineTo('_cr*_x9-_sr*_y9+_x5','_sr*_x9+_cr*_y9+_y5'),
                     this.lineTo('_cr*_x8-_sr*_y9+_x5','_sr*_x8+_cr*_y9+_y5'),
                     this.close()
                    ].join('');
            }
            case 'circle':{
                rect();
                 if(m){
                        return [
                            "if( (_x9 = mx - (",x,"))>=0 && _x9<(",w,")&&",
                            "    (_y9 = my - (",y,"))>=0 && _y9<(",h,")) return x;",
                        ].join('');
                }
                return t.pie?[
                    this.moveTo('_x6='+x+'+'+'(_x5=0.5*('+w+'))','_y6='+y+'+'+'(_y5=0.5*('+h+'))'),
                    this.ellipse('_x6','_y6','_x5','_y5',gx(t,'','range','' ),gy(t,'','range','' ) ),
                    this.close()].join(''):[
                    this.ellipse(x+'+'+'(_x5=0.5*('+w+'))',y+'+'+'(_y5=0.5*('+h+'))',
                                 '_x5','_y5',gx(t,'','range','' ),gy(t,'','range','' ) ),
                    this.close()].join('');
            }break;
             case 'polygon':{
                if(t.frames){
                    
                }else{
                    return [
                        "_x3=((_x2=",gy(t,"","range","","2*p"),
                        ")-(_x1=",gx(t,'','range','','0'),"))/(",t.steps||10,");v=_x1;",
                        this.moveTo("(_x4="+x+")+__sin(_x1)*(_x5="+w+")",
                                    "(_y4="+y+")+__cos(_x1)*(_y5="+h+")"),
                        "for(v=_x1+_x3;v<_x2;v+=_x3){",
                            this.lineTo("_x4+__sin(_x1)*_x5",
                                        "_y4+__cos(_x1)*_y5"),
                        "}",
                        this.close()
                    ].join('');
                }
            }break;
            case 'math':{
                if(t.frames){
                    // expand shape
                }else{
                    rect();
                    return [
                        "_x7=((_x6=",gy(t,"","range","","2*p"),
                        ")-(_x5=",gx(t,'','range','','0'),"))/(",t.steps||10,");v=_x5;",
                        this.moveTo("(_x8="+x+")+"+gx(t,"(","path",")","0")+"*(_x9="+w+")",
                                    "(_y8="+y+")+"+gy(t,"(","path",")","0")+"*(_y9="+h+")"),
                        "for(v=_x5+_x7;v<_x6;v+=_x7){",
                            this.lineTo("_x8"+gx(t,"+(","path",")*_x9"),
                                        "_y8"+gy(t,"+(","path",")*_y9")),
                        "}",
                        this.close()
                    ].join('');
                }
            }break;
        }
        return '';
    },
    
    $endDraw : function() {
        if(this.mousemode){
            return this.$endMouse();
        }
        if(this.statemode){
            return this.$endState();
        }
        var t = this.style;
        if(t){
            if(t.isshape)
                return this.$endShape();
            if(t.isfont)
                return this.$endFont();
        }
        return '';
    },
       
    //----------------------------------------------------------------------
    
    // State rendering

	//----------------------------------------------------------------------

    serializeStyleState : function(style){
        var s = [] ,h,v,k,f;
        if(!style.$stylelist)return "";
        s.push("$storelist:_n=[", Array(style.$stylelist.length).join("[],"),"[]]");
        s.push(",$storelut:{");
        h = style.$storelut;f = 1;
        for(k in h){
            s.push(--f?",":"","0x",parseInt(k).toString(16),":_n[",h[k],"]");
        }
        s.push("},$speedlut:{");
        h = style.$speedlut;f = 1;
        for(k in h){
            s.push(--f?",":"","0x",parseInt(k).toString(16),":",h[k]);
        }
        s.push("},$overlaylut:{");
        h = style.$overlaylut;f = 1;
        for(k in h){
           s.push(--f?",":"","0x",parseInt(k).toString(16),":0x",parseInt(h[k]).toString(16));
        }
        s.push("}");
        return s.join('');
    },
    
    // state based drawing
    beginState : function( style, sthis, func, nargs, dyns ){
        var s = [this.beginShape(style.$shadow || style)];
        
        this.statemode = 1;
        this.statethis = sthis;
        this.stateargs = nargs;
        this.statefunc = func;
        this.statedyns = dyns || [];
        this.statedyns.push("t","x");
        
        var v = style.$stylelist, i, n;
        if(!v || !v.length) return s.join('');
    
        s.push("_storelut = _s.$storelut, _storelist = _s.$storelist,_overlaylut = _s.$overlaylut,",
               "_translut = apf.draw.stateTransition, _speedlut = _s.$speedlut ;\n");
        
        for(i = 0, n = v.length;i<n;i++){
            s[s.length]="_storelist["+i+"].length=";
        }s[s.length]="0;";
        return s.join('');
    },
    
    drawState:function(state,time) {
        var a=[],t,i,j,v = this.style.$stylelist,d;
        if(!v || !v.length){
             for(i = 2, j = arguments.length;i<j;i++)
                a.push(arguments[i]);
            return this.statefunc.apply(this.statethis,a);
        }
        var s=["if((_t=",state,")&0x0f000000){",
                    "if((t=(n-(",time,"))*(_speedlut[_t]||100000))>1){",
                        "_t=",state,"=_translut[_t],",time,"=n,t=0;",
                    "}",
                    "if(_t&0x0f000000)_anim=1,nt=1-t;",
                "}"];
        for(i = 2, j = arguments.length;i<j;i++){
            a.push(t="_s"+(i-1));
            s.push( t,"=",arguments[i],(i!=j-1)?",":";");
        }
        d = this.statedyns.join(',');
        t = a.join(',');
        s.push( "if(_st=_storelut[_t]){",
                "_st.push(",d,",",t,");",
                "while(_t=_overlaylut[_t]){",
                    "if(_st = _storelut[_t]){_st.push(",d,",",t,");}",
                "};",
                "};",
                "if(!_st){",this.statefunc.apply(this.statethis,a),"}\n"
            );
        return s.join('');
    },
    
    $endState : function(){
        this.statemode = 0;
        var style = this.style, s = [this.$endDraw()];

        var v = style.$stylelist, i, j, l, m, n = this.stateargs+this.statedyns.length, a = [], d=[];
        if(!v || !v.length)return s.join('');
        
        for(i=this.statedyns.length;i<n;i++){
            a.push("_su[_sv+"+i+"]");
        }
        for(i=0;i<this.statedyns.length;i++){
            d.push(this.statedyns[i]+"=_su[_sv+"+i+"]");
        }
        d=d.join(',');
        for(i = 0, j = v.length;i<j;i++){
            style = v[i]; 
            s[s.length]=[
              "if((_st=(_su=_storelist["+i+"]).length)>0){",
                  "_sv=0,",d,";",
                  this.beginShape(style),
                  "for(_sv=0;_sv<_st;_sv+=",n,"){",
                    d,",nt = 1-t;",
                    this.statefunc.apply(this.statethis,a),
                  "}",
                  this.$endDraw(),
              "}else _styles[",style._id,"]._path=[];\n"
              ].join('');
        }
        return s.join('');
    },
    
    //----------------------------------------------------------------------
    
    // HTML Text output
    
    //----------------------------------------------------------------------
         
    
    // generic htmlText
    beginFont: function( style, needed, ml,mt,mr,mb ) {
        if(!style || needed===undefined)return "document.title='beginFont Failed';";
        var l = this.l, html = l._htmljoin, s=[this.$endDraw()];
        this.style = style;
        style._id = l._styles.push(style)-1;

        ml = ml!==undefined?ml/l.ds:0;
        mt = mt!==undefined?mt/l.ds:0;
        mr = mr!==undefined?mr/l.ds:0;
        mb = mb!==undefined?mb/l.ds:0;
       
       
        if(parseInt(style.left)!=style.left) this.mx = "+("+style.left+")"+(ml?"-"+ml:"");
        else this.mx = "+"+(style.left-ml);
        if(parseInt(style.top)!=style.top) this.my = "+("+style.top+")"+(mt?"-"+mt:"");
        else this.my = "+"+(style.top-mt);
        // find a suitable same-styled other text so we minimize the textdivs
        /*
        for(i = l._styles.length-2;i>=0;i--){
            if(!l._styles[i]._prev && 
                apf.draw.equalStyle( l._styles[i], style )){
                style._prev = i;
                break;
            }
        }
        s
        if(style._prev===undefined){*/
        this.dynsize = (parseInt(style.size)!=style.size);
        style._txtdiv = ["<div style='",
                (style.vertical)?
                "filter: flipv() fliph(); writing-mode: tb-rl;":"",
    "position:absolute;cursor:default;overflow:hidden;left:0;top:0;display:none;font-family:",
                style.family, ";color:",style.color,";font-weight:",
                style.weight,";",";font-size:",this.dynsize?10:style.size,"px;",
                (style.stroke!==undefined)?"border:1px solid "+style.stroke+";" : "",
                (style.fill!==undefined)?"background:"+style.fill+";" : "",

                (style.width!==undefined)?"width:"+style.width+"px;" : "",
                (style.height!==undefined)?"height:"+style.height+"px;" : "",
                (style.style!==undefined)?"font-style:"+style.style+";" : "",
                (style.align!==undefined)?"text-align:"+style.align+";" : "",
                "'>-</div>"].join('');
        html.push("<div onmousedown='return false' style='cursor:default;position:absolute;left:",ml,"px;top:",mt,
                  "px;width:",l.width-(mr+ml),"px;height:",l.height-(mb+mt),
                  "px;overflow:hidden;'></div>");

        s.push( "_s=_styles[",style._id,"],_tn=_s._txtnodes,_tc = 0;\n");
        /*} else {
            if(this.last !== style._prev) 
                s.push("_s=_styles[",style._prev,
                       "],_tn=_s._txtnodes,_tc = _s._txtcount;\n");
        }*/
        s.push("if((_l=(",needed,
               ")) > _tn.length-_tc)apf.draw.$allocText(_s,_l);");
        return s.join('');
    },
    
    text : function( x, y, text) {
        var t = ((this.l.ds>1)?"/"+this.l.ds:"");
        return ["if( (_t=_tn[_tc++]).s!=(_v=",text,") )_t.v.nodeValue=_t.s=_v;",
                "if(_t.x!=(_v=__round(",x,")))_t.n.style.left=_t.x=(_v",t,this.mx,")+'px';",
                "if(_t.y!=(_v=__round(",y,")))_t.n.style.top=_t.y=(_v",t,this.my,")+'px';",
                this.dynsize?[
                    "if(_t.sz!=(_v=__round(",this.style.size,"))&&_v>0)_t.n.style.fontSize=_t.sz=_v+'px';"
                ].join(''):""].join('');
    
    },
    
    $allocText : function(style, needed){
        var t, tn = style._domnode, ts = style._txtnodes;
        if(!ts.length)tn.innerHTML = Array(needed+1).join(style._txtdiv); 
        else tn.insertAdjacentHTML('beforeend',Array(needed+1).
                                    join(style._txtdiv));
        while(needed-->0){
            t=tn.childNodes[ts.length];
            ts.push({ x:-10000000000,y:-10000000000, n: t, v: t.firstChild,sz:-1,s:null});
        }
    },
    
    $endFont : function(){
        this.last = this.style._id;
        this.style = 0;
        this.mx="",this.my="";
        return "_s._txtcount = _tc;";
    },
    
    $finalizeFont : function(style) {
        var s=["if((_lc=(_s=_styles[",style._id,"])._txtused)>",
            "(_tc=_s._txtcount)){_tn=_s._txtnodes;",
            "for(;_lc>_tc;)_tn[--_lc].n.style.display='none';",
            "_s._txtused=_tc;",
        "} else if(_lc<_tc) {_tn=_s._txtnodes;",
            "for(;_lc<_tc;)_tn[_lc++].n.style.display='block';",
            "_s._txtused=_tc;",
        "}\n"];
        //var v = style._txtnodes = [];
        //style._txtused = 0;
        //style._txtcount = 0;
        return s.join('');
    },
    

    colors : apf.color.colors
};


/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/date.js)SIZE(29151)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

/**
 * @term dateformat Format a date based on small strings of characters representing
 * a variable.
 * Syntax:
 * <code>
 * d      day of the month as digits, no leading zero for single-digit days
 * dd     day of the month as digits, leading zero for single-digit days
 * ddd    day of the week as a three-letter abbreviation
 * dddd   day of the week as its full name
 * m      month as digits, no leading zero for single-digit months
 * mm     month as digits, leading zero for single-digit months
 * mmm    month as a three-letter abbreviation
 * mmmm   month as its full name
 * yy     year as last two digits, leading zero for years less than 2010
 * yyyy   year represented by four digits
 * h      hours, no leading zero for single-digit hours (12-hour clock)
 * hh     hours, leading zero for single-digit hours (12-hour clock)
 * H      hours, no leading zero for single-digit hours (24-hour clock)
 * HH     hours, leading zero for single-digit hours (24-hour clock)
 * M      minutes, no leading zero for single-digit minutes
 * MM     minutes, leading zero for single-digit minutes
 * s      seconds, no leading zero for single-digit seconds
 * ss     seconds, leading zero for single-digit seconds
 * </code>
 */


// Some common format strings
/**
 * @private
 */
apf.date = (function() {

return {
    masks : {
        "default":      "ddd mmm dd yyyy HH:MM:ss",
        shortDate:      "m/d/yy",
        mediumDate:     "mmm d, yyyy",
        longDate:       "mmmm d, yyyy",
        fullDate:       "dddd, mmmm d, yyyy",
        shortTime:      "h:MM TT",
        mediumTime:     "h:MM:ss TT",
        longTime:       "h:MM:ss TT Z",
        isoDate:        "yyyy-mm-dd",
        isoTime:        "HH:MM:ss",
        isoDateTime:    "yyyy-mm-dd'T'HH:MM:ss",
        isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
    },

    // Internationalization strings
    i18n : {
        /**
         * Defines what day starts the week
         *
         * Monday (1) is the international standard.
         * Redefine this to 0 if you want weeks to begin on Sunday.
         */
        beginWeekday : 1,
        dayNames : [
            "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
            "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
            "Friday", "Saturday"
        ],

        dayNumbers : {
            "Sun" : 0, "Mon" : 1, "Tue" : 2, "Wed" : 3, "Thu" : 4, "Fri" : 5,
            "Sat" : 6, "Sunday" : 0, "Monday" : 1, "Tuesday" : 2,
            "Wednesday" : 3, "Thursday" : 4, "Friday" : 5, "Saturday" : 6
        },
        monthNames : [
            "Jan", "Feb", "Mar", "Apr", "May", "Jun",
            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
            "January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ],
        monthNumbers : {
            "Jan" : 0, "Feb" : 1, "Mar" : 2, "Apr" : 3, "May" : 4, "Jun" : 5,
            "Jul" : 6, "Aug" : 7, "Sep" : 8, "Oct" : 9, "Nov" : 10, "Dec" : 11
        }
    }
    
};

})();

apf.date.dateFormat = (function () {
    var	token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
        timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
        timezoneClip = /[^-+\dA-Z]/g,
        pad = function (val, len) {
            val = String(val);
            len = len || 2;
            while (val.length < len) val = "0" + val;
            return val;
        };

    // Regexes and supporting functions are cached through closure
    return function (date, mask, utc) {
        var dF = apf.date;

        // You can't provide utc if you skip other args (use the "UTC:" mask prefix)
        if (arguments.length == 1 && (typeof date == "string"
            || date instanceof String) && !/\d/.test(date)) {
            mask = date;
            date = undefined;
        }

        // Passing date through Date applies Date.parse, if necessary
        date = date ? new Date(date) : new Date();

        if (isNaN(date)) return "NaN";//throw new SyntaxError("invalid date");

        mask = String(dF.masks[mask] || mask || dF.masks["default"]);

        // Allow setting the utc argument via the mask
        if (mask.slice(0, 4) == "UTC:") {
            mask = mask.slice(4);
            utc = true;
        }

        var	_ = utc ? "getUTC" : "get",
            d = date[_ + "Date"](),
            D = date[_ + "Day"](),
            m = date[_ + "Month"](),
            y = date[_ + "FullYear"](),
            H = date[_ + "Hours"](),
            M = date[_ + "Minutes"](),
            s = date[_ + "Seconds"](),
            L = date[_ + "Milliseconds"](),
            o = utc ? 0 : date.getTimezoneOffset(),
            flags = {
                d   : d,
                dd  : pad(d),
                ddd : dF.i18n.dayNames[D],
                dddd: dF.i18n.dayNames[D + 7],
                m   : m + 1,
                mm  : pad(m + 1),
                mmm : dF.i18n.monthNames[m],
                mmmm: dF.i18n.monthNames[m + 12],
                yy  : String(y).slice(2),
                yyyy: y,
                h   : H % 12 || 12,
                hh  : pad(H % 12 || 12),
                H   : H,
                HH  : pad(H),
                M   : M,
                MM  : pad(M),
                s   : s,
                ss  : pad(s),
                l   : pad(L, 3),
                L   : pad(L > 99 ? Math.round(L / 10) : L),
                t   : H < 12 ? "a"  : "p",
                tt  : H < 12 ? "am" : "pm",
                T   : H < 12 ? "A"  : "P",
                TT  : H < 12 ? "AM" : "PM",
                Z   : utc
                          ? "UTC"
                          : (String(date).match(timezone) 
                              || [""]).pop().replace(timezoneClip, ""),
                o   : (o > 0 ? "-" : "+") 
                         + pad(Math.floor(Math.abs(o) / 60) * 100
                         + Math.abs(o) % 60, 4),
                S   : ["th", "st", "nd", "rd"]
                      [d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
            };

        return mask.replace(token, function ($0) {
            return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
        });
    };
})();


/**
 * Create a object representation of date from datetime string parsing it with
 * datetime format string
 * 
 * @param {String}   datetime   the date and time wrote in allowed format
 * @param {String}   format     style of displaying date, created using various
 *                              masks
 *     Possible masks:
 *     d      day of the month as digits, no leading zero for single-digit days
 *     dd     day of the month as digits, leading zero for single-digit days
 *     ddd    day of the week as a three-letter abbreviation
 *     dddd   day of the week as its full name
 *     m      month as digits, no leading zero for single-digit months
 *     mm     month as digits, leading zero for single-digit months
 *     mmm    month as a three-letter abbreviation
 *     mmmm   month as its full name
 *     yy     year as last two digits, leading zero for years less than 2010
 *     yyyy   year represented by four digits
 *     h      hours, no leading zero for single-digit hours (12-hour clock)
 *     hh     hours, leading zero for single-digit hours (12-hour clock)
 *     H      hours, no leading zero for single-digit hours (24-hour clock)
 *     HH     hours, leading zero for single-digit hours (24-hour clock)
 *     M      minutes, no leading zero for single-digit minutes
 *     MM     minutes, leading zero for single-digit minutes
 *     s      seconds, no leading zero for single-digit seconds
 *     ss     seconds, leading zero for single-digit seconds
 */
apf.date.getDateTime = function(datetime, format) {
    var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g;
    var timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC:)(?:[-+]\d{4})?)\b/g;
    var alteration = 0;
    var time, y = new Date().getFullYear(), m = 1, d = 1,
        h = 12, M = 0, s = 0;
    var i18n = apf.date.i18n;

    if (!format) {
        throw new Error(apf.formatErrorString(0, null,
            "date-format", "Date format is null"));
    }

    format = format.replace(timezone, "");

    var str = format.replace(token, function(str, offset, p) {
        var part = datetime.substring(p + alteration, p + alteration + str.length);

        switch (str) {
            case 'd':
            case 'm':
            case 'h':
            case 'H':
            case 'M':
            case 's':
                if (!/[\/, :\-](d|m|h|H|M|s)$|^(d|m|h|H|M|s)[\/, :\-]|[\/, :\-](d|m|h|H|M|s)[\/, :\-]/.test(format)) {
                    throw new Error(apf.formatErrorString(0, null,
                        "date-format", "Dates without leading zero needs separators"));
                }

                var value = parseInt(datetime.substring(p + alteration,
                    p + alteration + 2));

                if (value.toString().length == 2)
                    alteration++;
    
                return str == 'd'
                    ? d = value
                    : (str == 'm'
                        ? m = value
                        : (str == 'M'
                            ? M = value
                            : (str == 's'
                                ? s = value
                                : h = value))); 
            case 'dd':
                return d = part; //01-31
            case 'dddd':
                //changeing alteration because "dddd" have no information about day number
                alteration += i18n.dayNames[i18n.dayNumbers[part.substring(0,3)] + 7].length - 4;
                break;
            case 'mm':
                return m = part; //01 - 11
            case 'mmm':
                return m = i18n.monthNumbers[part] + 1;
            case 'mmmm':
                var monthNumber = i18n.monthNumbers[part.substring(0, 3)];
                alteration += i18n.monthNames[monthNumber + 12].length - 4;
                return m = monthNumber + 1;
            case 'yy':
                return y = parseInt(part) < 70 ? "20" + part : part;
            case 'yyyy':
                return y = part;
            case 'hh':
                return h = part;
            case 'HH':
                return h = part;
            case 'MM':
                return M = part;
            case 'ss':
                return s = part;
            case "'T'":
            case "'Z'":
                //because in date we have only T
                alteration -= 2;
                break;
         }
    });

    return new Date(y, m-1, d, h, M, s);
};

// For convenience...
Date.prototype.format = function (mask, utc) {
    return apf.date.dateFormat(this, mask, utc);
};

Date.parse = function (datetime, format) {
    return apf.date.getDateTime(datetime, format);
};






/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/xmldb.js)SIZE(33019)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * The xml database object provides local storage for xml data. This object
 * routes all changes to the xml data to the data bound objects. It further
 * provides utility functions for xml handling.
 *
 * @constructor
 * @apfclass
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 *
 * @default_private
 */
apf.xmldb = new (function(){
    this.xmlDocTag    = "a_doc";
    this.xmlIdTag     = "a_id";
    this.xmlListenTag = "a_listen";
    this.htmlIdTag    = "id";
    this.disableRSB   = false;

    var xmlDocLut     = [];

    /**
     * @private
     */
    this.getElementById = function(id, doc){
        if (!doc)
            doc = xmlDocLut[id.split("\|")[0]];
        if (!doc)
            return false;

        return doc.selectSingleNode("descendant-or-self::node()[@"
            + this.xmlIdTag + "='" + id + "']");
    };

    /**
     * @private
     */
    this.getNode = function(htmlNode){
        if (!htmlNode || !htmlNode.getAttribute(this.htmlIdTag))
            return false;

        return this.getElementById(htmlNode.getAttribute(this.htmlIdTag)
            .split("\|", 2).join("|"));
    };

    /**
     * @private
     */
    this.getNodeById = function(id, doc){
        var q = id.split("\|");
        q.pop();
        return this.getElementById(q.join("|"), doc);//id.split("\|", 2).join("|")
    };

    /**
     * @private
     */
    this.getDocumentById = function(id){
        return xmlDocLut[id];
    };

    /**
     * @private
     */
    this.getDocument = function(node){
        return xmlDocLut[node.getAttribute(this.xmlIdTag).split("\|")[0]];
    };

    /**
     * @private
     */
    this.getID = function(xmlNode, o){
        return xmlNode.getAttribute(this.xmlIdTag) + "|" + o.$uniqueId;
    };

    /**
     * @private
     */
    this.getElement = function(parent, nr){
        var nodes = parent.childNodes;
        for (var j = 0, i = 0; i < nodes.length; i++) {
            if (nodes[i].nodeType != 1)
                continue;
            if (j++ == nr)
                return nodes[i];
        }
    };

    /**
     * Sets the model of an element
     *
     * @param {Model} The model to be set
     * 
     */
    this.setModel = function(model){
        apf.nameserver.register("model", model.data.ownerDocument
            .documentElement.getAttribute(this.xmlDocTag), model);
    };

    /**
     * Find the model of an element
     *
     * @param {XMLNode} xmlNode the {@link term.datanode data node} to find its model.
     *
     */
    this.findModel = function(xmlNode){
        return apf.nameserver.get("model", xmlNode.ownerDocument
            .documentElement.getAttribute(this.xmlDocTag));
    };

    /**
     * @private
     */
    this.getXmlId = function(xmlNode){
        return xmlNode.getAttribute(this.xmlIdTag) ||
          this.nodeConnect(apf.xmldb.getXmlDocId(xmlNode), xmlNode);
    }

    /**
     * Gets the html representation of an xml node for a certain element.
     *
     * @param {XMLNode} xmlNode  the {@link term.datanode data node} which is represented by the hml element.
     * @param {AMLNode} oComp    the element that has created the representation.
     * @return {HTMLNode} the html node representing the xml node.
     */
    this.getHtmlNode = function(xmlNode, oComp){
        if (xmlNode && xmlNode.nodeType == 1 && xmlNode.getAttribute(this.xmlIdTag)) {
            return oComp.$findHtmlNode(xmlNode.getAttribute(this.xmlIdTag)
                + "|" + oComp.$uniqueId);
        }
        return null;
    }
    
    /**
     * Finds the html representation of an xml node for a certain element.
     *
     * @param {XMLNode} xmlNode  the {@link term.datanode data node} which is represented by the hml element.
     * @param {AMLNode} oComp    the element that has created the representation.
     * @return {HTMLNode} the html node representing the xml node.
     */
    this.findHtmlNode = function(xmlNode, oComp){
        do {
            if (xmlNode.nodeType == 1 && xmlNode.getAttribute(this.xmlIdTag)) {
                return oComp.$findHtmlNode(xmlNode.getAttribute(this.xmlIdTag)
                    + "|" + oComp.$uniqueId);
            }
            if (xmlNode == oComp.xmlRoot)
                return null;
    
            xmlNode = xmlNode.parentNode;
        }
        while (xmlNode && xmlNode.nodeType != 9)
    
        return null;
    };
    
    /**
     * Finds the {@link term.datanode data node} that is represented by the html node.
     *
     * @param {HTMLNode} htmlNode  the html node representing the an xml node.
     * @return {XMLNode} the {@link term.datanode data node} for which the html node is it's representation.
     */
    this.findXmlNode = function(htmlNode){
        if (!htmlNode)
            return false;
        
        var id;
        while (htmlNode && htmlNode.nodeType == 1 && (
          htmlNode.tagName.toLowerCase() != "body" && !(id = htmlNode.getAttribute(this.htmlIdTag))
          || (id || (id = htmlNode.getAttribute(this.htmlIdTag))) && id.match(/^q/)
        )) {
            if (htmlNode.host && htmlNode.host.$ext == htmlNode)
                return htmlNode.host.xmlRoot;
    
            htmlNode = htmlNode.parentNode;
        }
        if (!htmlNode || htmlNode.nodeType != 1)
            return false;
    
        if (htmlNode.tagName.toLowerCase() == "body")
            return false;
    
        return this.getNode(htmlNode);
    };
    
    this.getXml = apf.getXml;

    this.nodeCount = {};
    /**
     * @private
     */
    this.nodeConnect = function(documentId, xmlNode, htmlNode, o){
        if (!this.nodeCount[documentId])
            this.nodeCount[documentId] = 0;

        var xmlId;
        xmlId = xmlNode.getAttribute(this.xmlIdTag)
          || xmlNode.setAttribute(this.xmlIdTag, (xmlId = documentId
               + "|" + ++this.nodeCount[documentId])) || xmlId;

        if (!o)
            return xmlId;

        var htmlId = xmlId + "|" + o.$uniqueId;
        if (htmlNode)
            htmlNode.setAttribute(this.htmlIdTag, htmlId);

        return htmlId;
    };

    /**
     * @private
     */
    this.addNodeListener = function(xmlNode, o, id){
        
        if (!o.$xmlUpdate && !o.setProperty)
            throw new Error(apf.formatErrorString(1040, null, 
                "Adding Node listener", 
                "Interface not supported."));
        

        var listen = xmlNode.getAttribute(this.xmlListenTag);
        id || (id = String(o.$uniqueId));
        if (!listen || listen.indexOf(id) == -1)
            xmlNode.setAttribute(this.xmlListenTag, listen ? listen + ";" + id : id);

        return xmlNode;
    };

    /**
     * @todo  Use this function when an element really unbinds from a
     *        piece of data and does not uses it for caching
     * @private
     */
    this.removeNodeListener = function(xmlNode, o, id){
        var listen = xmlNode.getAttribute(this.xmlListenTag);
        var nodes = (listen ? listen.split(";") : []);
        if (!id) id = o.$uniqueId

        for (var newnodes = [], i = 0; i < nodes.length; i++) {
            if (nodes[i] != id)
                newnodes.push(nodes[i]);
        }

        xmlNode.setAttribute(this.xmlListenTag, newnodes.join(";"));

        return xmlNode;
    };

    /**
     * Sets the value of a text node. If the node doesn't exists it is created.
     * Changes are propagated to the databound elements listening for changes
     * on the data changed.
     *
     * @param {XMLElement} pNode     the parent of the text node.
     * @param {String}     value     the value of the text node.
     * @param {String}     [xpath]   the xpath statement which selects the text node.
     * @param {UndoObj}    [undoObj] the undo object that is responsible for archiving the changes.
     */
    this.setTextNode = 
    apf.setTextNode  = function(pNode, value, xpath, undoObj){
        var tNode;

        if (xpath) {
            tNode = pNode.selectSingleNode(xpath);
            if (!tNode)
                return;
            pNode = tNode.nodeType == 1 ? tNode : null;
        }
        if (pNode || !tNode) {
            tNode = pNode.selectSingleNode("text()");

            if (!tNode)
                tNode = pNode.appendChild(pNode.ownerDocument.createTextNode(""));//createCDATASection
        }

        //Action Tracker Support
        if (undoObj)
            undoObj.extra.oldValue = tNode.nodeValue;

        //Apply Changes
        tNode.nodeValue = value;

        this.applyChanges("text", tNode.parentNode, undoObj);

        
        this.applyRSB(["setTextNode", pNode, value, xpath], undoObj);
        
    };

    /**
     * Sets an attribute on a node. Changes are propagated to the databound
     * elements listening for changes on the data changed.
     *
     * @param {XMLElement} xmlNode   the xml node to set the attribute on.
     * @param {String}     name      the name of the attribute.
     * @param {String}     value     the value of the attribute.
     * @param {String}     [xpath]   the xpath statement to select the attribute.
     * @param {UndoObj}    [undoObj] the undo object that is responsible for archiving the changes.
     */
    this.setAttribute = 
    apf.setAttribute  = function(xmlNode, name, value, xpath, undoObj){
        //Apply Changes
        (xpath ? xmlNode.selectSingleNode(xpath) : xmlNode).setAttribute(name, value);
        
        this.applyChanges("attribute", xmlNode, undoObj);
        
        this.applyRSB(["setAttribute", xmlNode, name, value, xpath], undoObj);
        
    };

    /**
     * Removes an attribute of an xml node. Changes are propagated to the
     * databound elements listening for changes on the data changed.
     *
     * @param {XMLElement} xmlNode   the xml node to delete the attribute from
     * @param {String}     name      the name of the attribute.
     * @param {String}     [xpath]   the xpath statement to select the attribute.
     * @param {UndoObj}    [undoObj] the undo object that is responsible for archiving the changes.
     */
    this.removeAttribute = 
    apf.removeAttribute  = function(xmlNode, name, xpath, undoObj){
        //if(xmlNode.nodeType != 1) xmlNode.nodeValue = value;

        //Action Tracker Support
        if (undoObj) undoObj.name = name;

        //Apply Changes
        (xpath ? xmlNode.selectSingleNode(xpath) : xmlNode).removeAttribute(name);
        this.applyChanges("attribute", xmlNode, undoObj);

        
        this.applyRSB(["removeAttribute", xmlNode, name, xpath], undoObj);
        
    };

    /**
     * Replace one node with another. Changes are propagated to the
     * databound elements listening for changes on the data changed.
     *
     * @param {XMLElement} oldNode   the xml node to remove.
     * @param {XMLElement} newNode   the xml node to set.
     * @param {String}     [xpath]   the xpath statement to select the attribute.
     * @param {UndoObj}    [undoObj] the undo object that is responsible for archiving the changes.
     */
    this.replaceNode = 
    apf.replaceNode  = function(newNode, oldNode, xpath, undoObj){
        //if(xmlNode.nodeType != 1) xmlNode.nodeValue = value;

        //Apply Changes
        if (xpath)
            oldNode = oldNode.selectSingleNode(xpath);

        //Action Tracker Support
        if (undoObj) {
            undoObj.oldNode = oldNode;
            undoObj.xmlNode = newNode;
        }
        var parentNode = oldNode.parentNode;
        parentNode.replaceChild(newNode, oldNode);
        this.copyConnections(oldNode, newNode);

        this.applyChanges("replacechild", newNode, undoObj);

        
        this.applyRSB(["replaceChild", oldNode, newNode, xpath], undoObj);
        
        
        return newNode;
    };

    /**
     * Creates a new element under a parent xml node. Changes are propagated
     * to the databound elements listening for changes on the data changed.
     *
     * @param {XMLElement} pNode       the parent xml node to add the new element to.
     * @param {String}     tagName     the tagName of the {@link term.datanode data node} to add.
     * @param {Array}      attr        list of the attributes to set. Each item is another array with the name and value.
     * @param {XMLElement} beforeNode  the xml node which indicates the insertion point.
     * @param {String}     [xpath]     the xpath statement to select the attribute.
     * @param {UndoObj}    [undoObj]   the undo object that is responsible for archiving the changes.
     */
    this.addChildNode = 
    apf.addChildNode  = function(pNode, tagName, attr, beforeNode, undoObj){
        //Create New Node
        var xmlNode = pNode.insertBefore(pNode.ownerDocument
            .createElement(tagName), beforeNode);

        //Set Attributes
        for (var i = 0; i < attr.length; i++)
            xmlNode.setAttribute(attr[i][0], attr[i][1]);

        //Action Tracker Support
        if (undoObj)
            undoObj.extra.addedNode = xmlNode;

        this.applyChanges("add", xmlNode, undoObj);

        
        this.applyRSB(["addChildNode", pNode, tagName, attr, beforeNode], undoObj);
        

        return xmlNode;
    };

    /**
     * Appends an xml node to a parent. Changes are propagated
     * to the databound elements listening for changes on the data changed.
     *
     * @param {XMLElement} pNode       the parent xml node to add the element to.
     * @param {XMLElement} xmlNode     the xml node to insert.
     * @param {XMLElement} beforeNode  the xml node which indicates the insertion point.
     * @param {Boolean}    unique      whether the parent can only contain one element with a certain tagName.
     * @param {String}     [xpath]     the xpath statement to select the parent node.
     * @param {UndoObj}    [undoObj]   the undo object that is responsible for archiving the changes.
     */
    this.appendChild = 
    apf.appendChild  = function(pNode, xmlNode, beforeNode, unique, xpath, undoObj){
        if (unique && pNode.selectSingleNode(xmlNode.tagName))
            return false;

        if (undoObj)
            this.cleanNode(xmlNode);

        // @todo: only do this once!
        if (pNode.ownerDocument.importNode && pNode.ownerDocument != xmlNode.ownerDocument)
            xmlNode = pNode.ownerDocument.importNode(xmlNode, true); //Safari issue not auto importing nodes

        //Add xmlNode to parent pNode or one selected by xpath statement
        if (xpath) {
            var addedNodes = [];
            var pNode = apf.createNodeFromXpath(pNode, xpath, addedNodes);
            if (addedNodes.length) {
                pNode.appendChild(xmlNode);
                while(addedNodes.length) {
                    if (pNode == addedNodes.pop() && addedNodes.length)
                        pNode = pNode.parentNode;
                }
            }
        }
        else if (xmlNode.parentNode)
            this.removeNode(xmlNode);

        pNode.insertBefore(xmlNode, beforeNode);

        //detect if xmlNode should be removed somewhere else
        //- [17-2-2004] changed pNode (2nd arg applychange) into xmlNode

        this.applyChanges("add", xmlNode, undoObj);

        
        this.applyRSB(["appendChild", pNode, xmlNode.xml, beforeNode, unique, xpath], undoObj);
        

        return xmlNode;
    };

    /**
     * Moves an xml node to a parent node. Changes are propagated
     * to the databound elements listening for changes on the data changed.
     *
     * @param {XMLElement} pNode       the new parent xml node of the node.
     * @param {XMLElement} xmlNode     the xml node to move.
     * @param {XMLElement} beforeNode  the xml node which indicates the insertion point.
     * @param {String}     [xpath]     the xpath statement to select the parent node.
     * @param {UndoObj}    [undoObj]   the undo object that is responsible for archiving the changes.
     */
    this.moveNode = 
    apf.moveNode  = function(pNode, xmlNode, beforeNode, xpath, undoObj){
        //Action Tracker Support
        if (!undoObj)
            undoObj = {extra:{}};

        undoObj.extra.oldParent  = xmlNode.parentNode;
        undoObj.extra.beforeNode = xmlNode.nextSibling;
        undoObj.extra.parent     = (xpath ? pNode.selectSingleNode(xpath) : pNode);

        this.applyChanges("move-away", xmlNode, undoObj);

        
        this.applyRSB(["moveNode", pNode, xmlNode, beforeNode, xpath], undoObj); //note: important that transport of rsb is async
        

        //Set new id if the node change document (for safari this should be fixed)
        if (!apf.isWebkit
          && apf.xmldb.getXmlDocId(xmlNode) != apf.xmldb.getXmlDocId(pNode)) {
            xmlNode.removeAttributeNode(xmlNode.getAttributeNode(this.xmlIdTag));
            this.nodeConnect(apf.xmldb.getXmlDocId(pNode), xmlNode);
        }

        if (apf.isWebkit && pNode.ownerDocument != xmlNode.ownerDocument)
            xmlNode = pNode.ownerDocument.importNode(xmlNode, true); //Safari issue not auto importing nodes

        undoObj.extra.parent.insertBefore(xmlNode, beforeNode);
        this.applyChanges("move", xmlNode, undoObj);
    };

    /**
     * Removes an xml node from it's parent. Changes are propagated
     * to the databound elements listening for changes on the data changed.
     *
     * @param {XMLElement} xmlNode     the xml node to remove from the dom tree.
     * @param {String}     [xpath]     the xpath statement to select the parent node.
     * @param {UndoObj}    [undoObj]   the undo object that is responsible for archiving the changes.
     */
    this.removeNode = 
    apf.removeNode  = function(xmlNode, xpath, undoObj){
        if (xpath)
            xmlNode = xmlNode.selectSingleNode(xpath);

        //ActionTracker Support
        if (undoObj) {
            undoObj.extra.parent      = xmlNode.parentNode;
            undoObj.extra.removedNode = xmlNode;
            undoObj.extra.beforeNode  = xmlNode.nextSibling;
        }

        
        this.applyRSB(["removeNode", xmlNode, xpath], undoObj); //note: important that transport of rsb is async
        

        //Apply Changes
        this.applyChanges("remove", xmlNode, undoObj);
        var p = xmlNode.parentNode;
        p.removeChild(xmlNode);
        this.applyChanges("redo-remove", xmlNode, null, p);//undoObj
        
        //@todo clean xmlNode after removal??
    };

    /**
     * Removes a list of xml nodes from their parent. Changes are propagated
     * to the databound elements listening for changes on the data changed.
     *
     * @param {Array}   xmlNodeList list of xml nodes to remove.
     * @param {UndoObj} [undoObj]   the undo object that is responsible for archiving the changes.
     */
    this.removeNodeList = 
    apf.removeNodeList  = function(xmlNodeList, undoObj){
        //if(xpath) xmlNode = xmlNode.selectSingleNode(xpath);
        for (var rData = [], i = 0; i < xmlNodeList.length; i++) { //This can be optimized by looping nearer to xmlUpdate
            //ActionTracker Support
            if (undoObj) {
                rData.push({
                    pNode      : xmlNodeList[i].parentNode,
                    removedNode: xmlNodeList[i],
                    beforeNode : xmlNodeList[i].nextSibling
                });
            }

            //Apply Changes
            this.applyChanges("remove", xmlNodeList[i], undoObj);
            var p = xmlNodeList[i].parentNode;
            p.removeChild(xmlNodeList[i]);
            this.applyChanges("redo-remove", xmlNodeList[i], null, p);//undoObj
        }

        if (undoObj)
            undoObj.extra.removeList = rData;

        
        this.applyRSB(["removeNodeList", xmlNodeList, null], undoObj);
        
    };

    /**
     * Looks for listeners and executes their $xmlUpdate methods.
     * @private
     */
    var notifyQueue = {}, notifyTimer;
    this.$hasQueue = false;
    this.applyChanges = function(action, xmlNode, undoObj, nextloop){
        
        if (typeof apf.offline != "undefined" && apf.offline.models.enabled
          && apf.offline.models.realtime) {
            var model = apf.nameserver.get("model", apf.xmldb.getXmlDocId(xmlNode));
            if (model) apf.offline.models.markForUpdate(model);
        }
        

        if (undoObj && !undoObj.xmlNode) //@todo are we sure about this?
            undoObj.xmlNode = xmlNode;

        //Set Variables
        var oParent  = nextloop;
        var loopNode = (xmlNode.nodeType == 1 ? xmlNode : xmlNode.parentNode);

        //var xmlId = xmlNode.getAttribute(this.xmlIdTag);

        if (!this.delayUpdate && "|remove|move-away|".indexOf("|" + action + "|") > -1)
            this.notifyQueued(); //empty queue

        var listen, uId, uIds, i, j, hash, info, amlNode, runTimer, found;
        while (loopNode && loopNode.nodeType != 9) {
            //Get List of Node listeners ID's
            listen = loopNode.getAttribute(this.xmlListenTag);

            if (listen) {
                uIds = listen.split(";");

                for (i = 0; i < uIds.length; i++) {
                    uId = uIds[i];
                    
                    //Property support
                    if (uId.charAt(0) == "p") {
                        uId = uId.split("|");
                        
                        //@todo apf3.0 should this be exactly like in class.js?
                        //@todo optimize this to check the async flag: parsed[3] & 4
                        
                        amlNode = apf.all[uId[1]]; //It's possible the aml node dissapeared in this loop.
                        if (amlNode) {
                            var model = apf.all[uId[3]];
                            var xpath = model.$propBinds[uId[1]][uId[2]].root;
                            
                            amlNode.$execProperty(uId[2], xpath
                                ? model.data.selectSingleNode(xpath)
                                : model.data);
                        }
                        continue;
                    }
                    
                    hash = notifyQueue[uId];
                    if (!hash)
                        notifyQueue[uId] = hash = [];

                    // Filtering
                    if ("|update|attribute|text|".indexOf("|"
                      + action + "|") > -1) {
                        found = false;
                        for (j = 0; j < hash.length; j++) {
                            if (hash[j] && xmlNode == hash[j][1]
                              && "|update|attribute|text|"
                              .indexOf("|" + hash[j][0] + "|") > -1) {
                                hash[j] = null;
                                found = true;
                                continue;
                            }
                        }

                        hash.push(["update", xmlNode, loopNode, undoObj, oParent]);
                        runTimer = true;
                        continue;
                    }

                    if (!this.delayUpdate && "|remove|move-away|add|".indexOf("|" + action + "|") > -1) {
                        amlNode = apf.all[uId];
                        if (amlNode)
                            amlNode.$xmlUpdate(action, xmlNode,
                                loopNode, undoObj, oParent);
                    }
                    else {
                        hash.push([action, xmlNode, loopNode, undoObj, oParent]);
                        runTimer = true;
                    }
                }
            }

            //Go one level up
            loopNode = loopNode.parentNode || nextloop;
            if (loopNode == nextloop)
                nextloop = null;
        }

        if (undoObj && !this.delayUpdate) {
            //Ok this was an action let's not delay execution
            apf.xmldb.notifyQueued();
        }
        else if (runTimer) {
            clearTimeout(notifyTimer);
            //@todo find a better solution for this (at the end of a event stack unroll)
            //notifyTimer = $setTimeout(function(){
                //this.$hasQueue = true;
                apf.xmldb.notifyQueued();
            //});
        }
    };

    /**
     *  @todo in actiontracker - add stack auto purging
     *        - when undo item is purged which was a removed, remove cache item
     *  @todo shouldn't the removeNode method remove all listeners?
     *  @todo rename to processQueue
     *  @private
     */
    this.notifyQueued = function(){
        this.$hasQueue = false;
        
        clearTimeout(notifyTimer);
        for (var uId in notifyQueue) {
            var q       = notifyQueue[uId];
            var amlNode = apf.all[uId];
            if (!amlNode || !q)
                continue;

            //Run queue items
            for (var i = 0; i < q.length; i++) {
                if (!q[i])
                    continue;

                //Update xml data
                amlNode.$xmlUpdate.apply(amlNode, q[i]);
            }
        }

        notifyQueue = {}; // update shouldn't add anything to the queue
    }

    /**
     * @private
     */
    this.notifyListeners = function(xmlNode){
        //This should be done recursive
        var listen = xmlNode.getAttribute(apf.xmldb.xmlListenTag);
        if (listen) {
            listen = listen.split(";");
            for (var j = 0; j < listen.length; j++) {
                apf.all[listen[j]].$xmlUpdate("synchronize", xmlNode, xmlNode);
                //load(xmlNode);
            }
        }
    };

    
    /**
     * Sends Message through transport to tell remote databound listeners
     * that data has been changed
     * @private
     */
    this.applyRSB = function(args, undoObj){
        if (apf.xmldb.disableRSB)
            return;

        var xmlNode = args[1] && args[1].length && args[1][0] || args[1],
            mdlId   = apf.xmldb.getXmlDocId(xmlNode), 
            model   = apf.nameserver.get("model", mdlId);
        if (!model && apf.isO3)
            model = self[mdlId];
        if (!model) {
            if (!apf.nameserver.getAll("remove").length)
                return;

            
            apf.console.warn("Could not find model for Remote SmartBinding connection, not sending change");
            
            return;
        }

        if (!model.rsb) return;

        // Add the messages to the undo object
        if (undoObj)
            model.rsb.queueMessage(args, model, undoObj);
        // Or send message now
        else
            model.rsb.sendChange(args, model);
    };
    

    /**
     * @private
     */
    this.copyConnections = function(fromNode, toNode){
        //This should copy recursive
        try {
            toNode.setAttribute(this.xmlListenTag, fromNode.getAttribute(this.xmlListenTag));
        }
        catch (e) {}
        try {
            toNode.setAttribute(this.xmlIdTag, fromNode.getAttribute(this.xmlIdTag));
        }
        catch (e) {}
    };

    /**
     * @private
     */
    this.cleanNode = function(xmlNode){
        try {
            var i, nodes = xmlNode.selectNodes("descendant-or-self::node()[@" + this.xmlListenTag + "]");
            for (i = nodes.length - 1; i >= 0; i--)
                nodes[i].removeAttribute(this.xmlListenTag);
            nodes = xmlNode.selectNodes("descendant-or-self::node()[@" + this.xmlIdTag + "]");
            for (i = nodes.length - 1; i >= 0; i--)
                nodes[i].removeAttribute(this.xmlIdTag);
            nodes = xmlNode.selectNodes("descendant-or-self::node()[@" + this.xmlDocTag + "]");
            for (i = nodes.length - 1; i >= 0; i--)
                nodes[i].removeAttribute(this.xmlDocTag);
            nodes = xmlNode.selectNodes("descendant-or-self::node()[@a_loaded]");
            for (i = nodes.length - 1; i >= 0; i--)
                nodes[i].removeAttribute("a_loaded");
            
            // var nodes = xmlNode.selectNodes("descendant-or-self::node()[@a_selection]");
            // for (var i = nodes.length - 1; i >= 0; i--)
            //     nodes[i].removeAttributeNode(nodes[i].getAttributeNode("a_selection"));
            
        }
        catch (e) {}

        return xmlNode;
    };
    
    /**
     * Returns a copy of the passed {@link term.datanode data node}. Bound
     * data nodes contain special attributes to track them. These attributes
     * are removed from the copied node when using this method.
     *
     * @param {XMLElement} xmlNode the {@link term.datanode data node} to copy.
     * @return {XMLElement} the copy of the {@link term.datanode data node}.
     */
    this.copy         = 
    this.getCleanCopy = 
    apf.getCleanCopy  = function(xmlNode){
        return apf.xmldb.cleanNode(xmlNode.cloneNode(true));
    };

    /**
     * Unbind all APF Elements from a certain Form
     * @private
     */
    this.unbind = function(frm){
        //Loop through objects of all apf
        for (var lookup = {}, i = 0; i < frm.apf.all.length; i++)
            if (frm.apf.all[i] && frm.apf.all[i].unloadBindings)
                lookup[frm.apf.all[i].unloadBindings()] = true;

        //Remove Listen Nodes
        for (var k = 0; k < xmlDocLut.length; k++) {
            
            if (!xmlDocLut[k]) continue;
            

            var Nodes = xmlDocLut[k].selectNodes("//self::node()[@"
                + this.xmlListenTag + "]");

            //Loop through Nodes and rebuild listen array
            for (var i = 0; i < Nodes.length; i++) {
                var listen = Nodes[i].getAttribute(this.xmlListenTag).split(";");
                for (var nListen = [], j = 0; j < listen.length; j++)
                    if (!lookup[listen[j]])
                        nListen.push(listen[j]);

                //Optimization??
                if (nListen.length != listen.length)
                    Nodes[i].setAttribute(this.xmlListenTag, nListen.join(";"));
            }
        }
    };

    /**
     * @private
     * @todo xml doc leakage
     */
    this.getXmlDocId = function(xmlNode, model){
        var docEl = xmlNode.ownerDocument.documentElement;
        if (!apf.isChildOf(docEl, xmlNode))
            docEl = xmlNode;

        var docId = (docEl || xmlNode).getAttribute(this.xmlDocTag)
            || xmlDocLut.indexOf(docEl || xmlNode.ownerDocument || xmlNode);

        if (docId && docId > -1)
            return docId;

        docId = xmlDocLut.push(docEl || xmlNode.ownerDocument || xmlNode) - 1;
        if (docEl)
            docEl.setAttribute(this.xmlDocTag, docId);

        if (model)
            apf.nameserver.register("model", docId, model);

        return xmlDocLut.length - 1;
    };
});




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/resize.js)SIZE(13139)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * This abstraction is using for resizing block elements. Resizing is allowed
 * with square elements in vertical, horizontal or both planes. Symmetric
 * resizing is possible with SHIFT button.
 * 
 * @private
 * @default_private
 * @constructor
 * 
 * @author      Lukasz Lipinski
 * @version     %I%, %G%
 * @since       1.0
 * @namespace apf
 */

apf.resize = function() {
    /** 
     *     {Boolean} scalex       resizing in horizontal plane, default is true
     *         Possible values:
     *         true   resizing in horizontal plane is allowed
     *         false  resizing in horizontal plane is not allowed
     *     {Boolean} scaley       resizing in vertical plane, default is true
     *         Possible values:
     *         true   resizing in vertical plane is allowed
     *         false  resizing in vertical plane is not allowed
     *     {Boolean} scaleratio   resizing in horizontal or vertical plane only is not allowed. Resizing in two dimensions plane at the same time is allowed.
     *         Possible values:
     *         true   resizing in two dimensions plane at the same time is allowed
     *         false  Resizing in two dimensions plane at the same time is not allowed
     *     {Number}  dwidth       the minimal horizontal size of Block element, default is 56 pixels
     *     {Number}  dheight      the minimal vertical size of Block element, default is 56 pixels
     */
    this.scales = {
        scalex    : false,
        scaley    : false,
        scaleratio: false,
        dwidth    : 0,
        dheight   : 0,
        snap      : false,
        gridW     : 48,
        gridH     : 48
    };

    /**
     * html representation of resized block element
     */
    this.htmlElement;

    /**
     * store object representations of inputs elements
     */
    var squares = [];

    this.init = function() {
        squares = [
            new apf.resize.square("top",    "left",   this),
            new apf.resize.square("top",    "middle", this),
            new apf.resize.square("top",    "right",  this),
            new apf.resize.square("middle", "left",   this),
            new apf.resize.square("middle", "right",  this),
            new apf.resize.square("bottom", "left",   this),
            new apf.resize.square("bottom", "middle", this),
            new apf.resize.square("bottom", "right",  this)];
    };
    
    /**
     * Links block element with resize feature
     * 
     * @param {HTMLElement}   oHtml    html representation of block element
     * @param {Object}        scales   blocks scale settings
     */
    this.grab = function(oHtml, scales) {
        this.htmlElement = oHtml;
        this.scales = scales;

        if (!squares.length)
            this.init();
        this.show();
    };

    /**
     * Hides all block squares
     */
    this.hide = function() {
        for (var i = 0, l = squares.length; i < l; i++) {
            squares[i].visible = false;
            squares[i].repaint();
        }
    };

    /**
     * Shows all block squares
     */
    this.show = function() {
        var sx   = this.scales.scalex;
        var sy   = this.scales.scaley;
        var sr   = this.scales.scaleratio;

        for (var i = 0, l = squares.length, s; i < l; i++) {
            s = squares[i];
            s.visible = sx && sy
                ? true
                : (sy && !sx
                    ? (s.posX == "middle"
                        ? true
                        : false)
                    : (sx && !sy
                        ? (s.posY == "middle"
                            ? true
                            : false)
                        : (sr
                            ? ((s.posY == "top" || s.posY == "bottom")
                              && s.posX !== "middle"
                                ? true
                                : false)
                            : false)));
            
            s.repaint();
        }
    };

    /**
     * Destroys all block squares
     */
    this.destroy = function(){
        for (var i = 0; i < squares.length; i++) {
            squares[i].destroy();
        }
    };
};

/**
 * Creates html and object representation for square element. Square is used for
 * resizing block elements.
 * 
 * @param {String}   posY        square vertical align relative to resized block element
 *     Possible values:
 *     top      square is on top of resized block element
 *     middle   square is in the middle of the resized block element
 *     bottom   square is on the bottom of resized block element
 * @param {String}   posX        square vertical align relative to resized block element
 *     Possible values:
 *     left     square is on the left of resized block element
 *     middle   square is in the middle of the resized block element
 *     right    square is on the right of resized block element
 * @param {Object}   objResize   object of resize class
 * @constructor
 */
apf.resize.square = function(posY, posX, objResize) {
    /**
     * Square visibility
     */
    this.visible  = true;
    /**
     * square vertical align relative to resized block element
     */
    this.posX     = posX;
    /**
     * square vertical align relative to resized block element
     */
    this.posY     = posY;

    var margin = 0;
    var _self  = this;

    /**
     * html represenation of square element
     */
    this.htmlElement = objResize.htmlElement.parentNode.appendChild(document.createElement('div'));
    apf.setStyleClass(this.htmlElement, "square");

    /**
     * Repaints square
     */
    this.repaint = function() {
        if (this.visible) {
            var block = objResize.htmlElement;
            this.htmlElement.style.display = "block";

            var bw = parseInt(block.style.width) + apf.getDiff(block)[0];
            var bh = parseInt(block.style.height) + apf.getDiff(block)[1];
            var bt = parseInt(block.style.top);
            var bl = parseInt(block.style.left);

            var sw = this.htmlElement.offsetWidth;
            var sh = this.htmlElement.offsetHeight;

            var t = posY == "top"
                ? bt - margin - sh
                : posY == "middle"
                    ? bt + bh/2 - sh/2
                    : bt + bh + margin;
            var l = posX == "left"
                ? bl - margin - sw
                : posX == "middle"
                    ? bl + bw/2 - sw/2
                    : bl + bw + margin;

            var c = (posY == "middle" 
                ? "w-resize"
                : (posX == "middle"
                     ? "n-resize"
                     : (posY + posX == "topleft"
                       || posY + posX == "bottomright") 
                         ? "nw-resize" 
                         : "ne-resize"));

            this.htmlElement.style.top    = (t - 1) + "px";
            this.htmlElement.style.left   = (l - 1) + "px";
            this.htmlElement.style.cursor = c;
        }
        else {
            //IE bug
            var sw = this.htmlElement.offsetWidth;
            this.htmlElement.style.display = 'none';
        }
    };

    this.destroy = function(){
        apf.destroyHtmlNode(this.htmlElement);
    };

    /* Events */
    this.htmlElement.onmouseover = function(e) {
        apf.setStyleClass(_self.htmlElement, "squareHover");
    };

    this.htmlElement.onmouseout = function(e) {
        apf.setStyleClass(_self.htmlElement, "", ["squareHover"]);
    };

    this.htmlElement.onmousedown = function(e) {
        e = (e || event);

        var block = objResize.htmlElement,

            sx = e.clientX,
            sy = e.clientY,

            pt = block.parentNode.offsetTop,
            pl = block.parentNode.offsetLeft,

            dw = objResize.scales.dwidth,
            dh = objResize.scales.dheight,
            
            snap = objResize.scales.snap,
            gridH = objResize.scales.gridH,
            gridW = objResize.scales.gridW,

            objBlock = apf.flow.isBlock(block),
            r = objBlock.other.ratio,

            posX = _self.posX,
            posY = _self.posY,

            width, height, top, left, dx, dy,
            prev_w, prev_h,

            l = parseInt(block.style.left),
            t = parseInt(block.style.top),
            w = parseInt(block.style.width),
            h = parseInt(block.style.height),
            resized = false;
            
        objResize.onresizedone(w, h, t, l);

        if (e.preventDefault) {
            e.preventDefault();
        }

        document.onmousemove = function(e) {
            e = (e || event);

            dx = e.clientX - sx;
            dy = e.clientY - sy;
            var shiftKey = e.shiftKey,
                proportion = r;

            if (shiftKey) {
                if (posX == "right" && posY == "bottom") {
                    width  = w + dx;
                    height = width/proportion;
                    left   = l;
                    top    = t;
                }
                else if (posX == "right" && posY == "top") {
                    width  = w + dx;
                    height = width/proportion;
                    left   = l;
                    top    = t - dx/proportion;
                }
                else if (posX == "left" && posY == "bottom") {
                    width  = w - dx;
                    height = width/proportion;
                    left   = l + dx;
                    top    = t;
                }
                else if (posX == "left" && posY == "top") {
                    width  = w - dx;
                    height = width/proportion;
                    left   = l + dx;
                    top    = t + dx/proportion;
                }

                /* Keep minimal size */
                if(width >= dw && height >= dh) {
                    width  = prev_w = Math.max(dw, width);
                    height = prev_h = Math.max(dh, height);
                }
                else {
                    width  = prev_w;
                    height = prev_h;
                    return false;
                }
            }
            else {
                width = posX == "right"
                    ? w + dx
                    : (posX == "left"
                        ? w - dx
                        : w);
                height = posY == "bottom"
                    ? h + dy
                    : (posY == "top"
                        ? h - dy
                        : h);
                left = posX == "right"
                    ? l
                    : (posX == "left"
                        ? Math.min(l + w - dw, l + dx)
                        : l);
                top = posY == "bottom"
                    ? t
                    : (posY == "top"
                        ? Math.min(t + h - dh, t + dy)
                        : t);

                /* Keep minimal size */
                width = Math.max(dw, width);
                height = Math.max(dh, height);
            }

            if (snap) {
                left   = Math.floor(left / gridW) * gridW;
                top    = Math.floor(top / gridH) * gridH;
                width  = Math.ceil(width / gridW) * gridW;
                height = Math.ceil(height / gridH) * gridH;
            }

            if (objResize.onresize) {
                objResize.onresize(block, top, left, width, height);
            }

            objResize.show();
            
            resized = true;
        };

        document.onmouseup = function(e) {
            document.onmousemove = null;
            if (objResize.onresizedone && resized) {
                objResize.onresizedone(width, height, top, left);
                objBlock.other.ratio = width / height;
                resized = false;
            }
        };
    };
}



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/queue.js)SIZE(1787)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 *
 */
apf.queue = {
    //@todo apf3.0
    q : {},
    
    timer : null,
    add : function(id, f){
        this.q[id] = f;
        if (!this.timer)
            this.timer = $setTimeout("apf.queue.empty()");
    },
    
    empty : function(prop){
        clearTimeout(this.timer);
        this.timer = null;
        
        
        if (apf.layout && apf.layout.$hasQueue)
            apf.layout.processQueue();
        
        
        if (apf.xmldb && apf.xmldb.$hasQueue)
            apf.xmldb.notifyQueued();
        
        
        var q = this.q;
        for (var prop in q){
            var f = q[prop];
            if (f) {
                delete q[prop];
                f();
            }
        }
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/storage.js)SIZE(8849)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Stores javascript structures based on a name and a namespace. This object
 * is used by {@link element.offline apf offline support} as well as the 
 * {@link core.registry registry} and the {@link teleport.http http object} for 
 * caching. All but the memory storage provider, provide persistent storage. 
 * This means the data is kept between browser sessions. This allows apf to
 * have inter-session communication. For instance offline support uses it to
 * store data that could not be send to the server. When the application does 
 * go online (and this could be several sessions later), the data is send to the
 * server.
 *
 * Remarks:
 * The HTML5 specification advices an interface for local persistent storage.
 * Not all browsers have implemented this yet. There are several plugins and/or
 * browser containers that provide solutions for this. Among them are google 
 * gears and adobe's flash. Storage providers for these and others are available.
 *
 * @default_private
 */
apf.storage = {
    modules : {},

    /**
     * Initializes the main storage engine based on the specified provider.
     * @param {String} name the name of the provider that will provider storage
     *   Possible values:
     *   memory     data is stored in memory and is lost when the application exits.
     *   air        data is stored in the air name/value storage.
     *   air.file   data is stored in the air file based storage.
     *   air.sql    data is stored in the air sqlite storage.
     *   flash      data is stored in a small flash container.
     *   gears      data is stored using the sqlite interface of gears.
     *   html5      data is stored in a local storage object specified by the WHATWG html5 standard.
     */
    init : function(name){
        if(!name) name = this.autodetect();
        var provider = this.getProvider(name);

        //Install the provider
        apf.storage = apf.extend(provider, this);
        apf.storage.init = null;
        
        
        apf.console.info("Installed storage provider '" + name + "'");
        
        
        return provider;
    },
    
    /** 
     * Retrieves a storage provider without installing it as the central storage provider.
     * @param {String} name the name of the storage provider.
     *   Possible values:
     *   memory     data is stored in memory and is lost when the application exits.
     *   air        data is stored in the air name/value storage.
     *   air.file   data is stored in the air file based storage.
     *   air.sql    data is stored in the air sqlite storage.
     *   flash      data is stored in a small flash container.
     *   gears      data is stored using the sqlite interface of gears.
     *   html5      data is stored in a local storage object specified by the WHATWG html5 standard.
     */
    getProvider : function(name){
        var provider = apf.storage.modules[name];

        if(!provider || typeof provider != "object") {
            
            apf.console.warn("Could not find storage provider '" + name + "'");
            
            
            return false;
        }
        
        if (!provider.isAvailable()) {
            
            apf.console.warn(
                "Storage provider '" + name + "' is not available");
            
            
            return false;
        }

        if(!provider.initialized 
          && (!provider.init || provider.init() === false)) {
            
            apf.console.warn(
                "Could not install storage provider '" + name + "");
            
            
            return false;
        }
        
        provider.name = name;
        apf.extend(provider, this.base);

        return provider;
    },

    /**
     *  Checks if a provider is available.
     */
    autodetect : function(){
        for (var name in this.modules) {
            if (name == "memory")
                continue;
                
            if (this.modules[name].isAvailable()) {
                return name;
            }
        }
        
        return this.modules.memory
            ? "memory" 
            : null;
    },

    /**
     * @private
     */
    base : {
        namespace : "default",
        
        isValidKeyArray : function(keys) {
            return (!keys || !keys.join)
                ? false
                : /^[0-9A-Za-z_\.\-]*$/.test(keys.join(""));
        },
        
        isValidKey : function(keyName){
            return (keyName === null || keyName === undefined)
                ? false
                : /^[0-9A-Za-z_\.\-]*$/.test(keyName);
        },
        
        //Optimization for slow API's
        getAllPairs : function(namespace, store){
            var keys   = this.getKeys(namespace);
            
            if (!keys || !keys.length)
                return;
                
            var values = this.getMultiple(keys, namespace);
            for (var i = 0; i < keys.length && values; i++) {
                if (values[i])
                    store[keys[i]] = values[i];
            }

            return keys.length;
        }
    }
    
    
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/selection.js)SIZE(32178)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @class apf.selection
 * @constructor
 * @author Mike de Boer  (mike AT javeline DOT com)
 */
apf.selection = function(oWin, oDoc, editor) {
    /*
     * Initialize the apf.selection class.
     *
     * @type apf.selection
     */
    oWin = oWin || window;
    oDoc = oDoc || window.document;
    this.current = null;

    var FUNC  = "function",
        UNDEF = "undefined",
        CHAR  = "character",
        TEXT  = "Text",
        CTRL  = "Control",
        NONE  = "None",
        csLock,
        vfocus = (editor && typeof editor.$visualFocus == FUNC),
        _self  = this;

    /**
     * Get the selection of the editable area
     *
     * @type {Selection}
     */
    this.get = function() {
        return apf.w3cRange ? oWin.getSelection() : oDoc.selection;
    };

    /**
     * Set or move the current selection to the cached one.
     * At the moment, this function is very IE specific and is used to make sure
     * that there's a correct selection object available at all times.
     * @see apf.selection.cache
     * 
     * @type {Range}
     */
    this.set = function() {
        if (!this.current) return null;
        if (apf.w3cRange) {
            this.moveToBookmark(this.current);
            return this.current;
        }

        try {
            if (vfocus)
                editor.$visualFocus();
            else
                oWin.focus();
            this.current.select();
        }
        catch (ex) {}

        if (vfocus)
            editor.$visualFocus();
        else
            oWin.focus();

        return this.current;
    };

    /**
     * Save the selection object/ current range into a global variable to cache
     * it for later use.
     * At the moment, this function is very IE specific and is used to make sure
     * that there's a correct selection object available at all times.
     *
     * @param {Boolean} [w3cToo] Also cache the selection for browsers that support
     *                           the w3c range spec
     * @type {void}
     */
    this.cache = function(w3cToo) {
        if (apf.w3cRange) {
            if (w3cToo)
                this.current = this.getBookmark();
            return this;
        }

        var oSel = oDoc.selection;
        this.current      = oSel.createRange();
        this.current.type = oSel.type;

        if (this.current.type == TEXT && this.current.text == "" && !csLock) {
            csLock = $setTimeout(this.cache, 0);
        }
        else {
            clearTimeout(csLock);
            csLock = null;
        }
        
        return this;
    };

    /**
     * Retrieve the active Range object of the current document selection.
     * Internet Explorer returns a controlRange when a control (e.g. image,
     * object tag) is selected or a textRange when a set of characters is
     * selected.
     *
     * @type {Range}
     */
    this.getRange = function() {
        var oSel = this.get(), range;

        try {
            if (oSel)
                range = oSel.rangeCount > 0
                    ? oSel.getRangeAt(0)
                    : (oSel.createRange
                        ? oSel.createRange()
                        : oDoc.createRange());
        }
        // IE throws unspecified error here if we're placed in a frame/iframe
        catch (ex) {}

        // No range found then create an empty one
        // This can occur when the editor is placed in a hidden container
        // element on Gecko. Or on IE when there was an exception
        if (!range)
            range = apf.w3cRange
                ? oDoc.createRange()
                : oDoc.body.createTextRange();

        return range;
    };

    /**
     * Set the active range of the current selection inside the editable
     * document to a specified range.
     *
     * @param {Range} range
     * @type {void}
     */
    this.setRange = function(range) {
        if (apf.w3cRange) {
            var oSel = this.get();

            if (oSel) {
                oSel.removeAllRanges();
                oSel.addRange(range);
            }
        }
        else {
            try {
                range.select();
            }
            // Needed for some odd IE bug
            catch (ex) {}
        }
        
        return this;
    };

    var activeEl,
        _inline  = "BR|IMG|HR|INPUT",
        _block   = "P|BUTTON|TEXTAREA|SELECT|DIV|H[1-6]|ADDRESS|PRE|OL|UL|LI|TABLE|TBODY|TR|DT|DE|TD|SUB|SUP",
        _form    = "SELECT|BUTTON|TEXTAREA",
        reBlock  = new RegExp("^(?:" + _block  + ")$", "i"),
        reForm   = new RegExp("^(?:" + _form   + ")$", "i"),
        reInline = new RegExp("^(?:" + _inline + ")$", "i");

    this.inline  = _inline;
    this.block   = _block;
    this.form    = _form;

    function trimNl(str) {
        return (apf.isOpera || apf.isIE) ? str : str.replace(/\r\n/g, " ");
    }

    function getText(node) {
        return String(apf.isIE ? node.nodeType == 3 ? node.nodeValue : node.innerText : node.textContent);
    }
    
    function getHtml(node) {
        return String(node.nodeType == 3 ? apf.isIE ? node.nodeValue : node.textContent : node.innerHTML);
    }

    function textContent(node, o) {
        var cn,
            sp       = 0,
            str      = "",
            i        = 0,
            l        = node.childNodes.length;
        for (; i < l; i++) {
            cn = node.childNodes[i];
            if (reForm.test(cn.nodeName)) {
                str += "<->" + (apf.isIE ? "" : trimNl(getText(cn)).replace(/./gi, " ")) + "</->";
            }
            else {
                if (reBlock.test(cn.nodeName)) {
                    str += "<+>" + (apf.isIE ? "" : trimNl(getText(cn)).replace(/./gi, " ")) + "</+>";
                }
                else {
                    if (reInline.test(cn.nodeName)) {
                        str += "<>";
                    }
                    else {
                        if (cn.nodeName == "SPAN" && (sp = _4.attr(cn, "scaytid")))
                            str += "<" + sp + ">" + trimNl(getHtml(cn)) + "</>";
                        else
                            str += trimNl(getHtml(cn));
                    }
                }
            }
        }
        return str;
    }

    function getParent(node, eltype, attr, root) {
        var k;
        root = root || this.containerNode;
        eltype = eltype ? new RegExp("^(?:" + eltype + ")$") : null;
        while (node && node != root) {
            if (eltype && eltype.test(node.nodeName.toUpperCase())) {
                return node;
            }
            if (attr) {
                for (k in attr) {
                    if (node.getAttribute(k) !== null && attr[k] === null)
                        return node;
                    if ((attr[k] !== null && node.getAttribute(k) !== null
                      && !(node.getAttribute(k) === false)) ? !attr[k] : attr[k]) {
                        return node;
                    }
                }
            }
            node = node.parentNode;
        }
        return false;
    }

    /**
     * Returns a bookmark location for the current selection. This bookmark
     * object can then be used to restore the selection after some content
     * modification to the document.
     *
     * @param  {Boolean}    [type]     State if the bookmark should be simple or not.
     *                                 Default is complex.
     * @param  {Function}   [callback] function used to retrieve a custom reference node
     * @return {Object}                Bookmark object, use moveToBookmark with this
     *                                 object to restore the selection.
     */
    this.getBookmark = function(type, callback) {
        var ch    = -16777215,
            range = this.getRange(),
            vp    = apf.getViewPort(oWin),
            c     = oDoc.body,
            o     = {
                scrollX : vp.x,
                scrollY : vp.y,
                collapse: 0,
                start   : 0
            },
            sel = this.get();

        activeEl = null;
        if (type == "simple") {
            o.rng = range;
            return o;
        }
        if (!apf.w3cRange) {
            if (range.item) {
                var e = range.item(0),
                    n = c.getElementsByTagName(e.nodeName),
                    i = 0,
                    l = n.length;
                for (; i < l; i++) {
                    if (e == n[i])
                        return !(sp = i);
                }
                return apf.extend(o, {
                    tag  : e.nodeName,
                    index: sp
                });
            }
            var tr, bp, sp, tr1;
            tr = range.duplicate();
            tr.moveToElementText(c);
            tr.collapse(true);
            bp = Math.abs(tr.move(CHAR, ch));
            tr = range.duplicate();
            tr.collapse(true);
            sp = Math.abs(tr.move(CHAR, ch));
            tr = range.duplicate();
            tr.collapse(false);
            var offset = 0;
            tr1 = tr.duplicate();
            tr1.moveEnd(CHAR, 1);
            tr1.collapse(false);
            var parN = tr1.parentElement();
            if (reBlock.test(parN.nodeName)) {
                if (getParent(tr.parentElement(), _block, null, c) != parN)
                    activeEl = parN;
            }
            return apf.extend(o, {
                start : sp - bp - offset,
                length: Math.abs(tr.move(CHAR, ch)) - sp
            });
        }
        var p = sel.anchorNode; //getParentElement()
        while (p && (p.nodeType != 1))
            p = p.parentNode;
        if (p && p.nodeName == "IMG") {
            return o;
        }
        if (!sel)
            return null;

        var w,
            sc     = range.startContainer,
            an     = sel.anchorNode,
            custom = callback ? callback(an) : null;
        if (sel.isCollapsed) {
            o.collapse = 1;
            p = getParent(an, _block) || c;
            if (an.nodeType == 3) {
                w = oDoc.createTreeWalker(p, NodeFilter.SHOW_TEXT, null, false);
                while (n = w.nextNode()) {
                    if (n == an) {
                        o.start = o.start + sel.anchorOffset;
                        break;
                    }
                    o.start += trimNl(n.nodeValue || "").length;
                }
            }
            else {
                if (an != p) {
                    w = oDoc.createTreeWalker(p, NodeFilter.SHOW_ALL, null, false);
                    while (n = w.nextNode()) {
                        if (n == an)
                            break;
                        o.start += trimNl(n.nodeValue || "").length;
                    }
                }
                for (i = 0, l = range.startOffset; i < l; i++)
                    o.start += parseInt(String(sc.childNodes[i].textContent).length);
            }
            o.end = o.start;
            if (!custom) {
                o.content = sc.textContent || sc.innerHTML;
                try {
                    if (range.startOffset == 0 && sc.previousSibling
                      && (/IMG|BR|INPUT/.test(sc.previousSibling.nodeName))) {
                        o.br = sc.previousSibling;
                    }
                    if (sc.childNodes[range.startOffset - 1]
                      && (/IMG|BR|INPUT/.test(sc.childNodes[range.startOffset - 1].nodeName))) {
                        o.br = sc.childNodes[range.startOffset - 1];
                    }
                }
                catch(e) {}
            }
            if (custom && range.startOffset == 0) {
                n = custom.previousSibling;
                while (n && ((n.nodeType == 3 && n.textContent == "")
                  || (n.nodeType != 3 && n.innerHTML == ""))) {
                    if (n && (/IMG|BR|INPUT/.test(n.nodeName))) {
                        o.br = n;
                        o.br2 = n.nextSibling;
                        break;
                    }
                    n = n.previousSibling;
                }
            }
            apf.extend(o, {
                block : p,
                node  : sc,
                offset: range.startOffset
            });
            return o;
        }
        var s = [];
        p = 0;
        w = oDoc.createTreeWalker(c, NodeFilter.SHOW_TEXT, null, false);
        while ((n = w.nextNode()) != null) {
            if (n == sc)
                s[0] = p;
            if (n == range.endContainer) {
                s[1] = p;
                break;
            }
            p += trimNl(n.nodeValue || "").length;
        }
        apf.extend(o, {
            start: s[0] + range.startOffset,
            end  : s[1] + range.endOffset,
            block: c
        });
        return o;
    };

    /**
     * Restores the selection to the specified bookmark.
     *
     * @param {Object}   b Bookmark to restore selection from.
     * @return {Boolean} true/false if it was successful or not.
     */
    this.moveToBookmark = function(b) {
        var crt,
            sel = this.get(),
            c   = oDoc.body,
            rng = this.getRange();

        function getPos(sp, ep) {
            var n, par, nv, nvl, o,
                p = 0,
                d = {},
                k = -1,
                w = oDoc.createTreeWalker(b.block, NodeFilter.SHOW_TEXT, null, false);
            while (n = w.nextNode()) {
                nv  = n.nodeValue || "";
                nvl = trimNl(nv).length;
                p  += nvl;
                if (b.collapse) {
                    if (p >= sp)
                        par = getParent(n, _block) || c;
                    if (p == sp)
                        k = par == b.block ? 1 : 0;
                    if (k == -1 && p > sp || k == 1) {
                        d.endNode   = d.startNode = n;
                        d.endOffset = d.startOffset = sp - (p - nvl);
                        return d;
                    }
                }
                else {
                    if (p >= sp && !d.startNode) {
                        o = sp - (p - nvl);
                        d.startNode = n;
                        d.startOffset = sp - (p - nvl);
                    }
                    if (p >= ep) {
                        d.endNode = n;
                        d.endOffset = ep - (p - nvl);
                        return d;
                    }
                }
            }
            return null;
        }
        
        if (!b)
            return false;

        if (!apf.w3cRange) {
            oDoc.body.setActive();
            if (crt = b.rng) {
                try {
                    crt.select();
                }
                catch(ex) {}
                return true;
            }
            if (b.tag) {
                crt = c.createControlRange();
                var n = oDoc.getElementsByTagName(b.tag),
                    i = 0,
                    l = n.length;
                for (; i < l; i++) {
                    if (i == b.index)
                        crt.addElement(n[i]);
                }
            }
            else {
                try {
                    if (b.start < 0) {
                        return true;
                    }
                    crt = sel.createRange();
                    if (activeEl) {
                        crt.moveToElementText(activeEl);
                        crt.moveStart(CHAR, -2);
                        crt.expand(word);
                        crt.collapse(false);
                    }
                    else {
                        crt.moveToElementText(c);
                        crt.collapse(true);
                        crt.moveStart(CHAR, b.start);
                        crt.moveEnd(CHAR, b.length);
                    }
                }
                catch(e) {
                    return true;
                }
            }
            try {
                crt.select();
            }
            catch(ex) {}
            return true;
        }
        if (!sel)
            return false;

        crt = rng.cloneRange();
        if (b.rng) {
            sel.removeAllRanges();
            sel.addRange(b.rng);
        }
        else {
            if (typeof b.node != UNDEF) {
                var a = false;
                if ((b.node.nodeType == 3 && b.node.parentNode != null 
                  && b.node.textContent == b.content) || (b.node.nodeType != 3
                  && b.node.innerHTML == b.content)) {
                    crt.setStart(b.node, b.offset);
                    crt.collapse(true);
                    a = true;
                }
                if (typeof b.br != UNDEF && (/IMG|BR|INPUT/.test(b.br.nodeName))) {
                    if (b.br.nextSibling) {
                        crt.selectNode(b.br.nextSibling);
                        crt.collapse(true);
                    }
                    else {
                        crt.selectNode(b.br);
                        crt.collapse(false);
                    }
                    a = true;
                }
                if (a) {
                    if (!apf.isOpera)
                        sel.removeAllRanges();
                    sel.addRange(crt);
                    c.focus();
                    oWin.scrollTo(b.scrollX, b.scrollY);
                    return;
                }
            }
            if (typeof b.start != UNDEF && typeof b.end != UNDEF) {
                try {
                    var sd = getPos(b.start, b.end);
                    if (sd) {
                        crt.setStart(sd.startNode, sd.startOffset);
                        crt.setEnd(sd.endNode, sd.endOffset);
                        oWin.scrollTo(b.scrollX, b.scrollY);
                        if (!apf.isOpera)
                            sel.removeAllRanges();
                        sel.addRange(crt);
                    }
                }
                catch(ex) {
                    apf.console.error(ex);
                }
            }
            return;
        }
    };

    /**
     * Retrieve the contents of the currently active selection/ range as a
     * string of HTML.
     *
     * @type {String}
     */
    this.getContent = function(retType) {
        if (typeof retType != "string")
            retType = "html"
        var range = this.getRange(), oSel = this.get(), prefix, suffix, n,
            oNode = oDoc.body;
        
        if (retType == "text")
             return this.isCollapsed() ? '' : (range.text || (oSel.toString ? oSel.toString() : ''));

        if (this.isCollapsed())
            return "";
        
        if (typeof range.htmlText != UNDEF)
            return range.htmlText;

        
        var pNode, n = range.cloneContents();
        if (!n.childNodes.length)
            return "";
        
        pNode = n.childNodes[0].ownerDocument.createElement("div");
        pNode.appendChild(n);
        return pNode.innerHTML;

        /*
        prefix = suffix = '';
        //if (editor && editor.output == 'text')
            //return this.isCollapsed() ? '' : (range.htmlText || (range.item
            //   && range.item(0).outerHTML) || '');

        if (range.cloneContents) {
            n = range.cloneContents();
            if (n)
                oNode.appendChild(n);
        }
        else if (typeof range.item != UNDEF || typeof range.htmlText != UNDEF)
            oNode.innerHTML = range.item ? range.item(0).outerHTML : range.htmlText;
        else
            oNode.innerHTML = range.toString();

        // Keep whitespace before and after
        if (/^\s/.test(oNode.innerHTML))
            prefix = ' ';
        if (/\s+$/.test(oNode.innerHTML))
            suffix = ' ';

        // Note: TinyMCE uses a serializer here, I don't.
        //       prefix + this.serializer.serialize(oNode, options) + suffix;
        return this.isCollapsed() ? '' : prefix + oNode.outerHTML + suffix;*/
    }

    /**
     * Alter the content of the current selection/ active range by setting its
     * contents with some other specified HTML
     *
     * @param {String} html
     * @type {void}
     * @return A reference to the HTML node which has been inserted or its direct parent
     */
    this.setContent = function(html, bNoPrepare) {
        var range = this.getRange();

        
        if (!bNoPrepare)
            html = apf.htmlCleaner.prepare(html, true);
        

        if (range.insertNode) {
            // Make caret marker since insertNode places the caret in the
            // beginning of text after insert
            html += '<span id="__caret">_</span>';

            // Delete and insert new node
            range.deleteContents();
            range.insertNode(this.getRange().createContextualFragment(html));

            // Move to caret marker
            var oCaret = oDoc.getElementById('__caret');
            var htmlNode = oCaret.previousSibling;

            // Make sure we wrap it completely, Opera fails with a simple
            // select call
            range = oDoc.createRange();
            range.setStartBefore(oCaret);
            range.setEndAfter(oCaret);
            this.setRange(range);

            // Delete the marker, and hopefully the caret gets placed in the
            // right location
            oDoc.execCommand('Delete', false, null);

            // In case it's still there
            if (oCaret && oCaret.parentNode)
                oCaret.parentNode.removeChild(oCaret);
                
            return htmlNode;
        }
        else {
            if (range.item) {
                // Delete content and get caret text selection
                this.remove();
                range = this.getRange();
            }

            html = html.replace(/^<(\w+)/, '<$1 id="__caret"');
            range.pasteHTML(html);
            var htmlNode = oDoc.getElementById('__caret');
            if (htmlNode) {
                htmlNode.removeAttribute("id");
                return htmlNode;
            }
        }
    }

    var styleObjNodes = {
        img   : 1,
        hr    : 1,
        li    : 1,
        table : 1,
        tr    : 1,
        td    : 1,
        embed : 1,
        object: 1,
        ol    : 1,
        ul    : 1
    };

    /**
     * Get the type of selection of the editable area
     *
     * @type String
     */
    this.getType = function() {
        var oSel = this.get();
        if (apf.isIE) {
            return oSel.type;
        }
        else {
            // By default set the type to "Text".
            var type = 'Text' ;
            // Check if the actual selection is a Control (IMG, TABLE, HR, etc...).
            if (oSel && oSel.rangeCount == 1) {
                var range = oSel.getRangeAt(0);
                if (range.startContainer == range.endContainer
                  && (range.endOffset - range.startOffset) == 1
                  && range.startContainer.nodeType == 1
                  && styleObjNodes[range.startContainer
                       .childNodes[range.startOffset].nodeName.toLowerCase()]) {
                    type = CTRL;
                }
            }
            return type;
        }
    };

    /**
     * Retrieve the currently selected element from the editable area
     *
     * @return {DOMObject} Currently selected element or common ancestor element
     */
    this.getSelectedNode = function() {
        var range = this.getRange();

        if (!apf.isIE) {
            // Range maybe lost after the editor is made visible again
            if (!range)
                return oDoc;

            var oSel = this.get(), oNode = range.commonAncestorContainer;

            // Handle selection as image or other control like element such
            // as anchors
            if (!range.collapsed) {
                // If the anchor node is an element instead of a text node then
                // return this element
                if (apf.isWebkit && oSel.anchorNode && oSel.anchorNode.nodeType == 1)
                    return oSel.anchorNode.childNodes[oSel.anchorOffset];

                if (range.startContainer == range.endContainer) {
                    if (range.startOffset - range.endOffset < 2) {
                        if (range.startContainer.hasChildNodes())
                            oNode = range.startContainer.childNodes[range.startOffset];
                    }
                }
            }

            //oNode = oNode.parentNode;
            //while (oNode && oNode.parentNode && oNode.nodeType != 1)
            //    oNode = oNode.parentNode;
            return oNode;
        }

        return range.item ? range.item(0) : range.parentElement();
    };

    /**
     * Retrieve the parent node of the currently selected element from the
     * editable area
     *
     * @type DOMObject
     */
    this.getParentNode = function() {
        switch (this.getType()) {
            case CTRL :
                if (apf.isIE)
                    return this.getSelectedNode().parentElement;
                else
                    return this.getSelectedNode().parentNode;
            case NONE :
                return;
            default :
                var oSel = this.get();
                if (apf.isIE) {
                    return oSel.createRange().parentElement();
                }
                else {
                    if (oSel) {
                        var oNode = oSel.anchorNode;
                        while (oNode && oNode.nodeType != 1)
                            oNode = oNode.parentNode;
                        return oNode;
                    }
                }
                break;
        }
    };

    /**
     * Select a specific node inside the editable area
     *
     * @param {DOMObject} node
     * @type void
     */
    this.selectNode = function(node) {
        var oSel, range;
        
        //@todo Mike please check this!
        while (node.nodeType == 1 && node.firstChild)
            node = node.firstChild;

        if (apf.isIE) {
            oSel = this.get();
            
            if (!node)
                node = oSel.createRange().parentElement();
            
            try{
                oSel.empty();
            }catch(e){}

            try {
                // Try to select the node as a control.
                range = oDoc.body.createControlRange();
                range.addElement(node);
            }
            catch (e) {
                // If failed, select it as a text range.
                range = oDoc.body.createTextRange();
                try {
                    range.moveToElementText(node.nodeType != 1 
                        ? node.parentNode 
                        : node);
                }
                catch (e2) {
                    if (node.nodeValue)
                        range.findText(node.nodeValue);
                }
            }
            try{
                range.select();
            }catch(e){}
        }
        else {
            range = this.getRange();
            if (node)
                range.selectNode(node);
            oSel  = this.get();
            oSel.removeAllRanges();
            oSel.addRange(range);
        }
        
        return this;
    };

    /**
     * Collapse the selection to start or end of range.
     *
     * @param {Boolean} [toEnd] Boolean state if to collapse to end or
     *                          not. Defaults to start.
     * @type  {void}
     */
    this.collapse = function(toEnd) {
        var range = this.getRange(), n;

        // 'Control' range on IE
        if (range.item) {
            n = range.item(0);
            range = oDoc.body.createTextRange();
            range.moveToElementText(n);
        }

        range.collapse(!!toEnd);
        this.setRange(range);
        
        return this;
    };

    /**
     * Checks if the active range is in a collapsed state or not.
     *
     * @type {Boolean}
     */
    this.isCollapsed = function() {
        var range = this.getRange(), oSel = this.get();

        if (!range || range.item)
            return false;

        return !oSel || range.boundingWidth == 0 || range.collapsed;
    };

    /**
     * Check if the currently selected element has any parent node(s) with the
     * specified tagname
     *
     * @param {String} nodeTagName
     * @type  {Boolean}
     */
    this.hasAncestorNode = function(nodeTagName) {
        var oContainer, range = this.getRange();
        if (this.getType() == CTRL || !apf.isIE) {
            oContainer = this.getSelectedNode();
            if (!oContainer && !apf.isIE) {
                try {
                    oContainer = range.startContainer;
                }
                catch(e){}
            }
        }
        else {
            oContainer = range.parentElement();
        }
        while (oContainer) {
            if (apf.isIE)
                if (oContainer.tagName == nodeTagName)
                    return true;
                else if (oContainer.nodeType == 1
                  && oContainer.tagName == nodeTagName)
                    return true;
            oContainer = oContainer.parentNode;
        }
        return false ;
    };

    /**
     * Move the selection to a parent element of the currently selected node
     * with the specified tagname
     *
     * @param {String} nodeTagName
     * @type  {void}
     */
    this.moveToAncestorNode = function(nodeTagName) {
        var oNode, i, range = this.getRange();
        nodeTagName = nodeTagName.toUpperCase();
        if (apf.isIE) {
            if (this.getType() == CTRL) {
                for (i = 0; i < range.length; i++) {
                    if (range(i).parentNode) {
                        oNode = range(i).parentNode;
                        break;
                    }
                }
            }
            else {
                oNode = range.parentElement();
            }
            while (oNode && oNode.nodeName != nodeTagName)
                oNode = oNode.parentNode;
            return oNode;
        }
        else {
            var oContainer = this.getSelectedNode();
            if (!oContainer)
                oContainer = oWin.getSelection().getRangeAt(0).startContainer
            while (oContainer) {
                if (oContainer.tagName == nodeTagName)
                    return oContainer;
                oContainer = oContainer.parentNode;
            }
            return null ;
        }
    };

    /**
     * Remove the currently selected contents from the editable area
     *
     * @type {Selection}
     */
    this.remove = function() {
        var oSel = this.get(), i;
        if (apf.isIE) {
            if (oSel.type != NONE)
                oSel.clear();
        }
        else if (oSel) {
            for (i = 0; i < oSel.rangeCount; i++)
                oSel.getRangeAt(i).deleteContents();
        }
        return this;
    };

    this.$destroy = function() {
        oWin = oDoc = editor = this.current = _self = null;
        delete oWin;
        delete oDoc;
        delete editor;
        delete this.current;
        delete _self;
    };
};


/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/html.js)SIZE(15364)TIME(1259708671)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * The parser of the HyperText Markup Language.
 * @private
 */
apf.htmlCleaner = (function() {
    var prepareRE    = null, exportRE = null,
        noMarginTags = {"table": 1, "TABLE": 1},
        selfClosing  = {"br": 1, "img": 1, "input": 1, "hr": 1};

    return {
        /**
         * Processes, sanitizes and cleanses a string of raw html that originates
         * from outside a contentEditable area, so that the inner workings of the
         * editor are less likely to be affected.
         *
         * @param  {String} html
         * @return The sanitized string, valid to store and use in the editor
         * @type   {String}
         */
        prepare: function(html, bNoEnclosing) {
            if (!prepareRE) {
                // compile 'em regezz
                prepareRE = [
                    /<(\/?)strong>|<strong( [^>]+)>/gi,
                    /<(\/?)em>|<em( [^>]+)>/gi,
                    /&apos;/g,
                    /*
                        Ruben: due to a bug in IE and FF this regexp won't fly:
                        /((?:[^<]*|<(?:span|strong|em|u|i|b)[^<]*))<br[^>]*?>/gi, //@todo Ruben: add here more inline html tag names
                    */
                    /(<(\/?)(span|strong|em|u|i|b|a|strike|sup|sub|font|img)(?:\s+[\s\S]*?)?>)|(<br[\s\S]*?>)|(<(\/?)([\w\-]+)(?:\s+[\s\S]*?)?>)|([^<>]*)/gi, //expensive work around
                    /(<a[^>]*href=)([^\s^>]+)*([^>]*>)/gi,
                    /<p><\/p>/gi,
                    /<a( )([^>]+)\/>|<a\/>/gi
                ];
            }

            // Convert strong and em to b and i in FF since it can't handle them
            if (apf.isGecko) {//@todo what about the other browsers?
                html = html.replace(prepareRE[0], "<$1b$2>")
                           .replace(prepareRE[1], "<$1i$2>");
            }
            else if (apf.isIE) {
                html = html.replace(prepareRE[2], "&#39;") // IE can't handle apos
                           .replace(prepareRE[4], "$1$2 _apf_href=$2$3");
                           //.replace(prepareRE[5], "<p>&nbsp;</p>");

                // <BR>'s need to be replaced to be properly handled as
                // block elements by IE - because they're not converted
                // when an editor command is executed
                var str = [], capture = false, strP = [], depth = [], bdepth = [],
                    lastBlockClosed = false;
                html.replace(prepareRE[3],
                  function(m, inline, close, tag, br, block, bclose, btag, any){
                    if (inline) {
                        var id = strP.push(inline);

                        tag = tag.toLowerCase();
                        if (!selfClosing[tag]) {
                            if (close) {
                                if (!depth[depth.length-1]
                                  || depth[depth.length-1][0] != tag) {
                                    strP.length--; //ignore non matching tag
                                }
                                else {
                                    depth.length--;
                                }
                            }
                            else {
                                depth.push([tag, id]);
                            }
                        }

                        capture = true;
                    }
                    else if (any) {
                        strP.push(any);
                        capture = true;
                    }
                    else if (br) {
                        if (capture) {
                            if (depth.length) {
                                strP.push(br);
                            }
                            else {
                                str.push("<p>", strP.join(""), "</p>");
                                strP = [];
                            }

                            if (!depth.length)
                                capture = false;
                        }
                        else {
                            if ((bdepth.length || lastBlockClosed)
                              && br.indexOf("_apf_marker") > -1) {
                                //debugger;
                                //donothing
                            }
                            else
                                str.push("<p>&nbsp;</p>");
                        }
                    }
                    else if (block){
                        if (bclose) {
                            if (bdepth[bdepth.length-1] != btag.toLowerCase()) {
                                return;
                            }
                            else {
                                bdepth.length--;
                            }

                            //Never put P's inside block elements
                            if (strP.length) {
                                str.push(strP.join(""));
                                strP = [];
                            }

                            lastBlockClosed = 2;
                        }
                        else {
                            var useStrP = strP.length && strP.join("").trim();
                            var last = useStrP ? strP : str;
                            if (!noMarginTags[btag]) {
                                if (last[last.length - 1] == "<p>&nbsp;</p>")
                                    last[last.length - 1] = "";//<p></p>"; //maybe make this a setting
                                else if(useStrP && !bdepth.length)
                                    last.push("<p></p>");
                            }

                            if (strP.length) {
                                //Never put P's inside block elements
                                if (!useStrP || bdepth.length) {
                                    str.push(strP.join(""));
                                    strP = [];
                                }
                                else {
                                    str.push("<p>", strP.join(""), "</p>");
                                    strP = [];
                                }
                            }

                            bdepth.push(btag.toLowerCase());
                        }

                        str.push(block);
                        capture = false;
                    }

                    lastBlockClosed = lastBlockClosed == 2 ? 1 : false;
                  });
                var s;
                if ((s = strP.join("")).trim())
                    str.push(bNoEnclosing
                     ? s
                     : "<p>" + s + "</p>");
                html = str.join("");
            }

            // Fix some issues
            html = (apf.xmlentities ? apf.xmlentities(html) : html)
                       .replace(prepareRE[6], "<a$1$2></a>");

            return html;
        },

        /**
         * Return a string of html, but then formatted in such a way that it can
         * embedded.
         *
         * @param  {String}  html
         * @param  {Boolean} bStrict
         * @type   {String}
         */
        parse: function(html, bStrict, noParagraph) {
            if (!exportRE) {
                // compile 'em regezz
                exportRE = [
                    /<br[^>]*><\/li>/gi,
                    /<br[^>]*_apf_placeholder="1"\/?>/gi,
                    /<(a|span|div|h1|h2|h3|h4|h5|h6|pre|address)>[\s\n\r\t]*<\/(a|span|div|h1|h2|h3|h4|h5|h6|pre|address)>/gi,
                    /<(tr|td)>[\s\n\r\t]*<\/(tr|td)>/gi,
                    /[\s]*_apf_href="?[^\s^>]+"?/gi,
                    /(".*?"|'.*?')|(\w)=([^'"\s>]+)/gi,
                    /<((?:br|input|hr|img)(?:[^>]*[^\/]|))>/ig, // NO! do <br /> see selfClosing
                    /<p>&nbsp;$/mig,
                    /(<br[^>]*?>(?:[\r\n\s]|&nbsp;)*<br[^>]*?>)|(<(\/?)(span|strong|em|u|i|b|a|br|strike|sup|sub|font|img)(?:\s+.*?)?>)|(<(\/?)([\w\-]+)(?:\s+.*?)?>)|([^<>]*)/gi,
                    /<\/p>/gi, //<p>&nbsp;<\/p>|
                    /<p>/gi,
                    /<\s*\/?\s*(?:\w+:\s*)?[\w-]*[\s>\/]/g
                ];
            }

            if (apf.isIE) {
                html = html.replace(exportRE[7], "<p></p>")
                           .replace(exportRE[9], "<br />")
                           .replace(exportRE[10], "")
            }
            else if (html == "<br>")
                html = "";

            html = (apf.xmlentities ? apf.xmlentities(html) : html)
                       .replace(exportRE[0], "</li>")
                       .replace(exportRE[1], "")
                       .replace(exportRE[2], "")
                       .replace(exportRE[3], "<$1>&nbsp;</$2>")
                       .replace(exportRE[4], "")
                       .replace(exportRE[6], "<$1 />")
                       .replace(exportRE[11], function(m){
                           return m.toLowerCase();
                       });

            //@todo: Ruben: Maybe make this a setting (paragraphs="true")
            //@todo might be able to unify this function with the one above.
            if (apf.isIE && !noParagraph) {
                var str = [], capture = true, strP = [], depth = [], bdepth = [];
                html.replace(exportRE[8],
                  function(m, br, inline, close, tag, block, bclose, btag, any){
                    if (inline) {
                        if (apf.isIE) {
                            inline = inline.replace(exportRE[5],
                                function(m, str, m, v){
                                    return str || m + "=\"" + v + "\"";
                                });//'$2="$3"') //quote un-quoted attributes
                        }

                        var id = strP.push(inline);

                        if (!selfClosing[tag]) {
                            if (close) {
                                if (!depth[depth.length-1]
                                  || depth[depth.length-1][0] != tag) {
                                    strP.length--; //ignore non matching tag
                                }
                                else {
                                    depth.length--;
                                }
                            }
                            else {
                                depth.push([tag, id]);
                            }
                        }

                        capture = true;
                    }
                    else if (any) {
                        strP.push(any);
                        capture = true;
                    }
                    else if (br) {
                        if (capture) {
                            if (depth.length) {
                                strP.push(br);
                            }
                            else {
                                str.push("<p>", strP.join("").trim()
                                    || "&nbsp;", "</p>");
                                strP    = [];
                                capture = false;
                            }
                        }
                        else
                            str.push("<p>&nbsp;</p>");
                    }
                    else if (block){
                        if (bclose) {
                            if (bdepth[bdepth.length-1] != btag) {
                                return;
                            }
                            else {
                                bdepth.length--;
                            }

                            //Never put P's inside block elements
                            if (strP.length) {
                                str.push(strP.join(""));
                                strP = [];
                            }
                        }
                        else {
                            if (apf.isIE) {
                                block = block.replace(exportRE[5],
                                    function(m, str, m, v){
                                        return str || m + "=\"" + v + "\"";
                                    });//'$2="$3"') //quote un-quoted attributes
                            }

                            //@todo this section can be make similar to the one
                            //      in the above function and vice verse
                            var last = strP.length ? strP : str;
                            if (last[last.length - 1] == "<p>&nbsp;</p>")
                                last.length--;

                            if (strP.length) {
                                var s;
                                //Never put P's inside block elements
                                if (bdepth.length || (s = strP.join("").trim())
                                  .replace(/<.*?>/g,"").trim() == "") {
                                    str.push(s || strP.join(""));
                                    strP = [];
                                }
                                else {
                                    str.push("<p>",
                                        (s || strP.join("").trim() || "&nbsp;")
                                            .replace(/<br \/>[\s\r\n]*$/, ""),
                                        "</p>");
                                    strP = [];
                                }
                            }

                            bdepth.push(btag);
                        }

                        str.push(block);
                        capture = false;
                    }
                  });
                if (strP.length) {
                    str.push("<p>" + strP.join("")
                        .replace(/<br \/>[\s\r\n]*$/, "") + "</p>");
                }
                html = str.join("");
            }
            else {
                html = html.replace(/<br[^>]*_apf_marker="1"[^>]*>/gi, "<br />");
            }

            
            // check for VALID XHTML in DEBUG mode...
            try {
                apf.getXml("<source>" + html.replace(/&.{3,5};/g, "")
                    + "</source>");
            }
            catch(ex) {
                apf.console.error(ex.message + "\n" + html.escapeHTML());
            }
            

            return html;
        }
    };
})();




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/sort.js)SIZE(7587)TIME(1263513663)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Object handling sorting in a similar way as xslt.
 *
 * @constructor
 * @todo use a struct instead of lots of local variables, and stop using eval
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 *
 * @private
 */
apf.Sort = function(xmlNode){
    var settings = {};
    //order, xpath, type, method, getNodes, dateFormat, dateReplace, sort_dateFmtStr, getValue;
    
    //use this function to parse the each node
    this.parseXml = function(xmlNode, clear){
        if (clear) settings = {};

        settings.order     = xmlNode.order;
        settings.getValue  = xmlNode.csort || xmlNode.$compile("sort");
        settings.getNodes  = self[xmlNode["nodes-method"]];

        settings.ascending = (settings.order || "").indexOf("desc") == -1;
        settings.order     = null;

        if (xmlNode["data-type"])
            settings.method = sort_methods[xmlNode["data-type"]];
        else if (xmlNode["sort-method"]) {
            settings.method = self[xmlNode["sort-method"]];
            
            
            if (!settings.method) {
                throw new Error(apf.formatErrorString(0, null, 
                    "Sorting nodes",
                    "Invalid or missing sort function name provided '" 
                    + xmlNode["sort-method"] + "'", xmlNode));
            }
            
        }
        else
            settings.method = sort_methods["alpha"];
        
        var str = xmlNode["date-format"];
        if (str) {
            settings.sort_dateFmtStr = str;
            settings.method = sort_methods["date"];
            var result = str.match(/(D+|Y+|M+|h+|m+|s+)/g);
            if (result) {
                for (var pos = {}, i = 0; i < result.length; i++) 
                    pos[result[i].substr(0, 1)] = i + 1;
                settings.dateFormat = new RegExp(str.replace(/([^\sDYMhms])/g, '\\$1')
                    .replace(/YYYY/, "(\\d\\d\\d\\d)")
                    .replace(/(DD|YY|MM|hh|mm|ss)/g, "(\\d\\d)"));
                settings.dateReplace = "$" + pos["M"] + "/$" + pos["D"] + "/$" + pos["Y"];
                if (pos["h"]) 
                    settings.dateReplace += " $" + pos["h"] + ":$" + pos["m"] + ":$" + pos["s"];
            }
        }
    };
    
    this.set = function(struct, clear){
        if (clear) settings = {};
        
        apf.extend(settings, struct);

        if (!settings.ascending)
            settings.ascending = struct.order 
                ? struct.order.indexOf("desc") == -1
                : true;
        
        settings.order = null;
        
        if (struct["type"]) 
            settings.method = sort_methods[struct["type"]];
        else if (struct["method"])
            settings.method = self[struct["method"]];
        else if (!settings.method) 
            settings.method = sort_methods["alpha"];
        
        if (!settings.getValue) {
            settings.getValue = function(item){
                return apf.queryValue(item, settings.xpath);
            }
        }
    };
    
    this.get = function(){
        return apf.extend({}, settings);
    };
    
    //use this function in __xmlUpdate [this function isnt done yet]
    this.findSortSibling = function(pNode, xmlNode){
        var nodes = getNodes ? getNodes(pNode, xmlNode) : this.getTraverseNodes(pNode);
        
        for (var i = 0; i < nodes.length; i++) 
            if (!compare(xmlNode, nodes[i], true, sortSettings)) 
                return nodes[i];
        
        return null;
    };
    
    // Sorting methods for sort()
    var sort_intmask = ["", "0", "00", "000", "0000", "00000", "000000",
        "0000000", "00000000", "000000000", "0000000000", "00000000000",
        "000000000000", "0000000000000", "00000000000000"];
    var sort_methods = {
        "alpha" : function (n){
            return n.toString().toLowerCase()
        },

        "number" : function (t){
            return (t.length < sort_intmask.length
                ? sort_intmask[sort_intmask.length - t.length]
                : "") + t;
        },

        "date" : function (t, args){
            var sort_dateFormat = settings.dateFormat;
            var sort_dateReplace = settings.dateReplace;
            var sort_dateFmtStr = settings.sort_dateFmtStr;
            
            var d;//|| (args && sort_dateFmtStr != args[0])
            if (!sort_dateFormat) {
                d = new Date(t);
            }
            else if (sort_dateFmtStr == '*') 
                d = Date.parse(t);
            else 
                d = (new Date(t.replace(sort_dateFormat, sort_dateReplace))).getTime();
            t = "" + d.getTime();//parseInt(d);
            if (t == "NaN") 
                t = "0";
            return (t.length < sort_intmask.length ? sort_intmask[sort_intmask.length
                - t.length] : "") + t;
        }
    };

    /*
     sort(xpath, sort_xpath, sort_alpha, boolDesc, from, len)
     jsort(n,f,p,ps,sm,desc,sp,ep)
     */
    //var order, xpath, type, method, getNodes, dateFormat, dateReplace, sort_dateFmtStr, getValue;
    this.apply = function(n, args, func, start, len){
        var sa = [], i = n.length;
        
        // build string-sortable list with sort method
        while (i--) {
            var v = settings.getValue(n[i]);
            if (n) 
                sa[sa.length] = {
                    toString: function(){
                        return this.v;
                    },
                    xmlNode : n[i],
                    v       : (settings.method || sort_methods.alpha)(v || "", args, n[i])
                };
        }
        
        // sort it
        sa.sort();
        
        //iterate like foreach
        var end = len ? Math.min(sa.length, start + len) : sa.length;
        if (!start) 
            start = 0;
        
        if (func) {
            if (settings.ascending) 
                for (i = start; i < end; i++) 
                    f(i, end, sa[i].xmlNode, sa[i].v);
            else 
                for (i = end - 1; i >= start; i--) 
                    f(end - i - 1, end, sa[i].xmlNode, sa[i].v);
        }
        else {
            //this could be optimized by reusing n... time it later
            var res = [];
            if (settings.ascending) 
                for (i = start; i < end; i++) 
                    res[res.length] = sa[i].xmlNode;
            else 
                for (i = end - 1; i >= start; i--) 
                    res[res.length] = sa[i].xmlNode;
            return res;
        }
    };
    
    if (xmlNode) 
        this.parseXml(xmlNode);
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/skins.js)SIZE(12312)TIME(1264809662)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @private
 * @define skin
 * @allowchild  style, presentation
 * @attribute src
 */
apf.skins = {
    skins  : {},
    css    : [],
    events : ["onmousemove", "onmousedown", "onmouseup", "onmouseout",
        "onclick", "ondragcopy", "ondragstart"],

    /* ***********
     Init
     ************/
    Init: function(xmlNode, refNode, path){
        /*
         get data from refNode || xmlNode
         - name
         - icon-path
         - media-path

         all paths of the xmlNode are relative to the src attribute of refNode
         all paths of the refNode are relative to the index.html
         images/ is replaced if there is a refNode to the relative path from index to the skin + /images/
         */
        var name      = (refNode ? refNode.getAttribute("id") : null)
            || xmlNode.getAttribute("id");
        var base      = (refNode ? refNode.getAttribute("src").match(/\//) || path : "")
            ? (path || refNode.getAttribute("src")).replace(/\/[^\/]*$/, "") + "/"
            : "";
        var mediaPath = (xmlNode.getAttribute("media-path")
            ? apf.getAbsolutePath(base || apf.hostPath, xmlNode.getAttribute("media-path"))
            : (refNode ? refNode.getAttribute("media-path") : null));
        var iconPath  = (xmlNode.getAttribute("icon-path")
            ? apf.getAbsolutePath(base || apf.hostPath, xmlNode.getAttribute("icon-path"))
            : (refNode ? refNode.getAttribute("icon-path") : null));
        if (!name)
            name = "default";

        if (xmlNode.getAttribute("id"))
            document.body.className += " " + xmlNode.getAttribute("id");

        var names = name.split("|");
        name = names[0];

        if (!this.skins[name] || name == "default") {
            this.skins[name] = {
                base     : base,
                name     : name,
                iconPath : typeof iconPath != "string" && !iconPath ? "icons/" : iconPath,
                mediaPath: typeof mediaPath != "string" && !mediaPath ? "images/" : mediaPath,
                templates: {},
                originals: {},
                xml      : xmlNode
            }
            
            if (names.length > 1) {
                for (var i = 0; i < names.length; i++)
                    this.skins[names[i]] = this.skins[name];
            }
        }
        
        if (!this.skins["default"] && this.$first == refNode)
            this.skins["default"] = this.skins[name];

        var nodes = xmlNode.childNodes;
        for (var i = nodes.length - 1; i >= 0; i--) {
            if (nodes[i].nodeType != 1)
                continue;

            //this.templates[nodes[i].tagName] = nodes[i];
            this.skins[name].templates[nodes[i].getAttribute("name")] = nodes[i];
            if (nodes[i].ownerDocument)
                this.importSkinDef(nodes[i], base, name);
        }

        this.purgeCss(mediaPath || base + "images/", iconPath || base + "icons/");
        
        if (this.queue[name]) {
            for (var prop in this.queue[name]) {
                this.queue[name][prop]();
            }
        }
    },

    /**
     * This method loads a stylesheet from a url
     * @param {String}    filename Required The url to load the stylesheet from
     * @param {String}    title Optional Title of the stylesheet to load
     * @method
     */
    loadStylesheet: function(filename, title){
        var o;
        with (o = document.getElementsByTagName("head")[0].appendChild(document.createElement("LINK"))) {
            rel   = "stylesheet";
            type  = "text/css";
            href  = filename;
            title = title;
        }

        return o;
    },

    /* ***********
     Import
     ************/
    importSkinDef: function(xmlNode, basepath, name){
        var i, l, nodes = $xmlns(xmlNode, "style", apf.ns.aml), tnode, node;
        for (i = 0, l = nodes.length; i < l; i++) {
            node = nodes[i];

            if (node.getAttribute("src"))
                this.loadStylesheet(node.getAttribute("src").replace(/src/, basepath + "/src"));
            else {
                var test = true;
                if (node.getAttribute("condition")) {
                    try {
                        test = eval(node.getAttribute("condition"));
                    }
                    catch (e) {
                        test = false;
                    }
                }

                if (test) {
                    //#-ifndef __PROCESSED
                    tnode = node.firstChild;
                    while (tnode) {
                        this.css.push(tnode.nodeValue);
                        tnode = tnode.nextSibling;
                    }
                    /*#-else
                    this.css.push(nodes[i].firstChild.nodeValue);
                    #-endif*/
                }
            }
        }

        nodes = $xmlns(xmlNode, "alias", apf.ns.apf);
        var t = this.skins[name].templates;
        for (i = 0; i < nodes.length; i++) {
            if (!nodes[i].firstChild)
                continue;
            t[nodes[i].firstChild.nodeValue.toLowerCase()] = xmlNode;
        }
    },

    loadedCss : "",
    purgeCss: function(imagepath, iconpath){
        if (!this.css.length)
            return;

        var cssString = this.css.join("\n").replace(/images\//g, imagepath).replace(/icons\//g, iconpath);
        apf.importCssString(cssString);

        
        this.loadedCss += cssString;
        

        this.css = [];
    },

    loadCssInWindow : function(skinName, win, imagepath, iconpath){
        this.css = [];
        var name = skinName.split(":");
        var skin = this.skins[name[0]];
        var template = skin.templates[name[1]];
        this.importSkinDef(template, skin.base, skin.name);
        var cssString = this.css.join("\n").replace(/images\//g, imagepath).replace(/icons\//g, iconpath);
        apf.importCssString(cssString);

        this.css = [];
    },

    /* ***********
     Retrieve
     ************/
    setSkinPaths: function(skinName, amlNode){
        skinName = skinName.split(":");
        var name = skinName[0];
        var type = skinName[1];

        
        if (!this.skins[name]) {
            throw new Error(apf.formatErrorString(1076, null,
                "Retrieving Skin",
                "Could not find skin '" + name + "'", amlNode.$aml));
        }
        

        amlNode.iconPath  = this.skins[name].iconPath;
        amlNode.mediaPath = this.skins[name].mediaPath;
    },

    getTemplate: function(skinName, noError){
        skinName = skinName.split(":");
        var name = skinName[0];
        var type = skinName[1];

        if (!this.skins[name]) {
            if (noError)
                return false;
            
            
            throw new Error(apf.formatErrorString(1077, null,
                "Retrieving Template",
                "Could not find skin '" + name + "'"));
            
            
            return false;
        }

        if (!this.skins[name].templates[type])
            return false;

        var skin      = this.skins[name].templates[type];
        var originals = this.skins[name].originals[type];
        if (!originals) {
            originals = this.skins[name].originals[type] = {};

            
            if (!$xmlns(skin, "presentation", apf.ns.aml)[0]) {
                throw new Error(apf.formatErrorString(1078, null,
                    "Retrieving Template",
                    "Missing presentation tag in '" + name + "'"));
            }
            

            var nodes = $xmlns(skin, "presentation", apf.ns.aml)[0].childNodes;
            for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].nodeType != 1) continue;
                originals[nodes[i].baseName || nodes[i][apf.TAGNAME]] = nodes[i];
            }
        }

        /*for (var item in originals) {
            pNodes[item] = originals[item];
        }*/

        return originals;
    },

    getCssString : function(skinName){
        return apf.queryValue($xmlns(this.skins[skinName.split(":")[0]].xml,
            "style", apf.ns.aml)[0], "text()");
    },

    
    changeSkinset : function(value){
        var node = apf.document.documentElement;
        while (node) {
            if (node && node.nodeFunc == apf.NODE_VISIBLE
              && node.hasFeature(apf.__PRESENTATION__) && !node.skinset) {
                node.$propHandlers["skinset"].call(node, value);//$forceSkinChange
                node.skinset = null;
            }

            //Walk tree
            if (node.firstChild || node.nextSibling) {
                node = node.firstChild || node.nextSibling;
            }
            else {
                do {
                    node = node.parentNode;
                } while (node && !node.nextSibling)

                if (node)
                    node = node.nextSibling;
            }
        }
    },
    
    
    queue : {},
    waitForSkin : function(skinset, id, callback){
        if (this.skins[skinset])
            return;
        
        (this.queue[skinset] || (this.queue[skinset] = {}))[id] = callback;
        return true;
    },

    
    iconMaps : {},
    addIconMap : function(options){
        this.iconMaps[options.name] = options;
        if (options.size)
            options.width = options.height = options.size;
        else {
            if (!options.width)
                options.width = 1;
            if (!options.height)
                options.height = 1;
        }
    },
    

    setIcon : function(oHtml, strQuery, iconPath){
        if (!strQuery) {
            oHtml.style.backgroundImage = "";
            return;
        }

        if (oHtml.tagName.toLowerCase() == "img") {
            oHtml.setAttribute("src", strQuery
                ? (iconPath || "") + strQuery
                : "");
            return;
        }

        
        var parts = strQuery.split(":"); //@todo apf3.x optimize this
        var map = this.iconMaps[parts[0]];
        if (map) {
            var left, top, coords = parts[1].split(",");
            left = (coords[(map.type == "vertical") ? 1 : 0] || 0) * map.width;
            top  = (coords[(map.type == "vertical") ? 0 : 1] || 0) * map.height;

            oHtml.style.backgroundImage = "url(" + (iconPath || "")
                + map.src + ")";
            oHtml.style.backgroundPosition = ((-1 * left) - map.offset[0])
                + "px " + ((-1 * top) - map.offset[1]) + "px";
        }
        else
        

        //Assuming image url
        {
            
            //@todo check here if it is really a url
            

            oHtml.style.backgroundImage = "url(" + (iconPath || "")
                + strQuery + ")";
        }
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/flow.js)SIZE(70808)TIME(1258476515)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * This abstraction is used for creating block elements which can be moved by
 * mouse or keyboard, rotated with 90 degreed steps, flipped horizontally and
 * vertically and resized on the fly using the mouse. Each block can have inputs
 * defined in a template file. Inputs allow creating stiff connections between
 * block elements. If a block does not have inputs, the connection is created in
 * the most optimal way.
 *
 * @event onmousedown   Fires when mouse button is pressed on document body
 * @event onmousemove   Fires when mouse pointer is moving over document body
 * @event onmouseup     Fires when mouse button is released while the pointer is
 *                      over the document body
 *
 * @attribute {Boolean} isMoved              the state of movement. When connection
 *                                           is moving, this attribute is set to true.
 *                                           It gives information to other methods
 *                                           what happens with the connection element.
 *     Possible values:
 *     true   block moves
 *     false  block don't move
 * @attribute {Object}  objCanvases          storage workareas objects, it allows
 *                                           an easy access to them if need
 * @attribute {Object}  connectionsTemp      keeps information about source block
 *                                           and its input in moment of connection
 *                                           creation. (mode must be set to
 *                                           "connection-add")
 * @attribute {Object}  connectionsManager   manage of entire connection creation
 *                                           process
 * @attribute {Number}  sSize                connection line width
 * @attribute {Number}  fsSize               define size of first and last connection
 *                                           segment
 *
 * @private
 * @default_private
 * @constructor
 *
 * @author      Lukasz Lipinski
 * @version     %I%, %G%
 * @since       1.0
 * @namespace apf
 */

apf.flow = {
    isMoved            : false,
    objCanvases        : {},
    connectionsTemp    : null,
    connectionsManager : null,

    sSize  : 7,
    fsSize : 15,

    init : function() {
        //apf.flow.connectionsManager = new apf.flow.connectionsManager;

        document.body.onmousedown = function(e) {
            e = (e || event);

            /* Looking for Block element */
            var target   = e.target || e.srcElement,
                isDragged = false;

            if (target.tagName == 'HTML')
                return;
            while (target != document.body && !apf.flow.findBlock(target.id)) {
                target = target.parentNode || target.parentElement;
            }
            /* Looking for Block element - End*/

            var objBlock = apf.flow.isBlock(target);

            if (!objBlock)
                return;
            if (!objBlock.draggable)
                return;

            var sx = e.clientX, sy = e.clientY,
                dx = 0, dy = 0,
                l = parseInt(target.style.left),
                t = parseInt(target.style.top),
                newTop, newLeft;
            //Snap
            var snap  = objBlock.canvas.snap,
                gridW = objBlock.canvas.gridW,
                gridH = objBlock.canvas.gridH;

            //objBlock.canvas.htmlElement.scrollLeft = Math.round(l+dx+target.offsetWidth);

            if (e.preventDefault)
                e.preventDefault();

            document.body.onmousemove = function(e) {
                e = (e || event);

                isDragged = true;

                dx = e.clientX - sx;
                dy = e.clientY - sy;
                
                newTop  = t + dy;
                newLeft = l + dx;

                if (snap) {
                    target.style.left = Math.round(newLeft / gridW) * gridW + "px";
                    target.style.top  = Math.round(newTop  / gridH) * gridH + "px";
                }
                else {
                    target.style.left = newLeft + "px";
                    target.style.top  = newTop + "px";
                }
                

                objBlock.onMove();
                apf.flow.onblockmove();

                return false;
            };

            document.body.onmouseup = function(e) {
                document.body.onmousemove = null;

                if (apf.flow.onaftermove && isDragged) {
                    apf.flow.onaftermove(dy, dx);

                    isDragged = false;
                }
            };
        };
    }
};

/**
 * Workarea where blocks and connections its placed
 *
 * @param {HTMLElement}   htmlElement    the html representation of a workarea
 * @constructor
 */
apf.flow.canvas = function(htmlElement) {
    if (!htmlElement.getAttribute("id")) {
        apf.setUniqueHtmlId(htmlElement);
    }

    this.id             = htmlElement.getAttribute("id");
    this.htmlElement    = htmlElement;

    this.htmlBlocks     = {};
    this.htmlConnectors = {};
    
    this.scrollPointer  = null;
    this.lastTop        = 0;
    this.lastLeft       = 0;

    this.mode           = "normal";
    this.disableremove  = false;
    this.snap           = false;
    this.gridW          = 48;
    this.gridH          = 48;

    this.initCanvas = function() {
        apf.flow.objCanvases[this.htmlElement.getAttribute("id")] = this;
    };

    this.removeConnector = function(id) {
        var c = this.htmlConnectors[id];
        c.htmlElement.parentNode.removeChild(c.htmlElement);
        this.htmlConnectors[id] = c = null;
        delete this.htmlConnectors[id];
    };

    this.deselectConnections = function() {
        for (var id in this.htmlConnectors) {
            var con = this.htmlConnectors[id];
            if (con.selected) {
                con.deselect("selected");
                con.deselectInputs("Selected");
                con.selected = false;
            }
        }
    };

    this.setMode = function(mode) {
        this.mode = mode;
    };

    this.getMode = function() {
        return this.mode;
    };
    
    this.getWindowScrollLeft = function() {
        return document.documentElement.scrollLeft || document.body.scrollLeft;
    };
    
    this.getWindowScrollTop = function() {
        return document.documentElement.scrollTop || document.body.scrollTop;
    };
    
    this.scrollLeft = function() {
        this.htmlElement.scrollLeft = 9999;
    };
    
    this.scrollTop = function() {
        this.htmlElement.scrollTop = 9999;
    };
    
    this.getScrollLeft = function() {
        return this.htmlElement.scrollLeft;
    };
    
    this.getScrollTop = function() {
        return this.htmlElement.scrollTop;
    };
    
    this.addScrollPointer = function() {
        this.scrollPointer = this.htmlElement.appendChild(document.createElement("div"));
        this.scrollPointer.className = "scrollPointer";
    };
    
    this.moveLeftScrollPointer = function(left) {
        var value = parseInt(left) + 150;
        this.scrollPointer.style.left = value + "px";
        this.lastLeft = parseInt(left);
    };
    
    this.moveTopScrollPointer = function(top) {
        var value = parseInt(top) + 150;
        this.scrollPointer.style.top  = value + "px";
        this.lastTop = parseInt(top);
    };
    
    this.getWidth = function() {
        return this.htmlElement.offsetWidth;
    };

    this.getHeight = function() {
        return this.htmlElement.offsetHeight;
    };
};

/**
 * Creates a new block object which can be moved by mouse or keyboard, rotated
 * with 90 degrees steps, flipped horizontally and vertically and resized on the fly
 * using the mouse. Each block can have inputs, background picture and minimal
 * dimension defined in the template file. It is possible to create connections
 * between blocks.
 *
 * @param {HTMLElement}   htmlElement   the html representation of block
 * @param {Object}        objCanvas     object representation of workarea (canvas) element
 * @param {Object}        other         the properties of the block element
 *    Properties:
 *    {Boolean}   lock   prohibit block move, default is false
 *        Possible values:
 *        false   block element is unlocled
 *        true    block element is locked
 *    {Boolean}   flipv   whether to mirror the block over the vertical axis,
 *                        background image is flipped automaticly, default is false
 *        Possible values:
 *        true    block element is flipped
 *        false   block element is not flipped
 *    {Boolean}   fliph   whether to mirror the block over the horizontal axis,
 *                        background image is flipped automaticly. default is false
 *        Possible values:
 *        true    block element is flipped
 *        false   block element is not flipped
 *    {Number}    rotation   the rotation in degrees clockwise, background image
 *                           is rotated automaticly, default is 0
 *        Possible values:
 *        0     0   degrees rotation
 *        90    90  degrees rotation
 *        180   180 degrees rotation
 *        270   270 degrees rotation
 *    {Object}   inputList   Block's inputs list, block could haven't any inputs
 *        Properties:
 *        {Number}  x          position in pixels relative to Block's horizontal
 *                             dimension
 *        {Number}  y          position in pixels relative to Block's vertical
 *                             dimension
 *        {String}  position   edge where input is placed
 *            Possible values:
 *            top      input is placed on top edge of block
 *            right    input is placed on right edge of block
 *            bottom   input is placed on bottom edge of block
 *            left     input is placed on left edge of block
 *    {String}       type         name of block with special abilities, which
 *                                could set in template file
 *    {String}       picture      Path to image file.
 *    {Number}       dwidth       the minimal horizontal size of Block element
 *    {Number}       dheight      the minimal vertical size of Block element
 *    {Boolean}      scalex       resizing in horizontal plane
 *    {Boolean}      scaley       resizing in vertical plane
 *    {Boolean}      scaleratio   resizing in horizontal or vertical plane only
 *                                is not allowed. Resizing in two dimensions
 *                                plane at the same time is allowed.
 *    {XMLElement}   xmlNode      the xml representation of block from model
 *    {String}       caption      description placed under block element
 * @constructor
 */
apf.flow.block = function(htmlElement, objCanvas, other) {
    this.canvas        = objCanvas;
    this.htmlElement   = htmlElement;
    this.id            = htmlElement.getAttribute("id");
    this.moveListeners = new Array();
    this.draggable     = true;
    this.htmlOutputs   = {};

    this.image         = null;
    this.other         = other;

    var _self          = this;

    this.destroy = function() {
        //removing events
        this.htmlElement.onmouseover =
        this.htmlElement.onmouseout =
        this.htmlElement.onclick = null;

        //removing connections
        for (var i = this.moveListeners.length-1; i >= 0; i--) {
            this.moveListeners[i].destroy();
            this.moveListeners.removeIndex(i);
        }
        //removing objBlock from canvas
        delete this.canvas.htmlBlocks[this.id];
    }

    this.initBlock = function() {
        this.canvas.htmlBlocks[this.id] = this;

        var tag, dChilds, j, l2,
            bChilds = this.htmlElement.childNodes,
            i       = 0,
            l       = bChilds.length
        for (; i < l; i++) {
            tag = bChilds[i].tagName;
            if (tag && (tag = tag.toLowerCase())) {
                if (tag == "div") {
                   dChilds = bChilds[i].childNodes;

                   for (j = 0, l2 = dChilds.length; j < l2; j++) {
                       if (dChilds[j].tagName && dChilds[j].tagName.toLowerCase() == "img") {
                           this.imageContainer = bChilds[i];
                           this.image = dChilds[j];
                       }
                   }
                }
                else if (tag == "blockquote") {
                    this.caption = bChilds[i];
                }
            }
        }

        if (!this.other.type) {
            apf.setStyleClass(this.htmlElement, "empty");
            this.image.style.display = "none";
        }
        else {
            if (this.other.picture == null) {
                this.image.style.display = "none";
            }
            else {
                this.image.style.display = "block";
                this.image.src = this.other.picture;
                this.image.onload = function() {
                    _self.changeRotation(_self.other.rotation,
                        _self.other.fliph, _self.other.flipv, true);
                }
            }
        }
        /* Set last scale ratio */
        this.other.ratio = this.other.dwidth / this.other.dheight;

        this.changeRotation(_self.other.rotation,
            _self.other.fliph, _self.other.flipv, true);
        this.setCaption(this.other.caption);
        this.setLock(this.other.lock, true)

        this.updateOutputs();
    };

    this.updateOutputs = function() {
        var id, input, pos, _x, _y,
            inp = this.other.inputList;

        for (id in inp) {
            input = this.htmlOutputs[id]
                ? this.htmlOutputs[id]
                : new apf.flow.input(this, id);

            if (!this.htmlOutputs[id])
                this.htmlOutputs[id] = input;
            pos = this.updateInputPos(inp[id]);

            _x = pos[0] - (pos[2] == "left" || pos[2] == "right"
                ? Math.ceil(parseInt(apf.getStyle(input.htmlElement, "width"))/2)
                : Math.ceil(apf.flow.sSize/2));
            _y = pos[1] - (pos[2] == "top" || pos[2] == "bottom"
                ? Math.ceil(parseInt(apf.getStyle(input.htmlElement, "height"))/2)
                : Math.ceil(apf.flow.sSize/2));

            input.lastUpdate = pos;
            input.moveTo(_x, _y);
        }
    };

    this.outputsVisibility = function(visible) {
        var inp = this.htmlOutputs;
        for (var id in inp) {
            var input = inp[id];
            if (visible)
                input.show();
            else
                input.hide();
        }
    };

    /**
     * Immobilise block element on workarea
     *
     * @param {Number}   lock   prohibit block move, default is false
     *     Possible values:
     *     true    block is locked
     *     false   block is unlocked
     */
    this.setLock = function(lock, init) {
        if (this.other.lock !== lock || init) {
            this.draggable = !lock;
            this.other.lock = lock;
            this.outputsVisibility(!lock);

            if (lock)
                apf.setStyleClass(this.htmlElement, "locked");
            else
                apf.setStyleClass(this.htmlElement, "", ["locked"]);
        }
    };

    /**
     * Sets new description which is placed under block element
     *
     * @param {String}   caption   block description
     */
    this.setCaption = function(caption) {
        var c = this.caption;
        if (!c || c.nodeType != 1) return;
        c.innerHTML = caption;
        if (this.other.capPos == "inside") {
            if (c.offsetWidth !== 0 && c.offsetHeight !== 0) {
                c.style.marginLeft =
                    "-" + (Math.ceil(c.offsetWidth / 2)) + "px";
                c.style.marginTop =
                    "-" + (Math.ceil(c.offsetHeight / 2)) + "px";
            }
        }
    };

    /**
     * Moves block to new x, y position
     *
     * @param {Number}   top   vertical coordinate
     * @param {Number}   left   horizontal coordinate
     */
    this.moveTo = function(top, left) {
        var t = parseInt(this.htmlElement.style.top),
            l = parseInt(this.htmlElement.style.left);

        if (t !== top || l !== left) {
            this.htmlElement.style.top  = top + "px";
            this.htmlElement.style.left = left + "px";
            
            //var st = this.canvas.getScrollTop();
            //var sl = this.canvas.getScrollLeft();
            
            if (this.canvas.lastTop < top || top > this.canvas.getHeight() - 100) {
                this.canvas.moveTopScrollPointer(top);
                this.canvas.scrollTop();
            }
            if (this.canvas.lastLeft < left && left > this.canvas.getWidth() - 100) {
                this.canvas.moveLeftScrollPointer(left);
                this.canvas.scrollLeft();
            }
        }
    }

    /**
     * Resize block element
     *
     * @param {Number}   width   new vertical block size
     * @param {Number}   height   new horizontal block size
     */
    this.resize = function(width, height) {
        var w = parseInt(this.htmlElement.style.width),
            h = parseInt(this.htmlElement.style.height);

        if (w !== width || h !== height) {
            this.htmlElement.style.width  = this.imageContainer.style.width
                                    = width  + "px";
            this.htmlElement.style.height = this.imageContainer.style.height
                                    = height + "px";
            this.image.style.height = height + "px";
            this.image.style.width  = width  + "px";
            this.image.style.filter = "";
        }
    }

    /**
     * Set rotation and flip and call to redraw image function.
     *
     * @param {Number}   rotation   the rotation in degrees clockwise, background image is rotated automaticly, Default is 0.
     *     Possible values:
     *     0     0   degrees rotation
     *     90    90  degrees rotation
     *     180   180 degrees rotation
     *     270   270 degrees rotation
     * @param {Boolean}   fliph      whether to mirror the block over the vertical axis, background image is flipped automaticly. Default is false.
     *     Possible values:
     *     true    block element is flipped
     *     false   block element is not flipped
     * @param {Boolean}   flipv      whether to mirror the block over the horizontal axis, background image is flipped automaticly. Default is false.
     *    Possible values:
     *    true    block element is flipped
     *    false   block element is not flipped
     * @param {Boolean}   init
     */
    this.changeRotation = function(rotation, fliph, flipv, init) {
        var o = this.other, prev = [o.rotation, o.fliph, o.flipv];
        if (!o.type)
            return;

        o.rotation = parseInt(rotation) % 360 || 0;
        o.fliph    = String(fliph) == "true" ? true : false;
        o.flipv    = String(flipv) == "true" ? true : false;

        var flip = (o.fliph && !o.flipv
            ? "horizontal"
            : (!o.fliph && o.flipv
                ? "vertical"
                : "none"));

        //if (init || prev[0] != o.rotation  || prev[1] != o.fliph || prev[2] != o.flipv) {
            this.repaintImage(flip, o.rotation, 'rel');
        //}
    };

    /**
     * Function repaints default block's image with new rotation and flip.
     *
     * @param {String}   flip    whether to mirror the image over the vertical or horizontal axis
     *     Possible values:
     *     none         image is not flipped
     *     horizontal   image is flipped horizontal
     *     vertical     image is flipped vertical
     * @param {Number}   angle   degrees angle
     *     Possible values:
     *     0     0   degrees angle
     *     90    90  degrees angle
     *     180   180 degrees angle
     *     270   270 degrees amgle
     * @param {String}   whence
     */
    this.repaintImage = function(flip, angle, whence) {
        var p = this.image;
        if (p.style.display == "none")
            return;
        p.style.display = "block";

        p.angle = !whence
            ? ((p.angle == undefined ? 0 : p.angle) + angle) % 360
            : angle;

        var canvas,
            rotation = Math.PI *(p.angle >= 0 ? p.angle : 360 + p.angle) / 180,
            costheta = Math.cos(rotation),
            sintheta = Math.sin(rotation);

        if (document.all && !window.opera) {
            canvas              = document.createElement('img');
            canvas.src          = p.src;
            canvas.style.height = p.height + "px";
            canvas.style.width  = p.width + "px";

            canvas.style.filter = "progid:DXImageTransform.Microsoft.Matrix(M11="
                                + costheta + ",M12=" + (-sintheta)
                                + ",M21=" + sintheta
                                + ",M22=" + costheta
                                + ",SizingMethod='auto expand')";

            if (flip !== "none") {
                canvas.style.filter += "progid:DXImageTransform.Microsoft.BasicImage("
                                    +(flip == "horizontal"
                                        ? "mirror=1"
                                        : "rotation=2, mirror=1")
                                    +")";
            }
        }
        else {
            canvas = document.createElement('canvas');
            if (!p.oImage) {
                canvas.oImage = new Image();
                canvas.oImage.src = p.src;
            }
            else {
                canvas.oImage = p.oImage;
            }

            canvas.style.width  = canvas.width
                                = Math.abs(costheta * canvas.oImage.width)
                                + Math.abs(sintheta * canvas.oImage.height);
            canvas.style.height = canvas.height
                                = Math.abs(costheta * canvas.oImage.height)
                                + Math.abs(sintheta * canvas.oImage.width);

            var context = canvas.getContext('2d');
            context.save();

            switch (flip) {
                case "vertical":
                    context.translate(0, canvas.oImage.height);
                    context.scale(1, -1);
                    break;
                case "horizontal":
                    context.translate(canvas.oImage.height, 0);
                    context.scale(-1, 1);
                    break;
            }

            if (rotation <= Math.PI / 2)
                context.translate(sintheta * canvas.oImage.height, 0);
            else if (rotation <= Math.PI)
                context.translate(canvas.width, -costheta * canvas.oImage.height);
            else if (rotation <= 1.5 * Math.PI)
                context.translate(-costheta * canvas.oImage.width, canvas.height);
            else
                context.translate(0, -sintheta * canvas.oImage.width);
            context.rotate(rotation);

            try {
                context.drawImage(canvas.oImage, 0, 0, canvas.oImage.width,
                    canvas.oImage.height);
                context.restore();
            }
            catch (e) {}
        }
        canvas.angle = p.angle;
        this.imageContainer.replaceChild(canvas, p);
        this.image = canvas;
    };

    /**
     * When Block change his position notify other elements about that fact
     * (actualy notify only connections, but it's not important what type
     * element have. Notified object must have onMove function).
     */
    this.onMove = function() {
        for (var i = 0, ml = this.moveListeners, l = ml.length; i < l; i++)
            ml[i].onMove();
    };

    /**
     * Calculates the new input position if block is resized, flipped or rotated.
     * Base on default informations about block element from template.
     *
     * @param {Object}   input   object representation of input element
     *     Properties:
     *     {Number}  x          x position in pixels based on Block's dimensions
     *     {Number}  y          y position in pixels based on Block's dimensions
     *     {String}  position   input orientation
     *         Possible values:
     *         top      input is placed on top edge of block
     *         right    input is placed on right edge of block
     *         bottom   input is placed on bottom edge of block
     *         left     input is placed on left edge of block
     * @param {Object}   [dPos]  destination block position
     *     Properties:
     *     dPos[0]   destination block horizontal coordinate
     *     dPos[1]   destination block vertical coordinate
     *     dPos[2]   horizontal size of destination block element
     *     dPos[3]   vertical size of destination block element
     * @return {Object}   new input position
     */
    this.updateInputPos = function(input, dPos) {
        var b         = this.htmlElement,
            o         = this.other,
            w         = parseInt(b.style.width),
            h         = parseInt(b.style.height),
            ior       = input ? input.position : "auto",
            x         = input ? input.x : w / 2,
            y         = input ? input.y : h / 2,
            dw        = o.dwidth,
            dh        = o.dheight,
            fv        = o.flipv,
            fh        = o.fliph,
            r         = o.rotation,
            positions = {0 : "top", 1 : "right", 2 : "bottom", 3 : "left",
                         "top" : 0, "right" : 1, "bottom" : 2, "left" : 3},
            sSize     = apf.flow.sSize,
            hSize     = Math.floor(apf.flow.sSize / 2);

        /* Changing input floating */
        ior = (ior == "auto")
            ? "auto"
            : positions[(positions[ior] + parseInt(r) / 90)%4];

        if (ior !== "auto") {
            if (fv)
                ior = ior == "top" ? "bottom" : (ior == "bottom" ? "top" : ior);
            if (fh)
                ior = ior == "left" ? "right" : (ior == "right" ? "left" : ior);

            /* If block is resized, block keep proportion */
            x = (r == 90 || r == 270) ? x*h / dh : x*w / dw;
            y = (r == 90 || r == 270) ? y*w / dw : y*h / dh;

            /* If rotate, change inputs coordinates */
            var _x = x, _y = y;

            _x = (r == 90) ? w - y - 1 : (r == 180 ? w - x - 1 : (r == 270 ? y : x));
            _y = (r == 90) ? x : (r == 180 ? h - y - 1 : (r == 270 ? h - x - 1 : y));

            /* Flip Vertical and Horizontal */
            _x = fh ? w - _x : _x;
            _y = fv ? h - _y : _y;

            _x = fh ? (ior == "top" || ior == "bottom" ? _x - 1 : _x) : _x
            _y = fv ? (ior == "left" || ior == "right" ? _y - 1 : _y) : _y

            _x = ior == "top" || ior == "bottom"
                ? _x - (sSize/2) + (apf.isIE || apf.isOpera || apf.isChrome ? 1 : 0)
                : _x;
            _y = ior == "left" || ior == "right"
                ? _y - (sSize/2) + (apf.isIE || apf.isOpera || apf.isChrome ? 1 : 0)
                : _y;
        }
        else {
            var st = parseInt(b.style.top),
                sl = parseInt(b.style.left),
                dt = dPos[1], dl = dPos[0];
            dw = dPos[2], dh = dPos[3];

            if (st + h * 1.5 < dt) {
                ior = "bottom";
            }
            else if (st > dt + dh * 1.5) {
                ior = "top";
            }
            else {
                if (sl > dl + dw / 2)
                    ior = "left";
                else if (sl < dl)
                    ior = "right";
                else
                    ior = "left";
            }

            _x = (ior == "top" || ior == "bottom")
                ? w/2 - hSize
                : ior == "right" ? w : 0;
            _y = (ior == "left" || ior == "right")
                ? h/2 - hSize
                : ior == "bottom" ? h : 0;
        }
        return [_x, _y, ior];
    };

    this.htmlElement.onmouseup = function(e) {
        if (!_self.other.type && _self.canvas.mode == "connection-add")
            apf.flow.connectionsManager.addBlock(_self, 0);
    };
};

/**
 * Creates object representation for input elements. Each block can have 
 * unlimited inputs.
 *
 * @param {Object}   objBlock   object representation of block element
 * @param {Number}   number     unique input number for block element
 * @constructor
 */
apf.flow.input = function(objBlock, number) {
    this.objBlock    = objBlock;
    this.htmlElement = objBlock.htmlElement.appendChild(document.createElement("div"));
    this.number      = number;
    this.lastUpdate    = null;

    var _self = this;

    apf.setStyleClass(this.htmlElement, "input");

    /**
     * Hides inpiut
     */
    this.hide = function() {
        this.htmlElement.style.display = "none";
    };
    
    /**
     * Shows input
     */
    this.show = function() {
        this.htmlElement.style.display = "block";
    };

    /**
     * Moves input to new position
     * 
     * @param {Number}   x   new horizontal position
     * @param {Number}   y   new vertical position
     */
    this.moveTo = function(x, y) {
        this.htmlElement.style.left = x + "px";
        this.htmlElement.style.top  = y + "px";
    };

    var connection;
    var vMB;
    this.htmlElement.onmousedown = function(e) {
        e              = (e || event);
        e.cancelBubble = true;
        apf.flow.isMoved = true;

        var canvas     = _self.objBlock.canvas,
            pn         = _self.htmlElement.parentNode,
            mode       = canvas.mode;

        if (e.preventDefault)
            e.preventDefault();

        vMB = new apf.flow.virtualMouseBlock(canvas, e);

        var con = apf.flow.findConnector(_self.objBlock, _self.number);
        if (con) {
            var source = con.source
                    ? con.connector.objDestination
                    : con.connector.objSource,
                destination = con.source
                    ? con.connector.objSource
                    : con.connector.objDestination,
                sourceInput = con.source
                    ? con.connector.other.input
                    : con.connector.other.output,
                destinationInput = con.source
                    ? con.connector.other.output
                    : con.connector.other.input;
            /* Temporary connection must keeping output direction */
            vMB.other.inputList[1].position = destination.updateInputPos(
                destination.other.inputList[destinationInput])[2];

            _self.objBlock.onremoveconnection([con.connector.other.xmlNode]);
            apf.flow.removeConnector(con.connector.htmlElement);

            connection = new apf.flow.addConnector(canvas , source, vMB, {
                output : sourceInput, input : 1
            });
            apf.flow.connectionsManager.addBlock(source, sourceInput);
            canvas.setMode("connection-change");
        }
        else {
            connection = new apf.flow.addConnector(canvas, _self.objBlock, vMB, {
                output : _self.number
            });
            apf.flow.connectionsManager.addBlock(_self.objBlock, _self.number);
            canvas.setMode("connection-add");
        }
        connection.newConnector.virtualSegment = true;
        vMB.onMove(e);

        document.body.onmousemove = function(e) {
            e = (e || event);
            if (vMB)
                vMB.onMove(e);
        };

        document.body.onmouseup = function(e) {
            e = (e || event);
            var t = e.target || e.srcElement;
            document.body.onmousemove = null;
            apf.flow.isMoved = false;

            if (t && canvas.mode == "connection-change") {
                if ((t.className || "").indexOf("input") == -1)
                    apf.flow.connectionsManager.addBlock(destination, destinationInput);
            }
            apf.flow.connectionsManager.clear();

            if (connection)
                apf.flow.removeConnector(connection.newConnector.htmlElement);
            if (vMB) {
                vMB.onMove(e);
                vMB.destroy();
                vMB = null;
                _self.objBlock.canvas.setMode("normal");
            }
        };
    };

    this.htmlElement.onmouseup = function(e) {
        apf.flow.connectionsManager.addBlock(_self.objBlock, _self.number);
    };

    this.htmlElement.onmouseover = function(e) {
        var mode = _self.objBlock.canvas.mode;
        if (mode == "connection-add" || mode == "connection-change") {
            apf.setStyleClass(_self.htmlElement, "inputHover");
        }
    };

    this.htmlElement.onmouseout = function(e) {
        apf.setStyleClass(_self.htmlElement, "", ["inputHover"]);
    };
};

/**
 * Manage informations about clicked blocks and/or inputs. If mode
 * connection-add is active and if two blocks or inputs has clicked, new
 * connection will be created.
 * @constructor
 */
apf.flow.connectionsManager = new (function() {
    this.addBlock = function(objBlock, inputNumber) {
        if (objBlock && (inputNumber || inputNumber == 0)) {
            var s = apf.flow.connectionsTemp;

            if (!s) {
                apf.flow.connectionsTemp = {
                    objBlock    : objBlock,
                    inputNumber : inputNumber
                };
            }
            else {
                if (s.objBlock.id !== objBlock.id || s.inputNumber !== inputNumber) {
                    objBlock.oncreateconnection(s.objBlock.other.xmlNode,
                        s.inputNumber, objBlock.other.xmlNode, inputNumber);
                    objBlock.canvas.setMode("normal");
                }
                this.clear();
            }
        }
    };

    this.clear = function() {
        apf.flow.connectionsTemp = null;
    };
})();

/**
 * Simulate block element to create temporary connection between source
 * block and mouse cursor, until destination block is not clicked.
 *
 * @param {Object}   canvas   object representation of canvas element
 * @constructor
 */
apf.flow.virtualMouseBlock = function(canvas) {
    var hook = [0, 0, "virtual"];
    this.canvas      = canvas;
    this.htmlElement = document.createElement('div');

    this.canvas.htmlElement.appendChild(this.htmlElement);

    this.htmlElement.style.display = "block";
    this.moveListeners             = new Array();
    this.draggable                 = 0;
    this.htmlOutputs               = {};
    this.htmlOutputs[1]            = {
        htmlElement : this.htmlElement.appendChild(document.createElement("div")),
        number      : 1,
        lastUpdate  : hook
    };
    this.other                     = {};
    this.other.inputList           = {};
    this.other.inputList[1]        = {x : hook[0], y : hook[1], position : hook[2]};

    apf.setStyleClass(this.htmlElement, "vMB");

    var sPos = apf.getAbsolutePosition(this.canvas.htmlElement);

    this.onMove = function(e) {
        //@todo apf3.x see why this is twice (2 * this.canvas.getWindowScrollLeft() - for Top either)
        this.htmlElement.style.left = (e.clientX + 2 + this.canvas.getWindowScrollLeft()
            + this.canvas.getScrollLeft() - sPos[0]) + "px";
        this.htmlElement.style.top  = (e.clientY + 2 + this.canvas.getWindowScrollTop()
            + this.canvas.getScrollTop() - sPos[1]) + "px";

        for (var i = 0, l = this.moveListeners.length; i < l; i++)
            this.moveListeners[i].onMove();
    };

    this.destroy = function() {
        this.htmlElement.parentNode.removeChild(this.htmlElement);
    };

    this.updateInputPos = function(input) {
        return hook;
    };
};


/**
 * Creates connection between two block elements. To remove connection is needed
 * select it by mouse and press delete button.
 *
 * @param {HTMLElement}   htmlElement      html representation of connector element
 * @param {Object}        objCanvas        object representation of connector element
 * @param {Object}        objSource        object representation of source block element
 * @param {Object}        objDestination   object representation of destination block element
 * @param {Object}        other            connection properties
 *     Properties:
 *     {Number}     output    source block input number
 *     {Number}     input     destination block input number
 *     {XMLElement} xmlNode   xml representation of connection element
 * @constructor
 */
apf.flow.connector = function(htmlElement, objCanvas, objSource, objDestination, other) {
    /**
     * Connection segments
     */
    this.htmlSegments    = [];
    
    /**
     * Array used when connection is repainting
     */
    var htmlSegmentsTemp = [];
    
    /**
     * Connection label - text defined by user in the middle of connection
     */
    this.htmlLabel       = null;
    
    /**
     * Connector-start object, it could be an arrow
     */
    this.htmlStart       = null;
    
    /**
     * Connector-end object, it could be an arrow
     */
    this.htmlEnd         = null;

    /**
     * Object of source block
     */
    this.objSource       = objSource;
    
    /**
     * Object of destination block
     */
    this.objDestination  = objDestination;
    this.other           = other;

    this.selected        = false;

    this.htmlElement     = htmlElement;
    this.virtualSegment  = null;

    var sSize            = apf.flow.sSize, //Segment size
        fsSize           = apf.flow.fsSize, //First segment size
        hSize            = Math.floor(sSize / 2),

        sourceHtml       = this.objSource.htmlElement,
        destinationHtml  = this.objDestination.htmlElement,

        _self = this;

    this.initConnector = function() {
        if (!htmlElement.getAttribute("id"))
            apf.setUniqueHtmlId(htmlElement);
        objCanvas.htmlConnectors[htmlElement.getAttribute("id")] = this;

        this.objSource.moveListeners.push(this);
        this.objDestination.moveListeners.push(this);
        this.activateInputs();
        this.onMove();
    };

    this.activateInputs = function() {
        this.i1 = other.output && this.objSource.other.inputList[other.output]
            ? this.objSource.other.inputList[other.output]
            : {x : 0, y : 0, position : "auto"};

        this.i2 = other.input && this.objDestination.other.inputList[other.input]
            ? this.objDestination.other.inputList[other.input]
            : {x : 0, y : 0, position : "auto"};
    };

    this.destroy = function() {
        this.deselectInputs("Selected");
        var sl = this.objSource.moveListeners,
            i  = 0,
            l  = sl.length;
        for (; i < l; i++) {
            if (sl[i] == this)
                this.objSource.moveListeners.removeIndex(i);
        }

        var dl = this.objDestination.moveListeners;
        for (i = 0, l = dl.length; i < l; i++) {
            if (dl[i] == this)
                this.objDestination.moveListeners.removeIndex(i);
        }
        objCanvas.removeConnector(this.htmlElement.getAttribute("id"));
    };

    this.onMove = function() {
        this.draw();
        if (this.selected) {
            this.deselectInputs("Hover");
            this.deselect("selected");
            this.deselectInputs("Selected");
            this.selected = false;
        }
    };

    this.draw = function() {
        var sIPos, dIPos,
            l = [],
            s = [parseInt(sourceHtml.style.left),
                 parseInt(sourceHtml.style.top)],
            d = [parseInt(destinationHtml.style.left),
                 parseInt(destinationHtml.style.top)];

        htmlSegmentsTemp = this.htmlSegments;
        /*for (var i = 0, l = this.htmlSegments.length; i < l; i++) {
            htmlSegmentsTemp.push(this.htmlSegments[i]);
        }*/
        this.htmlSegments = [];

        if (this.i1.position == "auto" || this.i2.position == "auto") {
            sIPos = this.objSource.updateInputPos(this.i1, d);
            dIPos = this.objDestination.updateInputPos(this.i2, s);
        }
        else {
            sIPos = this.objSource.htmlOutputs[other.output].lastUpdate;
            dIPos = this.objDestination.htmlOutputs[other.input].lastUpdate;
        }

        var sO = sIPos[2];
        var dO = dIPos[2];

        s[0] += sIPos[0];
        s[1] += sIPos[1];

        d[0] += dIPos[0];
        d[1] += dIPos[1];

        if (sO !== "virtual")
            s = this.createSegment(s, [fsSize, sO], true);

        if (dO !== "virtual")
            d = this.createSegment(d, [fsSize, dO], true);

        l = s;
        var position = s[0] > d[0]
                 ? (s[1] > d[1] ? "TL" : (s[1] < d[1] ? "BL" : "ML"))
                 : (s[0] < d[0]
                     ? (s[1] > d[1] ? "TR" : (s[1] < d[1] ? "BR" : "MR"))
                     : (s[1] > d[1] ? "TM" : (s[1] < d[1] ? "MM" : "BM"))),

            condition = position
                      + (sO == "left" ? 1 : (sO == "right" ? 2 : sO == "top" ? 4 : 8))
                      + (dO == "left" ? 1 : (dO == "right" ? 2 : dO == "top" ? 4 : 8));
    //rot.setValue(condition)

        switch (condition) {
            case "TR41":
                l = this.createSegment(l, [apf.isGecko 
                    ? s[1] - d[1]
                    : Math.ceil(s[1] - d[1]), "top"]);
                l = this.createSegment(l, [apf.isGecko 
                    ? d[0] - s[0]
                    : Math.ceil(d[0] - s[0]), "right"]);
                break;
            case "TR44":
            case "TR14":
            case "TR11":
                l = this.createSegment(l, [apf.isGecko 
                    ? s[1] - d[1]
                    : Math.ceil(s[1] - d[1]), "top"]);
                l = this.createSegment(l, [apf.isGecko 
                    ? d[0] - s[0]
                    : Math.floor(d[0] - s[0]), "right"]);
                break;
            case "BR22":
            case "BR24":
            case "BR42":
            case "BR44":
                l = this.createSegment(l, [apf.isGecko 
                    ? d[0] - s[0]
                    : Math.floor(d[0] - s[0]), "right"]);
                l = this.createSegment(l, [Math.ceil(Math.abs(d[1] - s[1])), "bottom"]);
                break;
            case "BR41":
                l = this.createSegment(l, [apf.isGecko 
                    ? (d[0] - s[0]) / 2
                    : (d[0] - s[0]) / 2, "right"]);
                l = this.createSegment(l, [d[1] - s[1], "bottom"]);
                l = this.createSegment(l, [apf.isGecko 
                    ? (d[0] - s[0]) / 2
                    : Math.ceil((d[0] - s[0]) / 2), "right"]);
                break;
            case "BR48":
            case "BR28":
                l = this.createSegment(l, [apf.isGecko
                    ? (d[0] - s[0]) / 2
                    : (d[0] - s[0]) / 2, "right"]);
                l = this.createSegment(l, [apf.isGecko
                    ? d[1] - s[1] : Math.ceil(d[1] - s[1]), "bottom"]);
                l = this.createSegment(l, [apf.isGecko
                    ? (d[0] - s[0]) / 2
                    : (d[0] - s[0]) / 2, "right"]);
                break;
            case "BR21":
                l = this.createSegment(l, [apf.isGecko
                    ? (d[0] - s[0]) / 2
                    : (d[0] - s[0]) / 2, "right"]);
                l = this.createSegment(l, [apf.isGecko
                    ? d[1] - s[1]
                    : Math.ceil(d[1] - s[1]), "bottom"]);
                l = this.createSegment(l, [parseInt((d[0] - s[0]) / 2)+1, "right"]);
                break;
            case "TL44":
            case "TL42":
            case "TL24":
            case "TL22":
                l = this.createSegment(l, [apf.isGecko
                    ? s[1] - d[1]
                    : Math.ceil(s[1] - d[1]), "top"]);
                l = this.createSegment(l, [apf.isGecko
                    ? s[0] - d[0]
                    : Math.ceil(s[0] - d[0]), "left"]);
                break;
            case "TR21":
            case "TR24":
            case "TR81":
            case "TR84":
            case "TR21":
            case "TR24":
            case "TR81":
            case "TR84":
                l = this.createSegment(l, [apf.isGecko
                    ? (d[0] - s[0]) / 2
                    : (d[0] - s[0]) / 2, "right"]);
                l = this.createSegment(l, [apf.isGecko
                    ? s[1] - d[1]
                    : Math.ceil(s[1] - d[1]), "top"]);
                l = this.createSegment(l, [apf.isGecko
                    ? (d[0] - s[0]) / 2
                    : (d[0] - s[0]) / 2, "right"]);
                break;
            case "BR18":
            case "BR88":
            case "BR81":
            case "BR11":
                l = this.createSegment(l, [d[1] - s[1], "bottom"]);
                l = this.createSegment(l, [apf.isGecko
                    ? d[0] - s[0]
                    : Math.ceil(d[0] - s[0]), "right"]);
                break;
            case "BR14":
                l = this.createSegment(l, [apf.isGecko
                    ? (d[1] - s[1]) / 2
                    : Math.ceil((d[1] - s[1]) / 2) , "bottom"]);
                l = this.createSegment(l, [apf.isGecko
                    ? d[0] - s[0]
                    : Math.floor(d[0] - s[0]), "right"]);
                l = this.createSegment(l, [Math.ceil((d[1] - s[1]) / 2), "bottom"]);
                break;
            case "BR84":
            case "BR82":
            case "BR12":
                l = this.createSegment(l, [apf.isGecko
                    ? (d[1] - s[1]) / 2
                    : Math.ceil((d[1] - s[1]) / 2) , "bottom"]);
                l = this.createSegment(l, [apf.isGecko
                    ? d[0] - s[0]
                    : Math.floor(d[0] - s[0]), "right"]);
                l = this.createSegment(l, [(d[1] - s[1]) / 2, "bottom"]);
                break;
            case "BL84":
            case "BL24":
            case "BL21":
                l = this.createSegment(l, [apf.isGecko
                    ? (d[1] - s[1]) / 2
                    : Math.ceil((d[1] - s[1]) / 2), "bottom"]);
                l = this.createSegment(l, [apf.isGecko
                    ? s[0] - d[0]
                    : Math.ceil(s[0] - d[0]), "left"]);
                l = this.createSegment(l, [apf.isGecko
                    ? (d[1] - s[1]) / 2
                    : Math.ceil((d[1] - s[1]) / 2), "bottom"]);
                break;
            case "BL11":
            case "BL14":
            case "BL41":
            case "BL44":
            case "BL81":
                l = this.createSegment(l, [apf.isGecko
                    ? s[0] - d[0]
                    : Math.ceil(s[0] - d[0]), "left"]);
                l = this.createSegment(l, [apf.isGecko
                    ? d[1] - s[1]
                    : Math.ceil(d[1] - s[1]), "bottom"]);
                break;
            case "BL12":
            case "BL18":
            case "BL42":
            case "BL48":
                l = this.createSegment(l, [apf.isGecko
                    ? (s[0] - d[0]) / 2
                    : (s[0] - d[0]) / 2, "left"]);
                l = this.createSegment(l, [apf.isGecko
                    ? d[1] - s[1]
                    : Math.ceil(d[1] - s[1]), "bottom"]);
                l = this.createSegment(l, [apf.isGecko
                    ? (s[0] - d[0]) / 2
                    : (s[0] - d[0]) / 2, "left"]);
                break;
            case "BL88":
            case "BL82":
            case "BL28":
            case "BL22":
                l = this.createSegment(l, [apf.isGecko
                    ? d[1] - s[1]
                    : Math.ceil(d[1] - s[1]), "bottom"]);
                l = this.createSegment(l, [apf.isGecko
                    ? s[0] - d[0]
                    : Math.ceil(s[0] - d[0]), "left"]);
                break;
            case "TL88":
            case "TL81":
            case "TL18":
            case "TL11":
                l = this.createSegment(l, [apf.isGecko
                    ? s[0] - d[0]
                    : Math.ceil(s[0] - d[0]), "left"]);
                l = this.createSegment(l, [apf.isGecko
                    ? s[1] - d[1]
                    : Math.ceil(s[1] - d[1]), "top"]);
                break;
            case "TL41":
                l = this.createSegment(l, [apf.isGecko
                    ? (s[1] - d[1]) / 2
                    : Math.floor((s[1] - d[1]) / 2), "top"]);
                l = this.createSegment(l, [apf.isGecko
                    ? s[0] - d[0] : Math.ceil(s[0] - d[0]), "left"]);
                l = this.createSegment(l, [apf.isGecko
                    ? (s[1] - d[1]) / 2
                    : Math.ceil((s[1] - d[1]) / 2), "top"]);
                break;
            case "TL48":
            case "TL28":
            case "TL21":
                l = this.createSegment(l, [apf.isGecko
                    ? (s[1] - d[1]) / 2
                    : Math.floor((s[1] - d[1]) / 2), "top"]);
                l = this.createSegment(l, [apf.isGecko
                    ? s[0] - d[0] : Math.ceil(s[0] - d[0]), "left"]);
                l = this.createSegment(l, [apf.isGecko
                    ? (s[1] - d[1]) / 2
                    : Math.floor((s[1] - d[1]) / 2), "top"]);
                break;
            case "TL12":
            case "TL14":
            case "TL82":
            case "TL84":
                l = this.createSegment(l, [apf.isGecko
                    ? (s[0] - d[0]) / 2
                    : (s[0] - d[0]) / 2, "left"]);
                l = this.createSegment(l, [apf.isGecko
                    ? s[1] - d[1]
                    : Math.ceil(s[1] - d[1]), "top"]);
                l = this.createSegment(l, [apf.isGecko
                    ? (s[0] - d[0]) / 2
                    : (s[0] - d[0]) / 2, "left"]);
                break;
            case "TR12":
            case "TR18":
            case "TR42":
            case "TR48":
                l = this.createSegment(l, [apf.isGecko
                    ? (s[1] - d[1]) / 2
                    : Math.floor((s[1] - d[1]) / 2), "top"]);
                l = this.createSegment(l, [apf.isGecko
                    ? d[0] - s[0]
                    : Math.floor(d[0] - s[0]), "right"]);
                l = this.createSegment(l, [apf.isGecko
                    ? (s[1] - d[1]) / 2
                    : Math.floor((s[1] - d[1]) / 2), "top"]);
                break;
            case "TR22":
            case "TR28":
            case "TR82":
            case "TR88":
                l = this.createSegment(l, [apf.isGecko
                    ? d[0] - s[0]
                    : Math.floor(d[0] - s[0]), "right"]);
                l = this.createSegment(l, [apf.isGecko
                    ? s[1] - d[1]
                    : Math.ceil(s[1] - d[1]), "top"]);
                break;
            default:
                switch (position) {
                    case "ML":
                        l = this.createSegment(l, [apf.isGecko
                            ? s[0] - d[0]
                            : Math.ceil(s[0] - d[0]), "left"]);
                        break;
                    case "MM":
                        l = this.createSegment(l, [apf.isGecko
                            ? s[0] - d[0]
                            : Math.ceil(s[0] - d[0]), "left"]);
                        l = this.createSegment(l, [apf.isGecko
                            ? d[1] - s[1]
                            : Math.ceil(d[1] - s[1]), "bottom"]);
                        break;
                    case "TM":
                        l = this.createSegment(l, [apf.isGecko
                            ? s[1] - d[1]
                            : Math.ceil(s[1] - d[1]), "top"]);
                        l = this.createSegment(l, [apf.isGecko
                            ? s[0] - d[0]
                            : Math.ceil(s[0] - d[0]), "left"]);
                        break;
                    case "MR":
                        // This part is not checked, MR41 needs only "right"
                        // line, else need them both
                        l = this.createSegment(l, [apf.isGecko
                            ? d[0] - s[0]
                            : Math.floor(d[0] - s[0]), "right"]);
                        if (condition.substring(2,4) == "41")
                            break;
                        l = this.createSegment(l, [Math.abs(d[1] - s[1]),
                                               "bottom"]);
                        break;
                }
                break;
        }

        for (var i = htmlSegmentsTemp.length - 1; i >= 0; i--)
            htmlSegmentsTemp[i][0].style.display = "none";

        if (this.other.label)
           this.htmlLabel = apf.flow.label(this);

        if (this.other.type) {
            var _type = this.other.type.split("-");

            if (_type[0] !== "none")
                this.htmlStart = apf.flow.connectorsEnds(this, "start", _type[0]);
            if (_type[1] !== "none")
                this.htmlEnd = apf.flow.connectorsEnds(this, "end", _type[1]);
        }
    };

    this.createSegment = function(coor, lines, startSeg) {
        var or      = lines[1],
            l       = lines[0],
            sX      = coor[0] || 0,
            sY      = coor[1] || 0,
            _temp   = htmlSegmentsTemp.shift(),
            _self   = this,
            segment = _temp ? _temp[0] : null,
            plane   = (or == "top" || or == "bottom") ? "ver" : "hor";

        if (!segment) {
            segment = htmlElement.appendChild(document.createElement("div"));

            apf.setUniqueHtmlId(segment);
            apf.setStyleClass(segment, "segment");

            if (_self.selected)
                _self.select("selected");

            var canvas = this.objSource.canvas;
            /* Segment events */
            segment.onmouseover = function(e) {
                if (!apf.flow.isMoved && ((canvas.mode == "connection-change"
                  && _self.selected) || canvas.mode == "connection-add")) {
                    _self.select("hover");
                }
            };

            segment.onmouseout = function(e) {
                _self.deselect("hover");
            };

            segment.onmousedown = function(e) {
                e = e || event;
                e.cancelBubble = true;
                _self.deselect("selected");
                _self.select("clicked");
            };

            segment.onmouseup = function(e) {
                e = (e || event);
                e.cancelBubble = true;
                var ctrlKey  = e.ctrlKey,
                    temp     = _self.selected;

                if (!ctrlKey)
                    _self.objSource.canvas.deselectConnections();

                _self.selected = temp ? false : _self.selected ? false : true;

                if (_self.selected) {
                    _self.selectInputs("Selected");
                    _self.deselect("clicked");
                    _self.select("selected");
                    canvas.setMode("connection-change");
                }
                else {
                    _self.deselectInputs("Selected");
                    _self.deselect("clicked");
                    _self.deselect("selected");
                    canvas.setMode("normal");
                }
            };
        }

        segment.plane = plane;

        var w = plane == "ver" ? sSize : l,
            h = plane == "ver" ? l : sSize,
            className = "segment "+"seg_" + plane;

        if (_self.virtualSegment)
            className += " seg_"+plane+"_virtual";

        segment.className = className;

        if (or == "top")
            sY -= l;
        if (or == "left")
            sX -=l;

        segment.style.display = "block";
        segment.style.left    = sX
            + (plane == "hor" && !startSeg || (or =="left" && startSeg) ? 3 : 0)
            + "px";
        segment.style.top     = sY + (plane == "ver" ? 3 : 0) + "px";
        segment.style.width   = w + (or =="left" && startSeg ? -3 : (or == "right" && startSeg ? 3 : 0)) + "px";
        segment.style.height  = h + "px";

        /* Define the connection end point */
        if (or == "bottom")
            sY += h;
        if (or == "right")
            sX += w;

        this.htmlSegments.push([segment, or]);

        return [sX, sY];
    };

    this.deselect = function(type) {
        var segments = this.htmlElement.childNodes,
            i        = 0,
            l        = segments.length;

        for (; i < l; i++) {
            if ((segments[i].className || "").indexOf("segment") != -1) {
                apf.setStyleClass(segments[i], "",
                    ["seg_" + segments[i].plane + "_" + type]);
            }
        }
        if (!this.selected)
            this.deselectInputs("Selected");

        if (this.htmlLabel && type == "selected")
            this.htmlLabel.className = "label";
    };

    this.select = function(type) {
        var segments = this.htmlElement.childNodes,
            i        = 0,
            l        = segments.length;

        for (; i < l; i++) {
            if ((segments[i].className || "").indexOf("segment") != -1) {
                apf.setStyleClass(segments[i],
                    "seg_" + segments[i].plane + "_" + type);
            }
        }
        this.selectInputs();
        if (this.htmlLabel && type == "selected")
            this.htmlLabel.className = "label labelSelected";
    };

    this.selectInputs = function(type) {
        if (this.other.output && this.objSource.htmlOutputs[other.output]) {
            var output = this.objSource.htmlOutputs[other.output].htmlElement;
            apf.setStyleClass(output, "input" + type);
        }
        if (this.other.input && this.objDestination.htmlOutputs[other.input]) {
            var input = this.objDestination.htmlOutputs[other.input].htmlElement;
            apf.setStyleClass(input, "input" + type);
        }
    };

    this.deselectInputs = function(type) {
        if (this.other.output && this.objSource.htmlOutputs[this.other.output]) {
            var output = this.objSource.htmlOutputs[this.other.output].htmlElement;
            apf.setStyleClass(output, "", ["input" + type]);
        }
        if (this.other.input && this.objDestination.htmlOutputs[this.other.input]) {
            var input = this.objDestination.htmlOutputs[this.other.input].htmlElement;
            apf.setStyleClass(input, "", ["input" + type]);
        }
    };
};

apf.flow.connectorsEnds = function(connector, place, type) {
    var conEnd  = (place == "start") ? connector.htmlStart : connector.htmlEnd,
        segment = connector.htmlSegments[place == "start" ? 0 : 1],

        l       = parseInt(segment[0].style.left),
        t       = parseInt(segment[0].style.top),

        htmlElement = conEnd ? conEnd : connector.htmlElement.appendChild(document.createElement("div"));

    t += (segment[1] == "top")  ? parseInt(segment[0].style.height) - 14 : 0;
    l += (segment[1] == "left") 
        ? parseInt(segment[0].style.width) - 11
        : (segment[1] == "right" ? 3 : 0);

    htmlElement.style.left = l + "px";
    htmlElement.style.top  = t + "px";
    htmlElement.className  = "connector-end " + type + " or"+segment[1];

    return htmlElement;
};

apf.flow.label = function(connector, number) {
    number = number || Math.ceil(connector.htmlSegments.length / 2);
    var htmlElement,
        segment = connector.htmlSegments[number],
        l       = parseInt(segment[0].style.left),
        t       = parseInt(segment[0].style.top);

    if (connector.htmlLabel) {
        htmlElement = connector.htmlLabel;
    }
    else {
        htmlElement = connector.htmlElement.appendChild(document.createElement("span"));
        apf.setStyleClass(htmlElement, "label");
    }

    l += segment[1] == "top" || segment[1] == "bottom"
        ? segment[0].offsetWidth + 3
        : (segment[0].offsetWidth - htmlElement.offsetWidth) / 2;
    t += segment[1] == "top" || segment[1] == "bottom"
        ? (segment[0].offsetHeight - htmlElement.offsetHeight) / 2
        : segment[0].offsetHeight - 2;

    htmlElement.style.left = l + "px";
    htmlElement.style.top  = t + "px";
    htmlElement.innerHTML  = connector.other.label;

    return htmlElement;
}

/*
 * Utility functions
 */

/**
 * Looking for object representation of block element with given id.
 *
 * @param {String}   blockId   html representation of block element id
 * @return {Object}   object representation of block element
 */
apf.flow.findBlock = function(blockId) {
    var c = apf.flow.objCanvases;

    for (var id in c) {
        if (c[id].htmlBlocks[blockId]) {
            return c[id].htmlBlocks[blockId];
        }
    }
};

/**
 * Looking for object representation of block element with given HTMLElement.
 *
 * @param {HTMLElement}   htmlNode   html representation of block element
 * @return {Object}   object representation of block element
 */
apf.flow.isBlock = function(htmlNode) {
    if(!htmlNode)
        return;
    
    var id, block,
        c = apf.flow.objCanvases;

    for (id in c) {
        block = c[id].htmlBlocks[htmlNode.getAttribute("id")];
        if (block)
            return block;
    }
};

/**
 * Looking for object representation of canvas element with given HTMLElement.
 *
 * @param {HTMLElement}   htmlNode   html representation of canvas element
 * @return {Object}   object representation of canvas element
 */
apf.flow.isCanvas = function(htmlNode) {
    if (htmlNode)
        return apf.flow.objCanvases[htmlNode.id];
};

/**
 * Looking for object representation of connector element with given object
 * representation of source and destination block element and with source and
 * destination input number.
 *
 * @param {Object}   objBlock    object representation of block element
 * @param {Number}   iNumber     block bnput number
 * @param {Object}   objBlock2   object representation of block element
 * @param {Number}   iNumber2    block input number
 *
 * @return {Object}   object representation of connector element and source description
 *     Properties:
 *     {Object}  connector   object representation of connector element
 *     {Boolean} source      infortmation about which block is a source block
 *         Possible values:
 *         true    when objBlock is a source block
 *         false   when objBlock isn't a source block
 */
apf.flow.findConnector = function(objBlock, iNumber, objBlock2, iNumber2) {
    var id, id2, cobjS, cobjD, co, ci, connectors,
        c = apf.flow.objCanvases;

    for (id in c) {
        connectors = c[id].htmlConnectors;
        for (id2 in connectors) {
            if (connectors[id2]) {
                cobjS = connectors[id2].objSource,
                cobjD = connectors[id2].objDestination,
                co    = connectors[id2].other.output,
                ci    = connectors[id2].other.input;

                if (objBlock2 && iNumber2) {
                    if (cobjS.id == objBlock.id && co == iNumber
                      && cobjD.id == objBlock2.id && ci == iNumber2) {
                        return {connector : connectors[id2], source : true};
                    }
                    else if (cobjD.id == objBlock.id && ci == iNumber
                      && cobjS.id == objBlock2.id && co == iNumber2) {
                        return {connector : connectors[id2], source : false};
                    }
                }
                else {
                    if (cobjS == objBlock && co == iNumber)
                        return {connector : connectors[id2], source : true};
                    else if (cobjD == objBlock && ci == iNumber)
                        return {connector : connectors[id2], source : false};
                }
            }
        }
    }
};

/**
 * Looking for object representation of connector element with given HTMLElement.
 *
 * @param {HTMLElement}   htmlNode   html representation of connector element
 * @return {Object}   object representation of connector element
 */
apf.flow.isConnector = function(htmlNode) {
    var c = apf.flow.objCanvases;
    for (var id in c) {
        if (c[id].htmlConnectors[htmlNode.id])
            return c[id].htmlConnectors[htmlNode.id];
    }
};

/**
 * Creates object representation of canvas element
 *
 * @param {HTMLElement}   htmlNode   html representation of canvas element
 * @return {Object}    newCanvas     object representation of canvas element
 */
apf.flow.getCanvas = function(htmlNode) {
    var newCanvas = apf.flow.isCanvas(htmlNode);

    if (!newCanvas) {
        newCanvas = new apf.flow.canvas(htmlNode);
        newCanvas.initCanvas();
    }
    return newCanvas;
};

/**
 * Removes html representation of canvas element with his all elements.
 *
 * @param {HTMLElement}   htmlNode   html representation of canvas element
 *
 */
apf.flow.removeCanvas = function(htmlNode) {
    var canvas = apf.flow.isCanvas(htmlNode);
    canvas.destroy();
};

/**
 * Creates object representation of block
 *
 * @param {HTMLElement}   htmlElement   html representation of block element
 * @param {Object}        objCanvas     object representation of Canvas element
 * @param {Object}        other         block properties
 *    Properties:
 *    {Boolean}   lock   prohibit block move. Default is false.
 *        Possible values:
 *        false   block element is unlocled
 *        true    block element is locked
 *    {Boolean}   flipv   whether to mirror the block over the vertical axis,
 *                        background image is flipped automaticly. Default is false.
 *        Possible values:
 *        true    block element is flipped
 *        false   block element is not flipped
 *    {Boolean}   fliph   whether to mirror the block over the horizontal axis,
 *                        background image is flipped automaticly. Default is false.
 *        Possible values:
 *        true    block element is flipped
 *        false   block element is not flipped
 *    {Number}    rotation   the rotation in degrees clockwise, background image
 *                           is rotated automaticly, Default is 0.
 *        Possible values:
 *        0     0   degrees rotation
 *        90    90  degrees rotation
 *        180   180 degrees rotation
 *        270   270 degrees rotation
 *    {Object}   inputList   Block's inputs list, block could haven't any inputs
 *        Properties:
 *        {Number}  x          position in pixels relative to Block's horizontal
 *                             dimension
 *        {Number}  y          position in pixels relative to Block's vertical
 *                             dimension
 *        {String}  position   edge where input is placed
 *            Possible values:
 *            top      input is placed on top edge of block
 *            right    input is placed on right edge of block
 *            bottom   input is placed on bottom edge of block
 *            left     input is placed on left edge of block
 *    {String}       type         name of block with special abilities, which
 *                                could set in template file
 *    {String}       picture      Path to image file.
 *    {Number}       dwidth       the minimal horizontal size of Block element
 *    {Number}       dheight      the minimal vertical size of Block element
 *    {Boolean}      scalex       Allows only horizontal resizing
 *    {Boolean}      scaley       Allows only vertical resizing
 *    {Boolean}      scaleratio   Vertical or horiznotal resizing only is not
 *                                allowed. It's possible to resizing in two
 *                                dimensions plane at the same time.
 *    {XMLElement}   xmlNode      xml representation of block from model
 *    {String}       caption      description placed under block element
 * @return {Object}   object representation of block element
 */
apf.flow.addBlock = function(htmlElement, objCanvas, other) {
    if (htmlElement && !apf.flow.isBlock(htmlElement)) {
        if (!htmlElement.getAttribute("id")) {
            apf.setUniqueHtmlId(htmlElement);
        }
        var newBlock = new apf.flow.block(htmlElement, objCanvas, other);
        newBlock.initBlock();
        return newBlock;
    }
};

/**
 * Removes html representation of block element with his all connections elements.
 *
 * @param {HTMLElement}   htmlElement   html representation of block element
 *
 */
apf.flow.removeBlock = function(htmlElement) {
    var block = apf.flow.isBlock(htmlElement);
    block.destroy();
};

/**
 * Creates html representation of connector element between two blocks
 *
 * @param {Object}   c   object representation of canvas element
 * @param {Object}   s   object representation of source block element
 * @param {Object}   d   object representation of destination block element
 * @param {Object}   o   connector properties
 *     Properties:
 *     {Number}     output    source block input number
 *     {Number}     input     destination block input number
 *     {XMLElement} xmlNode   xml representation of connection element
 */
apf.flow.addConnector = function(c, s, d, o) {
    var htmlElement = c.htmlElement.appendChild(document.createElement("div"));

    this.newConnector = new apf.flow.connector(htmlElement, c, s, d, o);
    this.newConnector.initConnector();
};

/**
 * Removes html representation of connector element from canvas.
 *
 * @param {HTMLElement}   htmlElement   html representation of connector element
 */
apf.flow.removeConnector = function(htmlElement) {
    var connector = apf.flow.isConnector(htmlElement);
    if (connector) {
        connector.destroy();
    }
    delete connector;
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/layout.js)SIZE(74820)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Takes care of the spatial order of elements within the display area
 * of the browser. Layouts can be saved to xml and loaded again. Window
 * elements are dockable, which means the user can change the layout as he/she
 * wishes. The state of the layout can be saved as xml at any time.
 *
 * Example:
 * This example shows 5 windows which have a layout defined in layout.xml.
 * <code>
 *  <a:appsettings layout="[mdlLayouts::layout[1]]" />
 *  <a:model id="mdlLayouts" src="layout.xml" />
 *  
 *  <a:window title="Main Window" id="b1" />
 *  <a:window title="Tree Window" id="b2" />
 *  <a:window title="Window of Oppertunity" id="b3" />
 *  <a:window title="Small window" id="b4" />
 *  <a:window title="Some Window" id="b5" />
 * </code>
 *
 * This is the layout file containing two layouts (layout.xml).
 * <code>
 *  <layouts>
 *      <layout name="Layout 1" margin="2,2,2,2">
 *          <vbox edge="splitter">
 *              <node name="b1" edge="2"/>
 *              <hbox edge="2">
 *                  <vbox weight="1">
 *                      <node name="b2"/>
 *                      <node name="b3"/>
 *                  </vbox>
 *                  <node name="b4" weight="1" />
 *              </hbox>
 *              <node name="b5" height="20" />
 *          </vbox>
 *      </layout>
 *
 *      <layout name="Layout 2">
 *          <vbox edge="splitter">
 *              <node name="b1" edge="2" />
 *              <node name="b2" height="100" />
 *              <hbox edge="2">
 *                  <node name="b3" width="20%" />
 *                  <node name="b4" width="100" />
 *              </hbox>
 *              <node name="b5" height="20" />
 *          </vbox>
 *      </layout>
 *  </layouts>
 * </code>
 *
 * By binding on the layout.xml you can easily create a layout manager.
 * <code>
 *  <a:list id="lstLayouts"
 *    model          = "mdlLayouts"
 *    allowdeselect  = "false"
 *    onafterselect  = "
 *      if(!this.selected || apf.layout.isLoadedXml(this.selected))
 *          return;
 *     
 *      apf.layout.saveXml();
 *      apf.layout.loadXml(this.selected);
 *    "
 *    onbeforeremove = "return confirm('Do you want to delete this layout?')">
 *      <a:bindings>
 *          <a:caption match="[@name]" />
 *          <a:icon value="layout.png" />
 *          <a:each match="[layout]" />
 *      </a:bindings>
 *      <a:actions>
 *          <a:rename match="[.]" />
 *          <a:remove match="[.]" />
 *      </a:actions>
 *  </a:list>
 *  <a:button
 *    onclick = "
 *      if (!lstLayouts.selected)
 *          return;
 *     
 *      var newLayout = apf.layout.getXml(document.body);
 *      newLayout.setAttribute('name', 'New');
 *      apf.xmldb.appendChild(lstLayouts.selected.parentNode, newLayout);
 *      lstLayouts.select(newLayout, null, null, null, null, true);
 *      apf.layout.loadXml(newLayout);
 *      lstLayouts.startRename();
 *    ">
 *    Add Layout
 *  </a:button>
 * </code>
 *
 * @default_private
 * @todo a __WITH_DOM_REPARENTING should be added which can remove many of the functions of this element.
 */
apf.layout = {
    
    layouts : {},

    addParent : function(oHtml, pMargin){
        var id;
        if (!(id = oHtml.getAttribute("id")))
            id = apf.setUniqueHtmlId(oHtml);

        return this.layouts[id] = {
            layout   : new apf.layoutParser(oHtml, pMargin),
            controls : []
        };
    },

    

    
    splitters     : {},
    freesplitters : [],
    vars          : {},

    getSplitter : function(layout){
        if (!this.splitters[this.getHtmlId(layout.parentNode)])
            this.splitters[this.getHtmlId(layout.parentNode)] = [];

        if (this.freesplitters.length){
            var splitter = this.freesplitters.pop();
        }
        else {
            var splitter = new apf.splitter();//this.parentNode
            var o = apf.findHost(layout.parentNode) || apf.document.documentElement;
            splitter.parentNode = o;
            splitter.skinset = apf.getInheritedAttribute(o, "skinset"); //@todo use skinset here. Has to be set in presentation
            splitter.dispatchEvent("DOMNodeInsertedIntoDocument");//{relatedParent : nodes[j].parentNode}
        }

        this.splitters[this.getHtmlId(layout.parentNode)].push(splitter);

        return splitter;
    },

    clearSplitters : function(layout){
        var ar = this.splitters[this.getHtmlId(layout.parentNode)];
        if (!ar) return;

        for (var i = 0; i < ar.length; i++) {
            this.freesplitters.push(ar[i]);
            if (!ar[i].$ext.parentNode) continue;

            ar[i].$ext.parentNode.removeChild(ar[i].$ext);
        }
        ar.length = 0;
    },
    

    

    get : function(oHtml, pMargin){
        var layout = this.layouts[oHtml.getAttribute("id")];
        if (!layout)
            layout = this.addParent(oHtml, pMargin);
        return layout;
    },

    /**
     * Determines whether an xmlNode is of the layout that's currently loaded
     * @param {XMLElement} xmlNode the xml layout description node.
     */
    isLoadedXml : function(xmlNode){
        var nodes   = xmlNode.childNodes;
        var node    = xmlNode.selectSingleNode(".//node[@name]");//was node()
        var amlNode = node ? self[node.getAttribute("name")] : null;

        
        if (!amlNode) {
            throw new Error(apf.formatErrorString(0, null,
                "Loading Alignment from XML",
                "Could not find AML node" + (node ? " by name '"
                + node.getAttribute("name") + "'" : ""), xmlNode));
        }
        

        var pNode = amlNode.$ext.parentNode;
        var pId   = this.getHtmlId(pNode);

        return (this.loadedXml[pId] == xmlNode);
    },

    /**
     * Loads a layout using a data instruction.
     * Example:
     * <code>
     *  apf.layout.$loadFrom(%[mdlLayout::layout[1]]);
     * </code>
     * Remarks:
     * The aml elements referenced in the layout definition should exist when
     * this function is called.
     * @param {String} instruction the {@link term.datainstruction data instruction} specifying where to load the data from.
     */
    $loadFrom : function(instruction){
        apf.getData(instruction, {callback: function(xmlNode){
            if (!xmlNode) return;

            
            if (!xmlNode) {
                throw new Error(apf.formatErrorString(0, null,
                    "Loading default layout",
                    "Could not find default layout using processing \
                     instruction: '" + instruction + "'"));

                return;
            }
            

            apf.layout.loadXml(xmlNode);
        }});
    },

    loadedXml : {},
    cacheXml  : {},
    /**
     * Loads a layout from an xml element.
     * Remarks:
     * The aml elements referenced in the layout definition should exist when
     * this function is called.
     * @param {XMLElement} xmlNode the xml element containing the layout description.
     */
    loadXml   : function(xmlNode){
        var nodes   = xmlNode.childNodes;
        var node    = xmlNode.selectSingleNode(".//node[@name]");//was node()
        var amlNode = node ? self[node.getAttribute("name")] : null;

        
        if(!amlNode) {
            throw new Error(apf.formatErrorString(0, null,
                "Loading Alignment from XML",
                "Could not find AML node" + (node ? " by name '"
                + node.getAttribute("name") + "'" : ""), xmlNode));
        }
        

        var pNode   = amlNode.$ext.parentNode;
        var layout  = this.get(pNode, apf.getBox(xmlNode.getAttribute("margin") || ""));
        var pId     = this.getHtmlId(pNode);

        this.metadata = [];

        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].nodeType != 1) continue;

            layout.root = this.parseXml(nodes[i], layout);
            break;
        }

        this.compile(pNode);
        if (apf.window.inited)
            this.activateRules(pNode);

        this.loadedXml[pId] = xmlNode;
    },

    metadata : [],
    getData  : function(type, layout){
        return {
            vbox        : (type == "vbox"),
            hbox        : (type == "hbox"),
            node        : "vbox|hbox".indexOf(type) == -1,
            children    : [],
            isRight     : false,
            isBottom    : false,
            edgeMargin  : 0,
            splitter    : null,
            minwidth    : 0,
            minheight   : 0,
            weight      : 1,
            pHtml       : layout.parentNode,
            size        : [300,200],
            position    : [0,0],
            last        : {},

            
            toString    : function(){
                var me = apf.vardump(this, null, false);
                for (var i = 0; i < this.children.length; i++) {
                    me += "\n{Child " + i + "\n===========\n"
                          + this.children[i].toString() + "}";
                }

                return me;
            },
            

            copy : function(){
                var copy = apf.extend({}, this);
                
                copy.toString = this.toString;
                

                if (!this.node) {
                    copy.children = [];
                    for (var i = 0; i < this.children.length; i++) {
                        copy.children[i] = this.children[i].copy();
                        copy.children[i].parent = copy;
                    }
                }
                return copy;
            },

            

            setPosition : function(x, y){
                this.oHtml.style.left = x + "px";
                this.oHtml.style.top  = y + "px";

                this.position = [x, y];
            },

            setFloat : function(){
                var diff = apf.getDiff(this.oHtml);

                this.oHtml.style.width = (this.size[0]-diff[0]) + "px";
                if (this.state < 0)
                    this.oHtml.style.height = (this.size[1] - diff[1]) + "px";

                this.prehide();
                this.hidden = 3;

                if (this.hid) {
                    var amlNode = apf.lookup(this.hid);
                    if (amlNode.syncAlignment)
                        amlNode.syncAlignment(this);
                }
            },

            unfloat : function(){
                if (this.hidden != 3) return;

                this.show();
            },

            state    : -1,
            minimize : function(height){
                if (this.state < 0) {
                    this.lastfheight  = this.fheight;
                    this.fheight      = "" + height;
                    this.lastsplitter = this.splitter;
                    if (this.parent.vbox)
                        this.splitter = -1;
                    this.state        = 1;
                }
            },

            restore : function(){
                if (this.state > 0) {
                    this.fheight  = this.lastfheight;
                    this.splitter = this.lastsplitter;
                    this.state    = -1;
                }
            },
            

            hidden         : false,
            hiddenChildren : [],
            prehide        : function(adminOnly){
                if (this.hidden == 3) {
                    this.hidden = true;
                    if (this.hid)
                        apf.lookup(this.hid).visible = false;
                    if (this.oHtml)
                        this.oHtml.style.display = "none";
                    return;
                }

                if (this.hidden && !adminOnly)
                    return;

                if (!this.parent)
                    return; //I think we're done here...

                //Record current position
                this.hidepos = {
                    prev : this.parent.children[this.stackId - 1],
                    next : this.parent.children[this.stackId + 1]
                }

                this.hidden = true;

                //Check if parent is empty
                var nodes, child, c = 0, i, l, sets = ["children", "hiddenChildren"];
                while(sets.length) {
                    nodes = this.parent[sets.pop()];
                    for (i = 0, l = nodes.length; i < l; i++) {
                        child = nodes[i];
                        if (child != this && !child.hidden) { // || apf.layout.dlist.contains(child)
                            c = 1;
                            break;
                        }
                    }
                }
                if (!c)
                    this.parent.prehide(adminOnly);

                if (adminOnly)
                    return this.hide(true);
                
                if (apf.layout.dlist.contains(this)) {
                    apf.layout.dlist.remove(this);
                    return false;
                }
                else
                    apf.layout.dlist.pushUnique(this);
            },
            preshow : function(adminOnly){
                if (!this.hidden)
                    return;

                this.hidden = false;

                if (adminOnly)
                    return this.show(true);

                //Check if parent is shown
                if (this.parent.hidden) // || apf.layout.dlist.contains(this.parent) @todo please make hidden a 4 state property
                    this.parent.preshow();

                if (apf.layout.dlist.contains(this)) {
                    apf.layout.dlist.remove(this);
                    return false;
                }
                else
                    apf.layout.dlist.pushUnique(this);
            },

            hide : function(adminOnly){
                //Remove from parent
                var nodes = this.parent.children;
                nodes.removeIndex(this.stackId);
                for (var i = 0; i < nodes.length; i++)
                    nodes[i].stackId = i;

                //Add to hidden
                this.parent.hiddenChildren.push(this);

                if (adminOnly)
                    return;

                if (this.hidden != 3) {
                    if (this.hid)
                        apf.lookup(this.hid).visible = false;
                    if (this.oHtml)
                        this.oHtml.style.display = "none";
                }
            },

            show : function(adminOnly){
                //Check if position is still available
                var nodes = this.parent.children;
                if (this.hidepos.prev && this.hidepos.prev.parent == this.parent
                  && !this.hidepos.prev.hidden && !apf.layout.dlist.contains(this.hidepos.prev)) { //@todo please make hidden a 4 state property
                    if (nodes.length < this.hidepos.prev.stackId+ 1 )
                        nodes.push(this);
                    else
                        nodes.insertIndex(this, this.hidepos.prev.stackId + 1);
                }
                else if (this.hidepos.next && this.hidepos.next.parent == this.parent
                  && !this.hidepos.next.hidden && !apf.layout.dlist.contains(this.hidepos.next)) { //@todo please make hidden a 4 state property
                    if (this.hidepos.next.stackId == 0)
                        nodes.unshift(this);
                    else if (nodes.length < this.hidepos.next.stackId - 1)
                        nodes.push(this);
                    else
                        nodes.insertIndex(this, this.hidepos.next.stackId - 1);
                }
                else if (!this.hidepos.prev) {
                    nodes.unshift(this);
                }
                else if(!this.hidepos.next) {
                    nodes.push(this);
                }
                else {
                    if (this.stackId < nodes.length)
                        nodes.insertIndex(this, this.stackId);
                    else
                        nodes.push(this);
                }

                for (var i = 0; i < nodes.length; i++)
                    if (nodes[i])
                        nodes[i].stackId = i;

                //Remove from hidden
                this.parent.hiddenChildren.remove(this);

                if (!adminOnly) {
                    if (this.hidden != 3) {
                        if (this.hid)
                            apf.lookup(this.hid).visible = true;
                        if (this.oHtml)
                            this.oHtml.style.display = "block";
                    }
                }

                this.hidden  = false;
                this.hidepos = null;
            },

            remove : function(){
                var p = this.parent;
                if (!p)
                    return;

                if (this.hidden || p.hiddenChildren.contains(this)) {
                    p.hiddenChildren.remove(this);
                    apf.layout.dlist.remove(this);
                }
                else {
                    var nodes = p.children;
                    nodes.remove(this);

                    for (var i = 0; i < nodes.length; i++)
                        nodes[i].stackId = i;
                }

                for (var prop in this.last) {
                    if (prop == "splitter") {
                        if (p.originalMargin) {
                            if (p.parent.pOriginalMargin) {
                                p.parent.splitter       = null;
                                p.parent.edgeMargin     = p.parent.pOriginalMargin[0];
                                p.parent.pOriginalMargin = null;
                                delete p.last.splitter;
                            }

                            p.splitter       = null;
                            p.edgeMargin     = p.originalMargin[0];
                            p.originalMargin = null;
                        }
                    }

                    this[prop] = p[prop] || this.last[prop];
                }
                this.last = {};

                if (!p.children.length && !p.hiddenChildren.length)
                    p.remove();

                this.parent = null;
            },

            add : function(parent){
                this.parent = parent;

                if (this.hidden) {
                    var nodes = parent.hiddenChildren;
                    nodes.push(this);
                    //clear stack id?
                }
                else {
                    var nodes = parent.children;
                    nodes.push(this);

                    for (var i = 0; i < nodes.length; i++) {
                        if (nodes[i])
                            nodes[i].stackId = i;
                    }
                }
            }
        };
    },

    //@todo rewrite this. Layout seperate from markup should not be stored in xml but in CSS.
    parseXml : function(x, layout, amlNode, norecur){
        var aData = this.getData(typeof amlNode == "string"
            ? amlNode
            : x.localName || x[apf.TAGNAME], layout.layout);

        if (aData.node) {
            if (!amlNode) {
                amlNode = self[x.getAttribute("name")];
                
                if (!amlNode) {
                    throw new Error(apf.formatErrorString(0, null,
                        "Parsing Alignment from XML",
                        "Could not find AML node" + x.getAttribute("name"), x));
                }
                
            }

            //if (!amlNode.visible)
                //amlNode.show(true);//amlNode.setProperty("visible", true);//not the most optimal position

            aData.oHtml   = amlNode.$ext;
            amlNode.aData = aData;

            //if (!amlNode.hasFeature(apf.__ALIGNMENT__)) {
                /*amlNode.implement(apf.Alignment);
                if (amlNode.hasFeature(apf.__ANCHORING__))
                    amlNode.$disableAnchoring();*/
                
                //amlNode.align = -1;
                amlNode.$setLayout("alignment");
            //}

            var aml = amlNode;
            if (aml.getAttribute("width"))
                aData.fwidth = aml.getAttribute("width");
            if (aml.getAttribute("height"))
                aData.fheight = aml.getAttribute("height");
            /*if (amlNode.minwidth)
                aData.minwidth = amlNode.minwidth;
            if (amlNode.minheight)
                aData.minheight = amlNode.minheight;*/

            if (!this.getHtmlId(aData.oHtml))
                apf.setUniqueHtmlId(aData.oHtml);
            aData.id = this.getHtmlId(aData.oHtml);
            if (aData.oHtml.style)
                aData.oHtml.style.position = "absolute";
            aData.hid = amlNode.$uniqueId;
        }
        else {
            aData.id = this.metadata.push(aData) - 1;
        }

        if (x.getAttribute("align"))
            aData.template = x.getAttribute("align");
        if (x.getAttribute("lean"))
            aData.isBottom = x.getAttribute("lean").match(/bottom/);
        if (x.getAttribute("lean"))
            aData.isRight = x.getAttribute("lean").match(/right/);
        if (x.getAttribute("edge") && x.getAttribute("edge") != "splitter")
            aData.edgeMargin = x.getAttribute("edge");
        if (x.getAttribute("weight"))
            aData.weight = parseFloat(x.getAttribute("weight"));
        if (x.getAttribute("splitter") || x.getAttribute("edge") == "splitter")
            aData.splitter = x.getAttribute("splitter")
                || (x.getAttribute("edge") == "splitter" ? 4 : false);
        if (x.getAttribute("width"))
            aData.fwidth = String(apf.parseExpression(x.getAttribute("width")));
        if (x.getAttribute("height"))
            aData.fheight = String(apf.parseExpression(x.getAttribute("height")));
        //@todo calculate inner minheight en minwidth
        /*if (x.getAttribute("minwidth"))
            aData.minwidth = x.getAttribute("minwidth");*/
        /*if (x.getAttribute("minheight"))
            aData.minheight = x.getAttribute("minheight");
        if (x.getAttribute("lastheight"))
            aData.lastfheight = x.getAttribute("lastheight");*/
        if (x.getAttribute("lastsplitter"))
            aData.lastsplitter = x.getAttribute("lastsplitter");
        if (x.getAttribute("hidden"))
            aData.hidden = (x.getAttribute("hidden") == 3)
                ? x.getAttribute("hidden")
                : apf.isTrue(x.getAttribute("hidden"));
        else if (x.getAttribute("visible") == "false")
            aData.hidden = true;
        if (x.getAttribute("state"))
            aData.state = x.getAttribute("state");
        if (x.getAttribute("stack"))
            aData.stackId = parseInt(x.getAttribute("stack"));
        if (x.getAttribute("position"))
            aData.position = x.getAttribute("position").split(",");
        if (x.getAttribute("size"))
            aData.size = x.getAttribute("size").split(",");

        //@todo Amazing hackery, can we please try to be consistent across all layout methods
        if (aData.fwidth && aData.fwidth.indexOf("/") > -1) {//match(/[\(\)\+\-=\/\*]/)){
            aData.fwidth = eval(aData.fwidth);
            if (aData.fwidth <= 1)
                aData.fwidth = (aData.fwidth * 100) + "%";
        }
        if (aData.fheight && aData.fheight.indexOf("/") > -1) {//.match(/[\(\)\+\-=\/\*]/)){
            aData.fheight = eval(aData.fheight);
            if (aData.fheight <= 1)
                aData.fheight = (aData.fheight * 100) + "%";
        }

        aData.edgeMargin = Math.max(aData.splitter || 0, aData.edgeMargin || 0);

        //guessing this is docking... unsure
        
        if (aData.node && amlNode.syncAlignment)
            amlNode.syncAlignment(aData);

        if (!norecur && !aData.node) {
            var nodes = x.childNodes;
            for (var last, a, i = 0; i < nodes.length; i++) {
                if (nodes[i].nodeType != 1) continue;

                a = this.parseXml(nodes[i], layout);

                if (last && last.hidden)
                    last.hidepos.next = a;

                if (a.hidden) {
                    if (a.hid) {
                        var j = apf.lookup(a.hid);
                        if (a.hidden === true && j.visible) {
                            j.visible = false;
                            a.oHtml.style.display = "none";
                        }
                        if (a.hidden == 3) {
                            var diff = apf.getDiff(a.oHtml);
                            a.oHtml.style.left   = a.position[0] + "px";
                            a.oHtml.style.top    = a.position[1] + "px";
                            a.oHtml.style.width  = (a.size[0] - diff[0]) + "px";
                            a.oHtml.style.height = ((!this.state || this.state < 0
                                ? a.size[1]
                                : a.fheight)-diff[1]) + "px";
                        }
                    }

                    aData.hiddenChildren.push(a);
                    a.hidepos = {
                        prev : aData.children[aData.children.length-1]
                    };
                }
                else {
                    if (a.hid) {
                        var j = apf.lookup(a.hid);
                        if (!j.visible) {
                            j.visible = true;
                            a.oHtml.style.display = "block";
                        }
                    }
                    a.stackId = aData.children.push(a) - 1;
                }

                a.parent = aData;
                last     = a;
            }
        }
        

        aData.xml = x;

        return aData;
    },

    

    /**
     * Makes a copy of the current state of the layout and encodes it in xml.
     * @param {HTMLElement} pNode the html parent for which the layout is expressed in xml.
     * @returns {XMLElement} the xml representation of the layout.
     */
    getXml : function(pNode){
        var l = apf.layout.get(pNode);
        var xmlNode = l.root.xml
            ? l.root.xml.ownerDocument.createElement("layout")
            : apf.xmldb.getXml("<layout />");
        apf.layout.parseToXml(l.root, xmlNode);
        return xmlNode;
    },

    /**
     * Updates the current state of the layout to the xml from which the
     * original state was loaded from.
     */
    saveXml : function(){
        for (var pId in this.loadedXml) {
            var xmlNode = this.loadedXml[pId];
            var l       = this.layouts[pId];
            var root    = l.root;

            for (var i = xmlNode.childNodes.length - 1; i >= 0; i--)
                xmlNode.removeChild(xmlNode.childNodes[i]);

            //xmlNode.removeChild(root.xml);
            this.parseToXml(root, xmlNode);
        }
    },

    parseToXml : function(oItem, parentNode){
        var xmlNode = oItem.xml
            ? oItem.xml.cloneNode(false)
            : parentNode.ownerDocument.createElement(oItem.vbox
                ? "vbox"
                : (oItem.hbox ? "hbox" : "node"));

        parentNode.appendChild(xmlNode);

        if (oItem.template)
            xmlNode.setAttribute("align", oItem.template);
        if (oItem.edgeMargin)
            xmlNode.setAttribute("edge", oItem.edgeMargin);
        if (oItem.weight)
            xmlNode.setAttribute("weight", oItem.weight);
        if (oItem.splitter)
            xmlNode.setAttribute("splitter", oItem.splitter === false
                ? -1
                : oItem.splitter);
        if (oItem.fwidth)
            xmlNode.setAttribute("width", oItem.fwidth);
        if (oItem.fheight)
            xmlNode.setAttribute("height", oItem.fheight);
        if (oItem.minwidth)
            xmlNode.setAttribute("minwidth", oItem.minwidth);
        if (oItem.minheight)
            xmlNode.setAttribute("minheight", oItem.minheight);
        if (oItem.lastfheight)
            xmlNode.setAttribute("lastheight", oItem.lastfheight);
        if (oItem.lastsplitter)
            xmlNode.setAttribute("lastsplitter", oItem.lastsplitter);
        if (oItem.hidden)
            xmlNode.setAttribute("hidden", (oItem.hidden == 3) ? '3' : 'true');
        else if (xmlNode.getAttribute("hidden"))
            xmlNode.removeAttribute("hidden");
        if (oItem.stackId)
            xmlNode.setAttribute("stack", oItem.stackId);
        if (oItem.state > 0)
            xmlNode.setAttribute("state", oItem.state);
        else if (xmlNode.getAttribute("state"))
            xmlNode.removeAttribute("state");
        if (oItem.position)
            xmlNode.setAttribute("position", oItem.position.join(","));
        if (oItem.size)
            xmlNode.setAttribute("size", oItem.size.join(","));
        //if(oItem.isBottom || oItem.isRight) xmlNode.setAttribute("lean", oItem.minheight);

        var list = oItem.children.copy();
        for (var i = 0; i < oItem.hiddenChildren.length; i++) {
            var hidepos = oItem.hiddenChildren[i].hidepos;
            if (hidepos.prev) {
                var index = list.indexOf(hidepos.prev);
                if (index < 0)
                    list.unshift(oItem.hiddenChildren[i]);
                else
                    list.insertIndex(oItem.hiddenChildren[i], index);
            }
            else if(hidepos.next) {
                var index = list.indexOf(hidepos.next);
                if (index-1 < 0)
                    list.unshift(oItem.hiddenChildren[i]);
                else
                    list.insertIndex(oItem.hiddenChildren[i], index-1);
            }
            else {
                list.push(oItem.hiddenChildren[i]);
            }
        }

        for (var i = 0; i < list.length; i++) {
            this.parseToXml(list[i], xmlNode);
        }
    },

    

    checkInheritance : function(node){
        
        var lastNode = node.children[node.children.length - 1];
        if (node.originalMargin) {
            if (node.parent.pOriginalMargin) {
                node.parent.splitter       = null;
                node.parent.edgeMargin     = node.parent.pOriginalMargin[0];
                node.parent.pOriginalMargin = null;
                node.splitter              = node.last.splitter;
                delete node.last.splitter;
            }

            node.splitter       = null;
            var lNode           = node.originalMargin[1];
            node.edgeMargin     = node.originalMargin[0];
            lNode.splitter      = lNode.splitter === false
                                    ? false
                                    : lNode.last.splitter;
            node.originalMargin = null;
            delete lNode.last.splitter;
        }

        if (lastNode && lastNode.template
          && (lastNode.splitter || lastNode.splitter === null
          && node.originalMargin) && node.parent) {
            if (!node.splitter) {
                lastNode.last.splitter =
                node.splitter          = lastNode.splitter;
                node.originalMargin    = [node.edgeMargin, lastNode];
                node.edgeMargin        = Math.max(node.edgeMargin, node.splitter);
            }
            lastNode.splitter = null;

            if (node.parent && node.stackId == node.parent.children.length - 1
              && (node.parent.parent && node.parent.parent.children.length > 1)) {
                if (!node.parent.splitter) {
                    node.last.splitter         =
                    node.parent.splitter       = node.splitter;
                    node.parent.last.splitter  = null;
                    node.parent.edgeMargin     = Math.max(
                        node.parent.edgeMargin, node.parent.splitter);
                    node.parent.pOriginalMargin = [node.parent.edgeMargin];
                }
                node.splitter = null;
            }
            else if (node.parent.pOriginalMargin) {
                node.parent.splitter       = null;
                node.parent.edgeMargin     = node.parent.pOriginalMargin[0];
                node.parent.pOriginalMargin = null;
                node.splitter              = node.last.splitter;
                delete node.last.splitter;
            }
        }
        

        for (var i = 0; i < node.children.length; i++) {
            if (!node.children[i].node)
                this.checkInheritance(node.children[i]);
        }

        var firstNode = node.children[0];
        if (firstNode && node.parent) {
            if (node.vbox) {
                /*
                    Width is inherited when parent doesn't have width or it
                    already inherited it and wasn't set later (and is thus
                    different from cached version (in .last)
                */
                if (!node.fwidth && firstNode.fwidth
                  || firstNode.last.fwidth && firstNode.fwidth !== null
                  && firstNode.last.fwidth == node.fwidth) {
                    firstNode.last.fwidth =
                    node.fwidth           = firstNode.fwidth;
                    firstNode.fwidth      = null;
                }

                //@todo test this with reparenting
                var pNode = node.parent;
                if ((pNode && !pNode.fheight && firstNode.fheight
                  || firstNode.last.fheight && firstNode.fheight !== null
                  && firstNode.last.fheight == pNode.fheight) && node.children.length == 1) {
                    firstNode.last.fheight =
                    pNode.fheight           = firstNode.fheight;
                    firstNode.fheight      = null;
                }
            }
            else {
                /*
                    Height is inherited when parent doesn't have height or it
                    already inherited it and wasn't set later (and is thus
                    different from cached version (in .last)
                */
                if ((!node.fheight && firstNode.fheight
                  || firstNode.last.fheight && firstNode.fheight !== null
                  && firstNode.last.fheight == node.fheight) && node.children.length == 1) {
                    firstNode.last.fheight =
                    node.fheight           = firstNode.fheight;
                    firstNode.fheight      = null;
                }
            }

            //@todo oops parent is always overriden... :(
            if (firstNode.weight || firstNode.last.weight
              && firstNode.last.weight == node.weight) {
                firstNode.last.weight =
                node.weight           = firstNode.weight;
            }
        }
    },

    compileAlignment : function(aData){
        if (!aData.children.length) {
            //All children were removed, we're removing the layout rule
            this.removeRule(aData.pHtml, "layout");

            var l = this.layouts[aData.pHtml.getAttribute("id")];
            
            if (l)
                apf.layout.clearSplitters(l.layout);
            
            return;
        }

        
        var n = aData.children;
        for (var f = false, i = 0; i < n.length; i++) {
            if (n[i].template == "bottom") {
                if (n[i].splitter) {
                    n[i - 1].splitter = n[i].splitter;
                    n[i].splitter = null;
                }

                n[i - 1].edgeMargin = Math.max(n[i].edgeMargin,
                    n[i - 1].edgeMargin || 0, n[i - 1].splitter || 0);
                n[i].edgeMargin = null;
            }
            
            if (n[i].hidden)
                n[i].prehide(true);
        }

        
        this.checkInheritance(aData);
        

        

        //this.compile(aData.pHtml); //oHtml
        var l = this.layouts[aData.pHtml.getAttribute("id")];
        l.layout.compile(aData.copy());
        l.layout.reset();
    },

    
    addAlignNode : function(amlNode, pData){
        var align = (typeof amlNode.align == "undefined"
            ? amlNode.getAttribute("align")
            : amlNode.align).split("-");
        var s = pData.children;
        var a = amlNode.aData;

        if (typeof amlNode.splitter == "undefined") {
            if (align[1] == "splitter")
                a.splitter = align[2] || 4
            else
                a.splitter = false;
        }

        a.edgeMargin = Math.max(a.edgeMargin, a.splitter || 0);
        align = align[0];
        a.template = align;

        if (align == "top") {
            for (var p = s.length, i = 0; i < s.length; i++) {
                if (s[i].template != "top") {
                    p = i;
                    break;
                }
            }
            for (var i = s.length - 1; i >= p; i--) {
                s[i + 1] = s[i];
                s[i].stackId = i + 1;
            }

            s[p] = a;
            s[p].stackId = p;
            a.parent = pData;
        }
        else if (align == "bottom") {
            a.stackId = s.push(a) - 1;
            a.parent = pData;
        }
        else {
            //find hbox
            var hbox = null;
            for (var p = -1, i = 0; i < s.length; i++) {
                if (s[i].hbox) {
                    hbox = s[i];
                    break;
                }
                else if (s[i].node && s[i].template == "top")
                    p = i;
            }

            //create hbox
            if (!hbox) {
                var l = apf.layout.get(pData.pHtml);
                hbox = apf.layout.parseXml(apf.xmldb.getXml("<hbox />"), l, null, true);
                hbox.parent = pData;
                if (p > -1) {
                    for (var i = s.length - 1; i > p; i--) {
                        s[i + 1] = s[i];
                        s[i].stackId++;
                    }
                    s[p + 1] = hbox;
                    hbox.stackId = p + 1;
                }
                else
                    hbox.stackId = s.unshift(hbox) - 1;
            }

            //find col
            var col, n = hbox.children.concat(hbox.hiddenChildren);
            for (var i = 0; i < n.length; i++) {
                if (n[i].template == align) {
                    col = n[i];
                    break;
                }
            }

            n = hbox.children;
            //create col
            if (!col) {
                var l = apf.layout.get(pData.pHtml);
                col = apf.layout.parseXml(apf.xmldb.getXml("<vbox />"), l, null, true);
                col.parent = hbox;
                col.template = align;

                if (align == "left") {
                    if (!a.fwidth) {
                        var ncol;
                        for (var found = false, i = 0; i < n.length; i++) {
                            if (n[i].template == "middle") {
                                found = n[i];
                                break;
                            }
                        }

                        if (found && !found.children.length) {
                            n.remove(found);
                            for(var i = 0; i < n.length; i++)
                                n[i].stackId = i;
                        }
                    }

                    n.unshift(col);
                    for (var i = 0; i < n.length; i++)
                        n[i].stackId = i;
                }
                else if (align == "right") {
                    if (a.fwidth) {
                        var ncol;
                        for (var found = false, i = 0; i < n.length; i++) {
                            if (n[i].template == "middle" || n[i].template == "left" && !n[i].fwidth) {
                                found = true;
                                break;
                            }
                        }

                        //create middle layer if none is specified
                        if (!found) {
                            ncol = apf.layout.parseXml(apf.xmldb.getXml("<vbox />"), l, null, true);
                            ncol.parent = hbox;
                            ncol.template = "middle";

                            ncol.stackId = n.push(ncol) - 1;
                        }
                    }

                    col.stackId = n.push(col) - 1;
                }
                else if (align == "middle") {
                    for (var f, i = 0; i < n.length; i++)
                        if (n[i].template == "right")
                            f = i;
                    var rcol = n[f];
                    if (rcol) {
                        n[f] = col;
                        col.stackId = f;
                        rcol.stackId = n.push(rcol) - 1;
                    }
                    else {
                        col.stackId = n.push(col) - 1;
                    }
                }
            }

            a.stackId = col.children.push(a) - 1;
            a.parent = col;

            if (col.hidden) {
                col.preshow(true);
            }
        }
    },
    

    compile : function(oHtml){
        var l = this.layouts[oHtml.getAttribute("id")];
        if (!l) return false;

        var root = l.root.copy();//is there a point to copying?
        
        l.layout.compile(root);
        l.layout.reset();
    },

    removeAll : function(aData) {
        aData.children.length = null
        this.compileAlignment(aData);

        var htmlId = this.getHtmlId(aData.pHtml);
        if (!this.rules[htmlId])
            delete this.qlist[htmlId];
    },

    
    
    

    timer : null,
    qlist : {},
    dlist : [],
    $hasQueue : false,
    
    queue : function(oHtml, obj, compile){
        this.$hasQueue = true;
        
        var id;
        if (!(id = this.getHtmlId(oHtml)))
            id = apf.setUniqueHtmlId(oHtml);
            
        if (this.qlist[id]) {
            if (obj)
                this.qlist[id][2].push(obj);
            if (compile)
                this.qlist[id][1] = compile;
            return;
        }

        this.qlist[id] = [oHtml, compile, [obj]];

        if (!this.timer)
            this.timer = $setTimeout("apf.layout.processQueue()");
    },

    processQueue : function(){
        clearTimeout(this.timer);
        this.timer = null;
        this.$hasQueue = false;

        var i, id, l, qItem, list;

        for (i = 0; i < this.dlist.length; i++) {
            if (this.dlist[i].hidden)
                this.dlist[i].hide();
            else
                this.dlist[i].show();
        }

        for (id in this.qlist) {
            qItem = this.qlist[id];

            if (qItem[1])
                apf.layout.compileAlignment(qItem[1]);

            list = qItem[2];
            for (i = 0, l = list.length; i < l; i++) {
                if (list[i])
                    list[i].$updateLayout();
            }

            apf.layout.activateRules(qItem[0]);
        }

        if (apf.hasSingleRszEvent)
            apf.layout.forceResize();

        this.qlist = {};
        this.dlist = [];
    },
    
    

    rules     : {},
    onresize  : {},

    getHtmlId : function(oHtml){
        //if(apf.hasSingleRszEvent) return 1;
        //else
        return oHtml.getAttribute ? oHtml.getAttribute("id") : 1;
    },

    /**
     * Adds layout rules to the resize event of the browser. Use this instead
     * of onresize events to add rules that specify determine the layout.
     * @param {HTMLElement} oHtml       the element that triggers the execution of the rules.
     * @param {String}      id          the identifier for the rules within the resize function of this element. Use this to easily update or remove the rules added.
     * @param {String}      rules       the javascript code that is executed when the html element resizes.
     * @param {Boolean}     [overwrite] whether the rules are added to the resize function or overwrite the previous set rules with the specified id.
     */
    setRules : function(oHtml, id, rules, overwrite){
        if (!this.getHtmlId(oHtml))
            apf.setUniqueHtmlId(oHtml);
        if (!this.rules[this.getHtmlId(oHtml)])
            this.rules[this.getHtmlId(oHtml)] = {};

        var ruleset = this.rules[this.getHtmlId(oHtml)][id];
        if (!overwrite && ruleset) {
            this.rules[this.getHtmlId(oHtml)][id] = rules + "\n" + ruleset;
        }
        else
            this.rules[this.getHtmlId(oHtml)][id] = rules;
    },

    /**
     * Retrieves the rules set for the resize event of an html element specified by an identifier
     * @param {HTMLElement} oHtml       the element that triggers the execution of the rules.
     * @param {String}      id          the identifier for the rules within the resize function of this element.
     */
    getRules : function(oHtml, id){
        return id
            ? this.rules[this.getHtmlId(oHtml)][id]
            : this.rules[this.getHtmlId(oHtml)];
    },

    /**
     * Removes the rules set for the resize event of an html element specified by an identifier
     * @param {HTMLElement} oHtml       the element that triggers the execution of the rules.
     * @param {String}      id          the identifier for the rules within the resize function of this element.
     */
    removeRule : function(oHtml, id){
        var htmlId = this.getHtmlId(oHtml);
        if (!this.rules[htmlId])
            return;

        var ret = this.rules[htmlId][id] ||  false;
        delete this.rules[htmlId][id];

        var prop;
        for (prop in this.rules[htmlId]) {

        }
        if (!prop)
            delete this.rules[htmlId]

        if (apf.hasSingleRszEvent) {
            if (this.onresize[htmlId])
                this.onresize[htmlId] = null;
            else {
                var p = oHtml.parentNode;
                while (p && p.nodeType == 1 && !this.onresize[p.getAttribute("id")]) {
                    p = p.parentNode;
                }
    
                if (p && p.nodeType == 1) {
                    var x = this.onresize[p.getAttribute("id")];
                    if (x.children)
                        delete x.children[htmlId]
                }
            }
        }
        
        return ret;
    },

    /**
     * Activates the rules set for an html element
     * @param {HTMLElement} oHtml       the element that triggers the execution of the rules.
     */
    activateRules : function(oHtml, no_exec){
        if (!oHtml) { //!apf.hasSingleRszEvent &&
            var prop, obj;
            for(prop in this.rules) {
                obj = document.getElementById(prop);
                if (!obj || obj.onresize) // || this.onresize[prop]
                    continue;
                this.activateRules(obj);
            }

             if (apf.hasSingleRszEvent && window.onresize)
                window.onresize();
            return;
        }

        var rsz, id, rule, rules, strRules = [];
        if (!apf.hasSingleRszEvent) {
            rules = this.rules[this.getHtmlId(oHtml)];
            if (!rules){
                oHtml.onresize = null;
                return false;
            }

            for (id in rules) { //might need optimization using join()
                if (typeof rules[id] != "string")
                    continue;
                strRules.push(rules[id]);
            }

            //apf.console.info(strRules.join("\n"));
            rsz = apf.needsCssPx
                ? new Function(strRules.join("\n"))
                : new Function(strRules.join("\n").replace(/ \+ 'px'|try\{\}catch\(e\)\{\}\n/g,""))

            oHtml.onresize = rsz;
            if (!no_exec)
                rsz();
        }
        else {
            var htmlId = this.getHtmlId(oHtml);
            rules = this.rules[htmlId];
            if (!rules){
                //@todo keep .children
                //delete this.onresize[htmlId];
                return false;
            }

            for (id in rules) { //might need optimization using join()
                if (typeof rules[id] != "string")
                    continue;
                strRules.push(rules[id]);
            }
            
            var p = oHtml.parentNode;
            while (p && p.nodeType == 1 && !this.onresize[p.getAttribute("id")]) {
                p = p.parentNode;
            }

            var f = new Function(strRules.join("\n"));//.replace(/try\{/g, "").replace(/}catch\(e\)\{\s*\}/g, "\n")
            if (this.onresize[htmlId])
                f.children = this.onresize[htmlId].children;
                
            if (p && p.nodeType == 1) {
                var x = this.onresize[p.getAttribute("id")];
                (x.children || (x.children = {}))[htmlId] = f;
            }
            else this.onresize[htmlId] = f;
            if (!no_exec)
                f();

            if (!window.onresize) {
                /*var f = apf.layout.onresize;
                window.onresize = function(){
                    var s = [];
                    for (var name in f)
                        s.unshift(f[name]);
                    for (var i = 0; i < s.length; i++)
                        s[i]();
                }*/
                
                var rsz = function(f){
                    //@todo fix this
                    try{
                        var c = [];
                        for (var name in f)
                            c.unshift(f[name]);
                        for (var i = 0; i < c.length; i++){
                            c[i]();
                            if (c[i].children) {
                                rsz(c[i].children);
                            }
                        }
                    }
                    catch(e){
                        
                    }
                }
                
                window.onresize = function(){
                    rsz(apf.layout.onresize);
                }
            }
        }
    },

    /**
     * Forces calling the resize rules for an html element
     * @param {HTMLElement} oHtml  the element for which the rules are executed.
     */
    forceResize : function(oHtml){
        if (apf.hasSingleRszEvent)
            return window.onresize && window.onresize();

        /* @todo this should be done recursive, old way for now
        apf.hasSingleRszEvent
            ? this.onresize[this.getHtmlId(oHtml)]
            :
        */

        var rsz = oHtml.onresize;
        if (rsz)
            rsz();

        var els = oHtml.getElementsByTagName("*");
        for (var i = 0, l = els.length; i < l; i++) {
            if (els[i].onresize)
                els[i].onresize();
        }
    },

    paused : {},

    /**
     * Disables the resize rules for the html element temporarily.
     * @param {HTMLElement} oHtml  the element for which the rules are paused.
     * @param {Function}    func   the resize code that is used temporarily for resize of the html element.
     */
    pause  : function(oHtml, replaceFunc){
        if (apf.hasSingleRszEvent) {
            var htmlId = this.getHtmlId(oHtml);
            this.paused[htmlId] = this.onresize[htmlId] || true;

            if (replaceFunc) {
                this.onresize[htmlId] = replaceFunc;
                this.onresize[htmlId].children = this.paused[htmlId].children;
                replaceFunc();
            }
            else
                delete this.onresize[htmlId];
        }
        else {
            this.paused[this.getHtmlId(oHtml)] = oHtml.onresize || true;

            if (replaceFunc) {
                oHtml.onresize = replaceFunc;
                replaceFunc();
            }
            else
                oHtml.onresize = null;
        }
    },

    /**
     * Enables paused resize rules for the html element
     * @param {HTMLElement} oHtml  the element for which the rules have been paused.
     */
    play : function(oHtml){
        if (!this.paused[this.getHtmlId(oHtml)])
            return;

        if (apf.hasSingleRszEvent) {
            var htmlId = this.getHtmlId(oHtml);
            var oldFunc = this.paused[htmlId];
            if (typeof oldFunc == "function") {
                this.onresize[htmlId] = oldFunc;
                //oldFunc();
            }
            else
                delete this.onresize[htmlId];

            if (window.onresize)
                window.onresize();

            this.paused[this.getHtmlId(oHtml)] = null;
        }
        else {
            var oldFunc = this.paused[this.getHtmlId(oHtml)];
            if (typeof oldFunc == "function") {
                oHtml.onresize = oldFunc;
                oldFunc();
            }
            else
                oHtml.onresize = null;

            this.paused[this.getHtmlId(oHtml)] = null;
        }
    }
};
apf.layout.load = apf.layout.loadXml;//@todo temp need to rename




/**
 * @private
 */
apf.getWindowWidth = function(){
    return apf.isIE ? document.documentElement.offsetWidth - (apf.isIE8 ? 4 : 0) : window.innerWidth;
}
/**
 * @private
 */
apf.getWindowHeight = function(){
    return apf.isIE ? document.documentElement.offsetHeight - (apf.isIE8 ? 4 : 0) : window.innerHeight;
}

/**
 * @constructor
 * @private
 */
apf.layoutParser = function(parentNode, pMargin){
    pMargin  = (pMargin && pMargin.length == 4) ? pMargin : [0, 0, 0, 0];
    this.pMargin = pMargin;
    this.RULES   = [];

    this.parentNode = parentNode;
    if (!this.parentNode.getAttribute("id"))
        apf.setUniqueHtmlId(this.parentNode);

    var knownVars        = {};
    var minWidth         = 0;
    var minHeight        = 0;
    this.createSplitters = true;

    this.setMargin = function(sMargin){
        pMargin = sMargin;
    };

    this.reset = function(){
        this.RULES = [];
        knownVars  = {};
        this.lastType = this.globalEdge = this.globalSplitter = null;
    };

    this.compile = function(root, noapply){
        this.addRule("var v = apf.layout.vars");

        this.globalSplitter = root.splitter;
        this.globalEdge     = root.edgeMargin;

        if (this.globalSplitter || this.globalEdge)
            this.setglobals(root);

        this.preparse(root);
        this.parserules(root);
        
        if (this.createSplitters) {
            apf.layout.clearSplitters(this);
            this.parsesplitters(root);
        }
        
        //Sort by checking dependency structure
        this.RULES = new DepTree().calc(this.RULES);
        var str = ("try{" + this.RULES.join("}catch(e){}\ntry{") + "}catch(e){}\n")
            .replace(/([^=]+\.style[^=]+) = (.*?)\}/g, "$1 = ($2) + 'px'}");

        if (!apf.hasHtmlIdsInJs) //@todo speed?
            str = str.replace(/q([\w|]+)\.(offset|style)/g, 'document.getElementById("q$1").$2');

        //optimization
        //if(this.parentNode != document.body)
            //"if(document.getElementById('" + this.parentNode.id + "').offsetHeight){" + str + "};";

        this.lastRoot = root;

        if (!noapply) {
            apf.layout.setRules(this.parentNode, "layout", str, true);
            apf.layout.queue(this.parentNode);
        }
        else
            return str;

        return false;
    };

    this.addRule = function(rule){
        this.RULES.push(rule);
    };

    this.setglobals = function(node, isLast){
        if (!isLast && this.globalEdge && !node.edgeMargin 
          && (!node.xml || !node.xml.getAttribute("edge"))) {
            if (!node.splitter)
                node.splitter = this.globalSplitter;
            node.edgeMargin = Math.max(this.globalSplitter, this.globalEdge);
        }

        if (node.node) return;

        for (var i = 0; i < node.children.length; i++) {
            this.setglobals(node.children[i], i == node.children.length - 1);
        }
    };

    this.preparse = function(node){
        /*
            Define:
            - minwidth
            - minheight
            - calcheight
            - calcwidth
            - restspace
            - innerspace
        */

        if (node.node) {
            return;
        }
        else {
            var type            = node.vbox ? "height" : "width";
            var cmhwp           = 0;
            var cmwwp           = 0;
            var ctph            = 0;
            //Calculate resultSpace
            node.childweight    = 0;
            node.childminwidth  = 0;
            node.childminheight = 0;
            var rules           = ["v." + type + "_" + node.id], extra = [];
            var nodes           = node.children;

            for (var i = 0; i < nodes.length; i++) {
                if (i < nodes.length-1)
                    rules.push(" - " + nodes[i].edgeMargin);
                var f = nodes[i]["f" + type];
                if (f) {
                    //if(f.indexOf("%") > -1) ctph += parseFloat(f);

                    extra.push(
                        (f.indexOf("%") > -1)
                            ? " - (" + (nodes[i]["calc" + type] = "v.innerspace_"
                                + node.id + " * " + parseFloat(f)/100) + ")"
                            : " - (" + f + ")"
                    );
                }
                else {
                    node.childweight += nodes[i].weight;
                    nodes[i]["calc" + type] = "Math." + (i%2 == 0 ? "ceil" : "floor")
                        + "(v.restspace_" + node.id + " * (" + nodes[i].weight
                        + "/v.weight_" + node.id + "))";
                }

                var g = (node.vbox ? "width" : "height");
                var v = nodes[i]["f" + g];
                if (!v)
                    nodes[i]["calc" + g] = (node.vbox ? "v.width_" : "v.height_")
                        + node.id;
                else
                    nodes[i]["calc" + g] = v.indexOf("%") > -1 ? "v.innerspace_"
                        + node.id + " * " + parseFloat(v)/100 : v

                if (nodes[i].node && nodes[i].xml.visible !== false)
                    nodes[i].oHtml.style.display = "block";
                else
                    this.preparse(nodes[i]);

                if (node.vbox) {
                    /*if(!nodes[i].fheight){
                        cmhwp = Math.max(cmhwp, Math.max(nodes[i].childminheight || 0, nodes[i].minheight || 0, 10)/nodes[i].weight);
                        node.childminheight += nodes[i].edgeMargin;
                    }
                    else */
                    node.childminheight += Math.max(nodes[i].childminheight || 0,
                        nodes[i].minheight || 0, 10) + nodes[i].edgeMargin;
                    node.childminwidth   = Math.max(node.childminwidth,
                        nodes[i].minwidth || nodes[i].childminwidth || 10);
                }
                else {
                    /*if(!nodes[i].fwidth){
                        cmwwp = Math.max(cmwwp, Math.max(nodes[i].childminwidth || 0, nodes[i].minwidth || 0, 10)/nodes[i].weight);
                        node.childminwidth += nodes[i].edgeMargin;
                    }
                    else */
                    node.childminwidth += Math.max(nodes[i].minwidth || 0,
                        nodes[i].childminwidth || 0, 10) + nodes[i].edgeMargin;
                    node.childminheight = Math.max(node.childminheight,
                        nodes[i].minheight || nodes[i].childminheight || 10);
                }
            }

            /*if (node.vbox) {
                if (cmhwp) {
                    if (ctph)
                        node.childminheight += (cmhwp * node.childweight / (100 - ctph)) * ctph;
                    node.childminheight += cmhwp * node.childweight;
                }
            } else {
                if (cmwwp) {
                    if (ctph)
                        node.childminwidth += (cmwwp * node.childweight / (100 - ctph)) * ctph;
                    node.childminwidth += cmwwp * node.childweight;
                }
            }*/

            node.innerspace = rules.join("");
            node.restspace  = node.innerspace + " " + extra.join("");

            if (!node.parent) {
                var hordiff = 0, verdiff = 0;
                if (this.parentNode.tagName.toLowerCase() != "body") {
                    var diff    = apf.getDiff(this.parentNode);
                    verdiff = diff[0];
                    hordiff = diff[1];
                }

                var strParentNodeWidth  = (this.parentNode.tagName.toLowerCase() == "body"
                    ? "apf.getWindowWidth()"
                    : "document.getElementById('" + this.parentNode.id + "').offsetWidth");
                var strParentNodeHeight = (this.parentNode.tagName.toLowerCase() == "body"
                    ? "apf.getWindowHeight()"
                    : "document.getElementById('" + this.parentNode.id + "').offsetHeight");
                node.calcwidth  = "Math.max(" + minWidth + ", " + strParentNodeWidth
                    + " - " + (pMargin[1]) + " - " + pMargin[3] + " - " + hordiff + ")";
                node.calcheight = "Math.max(" + minHeight + ", " + strParentNodeHeight
                    + " - " + (pMargin[2]) + " - " + pMargin[0] + " - " + verdiff + ")";
            }
        }
    };

    this.parserules = function(oItem){
        if (!oItem.node) {
            this.addRule("v.width_" + oItem.id + " = Math.max(" + oItem.childminwidth
                + "," + oItem.minwidth + "," + (oItem.calcwidth || oItem.fwidth) + ")");
            this.addRule("v.height_" + oItem.id + " = Math.max(" + oItem.childminheight
                + "," + oItem.minheight + "," + (oItem.calcheight || oItem.fheight) + ")");
            this.addRule("v.weight_" + oItem.id + " = " + oItem.childweight);
            this.addRule("v.innerspace_" + oItem.id + " = " + oItem.innerspace);
            this.addRule("v.restspace_" + oItem.id + " = " + oItem.restspace);

            var aData = apf.layout.metadata[oItem.id];
            aData.calcData = oItem;
            oItem.original = aData;

            if (!oItem.parent) {
                this.addRule("v.left_" + oItem.id + " = " + pMargin[3]);
                this.addRule("v.top_"  + oItem.id + " = " + pMargin[0]);

                for (var i = 0; i < oItem.children.length; i++)
                    this.parserules(oItem.children[i]);

                return;
            }
            else {
                var vtop  = ["v.top_"  + oItem.id, " = "];
                var vleft = ["v.left_" + oItem.id, " = "];
            }
        }
        else {
            var vtop  = [oItem.id, ".style.top = "];
            var vleft = [oItem.id, ".style.left = "];

            if (oItem.hid) {
                var aData = apf.lookup(oItem.hid).aData;
                aData.calcData = oItem;
                oItem.original = aData;
            }

            var oEl     = oItem.oHtml;//document.getElementById(oItem.id);
            var diff    = apf.getDiff(oEl);
            var verdiff = diff[1];
            var hordiff = diff[0];

            if (oItem.calcwidth)
                this.addRule(oItem.id + ".style.width = -" + hordiff
                    + " + Math.max( " + oItem.calcwidth + ", " + oItem.minwidth + ")");
            else
                oEl.style.width = Math.max(0, oItem.fwidth - hordiff) + "px";

            if (oItem.calcheight)
                this.addRule(oItem.id + ".style.height = -" + verdiff
                    + " + Math.max( " + oItem.calcheight + ", " + oItem.minheight + ")");
            else
                oEl.style.height = Math.max(0, oItem.fheight - verdiff) + "px";
        }

        var oLastSame = oItem.parent.children[oItem.stackId - 1];
        var oNextSame = oItem.parent.children[oItem.stackId + 1];

        //TOP
        if (oItem.parent.vbox) {
            if (oItem.parent.isBottom) {
                if (!oNextSame)
                    vtop.push("v.top_", oItem.parent.id, " + v.height_",
                        oItem.parent.id, " - ", oItem.id, ".offsetHeight");
                else {
                    if (oNextSame.node)
                        vtop.push(oNextSame.id, ".offsetTop - ", oNextSame.edgeMargin,
                            " - ", oItem.id, ".offsetHeight");
                    else
                        vtop.push("v.top_" + oNextSame.id, " - ", oNextSame.edgeMargin,
                            " - ", (oItem.node ? oItem.id + ".offsetHeight" : "v.height_" + oItem.id));
                }
            }
            else if (!oItem.stackId)
                vtop.push("v.top_" + oItem.parent.id);
            else if (oLastSame) {
                if (oLastSame.node)
                    vtop.push(oLastSame.id, ".offsetTop + ", oLastSame.id,
                        ".offsetHeight + ", oLastSame.edgeMargin);
                else
                    vtop.push("v.top_", oLastSame.id, " + v.height_",
                        oLastSame.id, " + ", oLastSame.edgeMargin);
            }
        }
        else
            vtop.push("v.top_" + oItem.parent.id);

        //LEFT
        if (oItem.parent.hbox) {
            if (oItem.parent.isRight) {
                if (!oNextSame) {
                    vleft.push("v.left_", oItem.parent.id, " + v.width_",
                        oItem.parent.id, " - ", (oItem.node ? oItem.id + ".offsetWidth" : "v.width_" + oItem.id), null);
                }
                else {
                    if (oNextSame.node)
                        vleft.push(oNextSame.id, ".offsetLeft - ",
                            oNextSame.edgeMargin, " - ", (oItem.node ? oItem.id + ".offsetWidth" : "v.width_" + oItem.id));
                    else
                        vleft.push("v.left_" + oNextSame.id, " - ", oNextSame.edgeMargin,
                            " - ", (oItem.node ? oItem.id + ".offsetWidth" : "v.width_" + oItem.id));
                }
            }
            else if (!oItem.stackId)
                vleft.push("v.left_" + oItem.parent.id);
            else if (oLastSame) {
                if (oLastSame.node)
                    vleft.push(oLastSame.id, ".offsetLeft + ", oLastSame.id,
                        ".offsetWidth + ", oLastSame.edgeMargin);
                else
                    vleft.push("v.left_", oLastSame.id, " + v.width_",
                        oLastSame.id, " + ", oLastSame.edgeMargin);
            }
        }
        else
            vleft.push("v.left_" + oItem.parent.id);

        if (vleft.length > 2)
            this.addRule(vleft.join(""));
        if (vtop.length > 2)
            this.addRule(vtop.join(""));

        if (!oItem.node) {
            for (var i = 0; i < oItem.children.length; i++)
                this.parserules(oItem.children[i]);
        }
    };

    this.parsesplitters = function(oItem){
        //&& oItem.stackId != oItem.parent.children.length - 1
        if (oItem.parent && oItem.splitter > 0) {
            apf.layout.getSplitter(this).init(oItem.splitter, oItem.hid, oItem);
        }

        if (!oItem.node) {
            for (var i = 0; i < oItem.children.length; i++)
                this.parsesplitters(oItem.children[i]);
        }
    };

    function DepTree(){
        this.parselookup = {};
        this.nRules      = [];
        this.doneRules   = {};

        this.maskText = function(str, m1, m2, m3){
            return m1 + ".offset" + m2.toUpperCase();
        }

        this.handleVar = function(match, m1, m2, m3){
            var vname = "a" + m1.replace(/\|/g, "_") + "_style_" + m2.toLowerCase();
            return knownVars[vname] ? vname : match;
        }

        //@todo this function needs some serious optimization (according to the profiler)
        this.parseRule = function(rule){
            var aRule        = rule.split(" = "),
                id           = aRule[0].replace(/^([_\w\d\|]+)\.style\.(\w)/, this.maskText),
                vname        = "a" + aRule[0].replace(/[\.\|]/g, "_");
            knownVars[vname] = true;

            var depsearch    = aRule[1].split(/[ \(\)]/),// " "
                deps         = [],
                ruleB;
            for (var i = 0; i < depsearch.length; i++) {
                if (depsearch[i].match(/^([_\w\d\|]+)\.offset(\w+)$/) && !depsearch[i].match(/PNODE/)) {
                    deps.push(depsearch[i]);
                }
            }

            if (vname.match(/width|height/i)) {
                aRule[1] = aRule[1].replace(/^(\s*[\-\d]+[\s\-\+]+)/, "");
                ruleB    = aRule[0] + " = " + RegExp.$1 + vname;
            }
            else
                ruleB = aRule[0] + " = " + vname;

            if (rule.match(/^v\./)) {
                return {
                    id        : id,
                    rule_p1   : aRule[0] + " = ",
                    rule_p2   : aRule[1],
                    ruleb      : null,
                    deps      : deps,
                    processed : false
                };
            }

            return {
                id        : id,
                rule_p1   : "var " + vname + " = ",
                rule_p2   : aRule[1],
                ruleb     : ruleB,
                deps      : deps,
                processed : false
            };
        }

        //@todo test safari
        this.calc = function(aRules){
            var i, prop, str = "";
            for (i = 0; i < aRules.length; i++) {
                if (aRules[i].match(/^var/)) {
                    this.nRules.push(aRules[i]);
                    continue;
                }
                var o = this.parseRule(aRules[i], i);
                this.parselookup[o.id] = o;
            }

            //build referential tree (graph)
            for (prop in this.parselookup) {
                this.processNode(this.parselookup[prop]);
            }

            //Walk Tree
            for (prop in this.parselookup) {
                var root = this.parselookup[prop];
                //if(root.processed) continue;
                this.walkRules(root);
            }

            //Set last rules
            for (prop in this.parselookup) {
                this.nRules.push(this.parselookup[prop].ruleb);
            }

            return this.nRules;
        }

        this.walkRules = function(root){
            if (this.doneRules[root.id]) return;

            for (var i = 0; i < root.deps.length; i++) {
                if (root.deps[i] && !root.deps[i].walked && !this.doneRules[root.deps[i].id]) {
                    root.deps[i].walked = true;
                    this.walkRules(root.deps[i]);
                }
            }

            this.doneRules[root.id] = true;
            this.nRules.push(root.rule_p1 + root.rule_p2
                .replace(/([_\w\d\|]+)\.offset(\w+)/g, this.handleVar));
        }

        this.processNode = function(o){
            for (var i = 0; i < o.deps.length; i++) {
                var l = typeof o.deps[i] == "string"
                    ? this.parselookup[o.deps[i]]
                    : o.deps[i];
                if (!l) {
                    o.deps[i] = null;
                    continue;
                }

                o.deps[i] = l;//.copy();
                if (!l.processed) {
                    l.processed = true;
                    this.processNode(l);
                }
            }
        }
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/language.js)SIZE(8586)TIME(1263859264)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Adds multilingual support for aml applications. Reads language symbols from
 * an xml file and distributes them among elements containing text elements
 * or images. When EditMode is turned on, it can subtract all text elements
 * necesary for translation and export them in an xml file. This file can be
 * sent to a translator to translate and then loaded back into the application.
 * Examples:
 * This examples shows a small language file. For example purpose it's loaded
 * inline in a model. Normally this file would be loaded from a web server.
 * There is a simple window and a couple of buttons that receive symbols from
 * the language file. Two buttons provide a means to switch the language of the
 * application, using the language symbols from the model.
 * <code>
 *   <a:model id="mdlLang">
 *       <groups>
 *           <!-- For French -->
 *           <french id="sub">
 *               <group id="main">
 *                   <key id="tab1">Textuele</key>
 *                   <key id="tab2">Arte</key>
 *                   <key id="title">Bonjour</key>
 *                   <key id="1">Adresse de courrier electronique *</key>
 *                   ...
 *               </group>
 *           </french>
 *
 *           <!-- For English -->
 *           <english id="sub">
 *               <group id="main">
 *                   <key id="tab1">Text</key>
 *                   <key id="tab2">Art</key>
 *                   <key id="title">Hello</key>
 *                   <key id="1">E-mail *</key>
 *                   ...
 *               </group>
 *           </english>
 *       </groups>
 *   </a:model>
 *
 *   <a:appsettings language="[mdlLang:english]" />
 *
 *   <a:window 
 *     title   = "$[sub/main/title]$" 
 *     width   = "400" 
 *     height  = "300" 
 *     visible = "true">
 *       <a:tab anchors="10 10 10 10">
 *           <a:page caption="$[sub/main/tab0]$">
 *               <a:label>$[sub/main/1]$</a:label>
 *               <a:textbox />
 *               <a:button>$[sub/main/2]$</a:button>
 *           </a:page>
 *           <a:page caption="$[sub/main/tab2]$">
 *               <a:picture src="$[sub/main/3]$" />
 *           </a:page>
 *       </a:tab>
 *   </a:window>
 *
 *   <a:button icon="us.gif"
 *     onclick="apf.language.$loadFrom(%[mdlLang::english]);">
 *        English
 *   </a:button>
 *   <a:button icon="fr.gif"
 *     onclick="apf.language.$loadFrom(%[mdlLang::french]);">
 *        French
 *   </a:button>
 * </code>
 *
 * @default_private
 * @todo get appsettings to understand language
 */
apf.language = {
    /**
     * Boolean specifying whether read strings are tried to match themselves if no key
     * was gives.
     */
    automatch : false,
    
    loaded    : false,
    
    /**
     * String setting the prefix to the set of language symbols. This is a tree path
     * using a dott (.) as a seperation symbol.
     */
    prefix    : "sub.main.",
    words     : {},
    texts     : {},
    elements  : {},
    bindings  : {},
    count     :  0,

    /**
     * Loads the symbol list from an xml node.
     * @param {XMLElement} xmlNode   the root of the symbol tree for the choosen language.
     * @param {String}     [prefix]  the prefix that overrides the default prefix.
     */
    load   : function(xmlNode, prefix){
        if (!xmlNode)
            return;
        
        if (typeof xmlNode == "string") {
            if (xmlNode.charAt(0) == "<")
                xmlNode = apf.getXmlDom(xmlNode).documentElement;
            else
                return this.loadFrom(xmlNode); //assuming data instruction
        }
        
        this.parseSection(xmlNode, prefix);
        this.redraw();
        this.loaded = true;
    },

    /**
     * Loads the symbol list using a {@link term.datainstruction data instruction}
     * @param {String} instruction  the {@link term.datainstruction data instruction} to load the symbol xml from.
     */
    loadFrom  : function(instruction) {
        apf.getData(instruction, {callback: function(xmlNode){
            if (!xmlNode) 
                return;

            
            if (!xmlNode) {
                throw new Error(apf.formatErrorString(0, null,
                    "Loading language",
                    "Could not find language symbols using processing \
                     instruction: '" + instruction + "'"));

                return;
            }
            

            apf.language.load(xmlNode);
        }});
    },

    parseSection: function(xmlNode, prefix){
        if (!prefix)
            prefix = xmlNode.getAttribute("id") || "";

        if (xmlNode.tagName == "key") {
            prefix += "/" + xmlNode.getAttribute("id");
            this.words[prefix] = xmlNode.firstChild ? xmlNode.firstChild.nodeValue : "";
            
/* @todo apf3.0 MIKE I think this is something you did
         var val     = xmlNode.firstChild ? xmlNode.firstChild.nodeValue : "",
                aliases = xmlNode.getAttribute("aliases");
            this.update(prefix + "/" + xmlNode.getAttribute("id"), val);
            if (aliases) {
                aliases = aliases.splitSafe(",");
                for (var i = 0, l = aliases.length; i < l; i++)
                    this.update(prefix + "/" + aliases[i], val);
            }
*/
            return;
        }

        //if(xmlNode.tagName == "lang") prefix = xmlNode.getAttribute("id");
        if (xmlNode.tagName == "group")
            prefix += (prefix ? "/" : "") + xmlNode.getAttribute("id");

        var nodes = xmlNode.childNodes;
        for (var i = 0; i < nodes.length; i++)
            if (nodes[i].nodeType == 1)
                this.parseSection(nodes[i], prefix);
    },
    
    redraw : function(){
        var id, fParsed, prop, props, els = this.elements, amlNode;
        for (id in els) {
            props = els[id], amlNode = apf.all[id];
            for (prop in props) {
                fParsed = props[prop];
                try {
                    if (fParsed.asyncs) { //if async
                        return fParsed.call(this, amlNode.xmlRoot, function(value){
                            amlNode.setProperty(prop, value, true);
                        }); 
                    }
                    else {
                        var value = fParsed.call(amlNode, amlNode.xmlRoot);
                    }
                }
                catch(e){
                    apf.console.warn("[275] Could not execute language update for " 
                        + prop + "\n\n" + e.message);
                    continue;
                    //return;
                }
                
                amlNode.setProperty(prop, value, true);
            }
        }
        
        var sel, amlNode, bds = this.bindings;
        for (id in bds) {
            amlNode = apf.all[id];
            if (amlNode.selection) {
                sel = amlNode.getSelection();
                amlNode.reload();
                amlNode.selectList(sel);
            }
            else amlNode.reload();
        }
    },
    
    getWord : function(symbol) {
        return this.words[symbol];
    },
    
    addProperty : function(amlNode, prop, func){
        (this.elements[amlNode.$uniqueId] || (this.elements[amlNode.$uniqueId] = {}))[prop] = func;
    },
    
    removeProperty : function(amlNode, prop){
        delete (this.elements[amlNode.$uniqueId] || false)[prop];
    },
    
    addBinding : function(amlNode){
        this.bindings[amlNode.$uniqueId] = true;
    },
    
    removeBinding : function(amlNode){
        delete this.bindings[amlNode.$uniqueId];
    }
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/data.js)SIZE(14920)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @term datainstruction Data instructions offer a single and consistent way for
 * storing and retrieving
 * data from different data sources. For instance from a webserver using REST
 * or RPC, or from local data sources such as gears, air, o3, html5, as well as
 * from in memory sources from javascript or cookies. There is often an xml
 * element which is relevant to storing information. This element can be
 * accessed using xpath statements in the data instruction using curly braces.
 *
 *  - for complex model expr. replace model.
 *  - use property binding for selection, instead of setConnections
 *  <a:bar model="{tree.selected}">
 *      <a:textbox value="[persons/person/text]" />
 *      <a:textbox value="[persons/person/text1]" />
 *      <a:textbox value="[persons/person/text2]" />
 *      <a:textbox value="[persons/person/text3]" />
 *      <a:textbox value="[persons/person/text4]" />
 *  </a:bar>
 *  - create exec function for async objects
 *  - have list of async objects
 *
 * Syntax:
 * Using data instructions to retrieve data
 * <code>
 *  model="name_of_model"
 *  model="[name_of_model::xpath]"
 *  model="{element.selected}"
 *  model="[local(element.selected) {xpath}]"
 *  model="{element.choose}"
 *      model="[local(element.choose) {xpath}]"
 *      model="[local(element.root) {xpath}]"
 *      load="<specialtag>[comm.doCall([@id], test(), 5+10).xml]</specialtag>"
 *      get="example.jsp"
 *      get="http://www.bla.nl?blah=10&foo=[@bar]&example=[10+5]"
 *      get="{comm.submit('abc', [@bar])}"
 *      get="[local(comm.submit('abc', [@bar])) return [xpath]]"
 *      get="[submit('abc', [@bar])]"
 *      get="{xmpp.login(username, password)}"
 *      get="{webdav.getRoot()}"
 *      get="[10+5]"
 * </code>
 *
 * Syntax:
 * Using data instructions to store data
 * <code>
 *  set="http://www.bla.nl?blah=10&foo={/bar}&example=[10+5]"
 *  set="post http://www.bla.nl?blah=10&foo={/bar}&example=[10+5]"
 * <a:add set="[[@uid] = comm.addPerson('abc', {/bar})]" />
 *  set="[submit('abc', {/bar})]"
 *  set="[example=[@name]]"
 *  set="[apf.setcookie('something', [.])]"
 *  set="[o3.fs.get('/var/test.xml').data = [.]]"
 * </code>
 *
 * [
 *  function test(){
 *      var blah = comm.blah();
 *      return blah;
 *  }
 * ]
 * <a:add set="[test([.])]" />
 *
 * See:
 * <ul>
 *  <li>{@link teleport.cgi the cgi teleport module}</li>
 *  <li>{@link teleport.rpc the rpc teleport module}</li>
 *  <li>{@link teleport.webdav the webdav teleport module}</li>
 *  <li>{@link teleport.xmpp the xmpp teleport module}</li>
 * </ul>
 */

/**
 * Stores data using a {@link term.datainstruction data instruction}.
 *
 * @param {String}      instruction  the {@link term.datainstruction data instruction} to be used to store the data.
 * @param {Object}      [options]    the options for this instruction
 *   Properties:
 *   {Boolean} multicall    whether this call should not be executed immediately but saved for later sending using the purge() command.
 *   {mixed}   userdata     any data that is useful to access in the callback function.
 *   {Array}   args         the arguments of the call, overriding any specified in the data instruction.
 *   {XMLElement}  [xmlContext] the subject of the xpath queries
 *   {Function}    [callback]   the code that is executed when the call returns, either successfully or not.
 */
apf.saveData = 

/**
 * Retrieves data using a {@link term.datainstruction data instruction}.
 * Example:
 * Several uses for a data instruction
 * <code>
 *  <!-- loading aml from an xml file -->
 *  <a:bar aml="moreaml.xml" />
 *
 *  <a:bindings>
 *    <!-- loads data using an remote procedure protocol -->
 *    <a:load   get = "{comm.getData()}" />
 *
 *    <!-- inserts data using an remote procedure protocol -->
 *    <a:insert get = "{comm.getSubData([@id])}" />
 *  </a:bindings>
 *
 *  <a:actions>
 *    <!-- notifies the server that a file is renamed -->
 *    <a:rename set = "update_file.jsp?id=[@id]&name=[@name]" />
 *
 *    <!-- adds a node by retrieving it's xml from the server. -->
 *    <a:add    get = "new_user.xml" />
 *  </a:actions>
 *
 *  <!-- creates a model which is loaded into a list -->
 *  <a:list model="{webdav.getRoot()}" />
 *
 *  <!-- loads data into a model and when submitted sends the altered data back -->
 *  <a:model load="load_contact.jsp" submission="save_contact.jsp" />
 * </code>
 *
 * @param {String}      instruction  the {@link term.datainstruction data instruction} to be used to retrieve the data.
 * @param {XMLElement}  [xmlContext] the subject of the xpath queries
 * @param {Object}      [options]    the options for this instruction
 *   Properties:
 *   {Boolean} multicall    whether this call should not be executed immediately but saved for later sending using the purge() command.
 *   {mixed}   userdata     any data that is useful to access in the callback function.
 *   {mixed}   data         data to use in the call
 *   {Array}   args         the arguments of the call, overriding any specified in the data instruction.
 * @param {Function}    [callback]   the code that is executed when the call returns, either successfully or not.
 */
apf.getData = function(instruction, options){
    if (!instruction) return false;

    //Instruction type detection
    var result, chr = instruction.charAt(0), callback = options.callback;

    
    var gCallback  = function(data, state, extra){
        var _self = this;
        $setTimeout(function(){
            s2.call(_self, data, state, extra);
        });
    }
    
    var s2 = 
    

    function(data, state, extra){
        var callback = options.callback
        
        if (state != apf.SUCCESS)
            return callback(data, state, extra || {});

        //Change this to warning?
        /*if (!data) {
            throw new Error(apf.formatErrorString(0, null,
                "Loading new data", "Could not load data. \n\
                Data instruction: '" + instruction + "'"));
        }*/

        return callback(data, state, extra || {});
    }
    
    if (!options) options = {}; //@todo optimize?
    var fParsed = options.fParsed || (instruction.indexOf("{") > -1 || instruction.indexOf("[") > -1
        ? apf.lm.compile(instruction, {
            withopt     : true, 
            precall     : options._pc == -1 ? false : options._pc, //for the actiontracker
            alwayscb    : true, 
            simplexpath : true
          })
        : {str: instruction, type: 2}); 

    //@todo hack because we're not using compileNode.. an imperfection..
    if (fParsed.type == 3){// parsed != "string" && (l = (x = parsed[1]).length)) {
        if (fParsed.xpaths[0]) { //fParsed.asyncs) {
            //if (l == 2 && x[1]) { //When there is a set model and not a generated xpath
                
                if (!apf.nameserver.get("model", fParsed.xpaths[0])) {
                    throw new Error("Could not find model '" + fParsed.xpaths[0] + "' in " + instruction); //@todo apf3.0 make proper error
                }
                
            
                return gCallback(apf.nameserver.get("model", fParsed.xpaths[0])
                    .data.selectSingleNode(fParsed.xpaths[1]), apf.SUCCESS, {});
            //}
        }
        else {
            
            if (!options.xmlNode) {
                throw new Error(apf.formatErrorString(0, null,
                    "Loading data",
                    "Xpath found without model and no xmlNode specified" 
                    + instruction));
            }
            
            
            return gCallback(options.xmlNode.data.selectSingleNode(fParsed.xpaths[1]), apf.SUCCESS, {});
        }
    }
    
    //xml generation
    if (chr == "<") {
        //string only
        if (fParsed.type == 2)
            result = fParsed.str;
        else
            return fParsed(options.xmlNode, gCallback, options);
    }
    //jslt fetching data
    else if ((chr == "[" || chr == "{")) { //(fParsed.asyncs || fParsed.models) && 
        return fParsed(options.xmlNode, gCallback, options);
    }
    //url
    else {
        if (fParsed.type == 1 || fParsed.type == 3) {
            var callback2 = callback;
            callback = options.callback = function(data, state, extra){
                if (options._pc === true)
                    return;
                
                if (state != apf.SUCCESS)
                    return callback2.apply(this, arguments);

                var url = data.split(" "), method = "get";
                if (url.length > 1 && url[0].length < 10) {
                    method = url.shift();
                    url    = url.join(" ");
                }
                else url = data;
                
                callback = options.callback = callback2;
                apf.oHttp.exec(method, [url], gCallback, options);
            }
            fParsed(options.xmlNode, gCallback, options);
        }
        else {
            if (options._pc === true)
                return;
            
            var url = instruction.split(" "), method = "get";
            if (url.length > 1 && url[0].length < 10) {
                method = url.shift();
                url    = url.join(" ");
            }
            else {
                url = instruction;
            }
            
            apf.oHttp.exec(method, [url], gCallback, options);
        }
    }
    
    if (result) {
        if (callback)
            gCallback(result, apf.SUCCESS, {});
        else {
            //apf.console.warn("Returning data directly in apf.getData(). \
                //This means that all callback communication ends in void!");
            return result;
        }
    }
};


/**
 * Creates a model object based on a {@link term.datainstruction data instruction}.
 *
 * @param {String} instruction  the {@link term.datainstruction data instruction} to be used to retrieve the data for the model.
 * @param {AmlNode} amlNode     the element the model is added to.
 */
apf.setModel = function(instruction, amlNode){
    if (!instruction) return;

    //Find existing model
    var fParsed = instruction.indexOf("{") > -1 || instruction.indexOf("[") > -1
        ? apf.lm.compile(instruction, {
            //precall  : false, 
            alwayscb : true
        })
        : {
            type: 2,
            str : instruction
        };

    if (instruction == "@default" || fParsed.type == 2) {
        var model = apf.nameserver.get("model", instruction);
        if (model)
            return model.register(amlNode);
        else if (instruction == "@default")
            return;
        
        //@todo apf3.0 check here if string is valid url (relative or absolute)
        if (instruction.indexOf(".") == -1 && instruction.indexOf("/") == -1) {
            
            apf.console.warn("Could not find model '" + instruction + "'");
            
            return;
        }
    }

    //Just an xpath doesnt work. We don't have context
    //var l, x;
    if (fParsed.type == 3) {//This won't work for complex xpaths
        if (fParsed.models) { //check for # in xpaths[i] to determine if its calculated
            if (fParsed.xpaths.length == 2 && fParsed.xpaths[0] != '#' && fParsed.xpaths [1] != '#') {
                
                if (!apf.nameserver.get("model", fParsed.xpaths[0])) {
                    throw new Error("Could not find model '" + fParsed.xpaths[0] + "' in " + instruction); //@todo apf3.0 make proper error
                }
                
                
                apf.nameserver.get("model", fParsed.xpaths[0]).register(amlNode, fParsed.xpaths[1]);
                return;
            }
        }
        
        else {
            //throw new Error(apf.formatErrorString(0, amlNode,
            apf.console.warn("Xpath found without model. This might fail if no\
                context is specified using local(): " + instruction);
        }
        
    }

    if (amlNode.clear)
        amlNode.clear("loading");

    //Complex data fetch (possibly async) - data is loaded only once. 
    //Potential property binding has to take of the rest
    apf.getData(instruction, {parsed: fParsed, callback: function(data, state, extra){
        //@todo apf3.0 call onerror on amlNode
        if (state != apf.SUCCESS) {
            throw new Error(apf.formatErrorString(0, null,
                "Loading new data", "Could not load data into model. \
                \nMessage: " + extra.message + "\
                \nInstruction: '" + instruction + "'"));
        }
        
        if (!data)
            return;

        if (typeof data == "string") {
            if (data.charAt(0) == "<")
                data = apf.getXml(data);
            else {
                //Assuming web service returned url
                if (data.indexOf("http://") == 0)
                    return apf.setModel(data, amlNode);
                else {
                    throw new Error("Invalid data from server");//@todo apf3.0 make proper apf error handling. apf.onerror
                }
            }
        }
        
        var model = apf.xmldb.findModel(data); //See if data is already loaded into a model
        if (model)
            model.register(amlNode, apf.xmlToXpath(data, model.data)); //@todo move function to xml library
        else
            new apf.model().register(amlNode).load(data);
    }});
};





/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/storage/gears.js)SIZE(12252)TIME(1257329186)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 *  Storage provider that uses Google Gears to store data.
 */
apf.storage.modules.gears = 
apf.storage.modules["gears.sql"] = {
    // instance methods and properties
    table_name  : "STORAGE",
    initialized : false,
    
    $available  : null,
    $db         : null,
    
    init: function(){
        this.factory = apf.nameserver.get("google", "gears");
        this.database_name = apf.config.name + ".apf.offline.gears";

        this.$db = this.factory.create('beta.database', '1.0');
        this.$db.open(this.database_name);

        // create the table that holds our data
        try {
            this.$sql("CREATE TABLE IF NOT EXISTS " + this.table_name + "( "
                        + " namespace TEXT, "
                        + " key TEXT, "
                        + " value TEXT "
                        + ")"
                    );
            this.$sql("CREATE UNIQUE INDEX IF NOT EXISTS namespace_key_index" 
                        + " ON " + this.table_name
                        + " (namespace, key)");
           
            this.initialized = true;
        }
        catch(e) {
            apf.console.warn(e.message);
            return false;
        }
    },
    
    $sql: function(query, params){
        var rs = this.$db.execute(query, params);
        
        return this.$normalizeResults(rs); //can I do this after I close db?
    },
    
    destroy : function(){
        //if (!apf.isIE)
        this.$db.close();
    },
    
    $normalizeResults: function(rs){
        var results = [];
        if (!rs) return [];
    
        while (rs.isValidRow()) {
            var row = {};
        
            for (var i = 0; i < rs.fieldCount(); i++) {
                var fieldName = rs.fieldName(i);
                var fieldValue = rs.field(i);
                row[fieldName] = fieldValue;
            }
        
            results.push(row);
        
            rs.next();
        }
    
        rs.close();
        
        return results;
    },
    
    isAvailable: function(){
        // is Google Gears available and defined?
        return apf.isGears;
    },

    put: function(key, value, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Setting name/value pair", 
                "Invalid key given: " + key));
        
        
        if (!namespace)
            namespace = this.namespace;

		
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Setting name/value pair", 
                "Invalid namespace given: " + namespace));
        
        
        value = apf.serialize(value);
        
        // try to store the value    
        try {
            this.$sql("DELETE FROM " + this.table_name
                        + " WHERE namespace = ? AND key = ?",
                        [namespace, key]);
            this.$sql("INSERT INTO " + this.table_name
                        + " VALUES (?, ?, ?)",
                        [namespace, key, value]);
        }
        catch(e) {
            
            throw new Error(apf.formatErrorString(0, null, 
                "Setting name/value pair", 
                "Error setting name/value pair: " + e.message));
            
            return false;
        }
        
        return true;
    },

    get: function(key, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Getting name/value pair", 
                "Invalid key given: " + key));
        
		
        if (!namespace)
            namespace = this.namespace;
		
		
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Getting name/value pair", 
                "Invalid namespace given: " + namespace));
        
        
        // try to find this key in the database
        var results = this.$sql("SELECT * FROM " + this.table_name
                                    + " WHERE namespace = ? AND "
                                    + " key = ?",
                                    [namespace, key]);

        if (!results.length)
            return null;

        return apf.unserialize(results[0].value);
    },
    
    getNamespaces: function(){
        var results = [ this.namespace ];
        
        var rs = this.$sql("SELECT namespace FROM " + this.table_name
                            + " DESC GROUP BY namespace");
        for (var i = 0; i < rs.length; i++) {
            if (rs[i].namespace != this.namespace)
                results.push(rs[i].namespace);
        }
        
        return results;
    },

    getKeys: function(namespace){
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Retrieving keys", 
                "Invalid namespace given: " + namespace));
        
        
        var rs = this.$sql("SELECT key FROM " + this.table_name
                            + " WHERE namespace = ?",
                            [namespace]);
        
        var results = [];
        for (var i = 0; i < rs.length; i++)
            results.push(rs[i].key);
        
        return results;
    },

    clear: function(namespace){
        if (!namespace)
            namespace = this.namespace;
	    
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Clearing storage", 
                "Invalid namespace given: " + namespace));
        
        
        this.$sql("DELETE FROM " + this.table_name 
                    + " WHERE namespace = ?",
                    [namespace]);
    },
    
    remove: function(key, namespace){
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Removing key", 
                "Invalid namespace given: " + namespace));
        
        
        this.$sql("DELETE FROM " + this.table_name 
                    + " WHERE namespace = ? AND"
                    + " key = ?",
                    [namespace, key]);
    },
    
    putMultiple: function(keys, values, namespace) {
        
        if(this.isValidKeyArray(keys) === false
                        || ! values instanceof Array
                        || keys.length != values.length){
            throw new Error(apf.formatErrorString(0, null,
                "Setting multiple name/value pairs",
                "Invalid arguments: keys = [" + keys + "], \
                                    values = [" + values + "]"));
        }
        

        if (!namespace)
            namespace = this.namespace;

		
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Setting multiple name/value pairs", 
                "Invalid namespace given: " + namespace));
        

        // try to store the value    
        try {
            this.$sql.open();
            this.$sql.db.execute("BEGIN TRANSACTION");
            var stmt = "REPLACE INTO " + this.table_name + " VALUES (?, ?, ?)";
            for(var i=0;i<keys.length;i++) {
                // serialize the value;
                // handle strings differently so they have better performance
                var value = apf.serialize(values[i]);

                this.$sql.db.execute(stmt, [namespace, keys[i], value]);
            }
            this.$sql.db.execute("COMMIT TRANSACTION");
            this.$sql.close();
        }
        catch(e) {
            
            throw new Error(apf.formatErrorString(0, null, 
                "Writing multiple name/value pair", 
                "Error writing file: " + e.message));
            
            return false;
        }
        
        return true;
    },

    getMultiple: function(keys, namespace){
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null, 
                "Getting name/value pair", 
                "Invalid key array given: " + keys));
        
		
        if (!namespace)
            namespace = this.namespace;

		
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Getting multiple name/value pairs", 
                "Invalid namespace given: " + namespace));
        
        
        var stmt = "SELECT * FROM " + this.table_name    + 
            " WHERE namespace = ? AND "    + " key = ?";
        
        var results = [];
        for (var i = 0; i < keys.length; i++) {
            var result = this.$sql(stmt, [namespace, keys[i]]);
            results[i] = result.length
                ? apf.unserialize(result[0].value)
                : null;
        }
        
        return results;
    },
    
    removeMultiple: function(keys, namespace){
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null, 
                "Removing name/value pair", 
                "Invalid key array given: " + keys));
        
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Removing multiple name/value pairs", 
                "Invalid namespace given: " + namespace));
        
        
        this.$sql.open();
        this.$sql.db.execute("BEGIN TRANSACTION");
        var stmt = "DELETE FROM " + this.table_name + " WHERE namespace = ? AND key = ?";

        for (var i = 0; i < keys.length; i++)
            this.$sql.db.execute(stmt, [namespace, keys[i]]);

        this.$sql.db.execute("COMMIT TRANSACTION");
        this.$sql.close();
    },                 
    
    isPermanent: function(){
        return true;
    },

    getMaximumSize: function(){
        return this.SIZE_NO_LIMIT;
    },

    hasSettingsUI: function(){
        return false;
    },
    
    showSettingsUI: function(){
        throw new Error(this.declaredClass 
            + " does not support a storage settings user-interface");
    },
    
    hideSettingsUI: function(){
        throw new Error(this.declaredClass 
            + " does not support a storage settings user-interface");
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/storage/air.js)SIZE(9669)TIME(1257329186)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



// summary: 
//		Storage provider that uses features in the Adobe AIR runtime to achieve
//		permanent storage
			
apf.storage.modules.air = {
    init: function(){
        this.ByteArray = window.runtime.flash.utils.ByteArray;
        this.EncryptedLocalStore = window.runtime.flash.data.EncryptedLocalStore;
    },

    isAvailable: function(){
        return apf.isAIR;
    },
	
    _getItem: function(key){
        var storedValue = this.EncryptedLocalStore.getItem("__apf_" + key);
        return storedValue ? storedValue.readUTFBytes(storedValue.length) : "";
    },
	
    _setItem: function(key, value){
        var bytes = new this.ByteArray();
        bytes.writeUTFBytes(value);
        this.EncryptedLocalStore.setItem("__apf_" + key, bytes);
    },
	
    _removeItem: function(key){
        this.EncryptedLocalStore.removeItem("__apf_" + key);
    },
	
    put: function(key, value, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair", "Invalid key given: " + key));
        
        
        if(!namespace)
            namespace = this.namespace;
		    
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair", "Invalid namespace given: " + namespace));
        
		
        // try to store the value
        try {
            var namespaces = this._getItem("namespaces") || '';
            if(namespaces.indexOf('|' + namespace + '|') == -1)
                this._setItem("namespaces", namespaces + namespace + '|');

            var keys = this._getItem(namespace + "_keys") || '';
            if(keys.indexOf('|' + key + '|') == -1)
                this._setItem(namespace + "_keys", keys + key + '|');

            this._setItem('_' + namespace + '_' + key, value);
        }
        catch(e) {
            
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair", "Error writing: " + e.message));
            
            
            return false;
        }
		
        return true;
    },
	
    get: function(key, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null, "Getting name/value pair", "Invalid key given: " + key));
        
		
        if (!namespace)
            namespace = this.namespace;
		
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting name/value pair", "Invalid namespace given: " + namespace));
        
		
        return this._getItem('_' + namespace + '_' + key);
    },
	
    getNamespaces: function(){
        var results = [ this.namespace ];
        var namespaces = (this._getItem("namespaces") || '').split('|');
        for (var i=0;i<namespaces.length;i++){
            if (namespaces[i] && namespaces[i] != this.namespace)
                results.push(namespaces[i]);
        }
        return results;
    },

    getKeys: function(namespace){
        if (!namespace)
            namespace = this.namespace;
		    
        
        if(this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, "Getting keys",
                "Invalid namespace given: " + namespace));
        

        var results = [];
        var keys = (this._getItem(namespace + "_keys") || '').split('|');
        for (var i = 0; i < keys.length; i++) {
            if (keys[i])
                results.push(keys[i]);
        }
		
        return results;
    },
	
    clear: function(namespace){
        if (!namespace)
            namespace = this.namespace;
	    
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, "Clearing storage",
                "Invalid namespace given: " + namespace));
        
        
        var namespaces = this._getItem("namespaces") || '';
        if (namespaces.indexOf('|' + namespace + '|') != -1)
            this._setItem("namespaces", namespaces.replace('|' + namespace + '|', '|'));

        var keys = (this._getItem(namespace + "_keys") || '').split('|');
        for (var i = 0; i < keys.length; i++)
            if (keys[i].length)
                this._removeItem(namespace + "_" + keys[i]);

        this._removeItem(namespace + "_keys");
    },
	
    remove: function(key, namespace){
        if (!namespace)
            namespace = this.namespace;
	    
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, "Removing key",
                "Invalid namespace given: " + namespace));
        
		
        var keys = this._getItem(namespace + "_keys") || '';
        if (keys.indexOf('|' + key + '|') != -1)
            this._setItem(namespace + "_keys", keys.replace('|' + key + '|', '|'));

        this._removeItem('_' + namespace + '_' + key);
    },
	
    putMultiple: function(keys, values, namespace) {
        
        if (this.isValidKeyArray(keys) === false
            || ! values instanceof Array
            || keys.length != values.length){
            throw new Error(apf.formatErrorString(0, null, 
                "Setting multiple name/value pairs", "Invalid arguments: keys = ["
                + keys + "], values = [" + values + "]"));
        }
        
		
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Setting multiple name/value pairs", "Invalid namespace given: "
                + namespace));
        

        // try to store the value
        try {
            for (var i = 0; i < keys.length; i++)
                this.put(keys[i], value[i], null, namespace);
        }
        catch(e) {
            
            throw new Error(apf.formatErrorString(0, null,
                "Writing multiple name/value pair", "Error writing file: "
                + e.message));
            
            return false;
        }
		
        return true;
    },

    getMultiple: function(keys, namespace){
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting name/value pair", "Invalid key array given: " + keys));
        
		
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Getting multiple name/value pairs", "Invalid namespace given: "
                + namespace));
        

        var results = [];
        for (var i = 0; i < keys.length; i++)
            results[i] = this.get(keys[i], namespace);

        return results;
    },
	
    removeMultiple: function(keys, namespace){
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null,
                "Removing name/value pair", "Invalid key array given: " + keys));
        
		
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Removing multiple name/value pairs", "Invalid namespace given: "
                + namespace));
        
        
        for (var i = 0; i < keys.length; i++)
            this.remove(keys[i], namespace);
    },
	
    isPermanent: function(){
        return true;
    },

    getMaximumSize: function(){
        return this.SIZE_NO_LIMIT;
    },

    hasSettingsUI: function(){
        return false;
    },
	
    showSettingsUI: function(){
        throw new Error(this.declaredClass
            + " does not support a storage settings user-interface");
    },
	
    hideSettingsUI: function(){
        throw new Error(this.declaredClass
            + " does not support a storage settings user-interface");
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/storage/memory.js)SIZE(10208)TIME(1257329186)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Storage module using javascript objects to store the data. When the 
 * application restarts or closes this data is be purged. This module is used
 * when no other storage mechanism is available to still allow for some of the
 * features that depend on a storage mechanism to be available.
 * @default_private
 */
apf.storage.modules.memory = {
    initialized: true,
    store      : {},
    
    isAvailable: function(){
        return true;
    },

    /**
     * Stores a key value pair in a namespace.
     * @param {String} key       the identifier of the information.
     * @param {mixed}  value     the information to store.
     * @param {String} namespace the named context into which to store the key value pair.
     */
    put: function(key, value, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Setting name/value pair", 
                "Invalid key given: " + key));
        
        
        if (!namespace)
		    namespace = this.namespace;

		
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Setting name/value pair", 
                "Invalid namespace given: " + namespace));
        
        
        // serialize the value;
        value = apf.serialize(value);
        
        // store the value    
        if (!this.store[namespace])
            this.store[namespace] = {};
        
        this.store[namespace][key] = value;
    },
    
    /**
     * Retrieves a keys in a namespace.
     * @param {String} key       the identifier of the information.
     * @param {String} namespace the named context of the keys to retrieve.
     * @return {mixed} the value that correspond to the key in the namespace.
     */
    get: function(key, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Getting name/value pair", 
                "Invalid key given: " + key));
        
		
		if (!namespace)
		    namespace = this.namespace;
		
		
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Getting name/value pair", 
                "Invalid namespace given: " + namespace));
        

        if (!this.store[namespace] || !this.store[namespace][key])
            return null;
          
        return apf.unserialize(this.store[namespace][key]);
    },
    
    /**
     * Retrieves all the namespaces in use.
     * @return {Array} list of namespaces.
     */
    getNamespaces: function(){
        var results = [ this.namespace ];
        
        for (var ns in this.store)
            results.push(ns);
        
        return results;
    },

    /**
     * Retrieves all the keys of a namespace.
     * @param {String} namespace the named context of the keys to retrieve.
     * @return {Array} the list of keys in the namespace.
     */
    getKeys: function(namespace){
        if (!namespace)
		    namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Clearing storage", 
                "Invalid namespace given: " + namespace));
        
        
        var results = [];
        for (var prop in this.store[namespace])
            results.push(prop);
        
        return results;
    },

    /** 
     * Removes all keys from a namespace
     */
    clear: function(namespace){
        if (!namespace)
		    namespace = this.namespace;
	    
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Clearing storage", 
                "Invalid namespace given: " + namespace));
        
        
        delete this.store[namespace]
    },
    
    /**
     * Removes a key in a namespace.
     * @param {String} key       the identifier of the information.
     * @param {String} namespace the named context of the keys to remove.
     */
    remove: function(key, namespace){
        if (!namespace)
		    namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Removing key", 
                "Invalid namespace given: " + namespace));
        
        
        if (this.store[namespace])
            delete this.store[namespace][key];
    },
    
    /**
     * Stores a key value pair in a namespace.
     * @param {Array}  keys      a list of keys that identify the information stored.
     * @param {Array}  values    a list of values to store.
     * @param {String} namespace the named context into which to store the key value pair.
     */
    putMultiple: function(keys, values, namespace) {
        
        if (this.isValidKeyArray(keys) === false
          || ! values instanceof Array
          || keys.length != values.length) {
            throw new Error(apf.formatErrorString(0, null,
                "Setting multiple name/value pairs",
                "Invalid arguments: keys = [" + keys + "], \
                                    values = [" + values + "]"));
        }
        

        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Setting multiple name/value pairs", 
                "Invalid namespace given: " + namespace));
        

         // store the value    
        if (!this.store[namespace])
            this.store[namespace] = {};
        
        // try to store the value    
        for (var i = 0; i < keys.length; i++) {
            this.store[namespace][keys[i]] = apf.serialize(values[i]);
        }
        
        return true;
    },

    /**
     * Retrieves all the values of several keys in a namespace.
     * @param {Array}  keys      a list of keys that identify the information retrieved.
     * @param {String} namespace the named context into which to store the key value pair.
     * @returns {Array} list of values that have been retrieved.
     */
    getMultiple: function(keys, namespace){
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null, 
                "Getting name/value pair", 
                "Invalid key array given: " + keys));
        
		
		if (!namespace)
		    namespace = this.namespace;

		
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Getting multiple name/value pairs", 
                "Invalid namespace given: " + namespace));
        
        
         if (!this.store[namespace])
            return [];
        
        var results = [];
        for (var i = 0; i < keys.length; i++){
            if (this.store[namespace][keys[i]])
                results.push(apf.unserialize(this.store[namespace][keys[i]]));
        }
        
        return results;
    },
    
    /**
     * Removes a key in a namespace.
     * @param {Array}  keys      a list of keys that identify the information to be removed.
     * @param {String} namespace the named context of the keys to remove.
     */
    removeMultiple: function(keys, namespace){
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null, 
                "Removing name/value pair", 
                "Invalid key array given: " + keys));
        

        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Removing multiple name/value pairs", 
                "Invalid namespace given: " + namespace));
        
        
        if (!this.store[namespace])
            return;
        
        for (var  i = 0; i < keys.length; i++)
            delete this.store[namespace][keys[i]];
    },                 
    
    isPermanent: function(){
        return false;
    },

    getMaximumSize: function(){
        return this.SIZE_NO_LIMIT;
    },

    hasSettingsUI: function(){
        return false;
    },
    
    showSettingsUI: function(){
        throw new Error(this.declaredClass 
            + " does not support a storage settings user-interface");
    },
    
    hideSettingsUI: function(){
        throw new Error(this.declaredClass 
            + " does not support a storage settings user-interface");
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/storage/flash.js)SIZE(15458)TIME(1257329186)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



// summary:
//        Storage provider that uses features in Flash to achieve permanent
//        storage
// description:

apf.storage.modules.flash = {
    initialized   : false,
    asyncInit     : true,

    _available    : null,
    _statusHandler: null,
    _flashReady   : false,
    _pageReady    : false,

    delayCalls    : [],

    init: function(){
        this.name = "flashStorage";
        this.id   = apf.flash.addPlayer(this);

        // IE/Flash has an evil bug that shows up some time: if we load the
        // Flash and it isn't in the cache, ExternalInterface works fine --
        // however, the second time when its loaded from the cache a timing
        // bug can keep ExternalInterface from working. The trick below
        // simply invalidates the Flash object in the cache all the time to
        // keep it loading fresh. -- Brad Neuberg
        
        this.STORAGE_SWF = (apf.config.resourcePath || apf.basePath)
            + "resources/apfStorage.swf?cachebust="
            + new Date().getTime();
        

        var flash = apf.flash.buildContent(
            "src",              this.STORAGE_SWF,
            "width",            "215",
            "height",           "138",
            "align",            "middle",
            "id",               this.name,
            "quality",          "high",
            "bgcolor",          "#ffffff",
            "allowFullScreen",  "true",
            "name",             this.name,
            "flashvars",        "playerID=" + this.id,
            "allowScriptAccess","always",
            "type",             "application/x-shockwave-flash",
            "pluginspage",      "http://www.adobe.com/go/getflashplayer",
            "menu",             "true");

        this.container = document.createElement('div');
        this.container.id           =  this.name + "_Container";
        this.container.className    = "apfVideo";
        with (this.container.style) {
            width = height = "0px";
            overflow = "hidden";
        }
        document.body.appendChild(this.container);
        this.container.innerHTML    = flash;

        //this.container = document.getElementById(this.name + "_Container");
        this.player    = apf.flash.getElement(this.name);

        // get available namespaces
        this._allNamespaces = this.getNamespaces();

        this._flashReady = this._pageReady = true;
    },

    /**
     * Sets the visibility of this Flash object.
     *
     * @param {Boolean} visible
     */
    setVisible: function(visible){
        if (visible == true) {
            this.container.style.position   = "absolute"; // IE -- Brad Neuberg
            this.container.style.visibility = "visible";
        }
        else {
            with (this.container.style) {
                position = "absolute";
                x = "-1000px";
                y = "-1000px";
                visibility = "hidden";
            }
        }
        return this;
    },

    /**
     * All public methods use this proxy to make sure that methods called before
     * initialization are properly called after the player is ready.
     *
     * @param {String} param1
     * @param {String} param2
     * @param {String} param3
     * @type {Object}
     */
    callMethod: function() {
        if (!this.initialized || typeof this.player.callMethod != "function") {
            this.delayCalls.push(arguments);
        }
        else {
            var args = [this.player, "callMethod"],
                f    = apf.flash,
                i    = 0,
                l    = arguments.length;
            for (; i < l; i++)
                args.push(f.encode(args[i]));
            f.remote.apply(null, args);
        }
    },

    /**
     * Call methods that were made before the player was initialized.
     *
     * @type {Object}
     */
    delayedCallTimer: null,
    makeDelayCalls  : function() {
        clearTimeout(this.delayedCallTimer);

        if (!this.delayCalls.length) {
            if (typeof this['onready'] == "function")
                this.onready();
            return this;
        }

        this.callMethod.apply(this, this.delayCalls[0]);
        this.delayCalls.splice(0, 1);

        //run timeout, we're interfacing with Flash here :S
        var _self = this;
        this.delayedCallTimer = window.setTimeout(function() {
            _self.makeDelayCalls();
        }, 1);

        return this;
    },

    ready : function(callback){
        if (this.initialized)
            callback();
        else
            this.onready = callback;
    },

    event: function(sEventName, oData) {
        //apf.console.info('Event called: ' + sEventName + ', ' + oData);
        if (sEventName == "status") {
            // Called if the storage system needs to tell us about the status
            // of a put() request.
            var ds  = apf.storage;

            if (statusResult == ds.PENDING) {
                //dfo.center();
                this.setVisible(true);
            }
            else
                this.setVisible(false);

            if (ds._statusHandler)
                ds._statusHandler.call(null, oData.status, oData.keyName, oData.namespace);
        }
        else if (sEventName == "loaded") {
            this.initialized = true;
            this.setVisible(false).makeDelayCalls();
        }
    },

    //    Set a new value for the flush delay timer.
    //    Possible values:
    //      0 : Perform the flush synchronously after each "put" request
    //    > 0 : Wait until 'newDelay' ms have passed without any "put" request to flush
    //     -1 : Do not  automatically flush
    setFlushDelay: function(newDelay){
        if (newDelay === null || typeof newDelay === "undefined" || isNaN(newDelay))
            throw new Error("Invalid argunment: " + newDelay);

        this.callMethod('setFlushDelay', String(newDelay));
    },

    getFlushDelay: function(){
        return Number(this.callMethod('getFlushDelay'));
    },

    flush: function(namespace){
        //@fixme: is this test necessary?  Just use !namespace
        if (namespace == null || typeof namespace == "undefined") {
            namespace = apf.storage.namespace;
        }
        this.callMethod('flush', namespace);
    },

    /**
     * @todo replace this with mikes flash detection code
     */
    isAvailable: function(){
        return location.protocol != "file:" && apf.flash.isEightAvailable();
    },

    put: function(key, value, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair", "Invalid key given: " + key));
        

        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair", "Invalid namespace given: " + namespace));
        

        this.callMethod('put', key, apf.serialize(value), namespace);
    },

    putMultiple: function(keys, values, namespace){
        
        if (this.isValidKeyArray(keys) === false
                || ! values instanceof Array
                || keys.length != values.length){
            throw new Error(apf.formatErrorString(0, null,
                "Setting multiple name/value pairs", "Invalid arguments: keys = ["
                + keys + "], values = [" + values + "]"));
        }
        

        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, "Setting multiple name/value pairs", "Invalid namespace given: " + namespace));
        

        //    Convert the arguments on strings we can pass along to Flash
        var metaKey = keys.join(",");
        var lengths = [];
        for (var i = 0; i < values.length; i++) {
            values[i]  = apf.unserialize(values[i]);
            lengths[i] = values[i].length;
        }
        var metaValue   = values.join("");
        var metaLengths = lengths.join(",");
        this.callMethod('putMultiple', metaKey, metaValue, metaLengths, namespace);
    },

    get: function(key, namespace){
       
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null, "Getting name/value pair", "Invalid key given: " + key));
        

        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting name/value pair", "Invalid namespace given: " + namespace));
        

        var results = this.callMethod('get', key, namespace);
        if (results == "")
            return null;

        return apf.unserialize(apf.flash.decode(results));
    },

    getMultiple: function(keys, namespace){
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting name/value pair", "Invalid key array given: " + keys));
        

        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting multiple name/value pairs", "Invalid namespace given: "
                + namespace));
        

        var metaKey     = keys.join(",");
        var metaResults = this.callMethod('getMultiple', metaKey, namespace);
        if (!metaResults)
            return null;
        var results     = eval("(" + metaResults.replace(/""([^",\]]+)/g, '"\\"$1')
            .replace(/([^",]+)""/g, '$1\\""') + ")");

        // destringify each entry back into a real JS object
        for (var i = 0; i < results.length; i++)
            results[i] = (results[i] == "") ? null : apf.unserialize(apf.flash.decode(results[i]));

        return results;
    },

    _destringify: function(results){
        // destringify the content back into a
        // real JavaScript object;
        // handle strings differently so they have better performance
        if (typeof results == "string" && (/^string:/.test(results)))
            results = results.substring("string:".length);
        else
            results = eval(results);

        return results;
    },

    getKeys: function(namespace){
       if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, "Clearing storage",
                "Invalid namespace given: " + namespace));
        

        var results = this.callMethod('getKeys', namespace);

        // Flash incorrectly returns an empty string as "null"
        if (results == this || results == null || results == "null")
          results = "";

        results = results.split(",");
        results.sort();

        return results;
    },

    getNamespaces: function(){
        var results = this.callMethod('getNamespaces');

        // Flash incorrectly returns an empty string as "null"
        if (results == this || results == null || results == "null")
            results = apf.storage.namespace || "default";

        results = results.split(",");
        results.sort();

        return results;
    },

    clear: function(namespace){
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, "Clearing storage",
                "Invalid namespace given: " + namespace));
        

        this.callMethod('clear', namespace);
    },

    remove: function(key, namespace){
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, "Removing key",
                "Invalid namespace given: " + namespace));
        

        this.callMethod('remove', key, namespace);
    },

    removeMultiple: function(/*array*/ keys, /*string?*/ namespace){ /*Object*/
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting name/value pair", "Invalid key array given: " + keys));
        

        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting multiple name/value pairs", "Invalid namespace given: "
                + namespace));
        

        var metaKey = keys.join(",");
        this.callMethod('removeMultiple', metaKey, namespace);
    },

    isPermanent: function(){
        return true;
    },

    getMaximumSize: function(){
        return this.SIZE_NO_LIMIT;
    },

    hasSettingsUI: function(){
        return false;
    },

    showSettingsUI: function(){
        throw new Error(apf.formatErrorString(0, null, this.declaredClass
            + " does not support a storage settings user-interface"));
    },

    hideSettingsUI: function(){
        throw new Error(apf.formatErrorString(0, null, this.declaredClass
            + " does not support a storage settings user-interface"));
    },

    getResourceList: function(){ /* Array[] */
        // @todo: implement offline support icw Flash storage
        return [];
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/storage/html5.js)SIZE(8141)TIME(1257329186)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 *        Storage provider that uses WHAT Working Group features in Firefox 2 
 *        to achieve permanent storage.
 *        The WHAT WG storage API is documented at 
 *        http://www.whatwg.org/specs/web-apps/current-work/#scs-client-side
 */
apf.storage.modules.html5 = {
    domain     : (location.hostname == "localhost")
                    ? "localhost.localdomain"
                    : location.hostname,
    initialized: true,
    
    isAvailable: function(){
        try {
            // see: https://bugzilla.mozilla.org/show_bug.cgi?id=357323
            var myStorage = globalStorage[this.domain];
        }
        catch(e){
            return false;
        }
        
        return true;
    },

    put: function(key, value, namespace){
        
        if(this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair", "Invalid key given: " + key));
        

        // get our full key name, which is namespace + key
        key = this.getFullKey(key, namespace);
        
        // serialize the value;
        value = apf.serialize(value);
        
        // try to store the value
        try {
            var myStorage = globalStorage[this.domain];
            myStorage.setItem(key, value);
        }
        catch(e) {
            // indicate we failed
            
            throw new Error(apf.formatErrorString(0, null, "Setting name/value pair",
                "Could not set name/value pair"));
        
        }
    },

    get: function(key, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair", "Invalid key given: " + key));
        

        // get our full key name, which is namespace + key
        key = this.getFullKey(key, namespace);
        
        // sometimes, even if a key doesn't exist, Firefox
        // will return a blank string instead of a null --
        // this _might_ be due to having underscores in the
        // keyname, but I am not sure.
        
        // @fixme: Simplify this bug into a testcase and
        // submit it to Firefox
        var myStorage = globalStorage[this.domain];
        var results = myStorage.getItem(key);
        
        if (results == null || results == "")
            return null;
        
        return apf.unserialize(results);
    },
    
    getNamespaces: function(){
        var results = [ this.namespace ];
        
        // simply enumerate through our array and save any string
        // that starts with __
        var found = {};
        var myStorage = globalStorage[this.domain];
        var tester = /^__([^_]*)_/;
        for (var i = 0; i < myStorage.length; i++) {
            var currentKey = myStorage.key(i);
            if (tester.test(currentKey) == true){
                var currentNS = currentKey.match(tester)[1];
                // have we seen this namespace before?
                if (typeof found[currentNS] == "undefined") {
                    found[currentNS] = true;
                    results.push(currentNS);
                }
            }
        }
        
        return results;
    },

    getKeys: function(namespace){
        if(!namespace)
            namespace = this.namespace;
		    
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, "Getting keys",
                "Invalid namespace given: " + namespace));
        
        
        // create a regular expression to test the beginning
        // of our key names to see if they match our namespace;
        // if it is the default namespace then test for the presence
        // of no namespace for compatibility with older versions
        // of dojox.storage
        var namespaceTester = new RegExp(namespace == this.namespace
            ? "^([^_]{2}.*)$"
            : "^__" + namespace + "_(.*)$");
        
        var myStorage = globalStorage[this.domain];
        var keysArray = [];
        for (var i = 0; i < myStorage.length; i++) {
            var currentKey = myStorage.key(i);
            if (namespaceTester.test(currentKey) == true) {
                // strip off the namespace portion
                currentKey = currentKey.match(namespaceTester)[1];
                keysArray.push(currentKey);
            }
        }
        
        return keysArray;
    },

    clear: function(namespace){
        if (!namespace)
            namespace = this.namespace;
	    
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, "Clearing storage", "Invalid namespace given: " + namespace));
        
        
        // create a regular expression to test the beginning
        // of our key names to see if they match our namespace;
        // if it is the default namespace then test for the presence
        // of no namespace for compatibility with older versions
        // of dojox.storage
        var namespaceTester = new RegExp(namespace == this.namespace
            ? "^[^_]{2}"
            : "^__" + namespace + "_");
        
        var myStorage = globalStorage[this.domain];
        for (var i = myStorage.length-1; i >= 0; i--) {
            if (namespaceTester.test(myStorage.key(i)) == true)
                myStorage.removeItem(myStorage.key(i));
        }
    },
    
    remove: function(key, namespace){
        // get our full key name, which is namespace + key
        key = this.getFullKey(key, namespace);
        
        var myStorage = globalStorage[this.domain];
        myStorage.removeItem(key);
    },
    
    isPermanent: function(){
        return true;
    },

    getMaximumSize: function(){
        return 0;
    },

    hasSettingsUI: function(){
        return false;
    },
    
    showSettingsUI: function(){
        throw new Error(apf.formatErrorString(0, null, this.declaredClass
            + " does not support a storage settings user-interface"));
    },
    
    hideSettingsUI: function(){
        throw new Error(apf.formatErrorString(0, null, this.declaredClass
            + " does not support a storage settings user-interface"));
    },
    
    getFullKey: function(key, namespace){
        if (!namespace)
            namespace = this.namespace;
        
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, "Clearing storage",
                "Invalid namespace given: " + namespace));
        
        
        // don't append a namespace string for the default namespace,
        // for compatibility with older versions of dojox.storage
        return namespace == this.namespace
            ? key
            : "__" + namespace + "_" + key;
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/storage/air.file.js)SIZE(10053)TIME(1257329186)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



// summary: 
//		Storage provider that uses features in the Adobe AIR runtime to achieve
//		permanent storage

apf.storage.modules['air.file'] = {
    initialized: false,
	
    init: function(){
        this.File = window.runtime.flash.filesystem.File;
        this.FileStream = window.runtime.flash.filesystem.FileStream;
        this.FileMode = window.runtime.flash.filesystem.FileMode;
        
        this.storagePath = "__JPF_" + (apf.config.name
            ? apf.config.name.toUpperCase()
            : "STORAGE") + "/";

        // need to initialize our storage directory
        try {
            var dir = this.File.applicationStorageDirectory.resolvePath(this.storagePath);
            if (!dir.exists)
                dir.createDirectory();
            this.initialized = true;
        }
        catch(e) {
            apf.console.warn(e.message);
            return false;
        }
    },

    isAvailable: function(){
        return apf.isAIR;
    },
	
    put: function(key, value, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair",
                "Invalid key given: " + key));
        
        
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair",
                "Invalid namespace given: " + namespace));
        
		
        // try to store the value
        try {
            this.remove(key, namespace);
			
            var dir = this.File.applicationStorageDirectory.resolvePath(this.storagePath + namespace);
            if (!dir.exists)
                dir.createDirectory();
			
            var file = dir.resolvePath(key);
            var stream = new this.FileStream();
            stream.open(file, this.FileMode.WRITE);
            stream.writeObject(value);
            stream.close();
        } 
        catch(e) {
            
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair",
                "Error writing file: " + e.message));
            
			
            return false;
        }
		
        return true;
    },
	
    get: function(key, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting name/value pair",
                "Invalid key given: " + key));
        
		
        if (!namespace)
            namespace = this.namespace;
		
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting name/value pair",
                "Invalid namespace given: " + namespace));
        
		
        var file = this.File.applicationStorageDirectory.resolvePath(this.storagePath + namespace + '/' + key);
        if (!file.exists || file.isDirectory)
            return false;

        var stream = new this.FileStream();
        stream.open(file, this.FileMode.READ);
        var results = stream.readObject();
        stream.close();
		
        return results;
    },
	
    getNamespaces: function(){
        var results = [ this.namespace ];
        var dir = this.File.applicationStorageDirectory.resolvePath(this.storagePath);
        var files = dir.getDirectoryListing();
        for (var i = 0; i < files.length; i++) {
            if (files[i].isDirectory && files[i].name != this.namespace)
                results.push(files[i].name);
        }
		
        return results;
    },

    getKeys: function(namespace){
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Clearing storage",
                "Invalid namespace given: " + namespace));
        

        var results = [];
        var dir = this.File.applicationStorageDirectory.resolvePath(this.storagePath + namespace);
        if (dir.exists && dir.isDirectory){
            var files = dir.getDirectoryListing();
            for (var i = 0; i < files.length; i++)
                results.push(files[i].name);
        }
        return results;
    },
	
    clear: function(namespace){
        if (!namespace)
            namespace = this.namespace;
	    
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Clearing storage",
                "Invalid namespace given: " + namespace));
        
		
        var dir = this.File.applicationStorageDirectory.resolvePath(this.storagePath + namespace);
        if (dir.exists && dir.isDirectory)
            dir.deleteDirectory(true);
    },
	
    remove: function(key, namespace){
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Removing key",
                "Invalid namespace given: " + namespace));
        

        var file = this.File.applicationStorageDirectory.resolvePath(this.storagePath + namespace + '/' + key);
        if (file.exists && !file.isDirectory)
            file.deleteFile();
    },
	
    putMultiple: function(keys, values, namespace) {
        
        if (this.isValidKeyArray(keys) === false
            || ! values instanceof Array
            || keys.length != values.length){
            throw new Error(apf.formatErrorString(0, null,
                "Setting multiple name/value pairs",
                "Invalid arguments: keys = [" + keys + "], values = [" + values + "]"));
        }
        
		
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting multiple name/value pairs",
                "Invalid namespace given: " + namespace));
        

        // try to store the value
        try {
            for (var i = 0; i < keys.length; i++)
                this.put(keys[i], values[i], null, namespace);
        }
        catch(e) {
            
            throw new Error(apf.formatErrorString(0, null,
                "Writing multiple name/value pair",
                "Error writing file: " + e.message));
            
            return false;
        }
		
        return true;
    },

    getMultiple: function(keys, namespace){
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting name/value pair",
                "Invalid key array given: " + keys));
        
		
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting multiple name/value pairs",
                "Invalid namespace given: " + namespace));
        

        var results = [];
        for (var i = 0; i < keys.length; i++)
            results[i] = this.get(keys[i], namespace);

        return results;
    },
	
    removeMultiple: function(keys, namespace){
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null,
                "Removing name/value pair",
                "Invalid key array given: " + keys));
        
		
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Removing multiple name/value pairs",
                "Invalid namespace given: " + namespace));
        
		
        for (var i = 0; i < keys.length; i++)
            this.remove(keys[i], namespace);
    },
	
    isPermanent: function(){
        return true;
    },

    getMaximumSize: function(){
        return this.SIZE_NO_LIMIT;
    },

    hasSettingsUI: function(){
        return false;
    },
	
    showSettingsUI: function(){
        throw new Error(this.declaredClass
            + " does not support a storage settings user-interface");
    },
	
    hideSettingsUI: function(){
        throw new Error(this.declaredClass
            + " does not support a storage settings user-interface");
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/storage/air.sql.js)SIZE(11835)TIME(1257329186)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



// summary: 
//		Storage provider that uses features in the Adobe AIR runtime to achieve
//		permanent storage

apf.storage.modules['air.sql'] = {
    database_file: "apf.db",

    initialized: false,
    _db: null,
	
    init: function(){
        this.File          = window.runtime.flash.filesystem.File;
        this.SQLConnection = window.runtime.flash.data.SQLConnection;
        this.SQLStatement  = window.runtime.flash.data.SQLStatement;
        
        this.table_name = "__JPF_" + (apf.config.name
            ? apf.config.name.toUpperCase()
            : "STORAGE");

        // need to initialize our storage database
        try {
            this._db = new this.SQLConnection();
            this._db.open(this.File.applicationStorageDirectory.resolvePath(this.database_file));
			
            this._sql("CREATE TABLE IF NOT EXISTS " + this.table_name
                + "(namespace TEXT, key TEXT, value TEXT)");
            this._sql("CREATE UNIQUE INDEX IF NOT EXISTS namespace_key_index ON "
                + this.table_name + " (namespace, key)");
			
            this.initialized = true;
        }
        catch(e) {
            apf.console.warn(e.message);
            return false;
        }
    },
	
    _sql: function(query, params){
        var stmt = new this.SQLStatement();
        stmt.sqlConnection = this._db;
        stmt.text          = query;
        if (params)
            apf.extend(stmt.parameters, params);

        stmt.execute();
        return stmt.getResult();
    },
	
    isAvailable: function(){
        return apf.isAIR;
    },
	
    put: function(key, value, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair",
                "Invalid key given: " + key));
        
        
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair",
                "Invalid namespace given: " + namespace));
        
		
        // try to store the value
        try {
            this._sql("DELETE FROM " + this.table_name
                + " WHERE namespace = :namespace AND key = :key",
            {
                ":namespace": namespace,
                ":key"      : key
            });
            this._sql("INSERT INTO " + this.table_name
                + " VALUES (:namespace, :key, :value)",
            {
                ":namespace": namespace,
                ":key"      : key,
                ":value"    : value
            });
        }
        catch(e) {
            
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair",
                "Error writing file: " + e.message));
            
			
            return false;
        }
		
        return true;
    },
	
    get: function(key, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting name/value pair",
                "Invalid key given: " + key));
        
		
        if (!namespace)
            namespace = this.namespace;
		
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting name/value pair",
                "Invalid namespace given: " + namespace));
        
		
        var results = this._sql("SELECT * FROM " + this.table_name
            + " WHERE namespace = :namespace AND key = :key",
        {
            ":namespace": namespace,
            ":key"      : key
        });
		
        if (results.data && results.data.length)
            return results.data[0].value;
		
        return null;
    },
	
    getNamespaces: function(){
        var results = [ this.namespace ];
        var rs = this._sql("SELECT namespace FROM " + this.table_name + " DESC GROUP BY namespace");
        if (rs.data) {
            for (var i = 0; i < rs.data.length; i++) {
                if (rs.data[i].namespace != this.namespace)
                    results.push(rs.data[i].namespace);
            }
        }
        return results;
    },

    getKeys: function(namespace){
        if(!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Clearing storage",
                "Invalid namespace given: " + namespace));
        
		
        var results = [];
        var rs = this._sql("SELECT key FROM " + this.table_name
            + " WHERE namespace = :namespace", {
            ":namespace": namespace
        });
        if (rs.data) {
            for (var i = 0; i < rs.data.length; i++)
                results.push(rs.data[i].key);
        }
        return results;
    },
	
    clear: function(namespace){
        if (!namespace)
            namespace = this.namespace;
	    
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Clearing storage",
                "Invalid namespace given: " + namespace));
        
        
        this._sql("DELETE FROM " + this.table_name
            + " WHERE namespace = :namespace", {
            ":namespace":namespace
        });
    },
	
    remove: function(key, namespace){
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Removing key",
                "Invalid namespace given: " + namespace));
        
        
        this._sql("DELETE FROM " + this.table_name
            + " WHERE namespace = :namespace AND key = :key",
        {
            ":namespace": namespace,
            ":key"      : key
        });
    },
	
    putMultiple: function(keys, values, namespace) {
        
        if (this.isValidKeyArray(keys) === false
            || ! values instanceof Array
            || keys.length != values.length){
            throw new Error(apf.formatErrorString(0, null,
                "Setting multiple name/value pairs",
                "Invalid arguments: keys = [" + keys + "], values = [" + values + "]"));
        }
        
		
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting multiple name/value pairs",
                "Invalid namespace given: " + namespace));
        

        // try to store the value
        try {
            this._db.begin();
            for (var i = 0; i < keys.length; i++) {
                this._sql("DELETE FROM " + this.table_name
                    + " WHERE namespace = :namespace AND key = :key",
                {
                    ":namespace": namespace,
                    ":key"      : key[i]
                });
                this._sql("INSERT INTO " + this.table_name
                    + " VALUES (:namespace, :key, :value)",
                {
                    ":namespace": namespace,
                    ":key"      : key[i],
                    ":value"    : value
                });
            }
            this._db.commit();
        }
        catch(e) {
            
            throw new Error(apf.formatErrorString(0, null,
                "Writing multiple name/value pair",
                "Error writing file: " + e.message));
            
            return false;
        }
		
        return true;
    },

    getMultiple: function(keys, namespace){
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting name/value pair",
                "Invalid key array given: " + keys));
        
		
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting multiple name/value pairs",
                "Invalid namespace given: " + namespace));
        

        var results = [];
        for (var i = 0; i < keys.length; i++) {
            var result = this._sql("SELECT * FROM " + this.table_name
                + " WHERE namespace = :namespace AND key = :key",
            {
                ":namespace": namespace,
                ":key"      : keys[i]
            });
            results[i] = result.data && result.data.length 
                ? result.data[0].value
                : null;
        }
		
        return results;
    },
	
    removeMultiple: function(keys, namespace){
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null,
                "Removing name/value pair",
                "Invalid key array given: " + keys));
        
		
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Removing multiple name/value pairs",
                "Invalid namespace given: " + namespace));
        
		
        this._db.begin();
        for (var i = 0; i < keys.length;i++) {
            this._sql("DELETE FROM " + this.table_name
                + " WHERE namespace = namespace = :namespace AND key = :key",
            {
                ":namespace": namespace,
                ":key"      : keys[i]
            });
        }
        this._db.commit();
    },
	
    isPermanent: function(){
        return true;
    },

    getMaximumSize: function(){
        return this.SIZE_NO_LIMIT;
    },

    hasSettingsUI: function(){
        return false;
    },
	
    showSettingsUI: function(){
        throw new Error(this.declaredClass + " does not support a storage settings user-interface");
    },
	
    hideSettingsUI: function(){
        throw new Error(this.declaredClass + " does not support a storage settings user-interface");
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/teleport/http.js)SIZE(34455)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * This object does what is commonly known as Ajax, it <strong>A</strong>synchronously 
 * communicates using <strong>J</strong>avascript <strong>A</strong>nd in most 
 * cases it sends or receives <strong>X</strong>ml. It allows for easy http 
 * communication from within the browser. This object provides
 * {@link teleport.http.method.savecache caching} on top of
 * the browser's cache. This enables you to optimize your application, because
 * this can be set on a per call basis. 
 * Example:
 * Retrieving content over http synchronously:
 * <code>
 *  var http = new apf.http();
 *  var data = http.get("http://www.example.com/mydata.jsp", {async: false});
 *  alert(data);
 * </code>
 * Example:
 * Retrieving content over http asynchronously:
 * <code>
 *  var http = new apf.http();
 *  http.get("http://www.example.com/mydata.jsp", {
 *      callback: function(data, state, extra){
 *          if (state != apf.SUCCESS)
 *              return alert('an error has occurred');
 *
 *          alert(data);
 *      }
 *  });
 * </code>
 * Example:
 * Async http request with retry.
 * <code>
 *  var http = new apf.http();
 *  http.get("http://www.example.com/mydata.jsp", {
 *      callback: function(data, state, extra){
 *          if (state != apf.SUCCESS) {
 *              var oError = new Error(apf.formatErrorString(0, null,
 *                  "While loading data", "Could not load data" + extra.message));
 *
 *              if (extra.tpModule.retryTimeout(extra, state, null, oError) === true)
 *                  return true;
 *
 *              throw oError;
 *          }
 *
 *          alert(data);
 *      }
 *  });
 * </code>
 *
 * @event error Fires when a communication error occurs.
 *   bubbles: yes
 *   cancelable:  Prevents a communication error to be thrown.
 *   object:
 *     {Error}          error     the error object that is thrown when the event
 *                                callback doesn't return false.
 *     {Number}         state     the state of the call
 *       Possible values:
 *       apf.SUCCESS  the request was successfull
 *       apf.TIMEOUT  the request has timed out.
 *       apf.ERROR    an error has occurred while making the request.
 *       apf.OFFLINE  the request was made while the application was offline.
 *     {mixed}          userdata  data that the caller wanted to be available in
 *                                the callback of the http request.
 *     {XMLHttpRequest} http      the object that executed the actual http request.
 *     {String}         url       the url that was requested.
 *     {Http}           tpModule  the teleport module that is making the request.
 *     {Number}         id        the id of the request.
 *     {String}         message   the error message.
 *
 * @constructor
 * @define http
 * @addnode teleport
 * @default_private
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.http = function(){
    this.queue     = [null];
    this.callbacks = {};
    this.cache     = {};

    /**
     * Sets the timeout of http requests in milliseconds. Default is 10000ms (10s).
     */
    this.timeout   = this.timeout || 10000; //default 10 seconds
    
    /**
     * Sets whether this element routes traffic through a server proxy.
     * Remarks:
     * This can also be set on a per call basis. See {@link teleport.http.method.get}.
     */
    this.autoroute = this.autoroute || false;
    
    /**
     * String specifying the url to the route script. 
     * Remarks:
     * The route script will receive the route information in 3 extra headers:
     *   X-Route-Request     - Containing the destination url.<br />
     *   X-Proxy-Request     - Containing the destination url.<br />
     *   X-Compress-Response - Set to 'gzip'.<br />
     */
    this["route-server"] = this["route-server"] || null;

    if (!this.$uniqueId)
        this.$uniqueId = apf.all.push(this) - 1;

    this.toString = this.toString || function(){
        return "[Ajax.org Teleport Component : (HTTP)]";
    };

    
    var namespace = apf.config.name + ".apf.http";

    /**
     * Saves the apf http cache to the available {@link core.storage storage engine}.
     */
    this.saveCache = function(){
        
        if (!apf.serialize)
            throw new Error(apf.formatErrorString(1079, this,
                "HTTP save cache",
                "Could not find JSON library."));
        

        
        apf.console.info("[HTTP] Loading HTTP Cache", "teleport");
        

        var strResult = apf.serialize(comm.cache);
        apf.storage.put("cache_" + this.name, strResult,
            apf.config.name + ".apf.http");
    };

    /**
     * Loads the apf http cache from the available {@link core.storage storage engine}.
     */
    this.loadCache = function(){
        var strResult = apf.storage.get("cache_" + this.name,
            apf.config.name + ".apf.http");

        
        apf.console.info("[HTTP] Loading HTTP Cache", "steleport");
        

        if (!strResult)
            return false;

        this.cache = apf.unserialize(strResult);

        return true;
    };

    /**
     * Removes the stored http cache from the available {@link core.storage storage engine}.
     */
    this.clearCache = function(){
        apf.storage.remove("cache_" + this.name,
            apf.config.name + ".apf.http");
    };
    

    /**
     * Makes an http request that receives xml
     * @param {String}   url       the url that is accessed.
     * @param {Object}   options   the options for the http request
     *   Properties:
     *   {Boolean} async          whether the request is sent asynchronously. Defaults to true.
     *   {mixed}   userdata       custom data that is available to the callback function.
     *   {String}  method         the request method (POST|GET|PUT|DELETE). Defaults to GET.
     *   {Boolean} nocache        whether browser caching is prevented.
     *   {String}  data           the data sent in the body of the message.
     *   {Boolean} autoroute      whether the request can fallback to a server proxy.
     *   {Boolean} caching        whether the request should use internal caching.
     *   {Boolean} ignoreOffline  whether to ignore offline catching.
     *   {Function} callback      the handler that gets called whenever the
     *                            request completes succesfully or with an error,
     *                            or when the request times out.
     */
    this.getXml = function(url, callback, options){
        if (!options) options = {};
        options.useXML = true;
        options.callback = callback;
        return this.get(url, options);
    };

    /**
     * Makes an http request.
     * @param {String}   url       the url that is accessed.
     * @param {Object}   options   the options for the http request
     *   Properties:
     *   {Boolean} async          whether the request is sent asynchronously. Defaults to true.
     *   {mixed}   userdata       custom data that is available to the callback function.
     *   {String}  method         the request method (POST|GET|PUT|DELETE). Defaults to GET.
     *   {Boolean} nocache        whether browser caching is prevented.
     *   {String}  data           the data sent in the body of the message.
     *   {Boolean} useXML         whether the result should be interpreted as xml.
     *   {Boolean} autoroute      whether the request can fallback to a server proxy.
     *   {Boolean} caching        whether the request should use internal caching.
     *   {Boolean} ignoreOffline  whether to ignore offline catching.
     *   {Function} callback      the handler that gets called whenever the
     *                            request completes succesfully or with an error,
     *                            or when the request times out.
     */
    this.get = this.$get = function(url, options){
        if (!options)
            options = {};

        var _self = this;
        var id    = options.id;
        
        var bHasOffline = (typeof apf.offline != "undefined");
        if (bHasOffline && !apf.offline.onLine && options.notWhenOffline)
            return false;

        if (bHasOffline && !apf.offline.onLine && !options.ignoreOffline) {
            if (apf.offline.queue.enabled) {
                //Let's record all the necesary information for future use (during sync)
                var info = apf.extend({
                    url      : url,
                    callback : options.callback,
                    retry    : function(){
                        _self.get(this.url, this.options);
                    },
                    $object : [this.name, "apf.oHttp", "new apf.http()"],
                    $retry : "this.object.get(this.url, this.options)"
                }, options);

                apf.offline.queue.add(info);

                return;
            }

            /*
                Apparently we're doing an HTTP call even though we're offline
                I'm allowing it, because the developer seems to know more
                about it than I right now
            */

            
            apf.console.warn("Executing HTTP request even though application is offline");
            
        }
        

        var async = options.async = (options.async
            || typeof options.async == "undefined" || apf.isOpera || false);

        
        if (apf.isWebkit)
            url = apf.html_entity_decode(url);
        

        var data = options.data || "";

        if (apf.isNot(id)) {
            
            if (this.cache[url] && this.cache[url][data]) {
                var http = {
                    responseText : this.cache[url][data],
                    responseXML  : {},
                    status       : 200,
                    isCaching    : true
                }
            }
            else
            
                var http = apf.getHttpReq();

            id = this.queue.push({
                http     : http,
                url      : url,
                callback : options.callback,
                retries  : 0,
                options  : options
            }) - 1;

            
            if (http.isCaching) {
                if (async)
                    return $setTimeout("apf.lookup(" + this.$uniqueId
                        + ").receive(" + id + ");", 50);
                else
                    return this.receive(id);
            }
            
        }
        else {
            var http = this.queue[id].http;

            
            if (http.isCaching)
                http = apf.getHttpReq();
            else
            
                http.abort();
        }

        if (async) {
            
            if (apf.hasReadyStateBug) {
                this.queue[id].starttime = new Date().getTime();
                this.queue[id].timer = setInterval(function(){
                    var diff = new Date().getTime() - _self.queue[id].starttime;
                    if (diff > _self.timeout) {
                        _self.$timeout(id);
                        return
                    };

                    if (_self.queue[id].http.readyState == 4) {
                        clearInterval(_self.queue[id].timer);
                        _self.receive(id);
                    }
                }, 20);
            }
            else
            
            {
                http.onreadystatechange = function(){
                    if (!_self.queue[id] || http.readyState != 4)
                        return;

                    _self.receive(id);
                }
            }
        }

        var autoroute = this.autoroute && apf.isOpera
            ? true //Bug in opera
            : (options.autoroute || this.shouldAutoroute),
            httpUrl = autoroute ? this["route-server"] : url;

        
        if (!options.hideLogMessage) {
            apf.console.info("[HTTP] Making request[" + id + "] using "
                + (this.method || options.method || "GET") + " to " + url
                + (autoroute
                    ? "<span style='color:green'>[via: " + httpUrl + "]</span>"
                    : ""),
                "teleport",
                new String(data && data.xml ? data.xml : data));
        }
        

        var errorFound = false;
        try {
            if (options.nocache)
                httpUrl = apf.getNoCacheUrl(httpUrl);

            
            if (apf.config.queryAppend) {
                httpUrl += (httpUrl.indexOf("?") == -1 ? "?" : "&")
                    + apf.config.queryAppend;
            }
            
            
            // experimental for Firefox Cross Domain problem
            // http://ubiquity-xforms.googlecode.com/svn/wiki/CrossDomainSubmissionDeployment.wiki
            
            
            try {
                netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
            }
            catch (e) {
            
            
                //Currently we don't support html5 cross domain access
                if (apf.hasHtml5XDomain
                  && httpUrl.match(/^http:\/\//)
                  && !new apf.url(httpUrl).isSameLocation()) {
                    throw new Error(apf.formatErrorString(0,
                        this, "Communication error", "Url: " + httpUrl
                            + "\nReason: Same origin policy in effect"));
                  }
            
            
            }
            
            
            //end experimental

            http.open(this.method || options.method || "GET", httpUrl, async);

            if (options.username) {
                http.setRequestHeader("Authorization", "Basic " 
                    + apf.crypto.Base64.encode(options.username + ":" + options.password))
            }

            //@todo OPERA ERROR's here... on retry [is this still applicable?]
            if (!apf.isWebkit)
                http.setRequestHeader("User-Agent", "Ajax.org Teleport 3.0"); //@deprecated
            http.setRequestHeader("X-Requested-With", "XMLHttpRequest");
            if (!options.headers || !options.headers["Content-type"])
                http.setRequestHeader("Content-type", this.contentType
                    || (this.useXML || options.useXML ? "text/xml" : "text/plain"));

            if (autoroute) {
                http.setRequestHeader("X-Route-Request", url);
                http.setRequestHeader("X-Proxy-Request", url);
                http.setRequestHeader("X-Compress-Response", "gzip");
            }
        }
        catch (e) {
            errorFound = e.message;
        }

        if (errorFound) {
            var useOtherXH = false;

            
            if (self.XMLHttpRequestUnSafe) {
                try {
                    http = new XMLHttpRequestUnSafe();
                    http.onreadystatechange = function(){
                        if (!_self.queue[id] || http.readyState != 4)
                            return;

                        _self.receive(id);
                    }
                    http.open(this.method || options.method || "GET", (options.nocache
                        ? apf.getNoCacheUrl(httpUrl)
                        : httpUrl), async);

                    http.setRequestHeader("X-Requested-With", "XMLHttpRequest");
                    if (!options.headers || !options.headers["Content-type"])
                        http.setRequestHeader("Content-type", this.contentType
                            || (this.useXML || options.useXML ? "text/xml" : "text/plain"));

                    this.queue[id].http = http;
                    options.async     = true; //force async
                    useOtherXH        = true;
                }
                catch (e) {}
            }
            

            // Retry request by routing it
            if (!useOtherXH && this.autoroute && !autoroute) {
                
                if (!apf.isNot(id))
                    clearInterval(this.queue[id].timer);
                

                this.shouldAutoroute = true;

                options.autoroute = true;
                return this.get(url, options);
            }

            if (!useOtherXH) {
                //Routing didn't work either... Throwing error
                var noClear = options.callback ? options.callback(null, apf.ERROR, {
                    userdata: options.userdata,
                    http    : http,
                    url     : url,
                    tpModule: this,
                    id      : id,
                    message : "Permission denied accessing remote resource: "
                              + url + "\nMessage: " + errorFound
                }) : false;
                if (!noClear)
                    this.clearQueueItem(id);

                return;
            }
        }

        if (this.$headerHook)
            this.$headerHook(http);

        //Set request headers
        if (options.headers) {
            for (var name in options.headers)
                http.setRequestHeader(name, options.headers[name]);
        }

        function handleError(){
            var msg = self.navigator.onLine
                ? "File or Resource not available " + url
                : "Browser is currently working offline";

            
            apf.console.warn(msg, "teleport");
            

            var state = self.navigator && navigator.onLine
                ? apf.ERROR
                : apf.TIMEOUT;

            // File not found
            var noClear = options.callback ? options.callback(null, state, {
                userdata : options.userdata,
                http     : http,
                url      : url,
                tpModule : _self,
                id       : id,
                message  : msg
            }) : false;
            if(!noClear) _self.clearQueueItem(id);
        }

        function send(isLocal){
            var hasError;

            if (apf.isIE && isLocal) { //When local IE calls onreadystate immediately
                var oldWinOnerror = window.onerror;
                window.onerror = function(){
                    if (arguments.caller.callee == send) {
                        window.onerror = oldWinOnerror;
                        //_self.receive(id);
                        //setTimeout(function(){handleError();});
                        return true;
                    }
                    else {
                        window.onerror = oldWinOnerror;
                        
                        if (oldWinOnerror)
                            return oldWinOnerror.apply(window, arguments);
                    }
                }
                http.send(data);
                window.onerror = oldWinOnerror;
            }
            else {
                try{
                    http.send(data);
                }
                catch(e){
                    hasError = true;
                }
            }

            if (hasError) {
                handleError();
                return;
            }
        }

        if (!async) {
            send.call(this);
            return this.receive(id);
        }
        else {
            if (apf.loadsLocalFilesSync && location.protocol == "file:"
              && url.indexOf("http://") == -1) {
                $setTimeout(function(){
                    send.call(_self, true);
                });
            }
            else
                send.call(_self);

            return id;
        }
    };
    
    
    /**
     * Method that all async objects should implement
     * @private
     */
    if (!this.exec) {
        this.exec = function(method, args, callback, options){
            if (!options)
                options = {};
            
            var url = args[0], query = "";
            if (!options.method)
                options.method = method.toUpperCase();
            if (!options.callback)
                options.callback = callback;
            
            this.contentType = "application/x-www-form-urlencoded";
            this.$get(
                apf.getAbsolutePath(apf.config.baseurl, url), 
                options.method == "GET" 
                    ? options 
                    : apf.extend({data : query}, options)
            );
        }
    }
    

    /**
     * @private
     */
    this.receive = function(id){
        if (!this.queue[id])
            return false;

        var qItem    = this.queue[id],
            http     = qItem.http,
            callback = qItem.callback;
        //if (apf.isGecko)
        //    var apf = self.apf || apf;     // needed here to fix a rare ReferenceError in FF

        
        clearInterval(qItem.timer);
        

        if (self.navigator && navigator.onLine === false && (location.protocol != "file:"
          || qItem.url.indexOf("http://") > -1))
            return false;

        // Test if HTTP object is ready
        if (qItem.async) {
            try {
                if (http.status) {}
            }
            catch (e) {
                var _self = this;
                return $setTimeout(function(){
                    _self.receive(id)
                }, 10);
            }
        }
        
        
        if (!qItem.options.hideLogMessage) {
            apf.console.info("[HTTP] Receiving [" + id + "]"
                + (http.isCaching
                    ? "[<span style='color:orange'>cached</span>]"
                    : "")
                + " from " + qItem.url,
                "teleport",
                http.responseText);
        }
        

        //Gonna check for validity of the http response
        var errorMessage = [],
            extra = {
                tpModule : this,
                http     : http,
                url      : qItem.url,
                callback : callback,
                id       : id,
                retries  : qItem.retries || 0,
                userdata : qItem.options.userdata
            };

        // Check HTTP Status
        // The message didn't receive the server. We consider this a timeout (i.e. 12027)
        if (http.status > 600)
            return this.$timeout(id);

        extra.data = http.responseText; //Can this error?

        if (http.status >= 400 && http.status < 600 || http.status < 10 && http.status != 0) {
            
            //@todo This should probably have an RPC specific handler
            if (http.status == 401) {
                var auth = apf.document.getElementsByTagNameNS(apf.ns.apf, "auth")[0];
                if (auth) {
                    var wasDelayed = qItem.isAuthDelayed;
                    qItem.isAuthDelayed = true;
                    if (auth.authRequired(extra, wasDelayed) === true)
                        return;
                }
            }
            

            errorMessage.push("HTTP error [" + id + "]:" + http.status + "\n"
                + http.responseText);
        }

        // Check for XML Errors
        if (qItem.options.useXML || this.useXML) {
            /* Note (Mike, Oct 14th 2008): for WebDAV, I had to copy the lines below,
                                           it required custom responseXML handling/
                                           parsing.
                                           If you alter this code, please correct
                                           webdav.js appropriately.
            */
            if ((http.responseText || "").replace(/^[\s\n\r]+|[\s\n\r]+$/g, "") == "")
                errorMessage.push("Received an empty XML document (0 bytes)");
            else {
                try {
                    var xmlDoc = (http.responseXML && http.responseXML.documentElement)
                        ? apf.xmlParseError(http.responseXML)
                        : apf.getXmlDom(http.responseText);

                    if (!apf.supportNamespaces)
                        xmlDoc.setProperty("SelectionLanguage", "XPath");

                    extra.data = xmlDoc.documentElement;
                }
                catch(e){
                    errorMessage.push("Received invalid XML\n\n" + e.message);
                }
            }
        }

        //Process errors if there are any
        if (errorMessage.length) {
            extra.message = errorMessage.join("\n");

            // Send callback error state
            if (!callback || !callback(extra.data, apf.ERROR, extra))
                this.clearQueueItem(id);

            return;
        }

        
        if (qItem.options.caching) {
            if (!this.cache[qItem.url])
                this.cache[qItem.url] = {};

            this.cache[qItem.url][qItem.options.data] = http.responseText;
        }
        

        //Http call was successfull Success
        if (!callback || !callback(extra.data, apf.SUCCESS, extra))
            this.clearQueueItem(id);

        return extra.data;
    };

    this.$timeout = function(id){
        if (!this.queue[id])
            return false;

        var qItem = this.queue[id],
            http  = qItem.http;

        
        clearInterval(qItem.timer);
        

        // Test if HTTP object is ready
        try {
            if (http.status) {}
        }
        catch (e) {
            var _self = this;
            return $setTimeout(function(){
                _self.$timeout(id)
            }, 10);
        }

        var callback = qItem.callback;

        http.abort();

        
        apf.console.info("HTTP Timeout [" + id + "]", "teleport");
        

        var noClear = callback ? callback(null, apf.TIMEOUT, {
            userdata: qItem.options.userdata,
            http    : http,
            url     : qItem.url,
            tpModule: this,
            id      : id,
            message : "HTTP Call timed out",
            retries : qItem.retries || 0
        }) : false;
        if (!noClear)
            this.clearQueueItem(id);
    };

    /**
     * Checks if the request has times out. If so it's retried
     * three times before an exception is thrown. Request retrying is a very
     * good way to create robust Ajax applications. In many cases, even with
     * good connections requests time out.
     * @param {Object}  extra      the information object given as a third
     *                             argument of the http request callback.
     * @param {Number}  state      the return code of the http request.
     *   Possible values:
     *   apf.SUCCESS  the request was successfull
     *   apf.TIMEOUT  the request has timed out.
     *   apf.ERROR    an error has occurred while making the request.
     *   apf.OFFLINE  the request was made while the application was offline.
     * @param {AmlNode} [amlNode]    the element receiving the error event.
     * @param {Error}   [oError]     the error to be thrown when the request is
     *                               not retried.
     * @param {Number}  [maxRetries] the number of retries that are done before
     *                               the request times out. Default is 3.
     */
    this.retryTimeout = function(extra, state, amlNode, oError, maxRetries){
        if (state == apf.TIMEOUT
          && extra.retries < (maxRetries || apf.maxHttpRetries))
            return extra.tpModule.retry(extra.id);

        oError = oError || new Error(apf.formatErrorString(0,
            this, "Communication " + (state == apf.TIMEOUT
                ? "timeout"
                : "error"), "Url: " + extra.url + "\nInfo: " + extra.message));

        if ((amlNode || apf).dispatchEvent("error", apf.extend({
            error   : oError,
            state   : state,
            bubbles : true
        }, extra)) === false)
            return true;
    };

    /**
     * Removes the item from the queue. This is usually done automatically.
     * However when the callback returns true the queue isn't cleared, for instance
     * when a request is retried. The id of the call
     * is found on the 'extra' object. The third argument of the callback.
     * Example:
     * <code>
     *  http.clearQueueItem(extra.id);
     * </code>
     * @param {Number} id the id of the call that should be removed from the queue.
     */
    this.clearQueueItem = function(id){
        if (!this.queue[id])
            return false;

        
        clearInterval(this.queue[id].timer);
        

        if (apf.releaseHTTP)
            apf.releaseHTTP(this.queue[id].http);

        this.queue[id] = null;
        delete this.queue[id];

        return true;
    };

    /**
     * Retries a call based on it's id. The id of the call is found on the
     * 'extra' object. The third argument of the callback.
     * Example:
     * <code>
     *  function callback(data, state, extra){
     *      if (state == apf.TIMEOUT && extra.retries < apf.maxHttpRetries)
     *          return extra.tpModule.retry(extra.id);
     *
     *      //Do stuff here
     *  }
     * </code>
     * @param {Number} id the id of the call that should be retried.
     */
    this.retry = function(id){
        if (!this.queue[id])
            return false;

        var qItem = this.queue[id];

        
        clearInterval(qItem.timer);
        

        
        apf.console.info("[HTTP] Retrying request [" + id + "]", "teleport");
        

        qItem.retries++;
        this.get(qItem.url, qItem.options);

        return true;
    };

    /**
     * see {@link teleport.http.method.clearqueueitem}
     */
    this.cancel = function(id){
        if (id === null)
            id = this.queue.length - 1;

        if (!this.queue[id])
            return false;

        //this.queue[id][0].abort();
        this.clearQueueItem(id);
    };

    if (!this.$loadAml && !this.instantiate && !this.call) {
        /**
         * @private
         */
        this.$loadAml = function(x){
            var receive = this["receive"];

            for (var i = 0, l = this.childNodes.length; i < l; i++) {
                if (this.childNodes[i].nodeType != 1)
                    continue;

                var url      = this.childNodes[i].getAttribute("url"),
                    callback = self[this.childNodes[i].getAttribute("receive") || receive],
                    options  = {
                        useXML  : this.childNodes[i].getAttribute("type") == "XML",
                        async   : !apf.isFalse(this.childNodes[i].getAttribute("async"))
                    };

                this[this.childNodes[i].getAttribute("name")] = function(data, userdata){
                    options.userdata = userdata;
                    options.data     = data;
                    return this.get(url, options);
                }
            }
        };

        /**
         * @private
         */
        this.instantiate = function(x){
            var url     = x.getAttribute("src"),
                options = {
                    async   : x.getAttribute("async") != "false",
                    nocache : true
                };

            this.getURL = function(data, userdata){
                options.data     = data;
                options.userdata = userdata;
                options.callback = this.callbacks.getURL;
                return this.get(url, options);
            }

            var name = "http" + Math.round(Math.random() * 100000);
            apf.setReference(name, this);

            return name + ".getURL()";
        };

        /**
         * @private
         */
        this.call = function(method, args){
            this[method].call(this, args);
        };
    }
};



apf.Init.run("http");


/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/teleport/iframe.js)SIZE(5748)TIME(1265038748)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*
 * This object create a compatibility layer for environments where the
 * native XMLHttpRequest object isn't available. It fall backs on an iframe for
 * it's communication
 */
apf.USEIFRAME = false;
/**
 * @private
 */
function runTpIframe(){
    function XMLHttpRequest(){
        this.$uniqueId = apf.all.push(this);
        var _self     = this;
        
        if (apf.USEIFRAME) {
            this.iframe = document.body.appendChild(document.createElement("iframe"));
            //this.iframe.style.display = "none";
            this.iframe.style.width  = "400px";
            this.iframe.style.height = "300px";
            this.iframe.style.position = "absolute";
            this.iframe.style.left = "0";
            this.iframe.style.top = "0";
            this.iframe.style.zIndex = 1000000000;
            document.body.style.display = "block";
        }
        else {
            var xml = document.body.appendChild(document.createElement("xml"));
            this.xmlDocument = xml.XMLDocument;
            this.xmlDocument.setProperty("SelectionLanguage", "XPath");
            document.body.removeChild(xml);
        }
        
        this.readyState   = 0;
        this.status       = null;
        this.responseText = null;
        this.responseXML  = null;
    
        this.setRequestHeader = function(){
            //Not supported
        }
        
        this.send = function(){
            this.done = false;
            if (apf.USEIFRAME) 
                this.iframe.src = this.url;
            else 
                this.xmlDocument.load(this.url);
        }
        
        this.open = function(protocol, url, async){
            this.method = protocol;
            this.url      = url;
            this.async    = async;
            
            if (apf.USEIFRAME) {
                if (!async) 
                    throw new Error(apf.formatErrorString(1081, null, "Iframe callback", "Compatibility mode prevents possibility of non-async calls"));
                this.iframe.onload = stateChangeHandlerIframe;
                //onreadystatechange
                //onerror
            }
            else {
                this.xmlDocument.async = async;
                this.xmlDocument.onreadystatechange = stateChangeHandler;
            }
        }
        
        this.abort = function(){
            if (apf.USEIFRAME) {
                this.iframe.onreadystatechange = null;
                this.iframe.src = "about:blank";
                _self.done = false;
                _self.readyState = "";
            }
            else 
                this.xmlDocument.abort();
        }
        
        var me = this;
        function stateChangeHandler(){
            me.receive();
        }
        
        this.receive = function(){
            this.readyState = this.xmlDocument.readyState;
            
            if (this.readyState == 4) {
                this.status       = 200;
                this.responseText = this.xmlDocument.responseText || this.xmlDocument.xml;
                this.responseXML  = this.xmlDocument;
           }
            
            if (this.onreadystatechange) 
                this.onreadystatechange();
        }
        
        function stateChangeHandlerIframe(){
            if (_self.done) // || _self.readyState != "complete") 
                return;
            _self.done = true;
            _self.receiveIframe();
        }
        
        this.receiveIframe = function(){
            var strXml = this.iframe.contentWindow.document.body.innerText;
            strXml     = strXml.replace(/^- /gm, "");
            
            try {
                this.responseXML = apf.getXmlDom(strXml);
                this.responseXML.setProperty("SelectionLanguage", "XPath");
                this.responseXML.loadXML(strXml);
            }
            catch (e) {
                this.responseXML = null;
            }
            this.responseText = this.responseXML ? this.responseXML.xml : strXml;
            this.status       = 200;
            this.readyState   = 4;
            
            if (this.onreadystatechange) 
                this.onreadystatechange();
        }
    }
    
    function getDOMParser(message, no_error){
        var xml = document.body.appendChild(document.createElement("xml"));
        var xmlParser = xml.XMLDocument;
        document.body.removeChild(xml);
        
        xmlParser.setProperty("SelectionLanguage", "XPath");
        if (message) 
            xmlParser.loadXML(message);
        if (!no_error) 
            apf.xmlParseError(xmlParser);
        
        return xmlParser;
    }
}



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/draw/vml.js)SIZE(20284)TIME(1265021705)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.draw.vml = {
   //----------------------------------------------------------------------
    
    // initialization
    
    //----------------------------------------------------------------------
     
    initRoot : function(r){
        // Note to microsoft: !@#$&(@#*& you destroyed VML performance on purpose didnt you. Get people to go silverlight. 
        if(!apf.isIE8){
            apf.importCssString("v\\:fill {behavior: url(#default#VML);display:inline-block} v\\:stroke {behavior: url(#default#VML);} v\\:shape {behavior: url(#default#VML);} v\\:path {behavior: url(#default#VML);}");
            r.$int.innerHTML = "\
                <div style='z-index:10000;position:absolute;left:0px;width:0px;\
                            background:url(images/spacer.gif);width:"+
                            r.width+"px;height:"+r.height+"px;'>\
                </div>\
                <div style='margin: 0 0 0 0;padding: 0px 0px 0px 0px; \
                            position:absolute;display:inline-block;left:0;top:0;width:"+
                            r.width+'px;height:'+r.height+
                            "px;overflow:hidden;'>\
                </div>";
            r.vmlroot = r.$int.lastChild;
       } else {
            r.$int.innerHTML = "\
                <div style='z-index:10000;position:absolute;left:0px;width:0px;\
                            background:url(images/spacer.gif);width:"+
                            r.width+"px;height:"+r.height+"px;'>\
                </div>\
                <iframe style='margin:0 0 0 0;padding:0 0 0 0;background:transparent; \
                            position:absolute;border:0px;display:inline-block;left:0;top:0;width:"+
                            r.width+'px;height:'+r.height+
                            "px;overflow:hidden;'>\
                </iframe>";
            r.vmliframe = r.$int.lastChild;
            r.vmliframe.allowTransparency=true;
            var doc = r.vmliframe.contentWindow.document;
            doc.open();
            doc.writeln("<head><meta http-equiv='X-UA-Compatible' content='IE=EmulateIE7' /></head>\
                        <style>v\\:fill {behavior: url(#default#VML);display:inline-block} v\\:stroke {behavior: url(#default#VML);}\
                        v\\:shape {behavior: url(#default#VML);} v\\:path {behavior: url(#default#VML);}</style>\
                        <html><body style='margin: 0 0 0 0;padding: 0 0 0 0;border: 0px;background:transparent;'>\
                        <div style='position:absolute;display:inline-block;'></div></body></html>");
            doc.close();
            r.vmlroot = doc.body.firstChild;
      }
      //  var div = r.vmlroot.document.createElement("div");
      //  div.innerHTML = "EHLLO";
      //  r.vmlroot.document.body.appendChild(div);
//        var doc = r.vmlroot.contentWindow.document.innerHTML="<body style='background:red'>WHEEE</body>";
//        alert();
        return this;
    },
    resizeRoot : function(r){
        var t = r.vmliframe || r.vmlroot;
        t.style.width = r.width;
        t.style.height = r.height;
        t = t.previousSibling;
        t.style.width = r.width,
        t.style.height = r.height;
        if(r.vmliframe){
            t = r.vmlroot;
            t.style.width = r.width;
            t.style.height = r.height;
        }
	},
    initLayer : function(l , r){
  //      var vmlroot = r.vmlroot;
        l.ds = 1;
        l.dx = 0,l.dy = 0;
        l.dw = parseFloat(l.width)*l.ds;
        l.dh = parseFloat(l.height)*l.ds;

        l._styles       = [];
        l._htmljoin     = [];
        l._vmlroot     = r.vmlroot;
//        l._vmlgroup    = vmlgroup;
    },

    resizeLayer : function(l, r){
        // update layer position, and perhaps z-order or all items in a _vmlgroup.
        var lx,ly,lw,lh,t;
        l.dx = 0, l.dy = 0;
        l.dw = parseFloat(lw=l.width)*l.ds;
        l.dh = parseFloat(lh=l.height)*l.ds;
        var coord = (l.dw+1)+","+(l.dh+1);
        if(l._vmlgroup){
            (t=l._vmlgroup).style.left=lx=l.left,t.style.top=ly=l.top,t.style.width=lw,t.style.height=lh;
            for(var n = l._vmlgroup.childNodes, l = n.length, i = 0;i<l;i++){
                (t=n[i]).style.width = lw, t.style.height = lh;
                if(t.coordsize){
                    t.coordsize = coord;
                }
            }
        }
    },

    deinitLayer : function(l){
        // we should remove the layer from the output group.
        if(l._vmlgroup){
            l._vmlgroup.removeNode();
            l._vmlgroup = 0;
        }
    },

    beginLayer : function(l){
		// if we already had a layer, we need to clean that shit up
		if(l._styles.length){
            if(l._vmlgroup)l._vmlgroup.innerHTML="";
            l._styles = [];
            l._htmljoin = [];
		}
		
        this.l = l,this.mx="",this.my="",this.last=null;
        return [ this.jssVars,
                "if(!l._styles)_initStyles();",
                "var _s1,_s2,_s3,_s4,_s5,_s6,_s7,_s8,_s9,_st,_su,_sv,",
                "_x1,_x2,_x3,_x4,_x5,_x6,_x7,_x8,_x9,_x10,",
                "_y1,_y2,_y3,_y4,_y5,_y6,_y7,_y8,_y9,_y10,",
                    "_t,_u,_l,_dx,_dy,_tn,_tc,_lc,_s,_p,",
                   "_styles = l._styles;"
        ].join('');
    },

    clear : function(){
        return '';
    },
    
    // create layer init code in output 
    endLayer : function(){
        var l = this.l;
        var s = [this.$endDraw()], k, h, v, f;
        var p = [];
        var i = 0, j = 0,style,len = l._styles.length;
        for(;i<len;i++){
            style = l._styles[i];
            if(style._prev===undefined){ // original style
                p.push("_styles[",i,"]={",
                       "_domnode:_n=l._vmlgroup.childNodes[",j,"]");
                if(style.$stylelist){
                    p.push(",",apf.draw.serializeStyleState(style))
                }
                if(style.isshape){
                    s.push(this.$finalizeShape(style));
                    p.push(",_vmlfill:_n.lastChild?_n.lastChild.previousSibling:0,_vmlstroke:_n.lastChild");
                }else{
                    p.push(",_txtused:0,_txtcount:0,_txtnodes:[],_txtdiv:\"",style._txtdiv,"\"");
                    s.push(this.$finalizeFont(style));
                 }
               p.push("};");  j++;
            }
        }
       
        s.push( [
            "l._anim = _anim;",
            "function _initStyles(){",
                "l._vmlroot.insertAdjacentHTML('beforeend',[",
                "\"<div style='position:absolute;display:inline-block;left:\",l.left,\"",
                              "px;top:\",l.top,\"px;width:\",l.width,\"px;height:\",l.height,\"",
                              "px;overflow:hidden;'>\",",
                "\"",l._htmljoin.join(''),"\",",
                "\"</div>\"].join(''));",
                "l._vmlgroup = l._vmlroot.lastChild;",
                "var _n, _styles = l._styles = [];",
                p.join(''),
            "};"
        ].join(''));
        l._styles = null;
        this.l = null;
        return s.join('');
//       alert(l._htmljoin.join(''));
    },
    
    //----------------------------------------------------------------------
    
    // Shape rendering
    
    //----------------------------------------------------------------------

    beginShape : function(style) {
        if(!style)return "document.title='beginShape Failed';";
        var l=this.l, html = l._htmljoin, i, t,
            shape=[], path=[], child=[], opacity="", s=[this.$endDraw()];
        style._path = [];
        if(style._id === undefined){
            style._id = l._styles.push(style)-1;
        }
        this.style = style;

        // find a suitable same-styled other shape so we minimize the VML nodes
        for(i = l._styles.length-2;i>=0;i--){
            if(!l._styles[i]._prev && 
                this.$canJoin( t=l._styles[i], style )){
                style._prev = (t._prev !== undefined)?t._prev:i;
                break;
            }
        }       

        if(style._prev === undefined) {
            s.push("_p=(_s=_styles[",style._id,"])._path=[];");
            // lets check the style object. what different values do we have?
            if(typeof style.tile != 'undefined'){
                var fillopacity = style.fillopacity;
                if( this.isDynamic(fillopacity) ){
                    fillopacity = '1';
                    s.push("_s._vmlfill.opacity=",style.fillopacity,";");
                };
                if(this.isDynamic(style.tile)){
                    s.push("if(_s._vmlimg!=(_t=",style.tile,"))_s._vmlfill.src=_t;");
                    child.push("<v:fill origin='0,0' position='0,0' opacity='",fillopacity,
                                "' src='' type='tile'/>"); 
                }else{
                    child.push("<v:fill origin='0,0' position='0,0' opacity='",fillopacity,
                         "'  src='",style.tile,"' type='tile'/>"); 
                    if(style.tilex || style.tiley){
                        style._img = new Image(); style._img.src = style.tile;
                        if(style.tilex)
                            s.push("_s._vmlfill.origin.x=((_t=((",
                                style.tilex,")/(_s._img.width))%1)<0?1+_t:_t);");
                        if(style.tiley)
                            s.push("_s._vmlfill.origin.y=((_t=((",
                                style.tiley,")/_s._img.height)%1)<0?1+_t:_t);");
                    }
                }
                s.push("_p.push('m',_dx=-_s._img.width*100,' ',_dy=-_s._img.height*100,",
                       "',l',_dx,' ',_dy);");
            }else
            if(style.fill !== undefined){
                // check if our fill is dynamic. 
                var fill = style.fill, fillopacity = style.fillopacity,
                    angle = style.angle, gradopacity = style.gradopacity;
                if(!fill.sort)fill=[fill];
                var len = fill.length;
                var color='black', colors, color2, getColorors;
                // precalc the colors value, we might need it later
                if(len>2){
                    for(i=1;i<len-1&&!this.isDynamic(fill[i]);i++);
                    if(i!=len-1){ // its dynamic
                        for(t=[],i=1;i<len-1;i++)
                            t.push(i>1?'+",':'"',Math.round((i/(len-1))*100),'% "+',
                              this.getColor(fill[i]));
                        colors = t.join('');
                        getColorors = 1;
                    }else{
                        for(t=[],i=1;i<len-1;i++)
                            t.push(i>1?',':'',Math.round((i/(len-1))*100),'% ',fill[i]);
                        colors = t.join(''); 
                    }
                }
                if(len>1){
                    // we have a gradient
                    if( this.isDynamic(gradopacity) || this.isDynamic(fillopacity)){
                        // hack to allow animated opacitys for gradients. There is no o:opacity2 property unfortunately
                        if(gradopacity == fillopacity)fillopacity='_t='+fillopacity,gradopacity='_t';
                        if(len>2)t=gradopacity,gradopacity=fillopacity,fillopacity=t;
                        s.push(
                          "if(_s._vmldata!=(_t=", 
                           "[\"<v:fill opacity='\",(",fillopacity,"),\"' method='none' ",
                           "o:opacity2='\",",gradopacity,",\"' color='\",",
                           this.getColor(fill[0]),",\"' color2='\",",
                           this.getColor(fill[len-1]),",\"' type='gradient' angle='\",parseInt(((",
                           angle,")*360+180)%360),\"' ", colors?(getColorors?"colors='\","+
                           colors+",\"'":"colors='"+colors+"'"):"",
                           "/>\"].join(''))){",
                           "_s._domnode.removeChild(_s._vmlfill);",
                           "_s._domnode.insertAdjacentHTML( 'beforeend',_s._vmldata=_t);",
                           "_s._vmlfill = _s._domnode.lastChild;};");
                        child.push("<v:fill opacity='0' color='black' type='fill'/>");
                    }else{
                        if(len>2)t=gradopacity,gradopacity=fillopacity,fillopacity=t;
                        if( this.isDynamic(fill[0]) )
                            s.push("_s._vmlfill.color=",this.getColor(fill[0]),";");
                        else color = fill[0];

                        if(this.isDynamic(fill[len-1]))
                            s.push("_s._vmlfill.color2=",
                                this.getColor(fill[len-1]),";");
                        else color2 = fill[len-1];
                        
                        if(getColorors){
                          s.push("_s._vmlfill.colors.value=",colors,";");
                        }
                        if( this.isDynamic(angle) ){
                            angle = '0';
                            s.push("_s._vmlfill.angle=(((",style.angle,")+180)*360)%360;");
                        };
                        if( this.isDynamic(fillopacity) ){
                            fillopacity = '1';
                            s.push("_s._vmlfill.opacity=",style.fillopacity,";");
                        };
                        child.push("<v:fill opacity='",
                            fillopacity,"' method='none' o:opacity2='",
                            gradopacity,colors?"' colors='"+colors+"'":"",
                            "' color='",color,"' color2='",color2,
                            "' type='gradient' angle='",(angle*360+180)%360,"'/>");
                    }
                }else{
                    if( this.isDynamic(fillopacity) ){
                            fillopacity = '1';
                            s.push("_s._vmlfill.opacity=",style.fillopacity,";");
                    };
                    if( this.isDynamic(fill[0]) ){
                        s.push("_s._vmlfill.color=",this.getColor(fill[0]),";");
                    }else color = fill[0];
                
                    child.push("<v:fill opacity='",fillopacity,
                        "' color=",this.getColor(color)," type='fill'/>");
                }
                shape.push("fill='t'"),path.push("fillok='t'");
            } else {
                shape.push("fill='f'"),path.push("fillok='f'");
            }
            if(style.stroke !== undefined){
                var weight = style.weight,
                    opacity = style.strokeopacity,
                    stroke = style.stroke;
                if( this.isDynamic(opacity) ){
                        opacity = '1';
                        s.push("_s._vmlstroke.opacity=",style.opacity,";");
                }
                if( this.isDynamic(weight) ){
                        weight = '1';
                        s.push("_t=",style.weight,
                            ";_s._vmlstroke.weight=_t;if(_t<",opacity,
                            ")_s._vmlstroke.opacity=_t;");
                }
                if( this.isDynamic(stroke) ){
                        stroke = 'black';
                        s.push("_s._vmlstroke.color=",this.getColor(style.stroke),";");
                }
                    
                //@todo @rik please check this I changed getColor(stroke) to getColor(stroke.dataType == apf.ARRAY ? stroke[0] : stroke)
                child.push("<v:stroke opacity='",
                    weight<1?(opacity<weight?opacity:weight):opacity,
                    "' weight='",weight,"' color=",this.getColor(stroke.dataType == apf.ARRAY ? stroke[0] : stroke),"/>");
            } else {
                shape.push("stroke='f'"), path.push("strokeok='f'");
            }
                    
            html.push(["<v:shape alignshape='f' ",
                      "style='position:absolute;display:inline-block;left:0;top:0;width:",
                      "\",l.width,\"px;height:\",l.height,\"px;overflow:hidden;' ",
                      "coordorigin='0,0' coordsize='\",(l.dw+1),\",\",(l.dh+1),\"'",
                      "path='' ",shape.join(' '),"><v:path ",
                    path.join(' '),"/>",child.join(' '),"</v:shape>"].join(''));
        }else{
            if(style._prev !== undefined){
                if(this.last !== style._prev)
                    s.push("_p=(_s=_styles[",style._prev,"])._path;");
            }    
        }
        //alert(html.join(''));
        return s.join('');
    },
       
    // drawing command
    moveTo : function(x, y){
        return ["_p.push('m',__round(",x,")",
               ",' ',__round(",y+"),'l');\n"].join('');
    },
    
    lineTo : function(x, y){
        return ["_p.push(__round(",x,")",
               ",' ',__round("+y+"));\n"].join('');
    },
    
    lineH : function(x,y,w){
        return ["_p.push('m',__round(",x,")",
                ",' ',__round(",y,")",
                ",'r',__round(",w,"),' 0');"].join('');
    },
    
    lineV : function(x,y,h){
        return ["_p.push('m',__round(",x,")",
                ",' ',__round(",y,")",
                ",'r0 ',__round(",h,"));"].join('');
    },
    
    dot : function(x,y){
        return ["_p.push('m',__round(",x,")",
                ",' ',__round(",y,")",
                ",'r0 0');"].join('');
    },
    
    rect : function( x,y,w,h,inv ){
        return ["_u=",x,";if((_t=__round(",w,"))>0)_p.push('m',__round(_u),' ',__round(",y,")",
                ",'r',_t,' 0r0 ',__round(",h,
                inv?"),'r-'+_t,' 0x');":"),'r-'+_t,' 0xe');"].join('');
    },

    ellipse : function( x,y,w,h,s,e,c){
       if(!s){
        return ["_p.push('at ',(_x1=__round(",x,"))-(_x2=__round(",w,
                ")),' ',(_y1=__round(",y,"))-(_y2=__round(",h,")),' ',",
                "_x1+_x2,' ',_y1+_y2,' 0 0 0 0');"].join('');
       }else{ // generate heaps of crap
        return ["if( (_t=",s,")+0.000001<(_u=",e,")){",
                "_p.push('",c?"wa":"at"," ',(_x1=__round(",x,
                "))-(_x2=__round(",w,")),' ',(_y1=__round(",y,
                "))-(_y2=__round(",h,")),' ',_x1+_x2,' ',_y1+_y2,' ',",
                "__round(_x1+__sin(_t)*_x2*4000),' ',",
                "__round(_y1+__cos(_t)*_y2*4000),' ',",
                "__round(_x1+__sin(_u)*_x2*4000),' ',",
                "__round(_y1+__cos(_u)*_y2*4000),'x');}else{",
                "_p.push('l',__round((",x,")+__sin(_t)*(",w,
                ")),' ',__round((",y,")+__cos(_t)*(",h,")),'x');",
                "}",
                ].join('');
       }
       /*
       
       return ["_p.push('al ',_x1=__round(",x,"),' ',_y1=__round(",y,"),' ',",
               "_x1+__round(",w,"),' ',_y1+__round(",h,"),' 90 1024');"].join('');*/
    },

    
    rectInv : function( x,y,w,h ){
        return this.rect(x,y,w,h,1);
    },
    
    close : function (){
        return "_p.push('xe');";
    },
      
    $endShape : function(){
        this.mx="",this.my="";
        this.last = this.style._id;
        this.style = 0;    
        return '';
    },
      
    $finalizeShape : function(style){
        return ["if((_s=_styles[",style._id,"])._pathstr!=(_t=",
            "(_p=_s._path).length?_p.join(' '):'m'))_s._domnode.path=_t;\n"].join('');
    }
           
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/draw/canvas.js)SIZE(21818)TIME(1257329186)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.draw.canvas = {
   
   //----------------------------------------------------------------------
    
    // initialization
    
    //----------------------------------------------------------------------
     
    initRoot : function(r){
                  
        var canvas = document.createElement("canvas");
        canvas.setAttribute("width",r.canvaswidth = r.width);
        canvas.setAttribute("height",r.canvasheight = r.height);
        canvas.className = "canvas";        
        r.$int.appendChild(canvas);
        r.canvaselem = canvas;
		r.canvas = canvas.getContext('2d');
        r.canvas.translate(0.5,0.5);
        r.imgcache = {};
        return this;
    },
     
    resizeRoot : function(r){
	   r.canvaselem.setAttribute("width",r.width);
	   r.canvaselem.setAttribute("height",r.height);
	   for(var n = r.canvaselem.nextSibling;n != null;n = n.nextSibling){
           n.style.width = r.width+'px', n.style.height = r.height+'px';
       }
	},
	
    initLayer : function(l, r){ 
        l.imgcache 	= r.imgcache;
        l.canvas 	= r.canvas;
        l.textroot  = r.$int;
        l.dx = l.left;
        l.dy = l.top;
        l.dw = l.width;
        l.dh = l.height;
        l.ds = 1;
       
        l._styles = [];
        l._htmljoin = [];
        return this;
    },
    
    resizeLayer : function(l, r){
        // update layer position, and perhaps z-order or all items in a _vmlgroup.
        l.dx = l.left; 
		l.dy = l.top;
        l.dw = l.width;
        l.dh = l.height;
    },

    destroyLayer : function(l){
        // lets clear our shite up
    },

    beginLayer : function(l){
        this.l = l,this.mx="",this.my="",this.last=null; this.tiletrans = 0;
        this.dodraw = 0;
        // check if we have styles.. ifso clean that shit up
        if(l._styles.length){
            for(var j = l._styles.length,i=0;i<j;i++){
                var s = l._styles[i];
                if(s._txtnode)s._txtnode.removeNode();
            }
            l._styles = [];
            l._htmljoin = [];
        }
        var s =  [ "if(!l._styles)_initStyles();",
                 "var _c=l.canvas,_styles=l._styles,",
                "_s1,_s2,_s3,_s4,_s5,_s6,_s7,_s8,_s9,",
                "_x1,_x2,_x3,_x4,_x5,_x6,_x7,_x8,_x9,_x10,",
                "_y1,_y2,_y3,_y4,_y5,_y6,_y7,_y8,_y9,_y10,",
                "_s,_sh,_sp,_sl,_sv,_su,_st,_dx,_dy,_td,_l,_lc,",
                "_tc,_cv,_t,_u,_r,_q,_o,_m,_sr,_cr;"];
        if ( l.dx != 0 )s.push(
            "_c.save();_c.beginPath();_c.translate(l.dx,l.dy);",
            "_c.moveTo(0,0);_c.lineTo(l.dw,0);_c.lineTo(l.dw,l.dh);",
            "_c.lineTo(0,l.dh);_c.closePath();_c.clip();\n");
        return s.join('');
    },    
    clear : function(){
        var l = this.l;
        var s = ["_c.clearRect(l.dx,l.dy,l.dw,l.dh);\n"];
/*        if ( l.dx != 0 )s.push(
            "_c.save();_c.beginPath();_c.translate(",l.dx,",",l.dy,");",
            "_c.moveTo(0,0);_c.lineTo(",l.dw,",0);_c.lineTo(",l.dw,",",l.dh,");",
            "_c.lineTo(0,",l.dh,");_c.closePath();_c.clip();\n");*/
        return s.join('');
    },

    endLayer : function(){
        var l = this.l;
        var s = [this.$endDraw()];
        var p = [];
        var i = 0, j = 0,style,len = l._styles.length;
        for(;i<len;i++){
            style = l._styles[i];
            if(style._prev===undefined && style.isfont){ // original style
                p.push("_styles[",i,"]={",
                    "_domnode:_n=l.textroot.childNodes[b+",j,"]",
                    ",_txtused:0,_txtcount:0,_txtnodes:[],_txtdiv:\"",style._txtdiv,"\"");
                s.push(this.$finalizeFont(style));
                p.push("};");  j++;
            }else {
                p.push("_styles[",i,"]={");
                if(style.$stylelist){
                    p.push(apf.draw.serializeStyleState(style));
                }
                p.push("};");
            }    
        }
        s.push( [
            "l._anim = _anim;",
            "function _initStyles(){",
                "var _n, _styles = l._styles = [], b=l.textroot.childNodes.length;",
                "l.textroot.insertAdjacentHTML('beforeend', \"",l._htmljoin.join(''),"\");",
                p.join(''),
            "}"
        ].join(''));
        if( l.dx != 0)s.push("_c.restore();");
        l._styles = null;
        this.l = null;
        return s.join('');
        /*
        var s = [this.$endDraw()], 
            html = l.textroot, j = html.childNodes.length,
            i = 0, len = l._styles.length;

        html.insertAdjacentHTML( 'beforeend', l._htmljoin.join('') );

        for(;i<len;i++){
            var style = l._styles[i];
            if(style._prev===undefined && style.isfont){
                style._txtnode =  html.childNodes[j++];
                s.push(this.$finalizeFont(style));
            }
        }
         s.push("l._anim = _anim;");
        if( l.dx != 0)s.push("_c.restore();");
        this.l = null;
        return s.join('');
        */
    },
    
    //----------------------------------------------------------------------
    
    // Shape rendering
    
    //----------------------------------------------------------------------

    beginShape : function( style, ml,mt,mr,mb){
        //aight lets set the style, if we have a previous style we should diff
        var pstyle = (this.style && this.style.isshape)?this.style:
                           {fill:"-",gradient:"-",angle:"-",stroke:"-",
                            fillopacity:"-",strokeopacity:"-",weight:"-"}; 
                            
        var s = [this.$endDraw(),"_c.beginPath();"], l = this.l;
        // if we have an ml,mt,mr and mb we need to insert a clipping path.
        this.style = style;
        if(style._id === undefined){
            style._id = l._styles.push(style)-1;
        }
        
        s.push("_s=_styles[",style._id,"];");
        
        if(ml !== undefined && ml!=''){
            this._clip = 1;
            s.push("_c.save();_c.moveTo(",ml,",",mt,");_c.lineTo(l.dw-",mr,
                    ",",mt,");_c.lineTo(l.dw-",mr,",l.dh-",mb,");",
                    "_c.lineTo(",mt,",l.dh-",mb,");_c.closePath();_c.clip();",
                    "_c.beginPath();\n");
        }else this._clip = 0;
        
        var a ,g, i, fillmode=0, fill = style.fill;
        if( style.tile!== undefined ) {
            var tilemove="";
            if(style.tilex || style.tiley){
                tilemove=["_dx=__round(",(style.tilex||'0'),
                    ")%((_s._img&&_s._img.width)?_s._img.width:1),",
                    "_dy=__round(",(style.tiley||'0'),
                    ")%((_s._img&&_s._img.height)?_s._img.height:1);",
                     "_c.save();_c.translate(-_dx,-_dy);"].join('');
                this.tiletrans =1,this.mx="+_dx",this.my="+_dy";
            }
            
            fillmode |= 1;
            // lets do a nice inline tile image cachin
            if(this.isDynamic(style.tile)){
                if(apf.isGecko && style.fillopacity != 1){
                    if(this.isDynamic(style.fillopacity)){
                         s.push(
                        "if(!(_u=l.imgcache[_t=",style.tile,"])){",
                            "l.imgcache[_t]=_u=new Image();",
                            "_u.onload=function(){",
                               "_u._canvas = document.createElement('canvas');",
                               "_u._canvas.setAttribute('width', _u.width);",
                               "_u._canvas.setAttribute('height', _u.height);",
                               "_u._ctx = _u._canvas.getContext('2d');",
                               "_u.onload=null;",
                            "};",
                            "_u.src=_t;",
                         "}",
                         "if(_u && !_u.onload && _u._opacity !== (_q=",style.fillopacity,")){",
                            "_u._ctx.clearRect(0,0,_u.width,_u.height);",
                            "_u._ctx.globalAlpha=_u._opacity=_q;",
                            "_u._ctx.drawImage(_u,0,0);",   
                            "_s._pattern=l.canvas.createPattern(_u._canvas,",
                                                                  "'repeat');",
                         "}",
                         "if(_t=_s._pattern)_c.fillStyle=_t;\n",tilemove);
                    }else{
                        s.push(
                        "if(!(_u=l.imgcache[_t=",style.tile,"])){",
                            "l.imgcache[_t]=_u=new Image();",
                            "_u.onload=function(){",
                               "_u._canvas = document.createElement('canvas');",
                               "_u._canvas.setAttribute('width', _u.width);",
                               "_u._canvas.setAttribute('height', _u.height);",
                               "_u._ctx = _s._canvas.getContext('2d');",
                               "_u._ctx.globalAlpha="+style.fillopacity+";"+
                               "_u._ctx.drawImage(_u,0,0);",
                               "_u._pattern=l.canvas.createPattern(_u._canvas,'repeat');",
                               "_u.onload=null;",
                            "};",
                            "_u.src=_t;",
                         "}",
                         "if(_u && !_u.onload && _u!=_s._img){",
                             "_s._img=_u,_s.pattern=_u._pattern;",
                         "}",
                         "if(_t=_s._pattern)_c.fillStyle=_t;\n",tilemove);
                    }
                }else{
                    s.push(
                    "if(!(_u=l.imgcache[_t=",style.tile,"])){",
                        "l.imgcache[_t]=_u=new Image();",
                        "_u.onload=function(){",
                           "_u.onload=null;",
                           "_u._pattern=l.canvas.createPattern(_u,'repeat');",
                        "};",
                        "_u.src=_t;",
                     "}",
                     "if(_u && !_u.onload && _u!=_s._img){",
                       "_s._img=_u,_s.pattern=_u._pattern;",
                     "}",
                     "if(_t=_s._pattern)_c.fillStyle=_t;\n",tilemove);
                }
            }
            else{
                if(l.imgcache[style.tile]){
                    style._pattern = l.canvas.createPattern(l.imgcache[style.tile],
                                "repeat");
                }else{
                    var img = new Image();
                    img.onload = function(){
                        // we should use a canvas object to do some transparency
                        style._img = img;

                        // Dirty hack to make gecko support transparent tiling
                        if(apf.isGecko && style.fillopacity != 1){
                            style._canvas = document.createElement("canvas");
                            style._canvas.setAttribute("width", img.width);
                            style._canvas.setAttribute("height", img.height);
                            style._ctx = style._canvas.getContext('2d');
                            // check if we have dynamic opacity
                            if(!apf.draw.isDynamic(style.fillopacity)){
                                style._ctx.globalAlpha=style.fillopacity;
                                style._ctx.drawImage(img,0,0);
                            }
                            style._pattern = l.canvas.createPattern(style._canvas,
                                "repeat");
                        }else{
                            style._pattern = l.canvas.createPattern(style._img=this,
                                "repeat");
                        }
                    }
                    
                    // Dirty hack to make gecko support transparent tiling                    
                    if(apf.isGecko && this.isDynamic(style.fillopacity)){
                        s.push("if(_s._ctx){",
                               "_s._ctx.clearRect(0,0,_s._img.width,_s._img.height);",
                               "_s._ctx.globalAlpha=",style.fillopacity,";",
                               "_s._ctx.drawImage(_s._img,0,0);",
                               "_s._pattern=l.canvas.createPattern(_s._canvas,",
                                            "'repeat');}\n");
                    }
                    img.src = style.tile;
               }
                s.push("if(_t=(_s._pattern))_c.fillStyle=_t;",tilemove);
            }
        }else
        if( fill !== undefined ){
            fillmode |= 1;
            if(fill.sort && fill.length<=1)
                fill = fill.length&&fill[0]?fill[0]:'black';
            if( fill.sort ){
                var f = fill, len = f.length;
                for(i=0; i<len && !this.isDynamic(fill[i]);i++);
                if(i!=len || this.isDynamic(style.angle)|| this.isDynamic(style.fillopacity)){
                    s.push("_o=",style.fillopacity,",_r=",style.gradopacity,",_t=_s._colors,_m=0;");
                    for(i=0;i<len;i++){
                        // calculate fillopacity and gradopacity and then interpolate over them through the colorstops
                        if(this.isDynamic(fill[len-i-1])){
                            s.push("if(_t[",i,"]!=(_l=[",
                                "'rgba(',(((_q=parseInt((",this.getColor(fill[len-i-1]),
                                ").slice(1),16))>>16)&0xff),",
                                "',',((_q>>8)&0xff),',',(_q&0xff),',',",
                                "(",i/(len-1),"*_o+",1-(i/(len-1)),"*_r)",
                                ",')'].join(''))",")_t[",i,"]=_l,_m=1;");
                        }else{
                            var t = parseInt((this.colors[fill[len-i-1].toLowerCase()] ||
                                    fill[len-i-1]).slice(1),16);
                            s.push("if(_t[",i,"]!=(_l=",
                                "['rgba(",(t>>16)&0xff,
                                ",",(t>>8)&0xff,",",t&0xff,",',","(",i/(len-1),"*_o+",
                                1-(i/(len-1)),"*_r),')'].join(''))",
                                ")_t[",i,"]=_l,_m=1;");
                        }
                    }
                    s.push("if(_s._angle!=(_u=(",style.angle,")*2*p) || _m){",
                            "_s._grad=_q=_c.createLinearGradient(",
                           "dtx+(__sin(_s._angle=_u)*0.5+0.5)*dw,",
                           "dty+(__cos(_u)*0.5+0.5)*dh,",
                           "dtx+(__sin(p+_u)*0.5+0.5)*dw,",
                           "dty+(__cos(p+_u)*0.5+0.5)*dh);");
                    for(i=0;i<len;i++)
                        s.push("_q.addColorStop(",i/(len-1),",_t[",i,"]);");
                    s.push("_c.fillStyle=_q;}else _c.fillStyle=_s._grad;\n");
                    style._colors=[];
                }else{
                    var g = l.canvas.createLinearGradient(
                        (Math.sin(style.angle)*0.5+0.5)*l.dw,
                        (Math.cos(style.angle)*0.5+0.5)*l.dh,
                        (Math.sin(Math.PI+style.angle)*0.5+0.5)*l.dw,
                        (Math.cos(Math.PI+style.angle)*0.5+0.5)*l.dh 
                    );
                    var u,o = style.fillopacity, r = style.gradopacity;
                    for(i=0;i<len;i++){
                        a = this.colors[a=fill[len-i-1].toLowerCase()] ||
                            fill[len-i-1];
                        g.addColorStop(u=i/(len-1), 
                        'rgba('+(((a=parseInt(a.slice(1),16))>>16)&0xff)+
                        ','+((a>>8)&0xff)+','+((a)&0xff)+','+(u*o+(1-u)*r)+')');
                    }
                    style._gradient = g;
                    s.push("_c.fillStyle=_styles[",style._id,"]._gradient;");
                }
            } else {
                if(this.isDynamic(fill) || pstyle.fill != fill)
                    s.push("_c.fillStyle=",this.getColor(fill),";");
            }
        }
        if(style.stroke!== undefined){
            fillmode |= 2;
            if(this.isDynamic(style.stroke) || pstyle.stroke != style.stroke)
                s.push("_c.strokeStyle=",this.getColor(style.stroke),";");
            
            if(this.isDynamic(style.weight) || pstyle.weight != style.weight)
                s.push("_c.lineWidth=",style.weight,";");
        }
        this.fillopacity = "";
        this.strokeopacity = "";
        this.fillmode = fillmode;
        switch(fillmode){
            case 3:// check if our fillopacity != stroke opacity, ifso we create switches between filling and stroking
            if(style.fillopacity != style.strokeopacity ){
                this.fillopacity ="_c.globalAlpha="+style.fillopacity+";";
                this.strokeopacity ="_c.globalAlpha="+style.strokeopacity+";";
            }else{
                if(this.isDynamic(style.fillopacity) || style.fillopacity != pstyle.fillopacity)
                    s.push("_c.globalAlpha=",style.fillopacity,";");
            }
            break;
            case 2: 
                if(this.isDynamic(style.strokeopacity) || style.strokeopacity != pstyle.strokeopacity)
                    s.push("_c.globalAlpha=",style.strokeopacity,";"); 
               break;
            case 1: 
                if(this.isDynamic(style.fillopacity) || style.fillopacity != pstyle.fillopacity)
                    s.push("_c.globalAlpha=",style.fillopacity,";"); 
                break;
        }
        return s.join('');
    },
    

    
    moveTo : function(x,y){
        // check our mode. if its 3 we need to cache it
        return "_c.moveTo("+x+this.mx+","+y+this.my+");\n";
    },
    lineTo : function(x, y){
        this.dodraw= 1;
        return "_c.lineTo("+x+this.mx+","+y+this.my+");\n";
    },
    lineH : function(x,y,w){
        this.dodraw = 1;
        return ["_c.moveTo(",x,this.mx,",",y,this.my,");",
                "_c.lineTo(",x,this.mx,"+",w,",",y,this.my,");\n"].join('');
    },
    lineV : function(x,y,h){
        this.dodraw = 1;
        return ["_c.moveTo(",x,this.mx,",",y,this.my,");",
                "_c.lineTo(",x,this.mx,",",y,this.my,"+",h,");\n"].join('');
    },    
    dot : function(x,y){
        this.dodraw = 1;
        return ["_c.moveTo(",x,this.mx,",",y,this.my,");",
                "_c.lineTo(",x,this.mx,",",y,this.my,");\n"].join('');
    },
    circle : function( x,y,r,s,e,c ){
        this.dodraw = 1;
        if(!s)s='0'; if(!e)e='p';c=c?1:0;
        return["_c.arc(",x,",",y,",",r,",",s,",",e,",",c,");"].join('');
    },
    ellipse : function(x,y,w,h,s,e,c){
        this.dodraw = 1;
        if(!s) s = '0'; if(!e) e = 'p2';c=c?1:0;
        return["if((_x2=(",w,"))!=0 && (_y2=-(",h,"))!=0){_c.translate(_x1=(",x,"),_y1=(",y,"));_c.scale(_x2,_y2);",
               "_c.arc(0,0,1,(",s,")-1.5707965,(",e,")-1.5707965,",!c,");_c.scale(1/_x2,1/_y2);_c.translate(-_x1,-_y1);}"].join('');
    },
    rect : function( x,y,w,h){
       /*
         if(this.style.outx){
            x=(parseFloat(x)==x)?(parseFloat(x)-this.ox):"("+x+"-"+this.ox+")";
            w=(parseFloat(w)==w)?(parseFloat(w)+2*this.ox):"("+w+"+"+2*this.ox+")";
        }
        if(this.style.outy){
            y=(parseFloat(y)==y)?(parseFloat(y)-this.oy):"("+y+"-"+this.oy+")";
            h=(parseFloat(h)==h)?(parseFloat(h)+2*this.oy):"("+h+"+"+2*this.oy+")";
        }
        */
        switch(this.fillmode){
            case 3: return this.fillopacity+
                            "_c.fillRect(_x1="+x+this.mx+",_y1="+y+this.my+
                            ",_x2="+w+",_y2="+h+");"+
                           this.strokeopacity+
                              "_c.strokeRect(_x1,_y1,_x2,_y2);";
            case 2: return "_c.strokeRect("+x+this.mx+","+y+this.my+","+w+","+h+");\n";
            case 1: return "_c.fillRect("+x+this.mx+","+y+this.my+","+w+","+h+");\n";
        }
    },    
    close : function (){
        return ["_c.closePath();",this.$dodraw()].join('');
    },
    $dodraw : function (){
        this.dodraw = 0;
        switch(this.fillmode){ 
            case 3: return this.fillopacity+"_c.fill();"+
                           this.strokeopacity+"_c.stroke();_c.beginPath();\n";
            case 2: return "_c.stroke();_c.beginPath();\n";
            case 1: return "_c.fill();_c.beginPath();\n";
        }    
    },
    
    $endShape : function(){
        var s = this.dodraw?[this.$dodraw()]:[];
        
        this.mx="",this.my="";
        this.last = this.style._id;
        this.style = 0;
        
        if(this.tiletrans)s.push("_c.restore();");
        this.tiletrans=0;
        if(this._clip)s.push("_c.restore();");
        this._clip = 0;
        return s.join('');
    },
    
    $finalizeShape : function(){
        return '';
    }
        
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/draw/chartdraw.js)SIZE(47182)TIME(1257329186)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */
 


apf.chart_draw = {
    
    _axis2D: {
        margin : {
            left : 30,
            top : 30,
            right : 30,
            bottom :30,
        $:1},
        layout : {
            pow : 10,
            step : 4,
            onsidex : 0,
            onaxisx : 0,
            onsidey : 1,
            onaxisy : 0,
        $:1},
        plane :{
            inherit : 'shape',
            stroke : '#cfcfcf',
            fill : '#e6f1f8',
        $:1},
        plane2 :{
            inherit : 'shape',
        $:1},            
        label : {
            inherit : 'font',
            join : 'label',
            left : 0,
            top : 0,
            format : "fixed(v,1)",
        $:0},
        labelx : {
            inherit : 'label', 
            width: 40,
            top : 5,
            left: -19,
            side: 0, 
            axis: 0, 
            edgeclip : 2,
            align:'center',
        $:1},
        labely : {
            inherit : 'label', 
            left : -110,
            top : -6,
            width: 100,
            side:1, 
            edgeclip : 0,
            align:1?'right':'left',
        $:1},
        grid : {
            inherit : 'shape',
            join : 'grid',
            extend : 0,
            /*stroke : '#cfcfcf',
            weight : 1,
            opacity: 0.3,
            extend : 0,*/
        $:0},
        hgrid : {inherit : 'grid',$:1},
        vgrid : {inherit : 'grid',$:1},
        tiles : {
            inherit : 'shape',
            join : 'tiles',
            fill : '#dfe7f5',
        $:1}, 
        bar : {
			inherit : 'shape',
            join : 'bar',
        $:0},    
        hbar : {
            inherit : 'bar',
        $:1},
        vbar : {
            inherit : 'bar',
            //stroke : '#cfcfcf',
            //fill : 'green',
        $:1},
        axis :{
            inherit : 'shape',
            join : 'grid',
            stroke : 'black',
            weight: 1,
            extend: 2,
        $:0},
        axisx :{inherit : 'axis',$:1},
        axisy :{inherit : 'axis',$:1},
        tick : {
            inherit : 'shape',
            join : 'grid',
            steps : 5,
            left: 0,
            top : 0,
            size : 4,
            stroke : '#000000',
        $:0},
        tickx : {inherit : 'tick',$:1},
        ticky : {inherit : 'tick',$:1},
        tickgx : {inherit : 'tick',weight:2,size:6,$:1},
        tickgy : {inherit : 'tick',weight:2,size:6,$:1}
    },
    axis2D : function(l,s){
        var e = apf.draw;
        if(!s.margin || !s.layout) return new Function('');
        var ml = s.margin.left*l.ds, mt = s.margin.top*l.ds,
            mr = s.margin.right*l.ds, mb = s.margin.bottom*l.ds;
        var c = e.optimize([
        e.beginLayer(l),
        e.vars(ml,mt,mr,mb),
        e.clear(),
        "var v,d,u,h,",
             "vcx = 0.5*__pow(",s.layout.pow,", __round(__log(__abs(vw)/",s.layout.pow,
                        ")/__log(",s.layout.pow,")))*",s.layout.step,",",
             "vcy = 0.5*__pow(",s.layout.pow,", __round(__log(__abs(vh)/",s.layout.pow,
                        ")/__log(",s.layout.pow,")))*",s.layout.step,",",
             "vbx = __ceil(vx1/vcx) * vcx,", 
             "vby = __ceil(vy1/vcy) * vcy,",
             "vex = __floor(vx2/vcx) * vcx,",
             "vey = __floor(vy2/vcy) * vcy,",
             "dcx = vcx*tw, dcy = vcy*th,",
             "dbx = vbx*tw+tx, dby = vby*th+ty,",
             "dex = vex*tw+tx, dey = vey*th+ty,",
             "dcx2 = dcx*2, dcy2 = dcy*2,",
             "dbx2 = __ceil(vx1/(2*vcx))*2*vcx*tw+tx,", 
             "dex2 = __floor(vx2/(2*vcx))*2*vcx*tw+tx,", 
             "dby2 = __floor(vy1/(2*vcy))*2*vcy*th+ty,", 
             "dey2 = __floor(vy2/(2*vcy))*2*vcy*th+ty;", 
         "var xmaxstep = __ceil( (dex-dbx)/dcx )+4,",
             "ymaxstep = __ceil( (dey-dby)/dcy )+4;",
			 
        s.plane?[ e.beginShape(s.plane),
            e.rect(ml,mt,"dw","dh")
        ].join(''):"",
        s.tiles?[ 
            e.rectInv?[
                e.beginShape(s.tiles),
                 "if((u=dbx2-dcx-",ml,")>0){",
                    e.rectInv(ml,mt,"u","dh"),
                "}",
                "for( v = dbx2, u  = dex-dcx; v < u; v += dcx2){",
                    e.rectInv("v",mt,"dcx","dh"),
                "};",
                "if((u=dr-v)>0){",
                    e.rectInv("v",mt,"__min(dcx,u)","dh"),
                "}",
                "if((u=dey2+dcy-",mt,")>0){",
                    e.rectInv(ml,mt,"dw","u"),
                "}",
                "for( v = dey2,u = dby+dcy; v < u; v -= dcy2){",
                    e.rectInv(ml,"v","dw","-dcy"),
                "};",
                "if((u=db-v)>0){",
                    e.rectInv(ml,"v","dw","__min(-dcy,u)"),
                "}"              
            ].join(''):[
                e.beginShape(s.tiles,ml,mt,mr,mb),
                "for( u = dey2+dcy2, t = dby2-dcy2; u <= t; u -= dcy2){",
                "for( v = dbx2-dcx2, d = dex2+dcx2; v <= d; v += dcx2){",
                    e.rect("v+dcx","u","dcx","-dcy"),
                    e.rect("v","u-dcy","dcx","-dcy"),
                "};",
            "}"].join('')
        ].join(''):"",
        s.vbar?[ e.beginShape(s.vbar),
            "if((u=dbx2-dcx-",ml,")>0){",
                e.rect(ml,mt,"u","dh"),
            "}",
            "for( v = dbx2, u  = dex-dcx; v < u; v += dcx2){",
                e.rect("v",mt,"dcx","dh"),
            "};",
            "if((u=dr-v)>0){",
                e.rect("v",mt,"__min(dcx,u)","dh"),
            "}"
        ].join(''):"",
        s.hbar?[ e.beginShape(s.hbar),
            "if((u=dey2+dcy-",mt,")>0){",
                e.rect(ml,mt,"dw","u"),
            "}",
            "for( v = dey2, u = dby+dcy; v < u; v -= dcy2){",
                e.rect(ml,"v","dw","-dcy"),
            "};",
            "if((u=db-v)>0){",
                e.rect(ml,"v","dw","__min(-dcy,u)"),
            "}"
        ].join(''):"",
        s.tickx?[ e.beginShape(s.tickx),
            "u = ",s.layout.onaxisx?("ty+"+(s.tickx.top*l.ds)):
                  (s.layout.onsidex?s.tickx.size*-l.ds+ml:("db")),";",
            "t = dcx/",s.tickx.steps,";",
            "h = ",s.tickx.size*l.ds,";",
            s.layout.onaxisx?[
            "if(u+h>",mt," && u<dh+",mb,"){",
                "if(u<dy)h=h-(dy-u),u=dy;",
                "if(u+h>db)h=db-u;"].join(''):"",
                "x = dbx-dcx;while(x<dx)x+=t;",
                "for(; x < dr; x += t){",
                    e.lineV("x","u","h"),
                "};",        
            s.layout.onaxisx?"}":"",
        ].join(''):"",
        s.ticky?[ e.beginShape(s.ticky),
            "t = dcy/",s.ticky.steps,";",
            "u = ",s.layout.onaxisy?("tx+"+s.ticky.left*l.ds):
                  (s.layout.onsidey?s.ticky.size*-l.ds+mt:"dr"),";",
            "h = ",s.ticky.size*l.ds,";",
            s.layout.onaxisy?[
            "if(u+h>dx && u<dr){",
                "if(u<dx)h=h-(dx-u),u=dx;",
                "if(u+h>dr)h=dr-u;"].join(''):"",            
                "y = dey+dcy;while(y<dy)y-=t;",
                "for(; y < db; y -= t){", // Y INVERTED
                    e.lineH("u","y","h"),
                "};",    
            s.layout.onaxisy?"}":"",
        ].join(''):"",
        s.hgrid?[ e.beginShape(s.hgrid),
            "t=dw+",s.hgrid.extend*l.ds,";",
            "u=",(s.hgrid.extend*l.ds*-s.layout.onsidey)+ml,";",
            "for(y = dby; y >= dy; y += dcy){", // Y INVERTED
                e.lineH("u","y","t"),
            "};"
        ].join(''):"",
        s.vgrid?[ e.beginShape(s.vgrid),
            "t=dh+",s.vgrid.extend*l.ds,";",
            "u=",(s.vgrid.extend*l.ds*-s.layout.onsidex)+mt,";",
            "for(x = dbx; x <= dr; x += dcx){",
                e.lineV("x","u","t"),
            "};"
        ].join(''):"",    
        s.tickgx?[ e.beginShape(s.tickgx),
            "u = ",s.layout.onaxisx?("ty+"+s.tickgx.top*l.ds):
                  (s.layout.onsidex?s.tickgx.size*-l.ds+ml:("db")),";",
            "h = ",s.tickgx.size*l.ds,";",
            s.layout.onaxisx?[
            "if(u+h>dy && u<db){",
                "if(u<dy)h=h-(dy-u),u=dy;",
                "if(u+h>db)h=db-u;"].join(''):"",
                "for(v=dbx; v <= dr; v += dcx){",
                    e.lineV("v","u","h"),
                "};",
            s.layout.onaxisx?"}":"",
        ].join(''):"",                            
        s.tickgy?[ e.beginShape(s.tickgy),
            "u = ",s.layout.onaxisy?("tx+"+s.tickgy.left*l.ds):
                  (s.layout.onsidey?s.tickgy.size*-l.ds+mt:"dr"),";",
            "h = ",s.tickgy.size*l.ds,";",
            s.layout.onaxisy?[
            "if(u+h>dx && u<dr){",
                "if(u<dx)h=h-(dx-u),u=dx;",
                "if(u+h>dr)h=dr-u;"].join(''):"",    
                "for(v=dby; v >= dy; v += dcy){", // Y INVERTED
                    e.lineH("u","v","h"),
                "};",
            s.layout.onaxisy?"}":"",
        ].join(''):"",   
        s.axisx?[ e.beginShape(s.axisx),
            "if(ty>=dy && ty<=dy+dh){",
                "t=dw+",s.axisx.extend*l.ds,";",
                "u=dx+",(s.axisx.extend*l.ds*-s.layout.onsidey),";",
                e.lineH("u","ty","t"),
            "}"
        ].join(''):"",
        s.axisy?[ e.beginShape(s.axisy),
            "if(tx>=dx && tx<=dx+dw){",
                "t=dh+",s.axisy.extend*l.ds,";",
                "u=dy+",(s.axisy.extend*l.ds*-s.layout.onsidex),";",    
                e.lineV("tx","u","t"),
            "}"
        ].join(''):"",
        s.plane2?[ e.beginShape(s.plane2),
            e.rect(ml,mt,"dw","dh")
        ].join(''):"",
        s.labelx?[
            s.layout.onaxisx?
                e.beginFont(s.labelx, "xmaxstep", ml,mt,mr,mb):
                e.beginFont(s.labelx, "xmaxstep", ml-s.labelx.edgeclip*l.ds,0,
                                                  mr-s.labelx.edgeclip*l.ds,0),
            "for( v = vbx, u = vex,d = dbx; v <= u; v+= vcx, d+= dcx ){",
                e.text("d",s.layout.onaxisx?"ty":(s.layout.onsidex?"dy":"db"),
                        s.labelx.format),
            "}"
        ].join(''):"",
        s.labely?[
            s.layout.onaxisy?
                e.beginFont(s.labely, "ymaxstep", ml,mt,mr,mb):
                e.beginFont(s.labely, "ymaxstep",0,mt-s.labely.edgeclip*l.ds,
                                                 0,mb-s.labely.edgeclip*l.ds),
            "for( v = vby, u = vey,d = dby;v<= u; v+= vcy, d+= dcy ){;",
                e.text(s.layout.onaxisy?"tx":(s.layout.onsidey?"dx":"dr"),"d",s.labelx.format),
            "}"
        ].join(''):"",
        e.endLayer()
        ]);
        try{
            //logw(apf.highlightCode2(apf.formatJS(c)));
			return new Function('l','v','m',c);
        }catch(x){
            //return new Function('l','v','m',c);
            //c = apf.formatJS(c);
            //window.open().document.write("<script>" + c + "</script>");
            alert("Failed to compile:\n"+x.message+'\n'+c);return 0;
        }		
    },
    
    
  
    _axis3D: {
		layout :{
		    pow : 10,
			step : 4,
		$:1},
        plane :{
            inherit : 'shape',
            side: 1,
            oneside : 0,            
            fill : '#e6f1f8',
        $:0},
        plane2 :{
            inherit : 'shape',
        $:1}, 
        planexy :{
            inherit: 'plane',
        $:1}, 
        planexz :{
            inherit: 'plane',
        $:1}, 
        planeyz :{
            inherit: 'plane',
            //fill: '#e6f1f8',
        $:1}, 

        /*
        grid : {
            inherit : 'shape',
            join : 'grid',
            stroke : '#cfcfcf',
            weight : 1,
            opacity: 0.3,
            extend : 0,
        $:0},
        xgrid : {inherit : 'grid'},
        ygrid : {inherit : 'grid'},*/

        bar : {
            inherit : 'shape',
            join : 'bar',
             oneside : 0,         
        $:0},    
        hbar : {
            side: 1,
            inherit : 'bar',
			stroke : '#cfcfcf',
            //opacity: 1,
        $:0},
        vbar : {
            side: 1,
            inherit : 'bar',
            stroke : '#cfcfcf',
            fill: 'blue',
			opacity: 0.25,
            //stroke : '#cfcfcf',
        $:0},
        hbarxy :{
            inherit: 'hbar',
        $:1}, 
        vbarxy :{
            inherit: 'vbar',
        $:1}, 
        hbarxz :{
            inherit: 'hbar',
            stroke: 'black',
            opacity:0.25,
        $:1}, 
        vbarxz :{
            inherit: 'vbar',
            fill: '#e6f1f8',
            stroke: 'black',
        //     opacity:0.5,
        $:1}, 
        hbaryz :{
            inherit: 'hbar',
             fill: '#blue',
            opacity:0.25,
        //    fill: null,
         //   opacity:0.5,
        $:1}, 
        vbaryz :{
            inherit: 'vbar',
            stroke: 'black',
            opacity:0.25,            
            fill: null,
        $:1}, 
        
        axis :{
            inherit : 'shape',
            join : 'grid',
            stroke : 'black',
            opacity: 0.5,
            weight: 3,
        $:0},
        axisx :{inherit : 'axis',$:1},
        axisy :{inherit : 'axis',$:1},
        axisz :{inherit : 'axis',$:1},

        tick : {
            inherit : 'shape',
            join : 'grid',
            steps : 5,
            size : 4, 
            scale : 0.1,
            angle : 'ang(180)',
            stroke : '#000000',
        $:0},
        tickx : {inherit : 'tick',angle:'ang(90+f1*90)',$:1},
        ticky : {inherit : 'tick',angle:'ang(90+f2*90)',$:1},
        tickz : {inherit : 'tick',$:1},
        
        label : {
            inherit : 'font',
            join : 'label',
            width: 40,
            height: 40,
            left: -20,
            top: "fontz(-5,200)",
            size: "fontz(10,200)",
            scale: 0.2,
            stroke: null,
            angle : 'ang(180)',
            format : "fixed(v,1)",
        $:0},
        labelx : {
            inherit : 'label', 
            angle:'ang(90+f1*90)',
            align:'center',
        $:1},
        labely : {
            inherit : 'label', 
            angle:'ang(90+f2*90)',
            align:'center',
        $:1},
        labelz : {
            inherit : 'label', 
            align:'center',
        $:1},        
        
        /*
        tickxg : {inherit : 'tick',weight:2,size:6},
        tickyg : {inherit : 'tick',weight:2,size:6}*/
    $:0},
     
    chartView3D : function(l,e){
        return [
		"var s3x=v.x3d/vw,s3xi=1/s3x,s3y=v.y3d/vh,s3yi=1/s3y,s3z=v.z3d/vd,s3zi=1/s3z;",
        e.sincos3('_m','v.rx','v.ry','v.rz'),
        e.setMatrix3D(
            e.matrixMul(
                e.matrix4T('(-0.5*vx1-0.5*vx2)','(-0.5*vy1-0.5*vy2)','(-0.5*vz1-0.5*vz2)'),
                e.matrix4S('s3x','s3y','s3z'),
                e.matrix4RP('_m'),
                e.matrix4T('v.tx','v.ty','v.tz'))
        )].join('');
    },
    
    axis3D : function(l,s){
        if(!s.layout) return new Function('');
        var e = apf.draw;
        var dt = (new Date()).getTime();
        var zclip = -0.01;
        function drawPlane(pr,fl,z1,z2,side,
                            vx1,vx2,vbx,vex,vbx2,vex2,vcx,vcx2,
                            vy1,vy2,vby,vey,vby2,vey2,vcy,vcy2 ){
            function plane(z){
                return e.poly3DClip([0,1,2,3],[[vx1,vy1,z],[vx1,vy2,z],[vx2,vy2,z],[vx2,vy1,z]],fl,zclip);
            }
            function hbar(z){
                return [
                "if((u=(",vbx2,"-",vcx,")-",vx1,")<",vcx," && u>0){",
                    e.poly3DClip([0,1,2,3],[[vx1,vy1,z],["("+vx1+"+u)",vy1,z],["("+vx1+"+u)",vy2,z],[vx1,vy2,z]],fl,zclip),
                "}",
                "for( v = ",vbx2,", u  = ",vex2,"-0.000001; v < u; v += ",vcx2,"){",
                    e.poly3DClip([0,1,2,3],[["v",vy1,z],["(v+"+vcx+")",vy1,z],["(v+"+vcx+")",vy2,z],["v",vy2,z]],fl,zclip),
                "};",
                "if( v<",vx2," ){",
                    e.poly3DClip([0,1,2,3],[["v",vy1,z],["(u="+e.min("v+"+vcx,vx2)+")",vy1,z],["u",vy2,z],["v",vy2,z]],fl,zclip),
                "}"].join('');
            }
            function vbar(z){
                return [
                "if((u=(",vby2,"-",vcy,")-",vy1,")<",vcy," && u>0){",
                    e.poly3DClip([0,1,2,3],[[vx1,vy1,z],[vx1,"("+vy1+"+u)",z],[vx2,"("+vy1+"+u)",z],[vx2,vy1,z]],fl,zclip),
                "}",
                "for( v = ",vby2,", u  = ",vey2,"-0.000001; v < u; v += ",vcy2,"){",
                    e.poly3DClip([0,1,2,3],[[vx1,"v",z],[vx1,"(v+"+vcy+")",z],[vx2,"(v+"+vcy+")",z],[vx2,"v",z]],fl,zclip),
                "};",
                "if( v<",vy2," ){",
                    e.poly3DClip([0,1,2,3],[[vx1,"v",z],[vx1,"(u="+e.min("v+"+vcy,vy2)+")",z],[vx2,"u",z],[vx2,"v",z]],fl,zclip),
                "}"].join('');
            }
            return [
                "s1=-(",e.backface3D([[vx1,vy1,z1],[vx1,vy2,z1],[vx2,vy1,z1]],fl),");",
                "s2=",e.backface3D([[vx1,vy1,z2],[vx1,vy2,z2],[vx2,vy1,z2]],fl),";",
                "s",pr,"=s1*",side,">=s2*",side,";",
                // if we have to pick a side, (instead of both) we should pick the side which has the biggest visible angle
                s['plane'+pr]?[ e.beginShape(s['plane'+pr]),
                   "sa = s1*",e.style.side*side,";","sb = s2*",e.style.side*side,";",e.style.oneside?"if(sa>=sb)sb = -1;if(sb>=sa)sa = -1;":"",
                   "for(i=1;i>=0;i--){if((i?sa:sb)>=0){z=i?",z1,":",z2,";", plane("z"),"}};",
                ].join(''):"",
                s['hbar'+pr]?[ e.beginShape(s['hbar'+pr]),
                   "sa = s1*",e.style.side*side,";","sb = s2*",e.style.side*side,";",e.style.oneside?"if(sa>=sb)sb = -1;if(sb>=sa)sa = -1;":"",
                   "for(i=1;i>=0;i--){if((i?sa:sb)>=0){z=i?",z1,":",z2,";",hbar("z"),"}};"
                ].join(''):"",
                s['vbar'+pr]?[ e.beginShape(s['vbar'+pr]),
                   "sa = s1*",e.style.side*side,";","sb = s2*",e.style.side*side,";",e.style.oneside?"if(sa>=sb)sb = -1;if(sb>=sa)sa = -1;":"",
                   "for(i=1;i>=0;i--){if((i?sa:sb)>=0){z=i?",z1,":",z2,";",vbar("z"),"}};"
                ].join(''):"",
                s['plane2'+pr]?[ e.beginShape(s['plane2'+pr]),
                   e.poly3DClip([0,1,2,3],[[vx1,vy1,z1],[vx2,vy1,z1],[vx2,vy2,z1],[vx1,vy2,z1]],fl,zclip),
                ].join(''):""
            ].join('');
        }
        
        function drawAxis(pr,fl,z1,z2,side1,side2,us,ws,wind,
                            vx1,vx2,vbx,vex,vbx2,vex2,vcx,vcx2,
                            vy1,vy2,vby,vey,vby2,vey2,vcy,vcy2 ){
            // pick a side, then draw a poly3DClip from vx1,vy1 to vx2, vy1
            var zclip = -1, sider, sd;
            if(s['axis'+pr]){
                if((sd = s['axis'+pr].side1) !== undefined )side1 = sd;
                if((sd = s['axis'+pr].side2) !== undefined )side2 = sd;
            }
            var sideloop = [
                "for(i=0;i<4;i++)if((i&2?(",side2,"?((f1=0,c=1,y=",vy1,"),1):0):(",side2,"?0:((f1=1,c=-1,y=",vy2,"),1)))&&",
                                   "(i&1?(",side1,"?((f2=0,d=1,z=",z1,"),1):0):(",side1,"?0:((f2=1,d=-1,z=",z2,"),1))))"
            ].join('');
            return [
                s['axis'+pr]?[e.beginShape(s['axis'+pr]),
                // "if(s//figure out side"
                sideloop,"{",
                    e.poly3DClip([0,1],[[vx1,"y","z"],[vx2,"y","z"]],fl,zclip,true),
                "};"].join(''):"",
                // lets draw the ticks
                s['tick'+pr]?[e.beginShape(s['tick'+pr]),
                sideloop,"{",
                    ";u=y+",us,"*__sin(f=(",e.style.angle,")*",wind,")*(",e.style.scale,")*c;w=z+",ws,"*__cos(f)*(",e.style.scale,")*d;",
                    "for(v=",vbx,";v<=",vex,";v+=",vcx,"){",
                        e.poly3DClip([0,1],[["v","y","z"],["v","u","w"]],fl,zclip,true),
                    "};",
                "};"].join(''):"",/*
                ";u=",vy1,"+",us,"*__sin(n);w=",z1,"+",ws,"*__cos(n);",
                "for(v=",vbx,";v<=",vex,";v+=",vcx,"/10){",
                    e.poly3DClip([0,1],[["v",vy1,z1],["v","u","w"]],fl,zclip,true),
                "};"
                */
                // lets draw some textitems
                s['label'+pr]?[e.beginFont(s['label'+pr], ["__ceil(((",vex,")-(",vbx,"))/(",vcx,"))*2"].join('')),
                sideloop,"{",
                    ";u=y+",us,"*__sin(f=(",e.style.angle,")*",wind,")*(",e.style.scale,")*c;w=z+",ws,"*__cos(f)*(",e.style.scale,")*d;",
                    "for(v=",vbx,";v<=",vex,";v+=",vcx,"){",
                        e.text3D(["v","u","w"],fl,zclip,e.style.format), 
                    "}",
                "}"].join(''):"",
                
            ].join('')
        }
        var c = e.optimize([
            e.beginLayer(l),
            e.vars(),
            this.chartView3D(l,e),
            e.defCamVec(),
            e.clear(),
            "var v,d,c,u,h,w,f1,f2,",
                "vcx = 0.5*__pow(",s.layout.pow,", __round(__log(__abs(vw)/",s.layout.pow,
                    ")/__log(",s.layout.pow,")))*",s.layout.step,",",
                "vcy = 0.5*__pow(",s.layout.pow,", __round(__log(__abs(vh)/",s.layout.pow,
                    ")/__log(",s.layout.pow,")))*",s.layout.step,",",
                "vcz = 0.5*__pow(",s.layout.pow,", __round(__log(__abs(vd)/",s.layout.pow,
                    ")/__log(",s.layout.pow,")))*",s.layout.step,",",
                "vbx = __ceil(vx1/vcx) * vcx,", 
                "vby = __ceil(vy1/vcy) * vcy,",
                "vbz = __ceil(vz1/vcz) * vcz,",
                "vex = __floor(vx2/vcx) * vcx,",
                "vey = __floor(vy2/vcy) * vcy,",
                "vez = __floor(vz2/vcz) * vcz,",
                "vcx2 = vcx*2, vcy2 = vcy*2, vcz2 = vcz*2,",
                "vbx2 = __ceil(vx1/vcx2)*vcx2,", 
                "vex2 = __floor(vx2/vcx2)*vcx2,", 
                "vby2 = __ceil(vy1/vcy2)*vcy2,", 
                "vey2 = __floor(vy2/vcy2)*vcy2,", 
                "vbz2 = __ceil(vz1/vcz2)*vcz2,", 
                "vez2 = __floor(vz2/vcz2)*vcz2,",
                "s1, s2, sa, sb, sxy, sxz, syz;", 
            "var xmaxstep = __ceil( (vex-vbx)/vcx )+4,",
                "ymaxstep = __ceil( (vey-vby)/vcy )+4,",
                "zmaxstep = __ceil( (vez-vbz)/vcz )+4;",
            //e.beginShape(s.test),
            //e.poly3DClip([0,1,2,3],[["-1","-1","1"],["1","-1","0"],["1","1","0"],["-1","1","1"]],null,-4),
            
            drawPlane('xy',[0,1,2],"vz1","vz2",1,
                        "vx1","vx2","vbx","vex","vbx2","vex2","vcx","vcx2",
                        "vy1","vy2","vby","vey","vby2","vey2","vcy","vcy2"),
            drawPlane('xz',[0,2,1],"vy1","vy2",-1,
                        "vx1","vx2","vbx","vex","vbx2","vex2","vcx","vcx2",
                        "vz1","vz2","vbz","vez","vbz2","vez2","vcz","vcz2"),
            drawPlane('yz',[2,0,1],"vx1","vx2",1,
                        "vy1","vy2","vby","vey","vby2","vey2","vcy","vcy2",
                        "vz1","vz2","vbz","vez","vbz2","vez2","vcz","vcz2"),
            // this axis can be drawn on 4 sides. which side it draws is styled + dynamic
            drawAxis('x',[0,1,2],"vz1","vz2","sxy","sxz","s3yi","s3zi",1,
                        "vx1","vx2","vbx","vex","vbx2","vex2","vcx","vcx2",
                        "vy1","vy2","vby","vey","vby2","vey2","vcy","vcy2"),
            drawAxis('y',[1,0,2],"vz1","vz2","sxy","syz","s3xi","s3zi",-1,
                        "vy1","vy2","vby","vey","vby2","vey2","vcy","vcy2",
                        "vx1","vx2","vbx","vex","vbx2","vex2","vcx","vcx2"),
            drawAxis('z',[2,1,0],"vx1","vx2","syz","sxz","s3yi","s3xi",1,
                        "vz1","vz2","vbz","vez","vbz2","vez2","vcz","vcz2",
                        "vy1","vy2","vby","vey","vby2","vey2","vcy","vcy2"),
			e.endLayer()
        ]);
        try{
          //c = apf.formatJS(c);
          //logw(apf.highlightCode2(c));        
          var f = new Function('l','v','m',c);
          //document.title = (new Date()).getTime() - dt;
          return f;
        }catch(x){
            //window.open().document.write("<script>" + c + "</script>");
            alert("Failed to compile:\n"+x.message+'\n'+c);return 0;
        }		
    },
    
    
    _line2D: {
        graph : {
            inherit : 'shape',
            stroke : '#000000',
            weight: 1,
        $:1}
    },
    line2D : function( l, d, s ){
        if(!s.graph) return new Function('');
        var wrap = s.graph.weight*8, e = apf.draw;
        var clipy = s.graph.fillout?"db":"ty";
        var c = e.optimize([
            e.vars(),
            "if(m){",
                "return -1;",
            "}",
            e.beginLayer(l),
            d.vars,d.stats,
            e.beginShape(s.graph),
            "var x1=",d.x1,",x2=",d.x2,",xs=",d.xs,
            ",x = x1,xw=x2-x1,idx=xw/xs;",d.begin,
            "var xfirst = x,dx=-vx1*tw,dy=-vy1*th;",
            d.seek,
            //"logw(",d.y,");",
            d.ifdraw,"{",
            s.graph.fill?[
                e.moveTo(d.x+"*tw+tx",clipy),
                e.lineTo(d.x+"*tw+tx",d.y+"*th+ty"),
            ].join(''):e.moveTo(d.x+"*tw+tx",d.y+"*th+ty"),
            
            "for(x+=idx;x<x2",d.forx,";x+=idx",d.incx,")",d.ifx,"{",
                e.lineTo(d.x+"*tw+tx",d.y+"*th+ty"),
            "}",
            s.graph.fill?["x-=idx;",e.lineTo(d.x+"*tw+tx",clipy)].join(''):"",
            "}",
            e.endLayer()
            ].join(''));
        try{
           // c = apf.formatJS(c);
			return new Function('l','v','m',c);
        }catch(x){
            alert("Failed to compile:\n"+c);return 0;
        }
    },
    
  
    
    _line3D: {
		graph : {
            inherit : 'shape',
			steps : 50,
			zpos : 0,
            depth : 0.5,
            stroke: 'black',
            fill: 'red',
            opacity: 0.3,
        $:1}
    },
    
    line3D : function( l, d, s ){
        if(!s.graph) return new Function('');
        var e = apf.draw, wrap = s.graph.weight*4; 

        var c = e.optimize([
            e.vars(),
            "if(m){",
                "return -1;",
            "}",
            e.beginLayer(l),
            this.chartView3D(l,e),
//e.poly3D([0,1,2,3,-1],[["vx1","vy1",0],["vx1","vy2",0],["vx2","vy2",0],["vx2","vy1",-1]]),
            d.vars,d.stats,
            "var x1=",d.x1,",x2=",d.x2,",xs=",d.xs,",x=x1,xw=x2-x1,idx=xw/xs,",
                "k = 0, xi, yi, xa, ya, xb, yb, xc, yc, xd, yd;",
            d.seek,
            e.beginShape(s.graph),
            d.ifdraw,"{",
            
            e.moveTo3D("xb="+d.x,"yb="+d.y,s.graph.zpos),
            "for(x+=idx,i=0;x<x2",d.forx,";x+=idx",d.incx,")",d.ifx,"{",
                "xa = ",d.x,",ya=",d.y,";",
                e.lineTo3D("xa","ya",s.graph.zpos,"xi=","yi="),
                e.lineTo3D("xa","ya",s.graph.zpos+"+"+s.graph.depth, "xc=","yc="),
                "if(!i){i++;",
                    e.lineTo3D("xb","yb",s.graph.zpos+"+"+s.graph.depth),
                "} else {",
                    e.lineTo("xd","yd"), 
                "}",
                e.close(),
                e.moveTo("xi","yi"),
                "xd=xc, yd=yc, xb = xa, yb = ya;",
            "}",
            "}",
            e.endLayer()]);
        try{        
            //c = apf.formatJS(c);
            //logw(apf.highlightCode2(c));
            return new Function('l','v','m',c);
        }catch(x){
//            window.open().document.write("<script>function(){" + apf.formatJS(c) + "}</script>");
            alert("Failed to compile:\n"+c);return 0;
        }
    },
    
    
    
    _bar3D: {
        graph : {
            inherit : 'shape',
            stroke: '#000000',
            weight : 1,
            fill : 'red',
        $:1}
    },    
    
    bar3D : function(l,d,s){
        if(!s.graph) return new Function('');
        var e = apf.draw, g = apf.visualize;
         
        var c = e.optimize([
            "if(m){return -1;}",
            e.beginLayer(l),
            e.vars(),
            this.chartView3D(l,e),
            e.defCamVec(),
            d.vars,
            "var x1=",d.x1,",x2=",d.x2,",xs=",d.xs,",x,xw=x2-x1,idx=xw/xs,",
                "wx = idx*tw,wy,cx1,cx2,cy1,cy2;",
            d.seek,
            e.beginState(s.graph, e, e.shapedRect, 4),
            d.ifdraw,"{",
            "for(x=x1;x<x2",d.forx,";x+=idx",d.incx,")",d.ifx,"{",
                "cx1=",d.x,",cy1=",d.y,",cx2=cx1+idx,cy2=0;",
                e.poly3DClip([0,1,2,3],[["cx1","cy1",0],["cx2","cy1",0],["cx2","cy2",0],["cx1","cy2",0]],[0,1,2],-1),
            "};",
            "}",
            e.endLayer()]);
        // lets return a mouse tracking function too.
        try{
            return new Function('l','v','m',c);
        }catch(x){
            alert(x.message+"\nFailed to compile:\n"+c);return 0;
        }
    },
     
    
    
    _height3D: {
		graph : {
            inherit : 'shape',
			steps : 50,
			zpos : 0,
            depth : 0.5,
            stroke: 'black',
            fill: 'red',
            opacity: 0.3,
        $:1}
    },
    
    height3D : function( l, d, s ){
        if(!s.graph) return new Function('');
        var e = apf.draw;
        var c = e.optimize([
            e.vars(),
            "if(m){",
                "return -1;",
            "}",
            e.beginLayer(l),
            this.chartView3D(l,e),
            d.vars,d.stats,
            "var x1=",d.x1,",x2=",d.x2,",xs=",d.xs,",x=x1,xw=x2-x1,idx=xw/xs,",
                "z1=",d.z1,",z2=",d.z2,",zs=",d.zs,",z=z1,zw=z2-z1,idz=zw/zs,",
                "k = 0, xi, yi, xa, ya, xb, yb, xc, yc, xd, yd;",
            d.seek,
            e.beginShape(s.graph),
            d.ifdraw,"{",
            (s.graph.fill)?[
            "var ar1=[], ar2=[];",
            "for(x=x1,i=0;x<x2",d.forx,";x+=idx",d.incx,")",d.ifx,"{",
                e.store3D(d.x,d.y,d.z,"ar1[i++]=","ar1[i++]="),
            "};",
            "for(z+=idz;z<z2",d.forz,";z+=idz",d.incz,")",d.ifz,"{",
                "x=x1, i=0, j=0;",
                // lets move to first pixel
                e.store3D(d.x,d.y,d.z,"ar2[i++]=","ar2[i++]="),
                "for(x+=idx;x<x2",d.forx,";x+=idx,j+=2",d.incx,")",d.ifx,"{",
                    e.moveTo("ar1[j]","ar1[j+1]"),
                    e.lineTo("ar1[j+2]","ar1[j+3]"),
                    e.lineTo3D(d.x,d.y,d.z,"ar2[i++]=","ar2[i++]="),
                    e.lineTo("ar2[j]","ar2[j+1]"),
                    e.close(),
                "}",
                "ar1=ar2,ar2=[];",
                // lets draw all the 3d shapes between the two arrays
                // then we switch arrays
            "}"].join(''):[
                 "for(;z<z2",d.forz,";z+=idz",d.incz,")",d.ifz,"{",
                    // lets move to first pixel
                    "x=x1;",
                    e.moveTo3D(d.x,d.y,d.z),
                    "for(x+=idx;x<x2",d.forx,";x+=idx",d.incx,")",d.ifx,"{",
                        e.lineTo3D(d.x,d.y,d.z),
                    "}",
                 "}",
                 (s.graph.single>0)?"":[
                 "for(x=x1;x<x2",d.forx,";x+=idx",d.incx,")",d.ifx,"{",
                    "z=z1;",
                    e.moveTo3D(d.x,d.y,d.z),
                    "for(z+=idz;z<z2",d.forz,";z+=idz",d.incz,")",d.ifz,"{",
                        e.lineTo3D(d.x,d.y,d.z),
                    "}",
                 "}"].join(''),
            ].join(''),
            /*
            e.moveTo3D("xb="+d.x,"yb="+d.y,s.graph.zpos),
            "for(x+=idx,i=0;x<x2",d.forx,";x+=idx",d.incx,")",d.ifx,"{",
                "xa = ",d.x,",ya=",d.y,";",
                e.lineTo3D("xa","ya",s.graph.zpos,"xi=","yi="),
                e.lineTo3D("xa","ya",s.graph.zpos+s.graph.depth, "xc=","yc="),
                "if(!i){i++;",
                    e.lineTo3D("xb","yb",s.graph.zpos+s.graph.depth),
                "} else {",
                    e.lineTo("xd","yd"), 
                "}",
                e.close(),
                e.moveTo("xi","yi"),
                "xd=xc, yd=yc, xb = xa, yb = ya;",
            "}",*/
            "}",
            e.endLayer()]);
        try{        
            //c = apf.formatJS(c);
            //logw(apf.highlightCode2(c));
            return new Function('l','v','m',c);
        }catch(x){
            //window.open().document.write("<script>" + c + "</script>");
            alert("Failed to compile:\n"+c);return 0;
        }
    },
    
    
    /* bar3D : function(l,e){

        e.allocShape(l, l.style.bar );
        e.allocDone(l);
        var vz = l.style.bar.zpos;
        var func = this.mathParse(l.formula);
        var c = [
            this.head,
            this.head3D,
            e.beginLayer(l),
            this.poly3DHead(8),
            e.beginShape(0),
            "var lx = vw/",l.style.bar.stepx,",xw, w = lx*",l.style.bar.sizex,
            ",d=lx*",l.style.bar.sizey,"+",vz,";",
            // we need the viewing angle, and create a switch with the 8 angles
            "for(x = vx1; x<=vx2; x+=lx){",
                "xw = x+w, z = ",func,";",
                this.poly3DIndex(e,[ 0,1,5,6,7,3,-1,3,2,6,7],
                    [["x",vz,0],["xw",vz,0],["xw",vz,"z"],["x",vz,"z"],
                    ["x","d",0],["xw","d",0],["xw","d","z"],["x","d","z"]]),
            "}",
            e.endShape(),
            e.endLayer()].join('');
        try{        
            return new Function('l',c);
        }catch(x){
            alert("Failed to compile:\n"+c);return 0;
        }
    },*/
    
    
    
    /*bar3DXY : function(l,e){
        // we should allocate as many shapes as we have datasets,
        // with different colors
        e.allocShape(l, l.style.bar );
        e.allocDone(l);
        var vz = l.style.bar.zpos;
        var func = this.mathParse(l.formula);
        var c = [
            this.head,
            this.head3D,
            e.beginLayer(l),
            this.poly3DHead(8),
            e.beginShape(0),
            "var tx,ty,xw,yw,",
            "lx = vw/",l.style.bar.stepx,",hxwv = 0.5*lx*",l.style.bar.sizex,",",
            "ly = vh/",l.style.bar.stepy,",hywv = 0.5*ly*",l.style.bar.sizey,";",
            // we need the viewing angle, and create a switch with the 8 angles
            "for(y = vy1; y<=vy2; y+=ly){",
                "for(x = vx1; x<=vx2; x+=lx){",
                    "tx = x-hxwv, ty = y-hywv, xw = x+hxwv, yw = y+hywv, z = ",func,";",
                    this.poly3DIndex(e,[ 0,1,5,6,7,3,-1,3,2,6,7],
                        [["tx","ty",0],["xw","ty",0],["xw","ty","z"],["tx","ty","z"],
                        ["tx","yw",0],["xw","yw",0],["xw","yw","z"],["tx","yw","z"]]),
                "}",
            "}",
            e.endShape(),
            e.endLayer()].join('');
        try{
            return new Function('l',c);
        }catch(x){
            alert("Failed to compile:\n"+c);return 0;
        }
    },*/
    
    
    
    _bar2D: {
        graph : {
            inherit : 'shape',
            shape: 'rect',
            stroke: '#000000',
            weight : 1,
            fill : 'red',
        $:1}
    },
    bar2D : function(l,d,s){
        var e = apf.draw, g = apf.visualize;
        if(!s.graph) return new Function('');
            
        var c = e.optimize([
            e.vars(),
            d.vars,
            "var x1=",d.x1,",x2=",d.x2,",xs=",d.xs,",x,xw=x2-x1,idx=xw/xs,",
                "wx = idx*tw,wy;",
            d.seek,
            "\n\n/*------ bar2D Mousecode ------ */\n",
            "if(m){",
                e.beginMouseState(s.graph,e,e.shapedRect,4),
                "for(x=x1;x<x2",d.forx,";x+=idx",d.incx,")",d.ifx,"{",
                    e.checkMouseState(d.state,d.time,"("+d.x+")*tw+tx","wy=("+d.y+")*th+ty",
                                "wx","ty-wy"),
                "};",                
                "return -1;",
            "}",
            "\n\n/*------ bar2D Drawcode ------ */\n",
            e.beginLayer(l),
            e.beginState(s.graph, e, e.shapedRect, 4),
            d.ifdraw,"{",
            "for(x=x1;x<x2",d.forx,";x+=idx",d.incx,")",d.ifx,"{",
                e.drawState(d.state,d.time,"("+d.x+")*tw+tx","wy=("+d.y+")*th+ty",
                            "wx","ty-wy"),
            "};",
            "}",
            e.endLayer()]);
        // lets return a mouse tracking function too.
        try{
            //logw(apf.highlightCode2(c=apf.formatJS(c)));
            return new Function('l','v','m',c);
        }catch(x){
            //window.open().document.write("<script>" +apf.formatJS(c)+ "</script>");
            alert(x.message+"\nFailed to compile:\n"+c);return 0;
        }
    },
    
    
    
   _shape2D: {
        graph: {
            inherit : 'shape',
            stroke: '#000000',
            weight : 1,
            left: -1.5,
            top : -1.5,
            height: 3,
            width: 4,
            fill : 'red',
        $:1}
    },
    shape2D : function(l,d,s){
        if(!s.graph) return new Function('');
        var e = apf.draw, g = apf.visualize;
         
        var c = e.optimize([
            "if(m){return -1;}",
            e.beginLayer(l),
            e.vars(),
            d.vars,
            "var x1=",d.x1,",x2=",d.x2,",xs=",d.xs,",x,xw=x2-x1,idx=xw/xs,",
                "wx = idx*tw,wy;",
            "tx += ",s.graph.left*l.ds,";",
            "ty += ",s.graph.top*l.ds,";",
            d.seek,
            e.beginState(s.graph, e, e.draw2D, 4),
            d.ifdraw,"{",
            "for(x=x1;x<x2",d.forx,";x+=idx",d.incx,")",d.ifx,"{",
                e.drawState(d.state,d.time,"("+d.x+")*tw+tx","wy=("+d.y+")*th+ty",
                            s.graph.width*l.ds,s.graph.height*l.ds),
            "};",
            "}",
            e.endLayer()]);
        // lets return a mouse tracking function too.
        try{
            return new Function('l','v','m',c);
        }catch(x){
            alert(x.message+"\nFailed to compile:\n"+c);return 0;
        }
    },    
    
    
    
    
    _pie2D: {
        margin : {
            left: 0,
            top: 0,
            width: 1,
            height: 1,
        $:1},
        graph : {
            inherit : 'shape',
            stroke: '#000000',
            weight : 1,
            fill : 'red',
        $:1}
    },
    pie2D : function(l,d,s){
        if(!s.graph) return new Function('');
       
        var e = apf.draw, g = apf.visualize;
        var c = e.optimize([
            "/*------ pie2D Init ------*/\n",
            e.vars(),
            
            d.vars,d.stats,
           "var x1=",d.vx1,",x2=",d.vx2,",xw=x2-x1,",
                "idx=1,sum=1/(",d.sum,"),rx=0,",
                "xp=(",s.margin.left,")*tw+tx,",
                "yp=(",s.margin.top,")*th+ty,",
                "wp=(",s.margin.width,")*tw,",
                "hp=(",s.margin.height,")*th,",
                "wq=0.5*wp, hq = 0.5*hp,",
                "xc=xp+wq, yc=yp+hq, piesize;",
            d.seek,
            "\n\n/*------ pie2D Mousecode ------ */\n",
            "if(m){",
                e.beginMouseState(s.graph,e,e.shapedPart,6,['piesize']),
                "for(rx=0,x=x1;x<x2",d.forx,";x+=idx",d.incx,")",d.ifx,"{",
                    e.checkMouseState(d.state,d.time,"xc","yc","wq","hq",
                                "rx","-rx+(rx+=("+d.y+")*sum)"),
                "};",
                "return -1;",
            "}",
            "\n\n/*------ pie2D Drawcode ------ */\n",
            e.beginLayer(l),
            e.beginState(s.graph,e,e.shapedPart,6,['piesize']),
            "for(rx=0,x=x1;x<x2",d.forx,";x+=idx",d.incx,")",d.ifx,"{",
/*                e.drawState(d.state,d.time,"xc","yc","wq","hq",
                            "rx","-rx+(rx+=("+d.y+")*sum)"),*/
                "piesize = ("+d.y+")*sum;",
                e.drawState(d.state,d.time,"xc","yc","wq","hq","rx","-rx+(rx+=piesize)"),
            "};",
            "\n\n/*------ pie2D End ------ */\n",
            e.endLayer()]);
            //alert(c);
        // lets return a mouse tracking function too.
        try{
            //;
//            logw(apf.highlightCode2(apf.formatJS(c)));
            return new Function('l','v','m',c);
        }catch(x){
            alert(x.message+"\nFailed to compile:\n"+c);return 0;
        }
    },
    
    dt_math1X : function(l) {
        return {
            type : 'math1X',
            vars : "var _stp= l.step&&(vx2-vx1)/l.step<l.steps?l.step:(vx2-vx1)/l.steps;",
            vx1 : 0, vx2 : 1, vy1 : 0, vy2 : 1, vz1 : 0, vz2 : 1,
            x1 : "__floor(vx1/_stp)*_stp",
            x2 : "__ceil(vx2/_stp+1)*_stp",
            xs : "(x2-x1)/_stp",
            stats : "", seek : "",
            forx : "",  ifx : "", incx : "",ifdraw : "",
            x : "x",
            y : "("+apf.draw.getXYWH(l.pformula,'x')+")"
        };
    },
    
    dt_math2X : function(l){
        return {
            type : 'math2X',
            vars : "var _stp= l.step&&(vx2-vx1)/l.step<l.steps?l.step:(vx2-vx1)/l.steps;",
            vx1 : -1, vx2 : 1, vy1 : -1, vy2 : 1, vz1 : 0, vz2 : 1,
            x1 : "__floor(vx1/_stp)*_stp",
            x2 : "__ceil(vx2/_stp+1)*_stp",
            xs : "(x2-x1)/_stp",
            stats : "", seek : "",
            forx : "",  ifx : "", incx : "",ifdraw : "",
            x : "("+apf.draw.getXYWH(l.pformula,'x')+")",
            y : "("+apf.draw.getXYWH(l.pformula,'y')+")"
        };
    },
    dt_math1XZ : function(l){
        return {
            type : 'math1XY',
            vars : "var _stpx= l.step&&(vx2-vx1)/l.step<l.steps?l.step:(vx2-vx1)/l.steps,"+
                       "_stpz=l.step&&(vz2-vz1)/l.step<l.steps?l.step:(vz2-vz1)/l.steps;",
            vx1 : -1, vx2 : 1, vy1 : -1, vy2 : 1, vz1 : 0, vz2 : 1,
            /*
            x1 : "__floor(vx1/_stp)*_stp",
            x2 : "__ceil(vx2/_stp+1)*_stp",
            xs : "(x2-x1)/_stp",
            z1 : "__floor(vz1/_stp)*_stp",
            z2 : "__ceil(vz2/_stp+1)*_stp",
            zs : "(z2-z1)/_stp",
            */
            x1 : "vx1",
            x2 : "vx2",
            xs : "(x2-x1)/_stpx",
            z1 : "vz1",
            z2 : "vz2",
            zs : "(z2-z1)/_stpz",

            
            stats : "", seek : "",
            forx : "",  ifx : "", incx : "",ifdraw : "",
            forz : "",  ifz : "", incz : "",ifdraw : "",            
            x : "x",
            z : "z",
            y : "("+apf.draw.getXYWH(l.pformula,'x')+")"
        };
    },
    
    dt_math1R : function(l){
        var part = l.formula.split(";");
        return {
            type : 'math1R',
            vx1 : -1, vx2 : 1, vy1 : -1, vy2 : 1, vz1 : 0, vz2 : 1,
            x1 : 0, 
            x2 : "Math.PI*2+(Math.PI*2/(l.style.steps-1))", 
            xs : "l.style.steps",
            x : "__sin(_p="+apf.visualize.mathParse(part[0])+
                ")*(_r="+apf.visualize.mathParse(part[1])+")",
            y : "__cos(_p)*_r"
        };
    },    
    dt_series1XM : function(l) {
        return {
            type : 'series1XM',
            vars : 
            "var _mf = __min(__ceil(vx2)+1,l.v_yvalmip[0].length)-__max(__floor(vx1),0);"+ 
            "var _ms = l.mipstep, _mt = 1;"+
            "while(_mf>l.mipthres && _mt<l.v_yvalmip.length){"+
                "_mf = _mf / _ms;_mt++;"+
            "}"+
            "var _div = __pow(_ms,_mt-1);"+
            "var _off = _mt>1?__pow(_ms,_mt-2):0;"+
            "var _yv = l.v_yvalmip[_mt-1],_i;",
            
            vx1 : 0, vx2 : "_yv.length", vy1 : -1, vy2 : 1, vz1 : 0, vz2 : 1,
            state : "0",
            time : "0",

            sum : "l.v_sum",
            min : "l.v_min",
            max : "l.v_max",
            avg : "l.v_avg",
            
            seek : "",stats:"",
            ifdraw : "if((!l.mipmin || _mt>l.mipmin) && (!l.mipmax || _mt<l.mipmax))",
            forx : "",  ifx : "",
            incx : "",
            x1 : "__max(__floor(vx1/_div-1),0)", 
            x2 : "__min((__ceil(vx2/_div)+1),_yv.length)", 
            xs : "x2-x1",
            x : "(x*_div+_off)",
            y : "_yv[x]"
        };
    },    
    dt_series1X : function(l) {
        return {
            type : 'series1X',
            vars : "var _yv = l.v_yval,_sv = l.v_state, _tv = l.v_time,_i,_mi,_ma;",
            vx1 : 0, vx2 : "_yv.length", vy1 : -1, vy2 : 1, vz1 : 0, vz2 : 1,
            state : "_sv[x]",
            time : "_tv[x]",
            sum : "l.v_sum",
            min : "l.v_min",
            max : "l.v_max",
            avg : "l.v_avg",
            forx : "",  ifx : "", incx : "",
            stats : 
"if(!l.v_sum){for(i=_yv.length-1,j=0,_mi=10000000,_ma=-10000000;i>=0;--i)j+=((m=_yv[i])<_mi?_mi=m:m)>_ma?_ma=m:m;l.v_avg=(l.v_sum=j)/_yv.length;l.v_min=_mi;l.v_max=_ma;}",
            x1 : "__max(__floor(vx1),0)", 
            x2 : "__min(__ceil(vx2)+1,_yv.length)", 
            x1c : "__max(__floor(vx1),0)", 
            x2c : "__min(__ceil(vx2)+1,_yv.length)", 
            xs : "x2-x1",
            x : "x",
            y : "_yv[x]"
        };
    },
    dt_series2X : function(l) {
        var    len = l.yvalue.length;
        return {
            type : 'series2X',
            vx1 : 0, vx2 : len, vy1 : -1, vy2 : 1, vz1 : 0, vz2 : 1,
            vars : "var _vx = l.xvalue, _vy = l.yvalue, _len = _vy.length;",
            x1 : 0, 
            x2 : "_len", 
            xs : "_len",
            x : "_vx[x]",
            y : "_vy[x]"
        };
    },
$:0};
apf.chart_draw.height2D = apf.chart_draw.line2D;
apf.chart_draw._height2D = apf.chart_draw._line2D;



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/domparser.js)SIZE(15767)TIME(1265032027)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * The parser of the Ajax.org Markup Language. Besides aml this parser takes care
 * of distributing parsing tasks to other parsers like the native html parser and
 * the xsd parser.
 * @parser
 * @private
 *
 * @define include element that loads another aml files.
 * Example:
 * <code>
 *   <a:include src="bindings.aml" />
 * </code>
 * @attribute {String} src the location of the aml file to include in this application.
 * @addnode global, anyaml
 */
apf.DOMParser = function(){};

apf.DOMParser.prototype = new (function(){
    this.caseInsensitive    = true;
    this.preserveWhiteSpace = true; //@todo apf3.0 whitespace issue
    
    this.$shouldWait = 0;

    // privates
    var RE     = [
            /\<\!(DOCTYPE|doctype)[^>]*>/,
            /&nbsp;/g,
            /<\s*\/?\s*(?:\w+:\s*)[\w-]*[\s>\/]/g
        ],
        XPATH  = "//@*[not(contains(local-name(), '.')) and not(translate(local-name(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz') = local-name())]",
        DOMINS = "DOMNodeInsertedIntoDocument",
        DEF    = "@default",
        ID     = "id";
    
    this.parseFromString = function(xmlStr, mimeType, options){
        var xmlNode;
        if (this.caseInsensitive) {
            //replace(/&\w+;/, ""). replace this by something else
            var str = xmlStr.replace(RE[0], "").replace(RE[1], " ")
              .replace(RE[2], //.replace(/^[\r\n\s]*/, "")
                function(m){ return m.toLowerCase(); });
        
            /* @todo apf3.0 integrate this
            x.ownerDocument.setProperty("SelectionNamespaces",
                                    "xmlns:a='" + apf.ns.aml + "'");
            */
        
            if (!this.supportNamespaces)
                str = str.replace(/xmlns\=\"[^"]*\"/g, "");
        
            
            xmlNode = apf.getXmlDom(str, null, this.preserveWhiteSpace || apf.debug).documentElement;
            var i, l,
                nodes = xmlNode.selectNodes(XPATH);
            // Case insensitive support
            for (i = 0, l = nodes.length; i < l; i++) {
                (nodes[i].ownerElement || nodes[i].selectSingleNode(".."))
                    .setAttribute(nodes[i].nodeName.toLowerCase(), nodes[i].nodeValue);
            }
            
        }
        else {
            xmlNode = apf.getXmlDom(xmlStr, null, this.preserveWhiteSpace || apf.debug).documentElement;
        }
        
        return this.parseFromXml(xmlNode, options);
    };
    
    //@todo prevent leakage by not recording .$aml
    this.parseFromXml = function(xmlNode, options){
        var doc, docFrag;
        if (!options) 
            options = {};
        
        if (!options.delayedRender) {
            //Create a new document
            if (options.doc) {
                doc     = options.doc;
                docFrag = options.docFrag || doc.createDocumentFragment();
            }
            else {
                doc            = new apf.AmlDocument();
                doc.$aml       = xmlNode;
                doc.$domParser = this;
            }
            
            
            //Check for children in Aml node
            /*if (!xmlNode.childNodes.length) {
                apf.console.warn("DOMParser got markup without any children");
                return (docFrag || doc);
            }*/
            
            
            //Let's start building our tree
            var amlNode = this.$createNode(doc, xmlNode.nodeType, xmlNode); //Root node
            (docFrag || doc).appendChild(amlNode);
            if (options.htmlNode)
                amlNode.$int = options.htmlNode;
        }
        else {
            var amlNode = options.amlNode;
            var doc     = options.doc;
        }

        //Set parse context
        this.$parseContext = [amlNode, options];

        //First pass - Node creation
        var nodes, nodelist = {}, prios = [], _self = this;
        (function recur(amlNode, nodes){
            var cL, newNode, node, nNodes,
                cNodes = amlNode.childNodes,
                i      = 0,
                l      = nodes.length;
            for (; i < l; i++) {
                //Create child
                newNode = _self.$createNode(doc, (node = nodes[i]).nodeType, node);
                if (!newNode) continue; //for preserveWhitespace support

                cNodes[cL = cNodes.length] = newNode; //Add to children
                
                //Set tree refs
                newNode.parentNode = amlNode;
                if (cL > 0)
                    (newNode.previousSibling = cNodes[cL - 1]).nextSibling = newNode;

                //Create children
                if (!newNode.render && newNode.canHaveChildren && (nNodes = node.childNodes).length)
                    recur(newNode, nNodes);
                
                //newNode.$aml = node; //@todo should be deprecated...
                
                //Store high prio nodes for prio insertion
                if (newNode.$parsePrio) {
                    if (newNode.$parsePrio == "001") {
                        newNode.dispatchEvent(DOMINS); //{relatedParent : nodes[j].parentNode}
                        continue;
                    }
                        
                    (nodelist[newNode.$parsePrio] || (prios.push(newNode.$parsePrio) 
                      && (nodelist[newNode.$parsePrio] = []))).push(newNode); //for second pass
                }
            }
            
            amlNode.firstChild = cNodes[0];
            amlNode.lastChild  = cNodes[l - 1];
        })(amlNode, xmlNode.childNodes);

        if (options.delay) {
            amlNode.$parseOptions = {
                prios: prios,
                nodelist: nodelist
            };
            return (docFrag || doc);
        }
        
        //Second pass - Document Insert signalling
        prios.sort();
        var i, j, l, l2;
        for (i = 0, l = prios.length; i < l; i++) {
            nodes = nodelist[prios[i]];
            for (j = 0, l2 = nodes.length; j < l2; j++)
                nodes[j].dispatchEvent(DOMINS); //{relatedParent : nodes[j].parentNode}
        }

        if (this.$shouldWait)
            return (docFrag || doc);

        if (options.timeout) {
            $setTimeout(function(){
                _self.$continueParsing(amlNode, options);
            });
        }
        else {
            this.$continueParsing(amlNode, options);
        }

        return (docFrag || doc);
    };
    
    this.$callCount = 0;
    this.$continueParsing = function(amlNode, options){
        if (this.$shouldWait && --this.$shouldWait != 0)
            return;

        if (!options)
            options = {};
            
        this.$callCount++;

        if (amlNode.$parseOptions) {
            var prios    = amlNode.$parseOptions.prios,
                nodelist = amlNode.$parseOptions.nodelist,
                i, j, l, l2, node;
            delete amlNode.$parseOptions;
            
            //Second pass - Document Insert signalling
            prios.sort();
            for (i = 0, l = prios.length; i < l; i++) {
                nodes = nodelist[prios[i]];
                for (j = 0, l2 = nodes.length; j < l2; j++) {
                    if (!(node = nodes[j]).parentNode || node.$amlLoaded) //@todo generalize this using compareDocumentPosition
                        continue;
                    nodes[j].dispatchEvent(DOMINS); //{relatedParent : nodes[j].parentNode}
                }
            }
        }
        
        //instead of $amlLoaded use something more generic see compareDocumentPosition
        if (!options.ignoreSelf && !amlNode.$amlLoaded)
            amlNode.dispatchEvent(DOMINS); //{relatedParent : nodes[j].parentNode}

        //Recursively signal non prio nodes
        (function _recur(nodes){
            var node, nNodes;
            for (var i = 0, l = nodes.length; i < l; i++) {
                if (!(node = nodes[i]).$parsePrio && !node.$amlLoaded)
                    node.dispatchEvent(DOMINS); //{relatedParent : nodes[j].parentNode}
                
                //Create children
                if (!node.render && (nNodes = node.childNodes).length)
                    _recur(nNodes);
            }
        })(amlNode.childNodes);
        
        if (!this.$callCount && !options.delay)
            apf.queue.empty();
        
        if (options.callback)
            options.callback.call(amlNode.ownerDocument);
        
        delete this.$parseContext;
    };
    
    this.$createNode = function(doc, nodeType, xmlNode, namespaceURI, nodeName, nodeValue){
        var o;
        switch (nodeType) {
            case 1:
                var id, prefix;
                if (xmlNode) {
                    if ((namespaceURI = xmlNode.namespaceURI || apf.ns.xhtml) 
                      && !(prefix = doc.$prefixes[namespaceURI])) {
                        doc.$prefixes[prefix = xmlNode.prefix || xmlNode.scopeName || ""] = namespaceURI;
                        doc.$namespaceURIs[namespaceURI] = prefix;
                        
                        if (!doc.namespaceURI && !prefix) {
                            doc.namespaceURI = namespaceURI;
                            doc.prefix       = prefix;
                        }
                    }
                    nodeName = xmlNode.baseName || xmlNode.localName || xmlNode.tagName.split(":").pop();
                }
                else {
                    prefix = doc.$prefixes[namespaceURI] || "";
                }
                
                
                if (!namespaceURI) {
                    throw new Error("Missing namespace definition."); //@todo apf3.0 make proper error
                }
                if (!apf.namespaces[namespaceURI]) {
                    if (this.allowAnyElement)
                        namespaceURI = apf.ns.xhtml;
                    else 
                        throw new Error("Missing namespace handler for '" + namespaceURI + "'"); //@todo apf3.0 make proper error
                }
                
                
                var els = apf.namespaces[namespaceURI].elements;

                
                if (!(els[nodeName] || els[DEF])) {
                    throw new Error("Missing element constructor: " + nodeName); //@todo apf3.0 make proper error
                }
                
                
                o = new (els[nodeName] || els[DEF])(null, nodeName);
                
                o.prefix       = prefix || "";
                o.namespaceURI = namespaceURI;
                o.tagName      = prefix ? prefix + ":" + nodeName : nodeName;
        
                if (xmlNode) {
                    if (id = xmlNode.getAttribute(ID))
                        o.$propHandlers[ID].call(o, o.id = id);

                    //attributes
                    var attr = xmlNode.attributes, n;
                    for (var a, i = 0, l = attr.length; i < l; i++) {
                        o.attributes.push(new apf.AmlAttr(o, 
                            (n = (a = attr[i]).nodeName), a.nodeValue));
                        
                        if (n == "render")
                            o.render = true;
                        
                    }
                }
                
                break;
            case 2:
                o = new apf.AmlAttr();
                o.name  = o.nodeName = nodeName;
                if (nodeValue || (nodeValue = xmlNode && xmlNode.nodeValue))
                    o.value = o.nodeValue = nodeValue;

                if (xmlNode) {
                    if (xmlNode.namespaceURI && !(o.prefix = doc.$namespaceURIs[o.namespaceURI = xmlNode.namespaceURI]))
                        doc.$prefixes[o.prefix = xmlNode.prefix || xmlNode.scopeName] = o.namespaceURI;
                }
                else {
                    o.prefix = doc.$prefixes[namespaceURI];
                }
                
                break;
            case 3:
                if (xmlNode) 
                    nodeValue = xmlNode && xmlNode.nodeValue;
                if (!this.preserveWhitespace && !(nodeValue || "").trim())
                    return;

                o = new apf.AmlText();
                o.nodeValue = nodeValue || xmlNode && xmlNode.nodeValue;
                break;
            case 7:
                var target = nodeName || xmlNode && xmlNode.nodeName;
                
                if(!apf.aml.processingInstructions[target])
                    throw new Error(apf.formatErrorString(0, null,
                        "The processing instruction does not exist", "Could not find the processing instruction with target: " + target));
                
                o = new apf.aml.processingInstructions[target]();
                o.target = o.nodeName  = target;
                o.data   = o.nodeValue = nodeValue || xmlNode && xmlNode.nodeValue;
                break;
            case 4:
                o = new apf.AmlCDATASection();
                o.nodeValue = nodeValue || xmlNode && xmlNode.nodeValue;
                break;
            case 5: //unsupported
                o = new apf.AmlNode();
                o.nodeType = nodeType;
                break;
            case 6: //unsupported
                o = new apf.AmlNode();
                o.nodeType = nodeType;
                break;
            case 8:
                o = new apf.AmlComment();
                o.nodeValue = nodeValue || xmlNode && xmlNode.nodeValue;
                break;
            case 9:
                o = new apf.AmlDocument();
                o.$domParser = this;
                break;
            case 10: //unsupported
                o = new apf.AmlNode();
                o.nodeType = nodeType;
                break;
            case 11:
                o = new apf.AmlDocumentFragment();
                break;
        }
        
        o.$aml          = xmlNode;
        o.ownerDocument = doc;
        
        return o;
    };
})();

/**
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 */
apf.AmlNamespace = function(){
    this.elements = {};
    this.processingInstructions = {};
};

apf.AmlNamespace.prototype = {
    setElement : function(tagName, fConstr){
        return this.elements[tagName] = fConstr;
    },
    
    setProcessingInstruction : function(target, fConstr){
        this.processingInstructions[target] = fConstr;
    }
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml.js)SIZE(1478)TIME(1257329185)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * The parser of the Ajax.org Markup Language. Besides aml this parser takes care
 * of distributing parsing tasks to other parsers like the native html parser and
 * the xsd parser.
 * @parser
 * @private
 *
 * @define include element that loads another aml files.
 * Example:
 * <code>
 *   <a:include src="bindings.aml" />
 * </code>
 * @attribute {String} src the location of the aml file to include in this application.
 * @addnode global, anyaml
 */
apf.aml = new apf.AmlNamespace();
apf.setNamespace("http://ajax.org/2005/aml", apf.aml);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/node.js)SIZE(20969)TIME(1264690337)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__AMLNODE__ = 1 << 14;



/**
 * All elements inheriting from this {@link term.baseclass baseclass} have Document Object Model (DOM) support. The DOM
 * is the primary method for accessing and manipulating an xml document. This
 * includes html documents and aml documents. Every element in the ajax.org
 * markup language can be manipulated using the W3C DOM. This means
 * that every element and attribute you can set in the xml format, can be
 * changed, set, removed reparented, etc runtime. This offers a great deal of
 * flexibility. Well known methods
 * from this specification are .appendChild .removeChild .setAttribute and
 * insertBefore to name a few. Ajax.org Platform aims to implement DOM1
 * completely and parts of DOM2. Which should be extended in the future to fully
 * implement DOM Level 2. For more information see {@link http://www.w3.org/DOM/} 
 * or {@link http://www.w3schools.com/dom/default.asp}.
 * Example:
 * Ajax.org Markup Language
 * <code>
 *  <a:window id="winExample" title="Example" visible="true">
 *      <a:button id="tstButton" />
 *  </a:window>
 * </code>
 * Document Object Model in javascript
 * <code>
 *  //The following line is only there for completeness sake. In fact apf
 *  //automatically adds a reference in javascript called winExample based
 *  //on the id it has.
 *  var winExample = apf.document.getElementById("winExample");
 *  winExample.setAttribute("title", "Example");
 *  winExample.setAttribute("icon", "icoFolder.gif");
 *  winExample.setAttribute("left", "100");
 *
 *  var lblNew = apf.document.createElement("label");
 *  winExample.appendChild(lblNew);
 *  lblNew.setAttribute("caption", "Example");
 *
 *  tstButton.setAttribute("caption", "Click me");
 * </code>
 * That would be the same as having the following aml:
 * <code>
 *  <a:window id="winExample"
 *    title   = "Example"
 *    icon    = "icoFolder.gif"
 *    left    = "100"
 *    visible = "true">
 *      <a:button id="tstButton" caption="Click me"/>
 *      <a:label caption="Example" />
 *  </a:window>
 * </code>
 * Remarks:
 * Because the W3C DOM is native to all modern browsers the internet is full
 * of tutorials and documentation for this API. If you need more information
 * it's a good idea to search for tutorials online.
 *
 * @event DOMNodeInserted
 * @event DOMNodeInsertedIntoDocument
 * @event DOMNodeRemoved
 * @event DOMNodeRemovedFromDocument
 *
 * @constructor
 * @baseclass
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.5
 */
apf.AmlNode = function(){
    this.$init(function(){
        /**
         * Nodelist containing all the child nodes of this element.
         */
        this.childNodes = []; //@todo AmlNodeList
    });
};

(function() {

    
    
    /**
     * Number specifying the type of node within the document.
     */
    this.$regbase = this.$regbase | apf.__AMLNODE__;
    
    /**
     * Constant for a dom element node.
     * @type {Number}
     */
    this.NODE_ELEMENT                = 1;
    /**
     * Constant for a dom attribute node.
     * @type {Number}
     */
    this.NODE_ATTRIBUTE              = 2;
    /**
     * Constant for a dom text node.
     * @type {Number}
     */
    this.NODE_TEXT                   = 3;
    /**
     * Constant for a dom cdata section node.
     * @type {Number}
     */
    this.NODE_CDATA_SECTION          = 4;
    /**
     * Constant for a dom entity reference node.
     * @type {Number}
     */
    this.NODE_ENTITY_REFERENCE       = 5;
    /**
     * Constant for a dom entity node.
     * @type {Number}
     */
    this.NODE_ENTITY                 = 6;
    /**
     * Constant for a dom processing instruction node.
     * @type {Number}
     */
    this.NODE_PROCESSING_INSTRUCTION = 7;
    /**
     * Constant for a dom comment node.
     * @type {Number}
     */
    this.NODE_COMMENT                = 8;
    /**
     * Constant for a dom document node.
     * @type {Number}
     */
    this.NODE_DOCUMENT               = 9;
    /**
     * Constant for a dom document type node.
     * @type {Number}
     */
    this.NODE_DOCUMENT_TYPE          = 10;
    /**
     * Constant for a dom document fragment node.
     * @type {Number}
     */
    this.NODE_DOCUMENT_FRAGMENT      = 11;
    /**
     * Constant for a dom notation node.
     * @type {Number}
     */
    this.NODE_NOTATION               = 12;
    
    

    /**
     * The document node of this application
     */
    this.ownerDocument = null;

    /**
     * Returns the value of the current node. 
     */
    this.nodeValue = "";
    
    /**
     * The namespace URI of the node, or null if it is unspecified (read-only). 
     * When the node is a document, it returns the XML namespace for the current 
     * document.
     */
    this.namespaceURI = "";
    
    /**
     * @todo
     */
    //this.baseURI = alsdjlasdj
    
    /**
     * @todo
     */
    //this.prefix = asdkljahqsdkh
        
    /**
     * Appends an element to the end of the list of children of this element.
     * If the element was already a child of another element it is removed from
     * that parent before adding it this element.
     *
     * @param  {AmlNode}  amlNode  the element to insert as child of this element.
     * @return  {AmlNode}  the appended node
     * @method
     */
    this.appendChild =

    /**
     * Inserts an element before another element in the list of children of this
     * element. * If the element was already a child of another element it is
     * removed from that parent before adding it this element.
     *
     * @param  {AmlNode}  amlNode     the element to insert as child of this element.
     * @param  {AmlNode}  beforeNode  the element which determines the insertion position of the element.
     * @return  {AmlNode}  the inserted node
     */
    this.insertBefore = function(amlNode, beforeNode, noHtmlDomEdit){
        
        if (!amlNode || !amlNode.hasFeature || !amlNode.hasFeature(apf.__AMLNODE__)){
            throw new Error(apf.formatErrorString(1072, this,
                "Insertbefore DOM operation",
                "Invalid argument passed. Expecting an AmlElement."));
        }
        
        
        if (this.nodeType == this.NODE_DOCUMENT) {
            if (this.childNodes.length) {
                throw new Error(apf.formatErrorString(0, this,
                    "Insertbefore DOM operation",
                    "Only one top level element is allowed in an AML document."));
            }
            else this.documentElement = amlNode; //@todo apf3.0 removal
        }

        if (amlNode.nodeType == this.NODE_DOCUMENT_FRAGMENT) {
            var nodes = amlNode.childNodes.slice(0);
            for (var i = 0, l = nodes.length; i < l; i++) {
                this.insertBefore(nodes[i], beforeNode);
            }
            return amlNode;
        }
        
        var isMoveWithinParent = amlNode.parentNode == this,
            oldParentHtmlNode  = amlNode.$pHtmlNode,
            oldParent          = amlNode.parentNode,
            index              = -1,
            _self              = this;
        
        if (beforeNode) {
            index = this.childNodes.indexOf(beforeNode);
            if (index < 0) {
                
                if (beforeNode == this)
                    throw new Error(apf.formatErrorString(1072, this,
                        "Insertbefore DOM operation",
                        "Before node is the same node as inserted node"));
                else 
                    throw new Error(apf.formatErrorString(1072, this,
                        "Insertbefore DOM operation",
                        "Before node is not a child of the parent node specified"));
                

                return false;
            }
        }

        if (!amlNode.ownerDocument)
            amlNode.ownerDocument = this.ownerDocument || apf.ownerDocument;

        if (amlNode.parentNode)
            amlNode.removeNode(isMoveWithinParent, noHtmlDomEdit);
        amlNode.parentNode = this;

        if (beforeNode) {
            amlNode.nextSibling = beforeNode;
            amlNode.previousSibling = beforeNode.previousSibling;
            beforeNode.previousSibling = amlNode;
            if (amlNode.previousSibling)
                amlNode.previousSibling.nextSibling = amlNode;
        }

        if (index >= 0) {
            this.childNodes = this.childNodes.slice(0, index).concat(amlNode,
                this.childNodes.slice(index));
        }
        else {
            index = this.childNodes.push(amlNode) - 1;

            amlNode.nextSibling = null;
            if (index > 0) {
                amlNode.previousSibling = this.childNodes[index - 1];
                amlNode.previousSibling.nextSibling = amlNode;
            }
            else {
                amlNode.previousSibling = null;
            }
        }

        this.firstChild = this.childNodes[0];
        this.lastChild  = this.childNodes[this.childNodes.length - 1];

        //@todo fix event struture, fix tree events
        function triggerUpdate(){
            amlNode.$pHtmlNode = _self.canHaveChildren ? _self.$int : document.body;

            //Signal node and all it's ancestors
            amlNode.dispatchEvent("DOMNodeInserted", {
                $beforeNode         : beforeNode,
                relatedNode         : _self,
                $isMoveWithinParent : isMoveWithinParent,
                $oldParentHtmlNode  : oldParentHtmlNode,
                $oldParent          : oldParent,
                bubbles             : true
            });

            //@todo this is a hack, a good solution should be found
            var iframelist;
            var containsIframe = (amlNode.$ext && amlNode.$ext.nodeType == 1 
              && (iframelist = amlNode.$ext.getElementsByTagName("iframe")).length > 0
              && apf.findHost(iframelist[0].parentNode) == amlNode);

            //!apf.isGecko && 
            if (!noHtmlDomEdit && amlNode.$ext && !containsIframe) {
                amlNode.$pHtmlNode.insertBefore(amlNode.$ext,
                    beforeNode && beforeNode.$ext || null);
            }
        }

        var doc = this.nodeType == this.NODE_DOCUMENT ? this : this.ownerDocument;
        if (!doc || doc.$domParser.$shouldWait)
            return amlNode;

        if (this.nodeType == this.NODE_DOCUMENT_FRAGMENT)
            return; //We don't update the tree if this is a doc fragment

        //@todo review this...
        //this.nodeType == 1 && 
        if (!amlNode.$amlLoaded) {
            //amlNode.$reappendToParent = triggerUpdate;
            (this.ownerDocument || this).$domParser.$continueParsing(amlNode, {delay: true});
            //return amlNode; //@todo apf3.0 so we do call DOMNodeInserted here
        }

        triggerUpdate();
        return amlNode;
    };

    /**
     * Removes this element from the document hierarchy. Call-chaining is
     * supported.
     *
     */
    this.removeNode = function(doOnlyAdmin, noHtmlDomEdit){
        
        if (doOnlyAdmin && typeof doOnlyAdmin != "boolean") {
            throw new Error(apf.formatErrorString(0, this,
                "Removing node from parent",
                "Invalid DOM Call. removeNode() does not take any arguments."));
        }
        

        if (!this.parentNode || !this.parentNode.childNodes)
            return this;

        
        if (!this.parentNode.childNodes.contains(this)) {
            /*throw new Error(apf.formatErrorString(0, this,
                "Removing node from parent",
                "Passed node is not a child of this node.", this.$aml));*/
            return false;
        }
        

        this.parentNode.childNodes.remove(this);
        
        //If we're not loaded yet, just remove us from the aml to be parsed
        if (this.$amlLoaded && !apf.isDestroying) {
            //this.parentNode.$aml.removeChild(this.$aml);

            if (!noHtmlDomEdit && this.$ext && this.$ext.parentNode)
                this.$ext.parentNode.removeChild(this.$ext);

            this.dispatchEvent("DOMNodeRemoved", {
                relatedNode  : this.parentNode,
                bubbles      : true,
                $doOnlyAdmin : doOnlyAdmin
            });
        }

        if (this.parentNode.firstChild == this)
            this.parentNode.firstChild = this.nextSibling;
        if (this.parentNode.lastChild == this)
            this.parentNode.lastChild = this.previousSibling;

        if (this.nextSibling)
            this.nextSibling.previousSibling = this.previousSibling;
        if (this.previousSibling)
            this.previousSibling.nextSibling = this.nextSibling;

        this.$pHtmlNode      =
        this.parentNode      =
        this.previousSibling =
        this.nextSibling     = null;

        return this;
    };

    /**
     * Removes a child from the node list of this element. Call-chaining is
     * supported.
     */
    this.removeChild = function(childNode) {
        
        if (!childNode || !childNode.hasFeature || !childNode.hasFeature(apf.__AMLNODE__)) {
            throw new Error(apf.formatErrorString(0, this,
                "Removing a child node",
                "Invalid Argument. removeChild() requires one argument of type AMLElement."));
        }
        

        childNode.removeNode();
        return this;
    };
    
    //@todo
    this.replaceChild = function(){};

    /**
     * Clones this element, creating an exact copy of it but does not insert
     * it in the document hierarchy.
     * @param {Boolean} deep whether the element's are cloned recursively.
     * @return {AmlNode} the cloned element.
     */
    this.cloneNode = function(deep){
        if (deep && this.nodeType == 1) {
            return this.ownerDocument.$domParser.parseFromXml(this, {
                doc   : this.ownerDocument,
                delay : true
            }).childNodes[0];
        }
        else {
            return this.ownerDocument.$domParser.$createNode(
                this.ownerDocument, this.nodeType, this);
        }
    };
    
    //@todo
    this.canDispatch = function(namespaceURI, type){};
    
    //@todo
    this.compareDocumentPosition = function(otherNode){
        /*
            DOCUMENT_POSITION_DISCONNECTED = 0x01;
            DOCUMENT_POSITION_PRECEDING = 0x02;
            DOCUMENT_POSITION_FOLLOWING = 0x04;
            DOCUMENT_POSITION_CONTAINS = 0x08;
            DOCUMENT_POSITION_CONTAINED_BY = 0x10;
        */
    };
    
    this.hasAttributes = function(){
        return this.attributes && this.attributes.length;
    };
    
    this.hasChildNodes = function(){
        return this.childNodes && this.childNodes.length;
    };
    
    this.isDefaultNamespace = function(namespaceURI){
        if (node.nodeType == 1) {
            if (!this.prefix)
                return this.namespaceURI == namespaceURI;
            
            //@todo Loop through attributes here
        }
        
        var node = this.parentNode || this.ownerElement;
        return node && node.isDefaultNamespace(namespaceURI);
    };
    
    this.lookupNamespaceURI = function(prefix){
        if (node.nodeType == 1) {
            if (this.namespaceURI && prefix == this.prefix)
                return this.namespaceURI ;
                
            //@todo Loop through attributes here
        }
        
        var node = this.parentNode || this.ownerElement;
        return node && node.lookupNamespaceURI(prefix);
    };
    
    this.lookupPrefix = function(namespaceURI){
        if (this.nodeType == 1) {
            if (namespaceURI == this.namespaceURI && this.prefix)
                return this.prefix;
            
            //@todo Loop through attributes here
        }
        
        var node = this.parentNode || this.ownerElement;
        return node && node.lookupPrefix(namespaceURI);    
    };
    
    this.normalize = function(){};
    
    /**** Xpath support ****/

    /**
     * Queries the aml dom using the W3C xPath query language and returns a node
     * list. This is not an official API call but can be useful in certain cases.
     * see {@link core.documentimplementation.method.evaluate evaluate on the apf.document}
     * @param {String}  sExpr          the xpath expression to query the aml DOM tree with.
     * @param {AmlNode} [contextNode]  the element that serves as the starting point of the search. Defaults to this element.
     * @returns {NodeList} list of found nodes.
     */
    this.selectNodes = function(sExpr, contextNode){
        if (!apf.XPath)
            apf.runXpath();
        return apf.XPath.selectNodes(sExpr,
            contextNode || (this.nodeType == 9 ? this.documentElement : this));
    };

    /**
     * Queries the aml dom using the W3C xPath query language and returns a single
     * node. This is not an official API call but can be useful in certain cases.
     * see {@link core.documentimplementation.method.evaluate evaluate on the apf.document}
     * @param {String}  sExpr          the xpath expression to query the aml DOM tree with.
     * @param {AmlNode} [contextNode]  the element that serves as the starting point of the search. Defaults to this element.
     * @returns {AmlNode} the first node that matches the query.
     */
    this.selectSingleNode  = function(sExpr, contextNode){
        if (!apf.XPath)
            apf.runXpath();
        return apf.XPath.selectNodes(sExpr,
            contextNode || (this.nodeType == 9 ? this.documentElement : this))[0];
    };
    
    /*this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        
    }, true);*/
}).call(apf.AmlNode.prototype = new apf.Class());



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/element.js)SIZE(19048)TIME(1264618245)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.AmlElement = function(struct, tagName){
    var $init = this.$init;
    this.$init = function(tagName, nodeFunc, struct){
        this.$supportedProperties = this.$supportedProperties.slice();
        
        var prop, p, q;
        p = this.$propHandlers;
        q = this.$propHandlers = {};
        for (prop in p)
            q[prop] = p[prop];
        
        p = this.$booleanProperties;
        q = this.$booleanProperties = {};
        for (prop in p)
            q[prop] = p[prop];
        
        $init.call(this, tagName, nodeFunc, struct);
    };
    
    this.$init(function(tagName, nodeFunc, struct){
        this.$events            = {};
        this.$inheritProperties = {};
        
        /**
         * Nodelist containing all attributes. This is implemented according to the
         * W3C specification.
         * Example:
         * <code>
         *  for (var i = 0; i < obj.attributes.length; i++) {
         *      alert(obj.attributes.item(i));
         *  }
         * </code>
         * @see baseclass.amldom.method.getAttribute
         * @see baseclass.amldom.method.setAttribute
         */
        this.attributes = new apf.AmlNamedNodeMap(this); //@todo apf3.0 move to init?
        
        /**
         * The purpose of this element
         * Possible values:
         * apf.NODE_VISIBLE     this element has a gui representation
         * apf.NODE_HIDDEN      this element does not display a gui
         */
        this.nodeFunc = nodeFunc;
        
        /**
         * The local name of this element
         */
        this.localName = tagName; //@todo
        
        //Parse struct to create attributes and child nodes
        if (struct) {
            var nodes, prop, i, l;
            if (struct.childNodes) {
                nodes = struct.childNodes;
                delete struct.childNodes; //why delete?
            }
            
            //Attributes
            for (prop in struct){ 
                if (prop == "htmlNode") continue;
                
                this.attributes.push(new apf.AmlAttr(this, prop, struct[prop]));
            }
            
            if (!this.ownerDocument) {
                this.ownerDocument = apf.document;
                this.prefix       = "";
                this.namespaceURI = null;
                this.tagName      = tagName;
            }
            
            if (nodes) {
                this.childNodes = nodes;

                for (i = 0, l = nodes.length; i < l; i++) {
                    nodes[i].nextSibling = nodes[i + 1] || null;
                    nodes[i].previousSibling = nodes[i - 1] || null;
                    nodes[i].parentNode = this;
                }
                this.firstChild = nodes[0] || null;
                this.lastChild  = nodes[nodes.length - 1] || null;
            }

            //Temp hack
            this.$aml = apf.$emptyNode || (apf.$emptyNode = apf.getXml("<empty />"));
        }
    });
    
    if (tagName) //of typeof is not function and not true
        $init.call(this, tagName, apf.NODE_HIDDEN, struct);
};

(function(){
    /**
     * Number specifying the type of node within the document.
     */
    this.nodeType = this.NODE_ELEMENT;
    this.canHaveChildren = true;
    
    this.$propHandlers = {
        /**
         * @attribute {String} id the identifier of this element. When set this
         * identifier is the name of the variable in javascript to access this
         * element directly. This identifier is also the way to get a reference to
         * this element using apf.document.getElementById.
         * Example:
         * <code>
         *  <a:bar id="barExample" />
         *  <a:script>
         *      alert(barExample);
         *  </a:script>
         * </code>
         */
        "id": function(value){
            
            if (value == "apf") {
                throw new Error(apf.formatErrorString(0, this, 
                    "Setting Name of Element",
                    "Cannot set name of element to 'apf'"));
            }
            
            
            if (this.name == value)
                return;
    
            if (self[this.name] == this)
                self[this.name] = null
    
            if (!self[value] || !self[value].hasFeature) {
                try {
                    self[value] = this;
                }
                catch(ex) {
                    
                    var error = true;
                    
                }
            }
            
            if (error && value in self) {
                apf.console.warn("trying to set a value in the global scope with "
                                + "a reserved name '" + value + "'.\nNothing wrong "
                                + "with that, except that you will not be able to "
                                + "reference\nthe object from the global scope in JS.")
            }
            
            
            //@todo dispatch event for new name creation.
            //@todo old name disposal
            
            apf.nameserver.register(this.localName, value, this)
            
            this.name = value;
        }
    };
    
    this.$booleanProperties   = {};
    this.$inheritProperties   = {};
    this.$supportedProperties = [];
    
    /**
     * Returns a list of elements with the given tag name.
     * The subtree below the specified element is searched, excluding the
     * element itself.
     *
     * @method
     * @param  {String}  tagName  the tag name to look for. The special string "*" represents any tag name.
     * @return  {NodeList}  containing any node matching the search string
     */
    this.getElementsByTagName = function(tagName, norecur){
        tagName = tagName.toLowerCase();
        var node, i, l,
            nodes  = this.childNodes,
            result = [];
        for (i = 0, l = nodes.length; i < l; i++) {
            if ((node = nodes[i]).nodeType != 1)
                continue;
            
            if (node.tagName == tagName || tagName == "*")
                result.push(node);

            if (!norecur && node.nodeType == 1)
                result = result.concat(node.getElementsByTagName(tagName));
        }
        
        return result;
    };
    
    this.getElementsByTagNameNS = function(namespaceURI, localName, norecur){
        localName = localName.toLowerCase();
        var node, i, l,
            nodes  = this.childNodes,
            result = [];
        for (i = 0, l = nodes.length; i < l; i++) {
            if ((node = nodes[i]).nodeType != 1)
                continue;

            if (node.namespaceURI == namespaceURI && (node.localName == localName || localName == "*"))
                result.push(node);

            if (!norecur && node.nodeType == 1)
                result = result.concat(node.getElementsByTagNameNS(namespaceURI, localName));
        }
        
        return result;
    };

    /**
     * Sets an attribute on this element. Call-chaining is supported.
     * @param {String} name the name of the attribute to which the value is set
     * @param {String} value the new value of the attribute.
     */
    this.setAttribute = function(name, value, noTrigger) {
        name = name.toLowerCase();
        
        var a = this.attributes.getNamedItem(name);
        if (!a) {
            this.attributes.push(a = new apf.AmlAttr(this, name, value));
        
            if (!this.$amlLoaded)
                return;
            
            if (noTrigger)
                a.$setValue(value);
            else {
                //@todo apf3.0 domattr
                a.dispatchEvent("DOMNodeInsertedIntoDocument", {
                    relatedNode : this
                });
                
                //@todo apf3.0 domattr
                a.dispatchEvent("DOMNodeInserted", {
                    relatedNode : this,
                    bubbles     : true
                });
            }

            return;
        }

        a.$setValue(value);
        
        if (noTrigger || !this.$amlLoaded)
            return;
        
        //@todo apf3.0 domattr
        a.$triggerUpdate();
    };
    
    //@todo apf3.0 domattr
    this.setAttributeNode = function(attrNode){
        this.attributes.setNamedItem(attrNode);
    };
    
    this.setAttributeNS = function(namespaceURI, name, value){
        return this.setAttribute(name, value);
    };
    
    //@todo apf3.0 domattr
    this.hasAttribute = function(name){
        return this.getAttributeNode(name) ? true : false;
    };
    
    //@todo
    this.hasAttributeNS = function(namespaceURI, name){
        return this.hasAttribute(name);
    };
    
    /**
     * Removes an attribute from this element. Call-chaining is supported.
     * @param {String} name the name of the attribute to remove.
     */
    //@todo apf3.0 domattr
    this.removeAttribute = function(name){
        this.attributes.removeNamedItem(name);
        return this;
    };
    
    //@todo apf3.0 domattr
    this.removeAttributeNS = function(namespaceURI, name){
        return this.removeAttribute(name);
    };
    
    //@todo apf3.0 domattr
    this.removeAttributeNode = function(attrNode){
        this.attributes.removeNamedItem(attrNode.name); //@todo this should probably be slightly different.
    };

    /**
     * Retrieves the value of an attribute of this element
     * @param  {String}  name       the name of the attribute for which to return the value.
     * @param  {Boolean} [inherited]
     * @return {String} the value of the attribute or null if none was found with the name specified.
     * @method
     */
    this.getAttribute = function(name, inherited){
        var item = this.attributes.getNamedItem(name);
        return item ? (inherited 
            ? item.inheritedValue || item.nodeValue 
            : item.nodeValue) : null;
    };
    
    /**
     * Retrieves the attribute node for a given name
     * @param {String} name the name of the attribute to find.
     * @return {AmlNode} the attribute node or null if none was found with the name specified.
     */
    this.getAttributeNode = function(name){
        return this.attributes.getNamedItem(name);
    };

    this.getBoundingClientRect = function(){
        return new apf.AmlTextRectangle(this);
    };
    
    //@todo
    this.querySelector = function(){
        // here we should use: http://code.google.com/p/css2xpath/source/browse/trunk/src/css2xpath.js
    };
    
    //@todo
    this.querySelectorAll = function(){
        // here we should use: http://code.google.com/p/css2xpath/source/browse/trunk/src/css2xpath.js
    };
    
    //@todo
    this.scrollIntoView = function(){
        
    };
    
    /**
     * Replaces the child aml elements with new aml.
     * @param {mixed}       amlDefNode  the aml to be loaded. This can be a string or a parsed piece of xml.
     * @param {HTMLElement} oInt        the html parent of the created aml elements.
     */
    this.replaceMarkup = function(amlDefNode, options) {
        
        apf.console.info("Remove all children from element");
        

        if (!options)
            options = {};

        if (!options.$intAML)
            options.$intAML = this.$aml;
        if (!options.$int)
            options.$int = this.$int;
        options.clear = true;
        
        //Remove All the childNodes
        for (var i = this.childNodes.length - 1; i >= 0; i--) {
            var oItem = this.childNodes[i];
            /*var nodes = oItem.childNodes;
            for (var k = 0; k < nodes.length; k++)
                if (nodes[k].destroy)
                    nodes[k].destroy(true);

            if (oItem.$aml && oItem.$aml.parentNode)
                oItem.$aml.parentNode.removeChild(oItem.$aml);*/

            if (oItem.destroy)
                oItem.destroy(true);

            if (oItem.$ext != this.$int)
                apf.destroyHtmlNode(oItem.$ext);
        }
        
        this.childNodes.length = 0;
        this.$int.innerHTML = "<div class='loading'>loading...</div>";

        //Do an insertMarkup
        this.insertMarkup(amlDefNode, options);
    };

    /**
     * Inserts new aml into this element.
     * @param {mixed}       amlDefNode  the aml to be loaded. This can be a string or a parsed piece of xml.
     * @param {HTMLElement} oInt        the html parent of the created aml elements.
     */
    this.insertMarkup = function(amlDefNode, options){
        
        apf.console.info("Loading sub markup from external source");
        

        
        if (typeof apf.offline != "undefined" && !apf.offline.onLine)
            return false; //it's the responsibility of the dev to check this
        

        var include = new apf.XiInclude();
        include.setAttribute("href", amlDefNode);
        if (options && options.clear)
            include.setAttribute("clear", true);
        include.options  = options;
        include.callback = options && options.callback;
        this.appendChild(include);
    };
    
    //@todo prefix only needs on top element
    this.serialize = function(shallow){
        if (shallow || !this.firstChild) {
            return "<" 
                + (this.prefix 
                  ? this.prefix + ":" + this.localName + " xmlns:" 
                    + this.prefix + "=\"" + this.namespaceURI + "\""
                  : this.localName) + (this.attributes.length ? " " : "")
                + this.attributes.join(" ")
                + "/>";
        }
        else {
            var str = ["<" 
                + (this.prefix 
                  ? this.prefix + ":" + this.localName + " xmlns:" 
                    + this.prefix + "=\"" + this.namespaceURI + "\""
                  : this.localName) + (this.attributes.length ? " " : "")
                + this.attributes.join(" ")
                + ">"];
            
            for (var i = this.firstChild; i; i = i.nextSibling)
                str.push(i.serialize());
            
            return str.join("") + "</" + (this.prefix ? this.prefix 
                + ":" + this.localName : this.localName) + ">";
        }
    };
    
    this.$setInheritedAttribute = function(prop){
        var value, node = this;
        
        value = node.getAttribute(prop);
        if (!value) {
            node = node.parentNode;
            
            //Second argument fetches special inheritance value, if any
            while (node && node.nodeType == 1 && !(value = node.getAttribute(prop, true))) {
                node = node.parentNode;
            }
        }
        
        if (!value && apf.config && prop)
            value = apf.config[prop];
    
        if (value) {
            
            //Remove any bounds if relevant
            this.$clearDynamicProperty(prop);
    
            if (typeof value == "string" 
              && (value.indexOf("{") > -1 || value.indexOf("[") > -1)) {
                this.$setDynamicProperty(prop, value);
                this.$inheritProperties[prop] = 2;
            }
            else 
            
                this.setProperty(prop, value, false, false, 2);
        }
        
        return value;
    };
    
    this.$handlePropSet = function(prop, value, force){
        if (value && this.$booleanProperties[prop])
            value = apf.isTrue(value);

        
        if (typeof this[prop] == "function") {
            throw new Error("Could not set property/attribute '" + prop
                + "' which has the same name as a method on this object: '"
                + this.toString() + "'");
        }
        

        this[prop] = value;

        var handler;
        return (handler = this.$propHandlers && this.$propHandlers[prop]
          || this.nodeFunc == apf.NODE_VISIBLE && apf.GuiElement && apf.GuiElement.propHandlers[prop] || null)
          && handler.call(this, value, prop, force);
    };
    
    //var aci = apf.config.$inheritProperties; << UNUSED
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var a, i, l, attr = this.attributes;

        
        if (typeof apf.offline != "undefined" && apf.offline.state.enabled) {
            var offlineLookup = apf.offline.state.getAll(this);
            for (i in offlineLookup) {
                a = attr.getNamedItem(i);
                if (a) 
                    a.$setValue(offlineLookup[i]);
                else {
                    this.attributes.push(
                        new apf.AmlAttr(this, i, offlineLookup[i]))
                }
            }
        }
        
        
        
        //Get defaults from the defaults element if it exists
        var defs = apf.nameserver.getAll("defaults_" + this.localName);
        if (defs.length) {
            for (var j = 0, jl = defs.length; j < jl; j++) {
                var d = defs[j].attributes, di;
                for (i = 0, l = d.length; i < l; i++) {
                    a = attr.getNamedItem((di = d[i]).nodeName);
                    if (a) {
                        if (a.value)//specified 
                            continue;
                        
                        a.$setValue(di.nodeValue);
                        this.$inheritProperties[di.nodeName] = 2;
                    }
                    else {
                        this.attributes.push(
                            new apf.AmlAttr(this, di.nodeName, di.nodeValue));
                        this.$inheritProperties[di.nodeName] = 2;
                    }
                }
            }
        }
        

        //Set all attributes
        for (i = 0, l = attr.length; i < l; i++) {
            attr[i].dispatchEvent("DOMNodeInsertedIntoDocument");
        }

        this.$amlLoaded = true;
    }, true);
}).call(apf.AmlElement.prototype = new apf.AmlNode());



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/characterdata.js)SIZE(1959)TIME(1259091141)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.AmlCharacterData = function(){
    this.data = "";
    this.length = 0;
    
    this.$init(true);
    
    this.appendData = function(sValue){
        this.dispatchEvent("DOMCharacterDataModified", {
            value : sValue
        });
    };
    
    this.deleteData = function(nOffset, nCount){
        this.dispatchEvent("DOMCharacterDataModified", {
            offset: nOffset,
            count : nCount
        });
    };
    
    this.insertData = function(nOffset, nCount){
        this.dispatchEvent("DOMCharacterDataModified", {
            offset: nOffset,
            count : nCount
        });
    };
    
    this.replaceData = function(nOffset, nCount, sValue){
        this.dispatchEvent("DOMCharacterDataModified", {
            offset: nOffset,
            count : nCount,
            value : sValue
        });
    };
    
    this.substringData = function(nOffset, nCount){};
}
apf.AmlCharacterData.prototype = new apf.AmlNode();


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/text.js)SIZE(4086)TIME(1264352083)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.AmlText = function(isPrototype){
    this.$init(isPrototype);
};

(function(){
    this.nodeType = this.NODE_TEXT;
    this.nodeName = "#text";
    
    this.serialize = function(){
        return apf.xmlentities(this.nodeValue).replace(/</g, "&lt;").replace(/>/g, "&gt;");
    };
    
    
    this.$handlePropSet = function(prop, value, force){
        this[prop] = value;
        if (prop == "data") {
            this.$clearDynamicProperty("calcdata");
            this.$setDynamicProperty(prop, value);
        }
        else if (this.$propHandlers[prop]) {
            this.$propHandlers[prop].call(this, value, prop);
        }
    };
    
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = {
        data : 0 //Start in code mode
    };
    
    this.getAttribute = function(){};
    
    this.mainBind = "data";
    
    
    //@todo think about using this.replaceData();
    this.$setValue = function(value){
        //if (!this.$amlLoaded)
            //return;
        
        this.dispatchEvent("DOMCharacterDataModified", {
            bubbles   : true,
            prevValue : this.nodeValue,
            newValue  : this.nodeValue = value
        });
        
        if (this.$amlLoaded)
            this.$ext.nodeValue = value;
    }

    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var pHtmlNode;
        if (!(pHtmlNode = this.parentNode.$int)) 
            return;

        this.$amlLoaded = true;
        
        var nodeValue = this.nodeValue;

        //@todo optimize for inside elements?
        if (apf.config.liveText && !this.parentNode.hasFeature(apf.__CHILDVALUE__) 
          && (nodeValue.indexOf("{") > -1 || nodeValue.indexOf("[") > -1)) {
            
            //Convert to live markup pi
            this.$supportedProperties = [];
            this.$propHandlers        = {};
            this.$booleanProperties   = {};
            this.$inheritProperties   = {};
            
            this.$propHandlers["calcdata"] = apf.LiveMarkupPi.prototype.$propHandlers["calcdata"];
            
            this.$setInheritedAttribute = apf.AmlElement.prototype.$setInheritedAttribute;
            
            this.implement(apf.StandardBinding);
            
            
            pHtmlNode.appendChild(this.$ext = this.$int = document.createElement("span"));
            this.$setDynamicProperty("calcdata", this.nodeValue);
            
            return;
        }

        if (apf.hasTextNodeWhiteSpaceBug) {
            var nodeValue = nodeValue.replace(/[\t\n\r ]+/g, " ");

            if (nodeValue && nodeValue != " ")
                this.$ext = pHtmlNode.appendChild(
                  pHtmlNode.ownerDocument.createTextNode(nodeValue));
        }
        else
            this.$ext = pHtmlNode.appendChild(
              pHtmlNode.ownerDocument.createTextNode(nodeValue));
    }, true);
}).call(apf.AmlText.prototype = new apf.AmlCharacterData());



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/textrectangle.js)SIZE(1662)TIME(1259091141)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.AmlTextRectangle = function(host){
    var _self = this;
    function handler(){
        var pos = _self.getAbsolutePosition(_self.$ext);
        _self.setProperty("left", pos[0]);
        _self.setProperty("top", pos[1]);
        _self.setProperty("right", document.documentElement.offsetWidth - pos[0]);
        _self.setProperty("bottom", document.documentElement.offsetWidth - pos[1]);
    }
    
    host.addEventListener("prop.width", handler);
    host.addEventListener("prop.height", handler);
    host.addEventListener("prop.left", handler);
    host.addEventListener("prop.top", handler);

    handler.call(host);
};
apf.AmlTextRectangle.prototype = new apf.Class();


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/processinginstruction.js)SIZE(2990)TIME(1263859263)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.AmlProcessingInstruction = function(isPrototype){
    this.$init(isPrototype);
    
    //@todo apf3.0 possibly move this to an init function
    this.$supportedProperties = [];
    this.$propHandlers        = {};
    this.$booleanProperties   = {};
    this.$inheritProperties   = {};
};

(function(){
    this.nodeType = this.NODE_PROCESSING_INSTRUCTION;
    
    /**
     * @todo docs
     */
    this.data   = null;
    
    /**
     * @todo docs
     */
    this.target = null;
    
    this.serialize = function(){
        return "<?" + this.target + "\n" + apf.xmlentities(this.nodeValue) + "\n?>";
    };
    
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        calcdata : 0 //Start in code mode
    }, this.$attrExcludePropBind);
    
    this.getAttribute = function(){};
    this.$setInheritedAttribute = apf.AmlElement.prototype.$setInheritedAttribute;
    
    this.$handlePropSet = function(prop, value, force){
        this[prop] = value;
        
        if (prop == "data") {
            this.$clearDynamicProperty("calcdata");
            this.$setDynamicProperty("calcdata", value);
        }
        else if (prop == "target") {
            //not implemented
        }
        else if (this.$propHandlers[prop]) {
            this.$propHandlers[prop].call(this, value, prop);
        }
    };

    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var pHtmlNode;
        if (this.parentNode.$bindingRule || !(pHtmlNode = this.parentNode.$int)) 
            return;

        pHtmlNode.appendChild(this.$ext = this.$int = document.createElement("span"));
        this.$ext.host = this;

        this.$setDynamicProperty("calcdata", this.data);
    }, true);
    
    this.addEventListener("DOMNodeRemovedFromDocument", function(e){
        this.$clearDynamicProperty("calcdata");
    });
}).call(apf.AmlProcessingInstruction.prototype = new apf.AmlNode());


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/document.js)SIZE(7104)TIME(1259091141)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * The aml document, this is the root of the DOM Tree and has a nodeType with 
 * value 9 (apf.NODE_DOCUMENT). 
 *
 * @constructor
 * @inherits apf.AmlNode
 * @inherits apf.Class
 * @default_private 
 * @see baseclass.amldom
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 */
apf.AmlDocument = function(){
    this.$prefixes      = {};
    this.$namespaceURIs = {};
    this.domConfig      = new apf.AmlConfiguration();
    
    this.$init();
};

(function() {
    /**
     * The type of node within the document.
     *   Possible values:
     */
    this.nodeType   = this.NODE_DOCUMENT;
    this.nodeFunc   = apf.NODE_HIDDEN;
    this.nodeName   = "#document";
    
    this.$amlLoaded = true;
    
    this.activeElement   = null; //@todo alias of window.foccussed;
    this.doctype         = null;
    this.domConfig       = null;
    this.implementation  = null;
    this.characterSet    = apf.characterSet;
    
    /**
     * The root element node of the aml application. This is an element with
     * the tagName 'application'. This is similar to the 'html' element
     */
    this.documentElement = null;
    
    /**
     * Gets a aml element based on it's id.
     * @param {String} id the id of the aml element to return.
     * @return {AMLElement} the aml element with the id specified.
     */
    this.getElementById = function(id){
        return self[id];
    };
    
    this.getElementsByTagName = function(tagName){
        var docEl, res = (docEl = this.documentElement)
            .getElementsByTagName(tagName);

        if (docEl.tagName == tagName)
            res.push(docEl);
        return res;
    };
    
    this.getElementsByTagNameNS = function(nameSpaceURI, tagName){
        var docEl,
            res = (docEl = this.documentElement)
                .getElementsByTagNameNS(nameSpaceURI, tagName);

        if (docEl.tagName == tagName && docEl.namespaceURI == nameSpaceURI)
            res.push(docEl);
        return res;
    };

    /**
     * Creates a new aml element.
     * @param {mixed} tagName information about the new node to create.
     *   Possible values:
     *   {String}     the tagName of the new element to create
     *   {String}     the aml definition for a single or multiple elements.
     *   {XMLElement} the aml definition for a single or multiple elements.
     * @return {AMLElement} the created aml element.
     */
    this.createElement = function(qualifiedName){
        return this.$domParser.$createNode(this, this.NODE_ELEMENT, null,
            this.namespaceURI, qualifiedName);
    };
        
    this.createElementNS = function(namespaceURI, qualifiedName){
        return this.$domParser.$createNode(this, this.NODE_ELEMENT, null,
            namespaceURI, qualifiedName);
    };
    
    this.importNode = function(node, deep){
        if (deep && node.nodeType == 1) {
            return this.$domParser.parseFromXml(node, {
                doc   : this,
                delay : true
            }).childNodes[0];
        }
        else {
            return this.$domParser.$createNode(this, node.nodeType, node);
        }
    };
    
    //@todo
    this.createAttribute = function(nodeName){
        return this.$domParser.$createNode(this, this.NODE_ATTRIBUTE, null,
            this.nameSpaceURI, nodeName);
    };
    
    //@todo
    this.createAttributeNS = function(nameSpaceURI, nodeName){
        return this.$domParser.$createNode(this, this.NODE_ATTRIBUTE, null,
            nameSpaceURI, nodeName);
    };
    
    this.createEvent = function(){
        return new apf.AmlEvent();
    };
    
    this.createComment = function(nodeValue){
        return this.$domParser.$createNode(this, this.NODE_COMMENT, null, null,
            null, nodeValue);
    };
    
    this.createProcessingInstruction = function(nodeValue){
        return this.$domParser.$createNode(this, this.NODE_PROCESSING_INSTRUCTION,
            null, null, null, nodeValue);
    };
    
    this.createCDATASection = function(nodeValue){
        return this.$domParser.$createNode(this, this.NODE_CDATA_SECTION, null,
            null, null, nodeValue);
    };
    
    this.createTextNode = function(nodeValue){
        return this.$domParser.$createNode(this, this.NODE_TEXT, null, null,
            null, nodeValue);
    };
    
    this.createDocumentFragment = function(){
        return this.$domParser.$createNode(this, this.NODE_DOCUMENT_FRAGMENT);
    };

    this.querySelector = function(){};
    
    this.querySelectorAll = function(){};

    
    /**
     * See W3C evaluate
     */
    this.evaluate = function(sExpr, contextNode, nsResolver, type, x){
        var result = apf.XPath.selectNodes(sExpr,
            contextNode || this.documentElement);

        /**
         * @private
         */
        return {
            snapshotLength : result.length,
            snapshotItem   : function(i){
                return result[i];
            }
        }
    };

    /**
     * See W3C createNSResolver
     */
    this.createNSResolver = function(contextNode){
        return {};
    };
    

    
    this.queryCommandState = function(cmd){
       if (!apf.document.activeElement || !apf.document.activeElement.$queryCommandState)
           return;
       apf.document.activeElement.$queryCommandState(cmd);
    };

    this.queryCommandValue = function(cmd){
       if (!apf.document.activeElement || !apf.document.activeElement.$queryCommandValue)
           return;
       apf.document.activeElement.$queryCommandValue(cmd);
    };

    this.execCommand = function(cmd, ui, val){
       if (!apf.document.activeElement || !apf.document.activeElement.$execCommand)
           return;
       apf.document.activeElement.$execCommand(cmd, val);
    };
    
}).call(apf.AmlDocument.prototype = new apf.AmlNode());



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/comment.js)SIZE(1509)TIME(1259091141)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.AmlComment = function(isPrototype){
    this.nodeType = this.NODE_COMMENT;
    this.nodeName = "#comment";
    
    this.$init(isPrototype);
};

(function(){
    this.serialize = function(){
        return "<!--" + this.nodeValue + "-->";
    };
    
    this.$setValue = function(value){
        this.dispatchEvent("DOMCharacterDataModified", {
            bubbles   : true,
            newValue  : value,
            prevValue : this.nodeValue
        });
    }
}).call(apf.AmlComment.prototype = new apf.AmlCharacterData());


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/namednodemap.js)SIZE(3161)TIME(1263915681)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


//@todo apf3.0
apf.AmlNamedNodeMap = function(host){
    this.$host = host;
};

(function(){
    this.getNamedItem    = function(name){
        for (var i = 0; i < this.length; i++) {
            if (this[i].name == name)
                return this[i];
        }
        return false;
    };
    
    this.setNamedItem    = function(node){
        var name = node.name;
        for (var item, i = this.length - 1; i >= 0; i--) {
            if (this[i].name == name) {
                this[i].ownerElement = null;
                this.splice(i, 1);
                break;
            }
        }
        
        this.push(node);
        
        node.ownerElement = this.$host;
        node.$triggerUpdate();
    };
    
    //@todo apf3.0 domattr
    this.removeNamedItem = function(name){
        //Should deconstruct dynamic properties
        
        for (var item, i = this.length - 1; i >= 0; i--) {
            if (this[i].name == name) {
                item = this[i];
                this.splice(i, 1);
                break;
            }
        }
        if (!item) return false;
        
        item.ownerElement.setProperty(name, "");
        item.ownerElement = null;
        
        return item;
    };
    
    this.item            = function(i){
        return this[i];
    };

    //if (apf.isIE < 8) { //Only supported by IE8 and above
        this.length = 0;
        
        this.splice = function(pos, length){
            for (var i = pos, l = this.length - length; i < l; i++) {
                this[i] = this[i + 1];
            }
            delete this[i];
            this.length -= length;
        }
        
        this.push = function(o) {
            this[this.length++] = o;
            return this.length;
        }
    //}
    
    this.join = function(glue){
        var x = [];
        for (var e, a, i = 0, l = this.length; i < l; i++) {
            if ((e = (a = this[i]).ownerElement) && !e.$inheritProperties[a.nodeName])
                x.push(this[i]);
        }
        return x.join(glue);
    }
}).call(apf.AmlNamedNodeMap.prototype = {}); //apf.isIE < 8 ? {} : []


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/event.js)SIZE(2086)TIME(1259091141)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Implementation of W3C event object. An instance of this class is passed as
 * the first argument of any event handler. Per event it will contain different
 * properties giving context based information about the event.
 * @constructor
 * @default_private
 */
apf.AmlEvent = function(name, data){
    this.name = name;
    
    var prop;
    for (prop in data)
        this[prop] = data[prop];
};

apf.AmlEvent.prototype = {
    
    bubbles : false,
    cancelBubble : false,
    

    /**
     * Cancels the event if it is cancelable, without stopping further 
     * propagation of the event. 
     */
    preventDefault : function(){
        this.returnValue = false;
    },

    
    /**
     * Prevents further propagation of the current event. 
     */
    stopPropagation : function(){
        this.cancelBubble = true;
    },
    

    stop : function() {
        this.returnValue = false;
        
        this.cancelBubble = true;
        
    }
};


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/attr.js)SIZE(4664)TIME(1259091141)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.AmlAttr = function(ownerElement, name, value){
    this.$init();
    
    this.ownerElement  = ownerElement;
    this.ownerDocument = ownerElement.ownerDocument;
    
    this.nodeName  = this.name  = name;
    this.nodeValue = this.value = value;
};

(function(){
    this.nodeType  = this.NODE_ATTRIBUTE;
    
    this.MODIFICATION = 1;
    this.ADDITION     = 2;
    this.REMOVAL      = 3;
    
    this.serialize = 
    this.toString  = function(){
        return this.name + "=\"" + apf.xmlentities(String(this.value))
            .replace(/</g, "&lt;").replace(/>/g, "&gt;") + "\"";
    };
    
    
    
    this.$setValue = function(value){
        this.nodeValue = this.value = value;
        this.specified = true;
        
        //@todo apf3.0 domattr
        /*host.dispatchEvent("DOMAttrModified", {
            relatedNode : this,
            attrChange  : this.MODIFICATION,
            attrName    : name,
            newValue    : value,
            prevValue   : null, //@todo apf3.0
            bubble      : true
        });*/
    };
    
    this.$triggerUpdate = function(e){
        var name  = this.name,
            value = this.value,
            host  = this.ownerElement;

        if (name == "id" && !this.specified && host.id) {
            this.specified = true;
            return;
        }

        if (name.substr(0, 2) == "on") {
            if (host.$events[name])
                host.removeEventListener(name.replace(/^on/, ""), host.$events[name]);
            if (value)
                host.addEventListener(name, (host.$events[name] = 
                  (typeof value == "string"
                    ? 
                      apf.lm.compile(value, {event: true, parsecode: true})
                      
                    : value)));
            return;
        }
        
        else {
            if (this.specified)
                host.$clearDynamicProperty(name);
            
            if (typeof value == "string" && (host.$attrExcludePropBind[name] || 
              (value.indexOf("{") > -1 || value.indexOf("[") > -1))) {
                host.$setDynamicProperty(name, value);
                
                return;//@todo apf3.0 test this for disabled
            }
        }
        
        
        host.setProperty(name, value); //@todo apf3.0 is this a lot slower?
        //host.$handlePropSet(name, value);

        if (this.specified) {
            //@todo apf3.0 domattr - slow?
            host.dispatchEvent("DOMAttrModified", { //@todo this is not good, node might not be specified at init
                relatedNode : this,
                attrChange  : this.MODIFICATION,
                attrName    : name,
                newValue    : value,
                prevValue   : null, //@todo apf3.0
                bubble      : true
            });
        }
        else this.specified = true;
    };
    
    //@todo apf3.0 domattr
    this.addEventListener("DOMNodeInsertedIntoDocument", this.$triggerUpdate);
}).call(apf.AmlAttr.prototype = new apf.AmlNode());


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/cdatasection.js)SIZE(1300)TIME(1259091141)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.AmlCDATASection = function(isPrototype){
    this.nodeType = this.NODE_CDATA_SECTION;
    this.nodeName = "#cdata-section";
    
    this.$init(isPrototype);
};

apf.AmlCDATASection.prototype = new apf.AmlText(true);
apf.AmlCDATASection.prototype.serialize = function(){
    return "<![CDATA[" + this.nodeValue + "]]>";
};


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/configuration.js)SIZE(1384)TIME(1259091141)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.AmlConfiguration = function(isPrototype){
    this.parameterNames = [];

    this.$init(isPrototype);
};

(function(){
    this.setParameter = this.setProperty;
    
    this.getParameter = this.getProperty;
    
    this.canSetParameter = function(name, value){ //@todo for value
        return this.parameterNames.indexOf(name) > -1;
    };
}).call(apf.AmlConfiguration.prototype = new apf.Class());


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/documentfragment.js)SIZE(1286)TIME(1259091141)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.AmlDocumentFragment = function(isPrototype){
    this.$init(isPrototype);
};

apf.AmlDocumentFragment.prototype = new apf.AmlNode();
apf.AmlDocumentFragment.prototype.nodeName = "#document-fragment";
apf.AmlDocumentFragment.prototype.nodeType = 
    apf.AmlDocumentFragment.prototype.NODE_DOCUMENT_FRAGMENT;


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xhtml.js)SIZE(1534)TIME(1257329185)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Object creating the XHTML namespace for the aml parser.
 *
 * @constructor
 * @parser
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 */
apf.xhtml = new apf.AmlNamespace();
apf.setNamespace("http://www.w3.org/1999/xhtml", apf.xhtml);


/*
if (apf.getTextNode(x)) {
    var data = {
        amlNode  : x,
        htmlNode : o
    }

    
    apf.language.addElement(apf.getTextNode(x)
        .nodeValue.replace(/^\$(.*)\$$/, "$1"), data);
    
}

*/

/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xhtml/element.js)SIZE(2943)TIME(1263859263)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.XhtmlElement = function(struct, tagName){
    this.$init(tagName || true, apf.NODE_VISIBLE, struct);
    
    this.$xoe                = this.addEventListener;
    this.addEventListener    = this.$xae;
    this.removeEventListener = this.$xre;
    
    var _self = this;
    this.$de = function(e){
        _self.dispatchEvent(e.type, e);
    }
};

(function(){
    this.$xae = function(type, fn){
        if (!this.$ext) return;

        apf.addListener(this.$ext, type, this.$de);
        this.$xoe.apply(this, arguments);
    };
    
    this.$xre = function(type, fn) {
        if (!this.$ext) return;
        
        apf.removeListener(this.$ext, type, this.$de);
        apf.AmlElement.prototype.removeEventListener.apply(this, arguments);
    }
    
    this.$handlePropSet = function(name, value, force){
        if (this.$booleanProperties[name])
            value = apf.isTrue(value);

        this[name] = value;
        
        var handler = this.$propHandlers && this.$propHandlers[name]
          || apf.GuiElement.propHandlers[name];
        
        if (handler)
            handler.call(this, value, null, name);
        else if (this.$int)
            this.$int.setAttribute(apf.isIE && name == "class" 
                ? "className" : name, value);
    };
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var pHtmlNode;
        if (!(pHtmlNode = this.parentNode.$int)) 
            return;

        if (this.$aml) {
            this.$ext = 
            this.$int = apf.insertHtmlNode(this.$aml.serialize
                ? this.$aml 
                : this.$aml.cloneNode(false), pHtmlNode);
        }
        else {
            this.$ext = this.$int = 
              pHtmlNode.appendChild(document.createElement(this.localName));
        }
    }, true);
}).call(apf.XhtmlElement.prototype = new apf.AmlElement());

apf.xhtml.setElement("@default", apf.XhtmlElement);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xhtml/option.js)SIZE(1537)TIME(1259091141)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.XhtmlOptionElement = function(struct, tagName){
    this.$init(tagName || "option", apf.NODE_VISIBLE, struct);
};

(function(){
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        this.$ext = 
        this.$int = this.parentNode.$int.appendChild(
          this.parentNode.$int.ownerDocument.createElement("option"));

        if (this.value)
            this.$int.setAttribute("value", this.value);
    }, true);
}).call(apf.XhtmlOptionElement.prototype = new apf.AmlElement());

apf.xhtml.setElement("option", apf.XhtmlOptionElement);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xhtml/html.js)SIZE(2477)TIME(1259091141)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @todo description
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.XhtmlHtmlElement = function(struct, tagName){
    this.$init(tagName || "html", apf.NODE_VISIBLE, struct);
    
    this.$int        = document.body;
    this.$tabList    = []; //Prevents documentElement from being focussed
    this.$focussable = apf.KEYBOARD;
    this.focussable  = true;
    this.visible     = true;
    this.$isWindowContainer = true;
    this.focus = function(){ this.dispatchEvent("focus"); };
    this.blur  = function(){ this.dispatchEvent("blur"); };
    
    
    apf.window.$addFocus(this);
    
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var i, l, n, a, c,
            attr = this.attributes, doc = this.ownerDocument;
        for (i = 0, l = attr.length; i < l; i++) {
            n = (a = attr[i]).nodeName.split(":");
            if (n[0] == "xmlns") {
                if (c = n[1]) {
                    doc.$prefixes[c] = a.nodeValue;
                    doc.$namespaceURIs[a.nodeValue] = c;
                }
                else {
                    doc.namespaceURI = a.nodeValue;
                }
            }
        }
        
        if (!doc.namespaceURI)
            doc.namespaceURI = apf.ns.xhtml;
    });
};
apf.XhtmlHtmlElement.prototype = new apf.XhtmlElement();

apf.xhtml.setElement("html", apf.XhtmlHtmlElement);



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xhtml/skipchildren.js)SIZE(2342)TIME(1259091141)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.XhtmlSkipChildrenElement = function(struct, tagName){
    this.$init(tagName, apf.NODE_VISIBLE, struct);
};

(function(){
    this.canHaveChildren = false;
    
    this.$redraw = function(){
        var _self = this;
        apf.queue.add("redraw" + this.$uniqueId, function(){
            var pHtmlNode  = _self.$ext.parentNode;
            var beforeNode = _self.$ext.nextSibling;
            pHtmlNode.removeChild(_self.$ext);
            
            _self.$ext = apf.insertHtmlNode(null, pHtmlNode, beforeNode, _self.$aml 
                ? (_self.$aml.serialize ? _self.$aml.serialize() : _self.$aml.xml)
                : _self.serialize());
        });
    }
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var pHtmlNode;
        if (!(pHtmlNode = this.parentNode.$int)) 
            return;

        this.$ext = apf.insertHtmlNode(null, pHtmlNode, null, this.$aml 
            ? (this.$aml.serialize ? this.$aml.serialize() : this.$aml.xml)
            : this.serialize());
    }, true);
}).call(apf.XhtmlSkipChildrenElement.prototype = new apf.AmlElement());

apf.xhtml.setElement("object", apf.XhtmlSkipChildrenElement);
apf.xhtml.setElement("embed", apf.XhtmlSkipChildrenElement);
apf.xhtml.setElement("table", apf.XhtmlSkipChildrenElement);

apf.xhtml.setElement("pre", apf.XhtmlSkipChildrenElement);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xhtml/body.js)SIZE(1443)TIME(1259091141)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.XhtmlBodyElement = function(struct, tagName){
    this.$init(tagName || "body", apf.NODE_VISIBLE, struct);
};

(function(){
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (!this.ownerDocument.body)
            this.ownerDocument.body = this;
        
        this.$ext = 
        this.$int = document.body;
    }, true);
}).call(apf.XhtmlBodyElement.prototype = new apf.AmlElement());

apf.xhtml.setElement("body", apf.XhtmlBodyElement);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xhtml/ignore.js)SIZE(1360)TIME(1264352083)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.XhtmlIgnoreElement = function(struct, tagName){
    this.$init(tagName, apf.NODE_VISIBLE, struct);
};

apf.XhtmlIgnoreElement.prototype = new apf.AmlElement();

apf.xhtml.setElement("script",   apf.XhtmlIgnoreElement);
apf.xhtml.setElement("noscript", apf.XhtmlIgnoreElement);
apf.xhtml.setElement("head",     apf.XhtmlIgnoreElement);
apf.xhtml.setElement("meta",     apf.XhtmlIgnoreElement);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd.js)SIZE(12775)TIME(1264690337)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Object creating the XML Schema namespace for the aml parser.
 *
 * @constructor
 * @parser
 *
 * @allownode simpleType, complexType
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 */
apf.xsd = new apf.AmlNamespace();
apf.setNamespace("http://www.w3.org/2001/XMLSchema", apf.xsd);

apf.xsd.typeHandlers = {
    "http://www.w3.org/2001/XMLSchema" : {
        //XSD datetypes [L10n potential]
        "dateTime": function(value){
            value = value.replace(/-/g, "/");
    
            value.match(/^(\d{2})\/(\d{2})\/(\d{4}) (\d{2}):(\d{2}):(\d{2})$/);
            if (!RegExp.$3 || RegExp.$3.length < 4)
                return false;
    
            var dt = new Date(value);
            if (dt.getFullYear() != parseFloat(RegExp.$3))
                return false;
            if (dt.getMonth() != parseFloat(RegExp.$2) - 1)
                return false;
            if (dt.getDate() != parseFloat(RegExp.$1))
                return false;
            if (dt.getHours() != parseFloat(RegExp.$4))
                return false;
            if (dt.getMinutes() != parseFloat(RegExp.$5))
                return false;
            if (dt.getSeconds() != parseFloat(RegExp.$5))
                return false;
    
            return true;
        },
        "time": function(value){
            value.match(/^(\d{2}):(\d{2}):(\d{2})$/);
    
            var dt = new Date("21/06/1980 " + value);
            if (dt.getHours() != parseFloat(RegExp.$1))
                return false;
            if (dt.getMinutes() != parseFloat(RegExp.$2))
                return false;
            if (dt.getSeconds() != parseFloat(RegExp.$3))
                return false;
    
            return true;
        },
        "date": function(value){
            value = value.replace(/-/g, "/");
            value.match(/^(\d{2})\/(\d{2})\/(\d{4})$/);
            if (!RegExp.$3 || RegExp.$3.length < 4)
                return false;
    
            //@todo this is a dutch date, localization...
            var dt = new Date(RegExp.$2 + "/" + RegExp.$1 + "/" + RegExp.$3);
            if (dt.getFullYear() != parseFloat(RegExp.$3))
                return false;
            if (dt.getMonth() != parseFloat(RegExp.$2) - 1)
                return false;
            if (dt.getDate() != parseFloat(RegExp.$1))
                return false;
    
            return true;
        },
        "gYearMonth": function(value){
            value = value.replace(/-/g, "/");
            value.match(/^\/?(\d{4})(?:\d\d)?\/(\d{2})(?:\w|[\+\-]\d{2}:\d{2})?$/);
            if (!RegExp.$1 || RegExp.$1.length < 4)
                return false;
    
            var dt = new Date(value);
            if (dt.getFullYear() != parseFloat(RegExp.$))
                return false;
            if (dt.getMonth() != parseFloat(RegExp.$2) - 1)
                return false;
    
            return true;
        },
        "gYear": function(value){
            value.match(/^\/?(\d{4})(?:\d\d)?(?:\w|[\+\-]\d{2}:\d{2})?$/);
            if (!RegExp.$1 || RegExp.$1.length < 4)
                return false;
    
            var dt = new Date(value);
            if (dt.getFullYear() != parseFloat(RegExp.$1))
                return false;
    
            return true;
        },
        "gMonthDay": function(value){
            value = value.replace(/-/g, "/");
            value.match(/^\/\/(\d{2})\/(\d{2})(?:\w|[\+\-]\d{2}:\d{2})?$/);
    
            var dt = new Date(value);
            if (dt.getMonth() != parseFloat(RegExp.$1) - 1)
                return false;
            if (dt.getDate() != parseFloat(RegExp.$2))
                return false;
    
            return true;
        },
        "gDay": function(value){
            value = value.replace(/-/g, "/");
            value.match(/^\/{3}(\d{2})(?:\w|[\+\-]\d{2}:\d{2})?$/);
    
            var dt = new Date(value);
            if (dt.getDate() != parseFloat(RegExp.$1))
                return false;
    
            return true;
        },
        "gMonth": function(value){
            value = value.replace(/-/g, "/");
            value.match(/^\/{2}(\d{2})(?:\w|[\+\-]\d{2}:\d{2})?$/);
    
            var dt = new Date(value);
            if (dt.getMonth() != parseFloat(RegExp.$1) - 1)
                return false;
    
            return true;
        },
    
        //XSD datetypes
        "string": function(value){
            return typeof value == "string";
        },
        "boolean": function(value){
            return /^(true|false)$/i.test(value);
        },
        "base64Binary": function(value){
            return true;
        },
        "hexBinary": function(value){
            return /^(?:0x|x|#)?[A-F0-9]{0,8}$/i.test(value);
        },
        "float": function(value){
            return parseFloat(value) == value;
        },
        "decimal": function(value){
            return /^[0-9\.\-,]+$/.test(value);
        },
        "double": function(value){
            return parseFloat(value) == value;
        },
        "anyURI": function(value){
            return /^(?:\w+:\/\/)?(?:(?:[\w\-]+\.)+(?:[a-z]+)|(?:(?:1?\d?\d?|2[0-4]9|25[0-5])\.){3}(?:1?\d\d|2[0-4]9|25[0-5]))(?:\:\d+)?(?:\/([^\s\\\%]+|%[\da-f]{2})*)?$/i
                .test(value);
        },
        "QName": function(value){
            return true;
        },
        "normalizedString": function(value){
            return true;
        },
        "token": function(value){
            return true;
        },
        "language": function(value){
            return true;
        },
        "Name": function(value){
            return true;
        },
        "NCName": function(value){
            return true;
        },
        "ID": function(value){
            return true;
        },
        "IDREF": function(value){
            return true;
        },
        "IDREFS": function(value){
            return true;
        },
        "NMTOKEN": function(value){
            return true;
        },
        "NMTOKENS": function(value){
            return true;
        },
        "integer": function(value){
            return parseInt(value) == value;
        },
        "nonPositiveInteger": function(value){
            return parseInt(value) == value && value <= 0;
        },
        "negativeInteger": function(value){
            return parseInt(value) == value && value < 0;
        },
        "long": function(value){
            return parseInt(value) == value && value >= -2147483648
                && value <= 2147483647;
        },
        "int": function(value){
            return parseInt(value) == value;
        },
        "short": function(value){
            return parseInt(value) == value && value >= -32768 && value <= 32767;
        },
        "byte": function(value){
            return parseInt(value) == value && value >= -128 && value <= 127;
        },
        "nonNegativeInteger": function(value){
            return parseInt(value) == value && value >= 0;
        },
        "unsignedLong": function(value){
            return parseInt(value) == value && value >= 0 && value <= 4294967295;
        },
        "unsignedInt": function(value){
            return parseInt(value) == value && value >= 0;
        },
        "unsignedShort": function(value){
            return parseInt(value) == value && value >= 0 && value <= 65535;
        },
        "unsignedByte": function(value){
            return parseInt(value) == value && value >= 0 && value <= 255;
        },
        "positiveInteger": function(value){
            return parseInt(value) == value && value > 0;
        }
    },
    
    
    
    "http://ajax.org/2005/aml" : {
        //Ajax.org Platform datatypes
        "url": function(value){
            //@todo please make this better
            return /\b(https?|ftp):\/\/([\-A-Z0-9.]+)(\/[\-A-Z0-9+&@#\/%=~_|!:,.;]*)?(\?[\-A-Z0-9+&@#\/%=~_|!:,.;]*)?/i.test(value.trim());
        },
        "website": function(value){
            //@todo please make this better
            return /^(?:http:\/\/)?([\w-]+\.)+\w{2,4}$/.test(value.trim());
        },
        "email": function(value){
            return /^[A-Z0-9\.\_\%\-]+@(?:[A-Z0-9\-]+\.)+[A-Z]{2,4}$/i
                .test(value.trim());
        },
        "creditcard": function(value){
            value = value.replace(/ /g, "");
            value = value.pad(21, "0", apf.PAD_LEFT);
            for (var total = 0, r, i = value.length; i >= 0; i--) {
                r = value.substr(i, 1) * (i % 2 + 1);
                total += r > 9 ? r - 9 : r;
            }
            return total % 10 === 0;
        },
        "expdate": function(value){
            value = value.replace(/-/g, "/");
            value = value.split("/");//.match(/(\d{2})\/(\d{2})/);
            var dt = new Date(value[0] + "/01/" + value[1]);
            //if(fulldate && dt.getFullYear() != parseFloat(value[1])) return false;
            if (dt.getYear() != parseFloat(value[1]))
                return false;//!fulldate &&
            if (dt.getMonth() != parseFloat(value[0]) - 1)
                return false;
    
            return true;
        },
        "wechars": function(value){
            return /^[0-9A-Za-z\xC0-\xCF\xD1-\xD6\xD8-\xDD\xDF-\xF6\xF8-\xFF -\.',]+$/
              .test(value)
        },
        "phonenumber": function(value){
            return /^[\d\+\- \(\)]+$/.test(value)
        },
        "faxnumber": function(value){
            return /^[\d\+\- \(\)]+$/.test(value)
        },
        "mobile": function(value){
            return /^[\d\+\- \(\)]+$/.test(value)
        }
    }
};

apf.xsd.custumTypeHandlers = {};

apf.xsd.matchType = function(value, type){
    var split  = type.split(":"),
        prefix = split[0],
        doc    = apf.document,
        ns     = doc.$prefixes[prefix];
    type = split[1];
    if (prefix == "xsd")
        ns = "http://www.w3.org/2001/XMLSchema";
    if (!ns) 
        ns = doc.namespaceURI || apf.ns.xhtml;
    
    var c = this.typeHandlers[ns];
    
    //check if type is type
    if (c && c[type])
        return c[type](value);
    
    throw new Error(apf.formatErrorString(0, null, 
        "Validating XSD Type", "Could not find type: " + type));
       
    return true;
};

apf.xsd.checkType = function(type, xmlNode){
    var value = typeof xmlNode == "object"
        ? apf.queryValue(xmlNode)
        : xmlNode;
    
    if (type.indexOf(":") > -1) {
        var split  = type.split(":"),
            prefix = split[0],
            name   = split[1],
            doc    = apf.document,
            ns     = doc.$prefixes[prefix];
        if (prefix == "xsd")
            ns = "http://www.w3.org/2001/XMLSchema";
        if (!ns) 
            ns = doc.namespaceURI || apf.ns.xhtml;
        
        var c = this.typeHandlers[ns];
        if (c && c[name])
            return c[name](value);
    }

    if (this.custumTypeHandlers[type]) {
        return this.custumTypeHandlers[type](value);
    }
    else {
        //@todo MIKE: to be implemented?
    }
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/element.js)SIZE(1869)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.XsdElement = function(struct, tagName){
    this.$init(true);
    
    this.addEventListener("DOMNodeInserted", function(){
        if (!this.parentNode.$compile)
            this.$compile();
    });

    this.addEventListener("DOMNodeRemoved", function(){
        if (!this.parentNode.$compile)
            this.$compile();
    });
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (this.parentNode.$compile)
            return;
        
        var _self = this;
        apf.queue.add("compile" + this.$uniqueId, function(){
            _self.$compile();
        });
    });
}
apf.XsdElement.prototype = new apf.AmlElement();
apf.XsdElement.prototype.$recompile = function(stack){
    if (!this.$amlLoaded)
        return;
    
    if (this.parentNode.$recompile)
        this.parentNode.$recompile();
    else
        this.$compile();
};


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/maxinclusive.js)SIZE(1568)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Specifies the upper bounds for numeric values (the value must be less than or equal to this value)
 */
apf.XsdMaxInclusive = function(struct, tagName){
    this.$init(tagName || "maxinclusive", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$propHandlers["value"] = function(){
        this.parentNode.$recompile();
    };
    
    this.$compile = function(stack){
        stack.push("if (parseFloat(value) > " + this.value + ") return false;");
    };
}).call(apf.XsdMaxInclusive.prototype = new apf.XsdElement());

apf.xsd.setElement("maxinclusive", apf.XsdMaxInclusive);



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/enumeration.js)SIZE(1844)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Defines a list of acceptable values
 */
apf.XsdEnumeration = function(struct, tagName){
    this.$init(tagName || "enumeration", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$propHandlers["value"] = function(){
        this.parentNode.$recompile();
    };
    
    this.$compile = function(stack){
        if (stack.enumDone) 
            return;

        stack.enumDone = true;

        var k, l,
            re    = [],
            nodes = this.parentNode.getElementsByTagNameNS(this.namespaceURI,
                    "enumeration");
        for (k = 0, l = nodes.length; k < l; k++)
            re.push(nodes[k].value);
        
        stack.push("if (!/^(?:" + re.join("|") + ")$/.test(value)) return false;");
    };
}).call(apf.XsdEnumeration.prototype = new apf.XsdElement());

apf.xsd.setElement("enumeration", apf.XsdEnumeration);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/maxscale.js)SIZE(1436)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.XsdMaxScale = function(struct, tagName){
    this.$init(tagName || "maxscale", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$propHandlers["value"] = function(){
        this.parentNode.$recompile();
    };
    
    //@todo http://www.w3.org/TR/2006/WD-xmlschema11-2-20060217/datatypes.html#element-maxScale
    this.$compile = function(stack){};
}).call(apf.XsdMaxScale.prototype = new apf.XsdElement());

apf.xsd.setElement("maxscale", apf.XsdMaxScale);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/length.js)SIZE(1527)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Specifies the exact number of characters or list items allowed. Must be equal to or greater than zero
 */
apf.XsdLength = function(struct, tagName){
    this.$init(tagName || "length", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$propHandlers["value"] = function(){
        this.parentNode.$recompile();
    };
    
    this.$compile = function(stack){
        stack.push("if (value.length != " + this.value + ") return false;");
    };
}).call(apf.XsdLength.prototype = new apf.XsdElement());

apf.xsd.setElement("length", apf.XsdLength);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/list.js)SIZE(1215)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.XsdList = function(struct, tagName){
    this.$init(tagName || "list", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$compile = function(stack){};
}).call(apf.XsdList.prototype = new apf.XsdElement());

apf.xsd.setElement("list", apf.XsdList);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/pattern.js)SIZE(1537)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Defines the exact sequence of characters that are acceptable
 */
apf.XsdPattern = function(struct, tagName){
    this.$init(tagName || "pattern", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$propHandlers["value"] = function(){
        this.parentNode.$recompile();
    };
    
    this.$compile = function(stack){
        stack.push("if (!/^" + this.value
            .replace(/(\/|\^|\$)/g, "\\$1") + "$/.test(value)) return false;")
    };
}).call(apf.XsdPattern.prototype = new apf.XsdElement());

apf.xsd.setElement("pattern", apf.XsdPattern);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/totaldigits.js)SIZE(1564)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Specifies the exact number of digits allowed. Must be greater than zero
 */
apf.XsdTotalDigits = function(struct, tagName){
    this.$init(tagName || "totaldigits", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$propHandlers["value"] = function(){
        this.parentNode.$recompile();
    };
    
    this.$compile = function(stack){
        stack.push("if (new String(parseFloat(value)).length == "
            + this.value + ") return false;");
    };
}).call(apf.XsdTotalDigits.prototype = new apf.XsdElement());

apf.xsd.setElement("totaldigits", apf.XsdTotalDigits);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/maxlength.js)SIZE(1597)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Specifies the maximum number of characters or list items allowed. Must be equal to or greater than zero
 */
apf.XsdMaxLength = function(struct, tagName){
    this.$init(tagName || "maxlength", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$propHandlers["value"] = function(){
        this.parentNode.$recompile();
    };
    
    //@todo This should also check for list items
    this.$compile = function(stack){
        stack.push("if (value.length > " + this.value + ") return false;");
    };
}).call(apf.XsdMaxLength.prototype = new apf.XsdElement());

apf.xsd.setElement("maxlength", apf.XsdMaxLength);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/union.js)SIZE(2331)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/*
  <xs:simpleType name="SizeType">
    <xs:union memberTypes="DressSizeType">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="small"/>
          <xs:enumeration value="medium"/>
          <xs:enumeration value="large"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="DressSizeType">
    <xs:restriction base="xs:integer">
      <xs:minInclusive value="2"/>
      <xs:maxInclusive value="18"/>
    </xs:restriction>
  </xs:simpleType>
*/
apf.XsdUnion = function(struct, tagName){
    this.$init(tagName || "union", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$propHandlers["memberTypes"] = function(value){
        this.$memberTypes = value.splitSafe(" ");
        this.parentNode.$recompile();
    };
    
    this.$compile = function(stack){
        var i, l, node,
            nodes = this.childNodes;
        for (i = 0, l = this.$memberTypes.length; i < l; i++) {
            stack.push("if (apf.xsd.checkType('"
              + this.$memberTypes[i] + "', value)) return true;");
        }

        for (i = 0, l = nodes.length; i < l; i++)
            (node = nodes[i]).$compile && node.$compile(stack);
    }
}).call(apf.XsdUnion.prototype = new apf.XsdElement());

apf.xsd.setElement("union", apf.XsdUnion);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/minscale.js)SIZE(1436)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.XsdMinScale = function(struct, tagName){
    this.$init(tagName || "minscale", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$propHandlers["value"] = function(){
        this.parentNode.$recompile();
    };
    
    //@todo http://www.w3.org/TR/2006/WD-xmlschema11-2-20060217/datatypes.html#element-minScale
    this.$compile = function(stack){};
}).call(apf.XsdMinScale.prototype = new apf.XsdElement());

apf.xsd.setElement("minscale", apf.XsdMinScale);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/restriction.js)SIZE(1644)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.XsdRestriction = function(struct, tagName){
    this.$init(tagName || "restriction", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$propHandlers["base"] = function(){
        this.parentNode.$recompile();
    }
    
    this.$compile = function(stack){
        stack.push("if (!apf.xsd.matchType(value, '"
            + this.base + "')) return false;");

        var i, l, node,
            nodes = this.childNodes;
        for (i = 0, l = nodes.length; i < l; i++)
            (node = nodes[i]).$compile && node.$compile(stack);
    }
}).call(apf.XsdRestriction.prototype = new apf.XsdElement());

apf.xsd.setElement("restriction", apf.XsdRestriction);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/simpletype.js)SIZE(2201)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.XsdSimpleType = function(struct, tagName){
    this.$init(tagName || "simpletype", apf.NODE_HIDDEN, struct);
    
    var lastName;
    this.$propHandlers["name"] = function(value){
        if (lastName) {
            apf.xsd.custumTypeHandlers[value] = 
                apf.xsd.custumTypeHandlers[lastName]
            apf.xsd.custumTypeHandlers[lastName] = null;
        }
        
        lastName = value;
    };
};

(function(){
    this.$compile = function(stack){
        var i, l, nodes, node;
        if (!this.parentNode.$compile) {
            stack = [];
    
            nodes = this.childNodes;
            for (i = 0, l = nodes.length; i < l; i++)
                (node = nodes[i]).$compile && node.$compile(stack);
    
            stack.push("return true;");
            apf.xsd.custumTypeHandlers[this.name] =
                new Function('value', stack.join("\n"));
        }
        else {
            nodes = this.childNodes;
            for (i = 0, l = nodes.length; i < l; i++)
                (node = nodes[i]).$compile && node.$compile(stack);
        }
    };
}).call(apf.XsdSimpleType.prototype = new apf.XsdElement());

apf.xsd.setElement("simpletype", apf.XsdSimpleType);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/minlength.js)SIZE(1610)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Specifies the minimum number of characters or list items allowed. Must be equal to or greater than zero
 */
apf.XsdMinLength = function(struct, tagName){
    this.$init(tagName || "minlength", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$propHandlers["value"] = function(){
        this.parentNode.$recompile();
    };
    
    //@todo This should also check for list items
    this.$compile = function(stack){
        stack.push("if (value.length < " + this.value
            + ") return false;");
    };
}).call(apf.XsdMinLength.prototype = new apf.XsdElement());

apf.xsd.setElement("minlength", apf.XsdMinLength);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/schema.js)SIZE(1124)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.XsdSchema = function(struct, tagName){
    this.$init(true);
};

apf.XsdSchema.prototype = new apf.XsdElement();

apf.xsd.setElement("schema", apf.XsdSchema);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/mininclusive.js)SIZE(1567)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Specifies the lower bounds for numeric values (the value must be greater than or equal to this value)
 */
apf.XsdMinInclusive = function(struct, tagName){
    this.$init(tagName || "mininclusive", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$propHandlers["value"] = function(){
        this.parentNode.$recompile();
    };
    
    this.$compile = function(stack){
        stack.push("if (parseFloat(value) < " + this.value + ") return false;");
    };
}).call(apf.XsdMinInclusive.prototype = new apf.XsdElement());

apf.xsd.setElement("mininclusive", apf.XsdMinInclusive);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/minexclusive.js)SIZE(1556)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Specifies the lower bounds for numeric values (the value must be greater than this value)
 */
apf.XsdMinExclusive = function(struct, tagName){
    this.$init(tagName || "minexclusive", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$propHandlers["value"] = function(){
        this.parentNode.$recompile();
    };
    
    this.$compile = function(stack){
        stack.push("if (parseFloat(value) => " + this.value + ") return false;");
    };
}).call(apf.XsdMinExclusive.prototype = new apf.XsdElement());

apf.xsd.setElement("minexclusive", apf.XsdMinExclusive);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/fractiondigits.js)SIZE(1620)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Specifies the maximum number of decimal places allowed. Must be equal to or greater than zero
 */
apf.XsdFractionDigits = function(struct, tagName){
    this.$init(tagName || "maxinclusive", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$propHandlers["value"] = function(){
        this.parentNode.$recompile();
    };
    
    this.$compile = function(stack){
        stack.push("if (parseFloat(value) == value && value.split('.')[1].length != "
            + this.value + ") return false;");
    };
}).call(apf.XsdFractionDigits.prototype = new apf.XsdElement());

apf.xsd.setElement("maxinclusive", apf.XsdFractionDigits);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/maxexclusive.js)SIZE(1553)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Specifies the upper bounds for numeric values (the value must be less than this value)
 */
apf.XsdMaxExclusive = function(struct, tagName){
    this.$init(tagName || "maxexclusive", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$propHandlers["value"] = function(){
        this.parentNode.$recompile();
    };
    
    this.$compile = function(stack){
        stack.push("if (parseFloat(value) =< " + this.value + ") return false;");
    };
}).call(apf.XsdMaxExclusive.prototype = new apf.XsdElement());

apf.xsd.setElement("maxexclusive", apf.XsdMaxExclusive);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xforms.js)SIZE(4195)TIME(1257329185)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */





//XForms





/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xinclude.js)SIZE(1329)TIME(1264690337)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Object creating the XML Include namespace for the aml parser.
 *
 * @constructor
 * @parser
 *
 * @allownode simpleType, complexType
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 */
apf.xinclude = new apf.AmlNamespace();
apf.setNamespace("http://www.w3.org/2001/XInclude", apf.xinclude);



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/html5.js)SIZE(3236)TIME(1258118721)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Object creating the HTML5 namespace for the aml parser.
 *
 * @constructor
 * @parser
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 */
apf.html5 = new apf.AmlNamespace();
apf.setNamespace("", apf.html5);



/**
 * @define input
 * Remarks:
 * Ajax.org Platform supports the input types specified by the WHATWG html5 spec.
 * @attribute {String} type the type of input element.
 *   Possible values:
 *   email      provides a way to enter an email address.
 *   url        provides a way to enter a url.
 *   password   provides a way to enter a password.
 *   datetime   provides a way to pick a date and time.
 *   date       provides a way to pick a date.
 *   month      provides a way to pick a month.
 *   week       provides a way to pick a week.
 *   time       provides a way to pick a time.
 *   number     provides a way to pick a number.
 *   range      provides a way to select a point in a range.
 *   checkbox   provides a way to set a boolean value.
 *   radio      used in a set, it provides a way to select a single value from multiple options.
 *   file       provides a way to upload a file.
 *   submit     provides a way to submit data.
 *   image      provides a way to submit data displaying an image instead of a button.
 *   reset      provides a way to reset entered data.
 * @addnode elements
 */
/**
 * @private
 */
apf.HTML5INPUT = {
    "email"    : "textbox",
    "url"      : "textbox",
    "password" : "textbox",
    "datetime" : "spinner", //@todo
    "date"     : "calendar",
    "month"    : "spinner", //@todo
    "week"     : "spinner", //@todo
    "time"     : "spinner", //@todo
    "number"   : "spinner",
    "range"    : "slider",
    "checkbox" : "checkbox",
    "radio"    : "radiobutton",
    "file"     : "upload",
    "submit"   : "submit",
    "image"    : "submit",
    "reset"    : "button"
};

/* way to implement this:
var o = (new function(){
})
o.constructor.prototype = new apf.list();

*/



/* #-ifdef __WITH_HTML5
if (tagName == "input") {
    objName = apf.HTML5INPUT[objName = x.getAttribute("type")]
        || objName || "textbox";
}
//#-endif*/


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xslt/xslt.js)SIZE(13722)TIME(1265038748)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * @private
 */
apf.runXslt = function(){
    /**
     * @constructor
     * @parser
     */
    apf.XSLTProcessor = function(){
        this.templates = {};
        this.p = {
            "value-of": function(context, xslNode, childStack, result){
                var value,
                    xmlNode = apf.XPath.selectNodes(xslNode.getAttribute("select"),
                              context)[0];// + "[0]"
                if (!xmlNode) {
                    value = "";
                }
                else {
                    if (xmlNode.nodeType == 1)
                        value = xmlNode.firstChild ? xmlNode.firstChild.nodeValue : "";
                    else
                        value = typeof xmlNode == "object" ? xmlNode.nodeValue : xmlNode;
                }

                result.appendChild(this.xmlDoc.createTextNode(value));
            },

            "copy-of": function(context, xslNode, childStack, result){
                var xmlNode = apf.XPath.selectNodes(xslNode.getAttribute("select"),
                              context)[0];// + "[0]"
                if (xmlNode)
                    result.appendChild(apf.canImportNode
                        ? result.ownerDocument.importNode(xmlNode, true)
                        : xmlNode.cloneNode(true));
            },

            "if": function(context, xslNode, childStack, result){
                if (apf.XPath.selectNodes(xslNode.getAttribute("test"), context)[0])// + "[0]"
                    this.parseChildren(context, xslNode, childStack, result);
            },

            "for-each": function(context, xslNode, childStack, result){
                var i, l,
                    nodes = apf.XPath.selectNodes(xslNode.getAttribute("select"), context);
                for (i = 0, l = nodes.length; i < l; i++)
                    this.parseChildren(nodes[i], xslNode, childStack, result);
            },

            "choose": function(context, xslNode, childStack, result){
                var i, l,
                    nodes = xslNode.childNodes;
                for (i = 0, l = nodes.length; i < l; i++) {
                    if (!nodes[i].tagName)
                        continue;

                    if (nodes[i][apf.TAGNAME]  == "otherwise"
                      || nodes[i][apf.TAGNAME] == "when"
                      && apf.XPath.selectNodes(nodes[i].getAttribute("test"), context)[0])
                        return this.parseChildren(context, nodes[i], childStack[i][2], result);
                }
            },

            "output": function(context, xslNode, childStack, result){},

            "param": function(context, xslNode, childStack, result){},

            "attribute": function(context, xslNode, childStack, result){
                var nres = this.xmlDoc.createDocumentFragment();
                this.parseChildren(context, xslNode, childStack, nres);

                result.setAttribute(xslNode.getAttribute("name"), nres.xml);
            },

            "apply-templates": function(context, xslNode, childStack, result){
                var t, i, l, nodes;
                if (!xslNode) {
                    t = this.templates["/"] || this.templates[context.tagName];
                    if (t) {
                        this.parseChildren(t == this.templates["/"]
                            ? context.ownerDocument : context, t[0], t[1], result);
                    }
                }
                else {
                    if (xslNode.getAttribute("select")) {
                        t = this.templates[xslNode.getAttribute("select")];
                        if (t) {
                            if (xslNode.getAttribute("select") == "/")
                                return alert("Something went wrong. The / template was executed as a normal template");

                            nodes = context.selectNodes(xslNode.getAttribute("select"));
                            for (i = 0, l = nodes.length; i < l; i++)
                                this.parseChildren(nodes[i], t[0], t[1], result);
                        }
                    }
                    //Named templates should be in a different hash
                    else {
                        if (xslNode.getAttribute("name")) {
                            t = this.templates[xslNode.getAttribute("name")];
                            if (t)
                                this.parseChildren(context, t[0], t[1], result);
                        }
                        else {
                            //Copy context
                            var ncontext = context.cloneNode(true), //importnode here??
                                nres     = this.xmlDoc.createDocumentFragment(),
                                tName, p, k;

                            nodes = ncontext.childNodes;
                            for (i = nodes.length - 1; i >= 0; i--) {
                                if (nodes[i].nodeType == 3 || nodes[i].nodeType == 4) {
                                    //result.appendChild(this.xmlDoc.createTextNode(nodes[i].nodeValue));
                                    continue;
                                }
                                if (!nodes[i].nodeType == 1)
                                    continue;
                                var n = nodes[i];

                                //Loop through all templates
                                for (tName in this.templates) {
                                    if (tName == "/")
                                        continue;
                                    t = this.templates[tName];

                                    var snodes = n.selectNodes("self::" + tName);
                                    for (var j = snodes.length - 1; j >= 0; j--) {
                                        var s = snodes[j];
                                        p = s.parentNode;
                                        this.parseChildren(s, t[0], t[1], nres);
                                        if (nres.childNodes) {
                                            for (k = nres.childNodes.length - 1; k >= 0; k--)
                                                p.insertBefore(nres.childNodes[k], s);
                                        }
                                        p.removeChild(s);
                                    }
                                }

                                if (n.parentNode) {
                                    p = n.parentNode;
                                    this.p["apply-templates"].call(this, n, xslNode, childStack, nres);
                                    if (nres.childNodes) {
                                        for (k = nres.childNodes.length - 1; k >= 0; k--)
                                            p.insertBefore(nres.childNodes[k], n);
                                    }
                                    p.removeChild(n);
                                }
                            }

                            for (i = ncontext.childNodes.length - 1; i >= 0; i--)
                                result.insertBefore(ncontext.childNodes[i], result.firstChild);
                        }
                    }
                }
            },

            cache   : {},
            "import": function(context, xslNode, childStack, result){
                var file = xslNode.getAttribute("href");
                if (!this.cache[file]) {
                    var data = apf.oHttp.get(file);
                    this.cache[file] = data;
                }
                //compile
                //parseChildren
            },

            "include"  : function(context, xslNode, childStack, result){},

            "when"     : function(){},
            "otherwise": function(){},

            "copy-clone": function(context, xslNode, childStack, result){
                result = result.appendChild(apf.canImportNode 
                    ? result.ownerDocument.importNode(xslNode, false)
                    : xslNode.cloneNode(false));
                if (result.nodeType == 1) {
                    for (var value, i = 0, l = result.attributes.length; i < l; i++) {
                        var blah = result.attributes[i].nodeValue; //stupid Safari shit
                        if (!apf.isSafariOld && result.attributes[i].nodeName.match(/^xmlns/))
                            continue;
                        result.attributes[i].nodeValue = result.attributes[i].nodeValue
                            .replace(/\{([^\}]+)\}/g, function(m, xpath){
                                var xmlNode = apf.XPath.selectNodes(xpath, context)[0];

                                if (!xmlNode) {
                                    value = "";
                                }
                                else {
                                    if (xmlNode.nodeType == 1) {
                                        value = xmlNode.firstChild 
                                            ? xmlNode.firstChild.nodeValue
                                            : "";
                                    }
                                    else {
                                        value = typeof xmlNode == "object"
                                            ? xmlNode.nodeValue
                                            : xmlNode;
                                    }
                                }

                                return value;
                            });

                        result.attributes[i].nodeValue; //stupid Safari shit
                    }
                }

                this.parseChildren(context, xslNode, childStack, result);
            }
        }

        this.parseChildren = function(context, xslNode, childStack, result){
            if (!childStack) return;
            for (var i = 0, l = childStack.length; i < l; i++) {
                childStack[i][0].call(this, context, childStack[i][1],
                    childStack[i][2], result);
            }
        };

        this.compile = function(xslNode){
            var nodes = xslNode.childNodes;
            for (var stack = [], i = 0, l = nodes.length; i < l; i++) {
                if (nodes[i].nodeType != 1 && nodes[i].nodeType != 3 && nodes[i].nodeType != 4)
                    continue;

                if (nodes[i][apf.TAGNAME] == "template") {
                    this.templates[nodes[i].getAttribute("match")
                        || nodes[i].getAttribute("name")] = [nodes[i], this.compile(nodes[i])];
                }
                else {
                    if (nodes[i][apf.TAGNAME] == "stylesheet") {
                        this.compile(nodes[i])
                    }
                    else {
                        if (nodes[i].prefix == "xsl") {
                            var func = this.p[nodes[i][apf.TAGNAME]];
                            if (!func)
                                alert("xsl:" + nodes[i][apf.TAGNAME] + " is not supported at this time on this platform");
                            else
                                stack.push([func, nodes[i], this.compile(nodes[i])]);
                        }
                        else {
                            stack.push([this.p["copy-clone"], nodes[i], this.compile(nodes[i])]);
                        }
                    }
                }
            }
            return stack;
        };

        this.importStylesheet = function(xslDoc){
            this.xslDoc = xslDoc.nodeType == 9 ? xslDoc.documentElement : xslDoc;
            var xslStack = this.compile(xslDoc);

            //var t = this.templates["/"] ? "/" : false;
            //if(!t) for(t in this.templates) if(typeof this.templates[t] == "array") break;
            this.xslStack = [[this.p["apply-templates"], null]];//{getAttribute : function(n){if(n=="name") return t}
        };

        //return nodes
        this.transformToFragment = function(doc, newDoc){
            //new DOMParser().parseFromString("<xsltresult></xsltresult>", "text/xml");//
            this.xmlDoc = newDoc.nodeType != 9 ? newDoc.ownerDocument : newDoc;
            var docfrag = this.xmlDoc.createDocumentFragment();

            if (!apf.isSafariOld && doc.nodeType == 9)
                doc = doc.documentElement;
            var result = this.parseChildren(doc, this.xslDoc, this.xslStack, docfrag);
            return docfrag;
        };
    };

    self.XSLTProcessor = apf.XSLTProcessor;
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xinclude/include.js)SIZE(5677)TIME(1264690337)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Defines a list of acceptable values
 */
apf.XiInclude = function(struct, tagName){
    this.$init(tagName || "include", apf.NODE_HIDDEN, struct);
};

apf.xinclude.setElement("include", apf.XiInclude);
apf.aml.setElement("include", apf.XiInclude);

(function(){
    this.$parsePrio = "002";

    //1 = force no bind rule, 2 = force bind rule
    /*this.$attrExcludePropBind = apf.extend({
        href : 1,
        src  : 1
    }, this.$attrExcludePropBind);*/

    this.$propHandlers["href"] = 
    this.$propHandlers["src"]  = function(value){
        if (typeof value != "string")
            return finish.call(this, value);

        this.$path = value.charAt(0) == "{" //@todo this shouldn't happen anymore
          ? value
          : apf.getAbsolutePath(apf.hostPath, value);
        
        var domParser = this.ownerDocument.$domParser;
        if (!this.defer) {
            domParser.$shouldWait++;
            this.$parseContext = domParser.$callCount < 2 
                && domParser.$parseContext || [this.parentNode];
        }
        
        //var basePath = apf.hostPath;//only for recursion: apf.getDirname(xmlNode.getAttribute("filename")) || 
        loadIncludeFile.call(this, this.$path);
    };
    
    function finish(xmlNode){
        var domParser = this.ownerDocument.$domParser;

        if (this.clear)
            this.parentNode.$int.innerHTML = "";
        
        //@todo apf3.x the insertBefore seems like unnecessary overhead
        if (xmlNode) {
            var nodes = domParser.parseFromXml(xmlNode, {
                    doc: this.ownerDocument
                }).firstChild.childNodes,
                pNode = this.parentNode,
                node, i, l;
            for (node, i = 0, l = nodes.length; i < l; i++) {
                (node = nodes[i]).parentNode = null; //@todo a little hackery
                pNode.insertBefore(node, this);
            }
        }

        if (!this.defer)
            domParser.$continueParsing.apply(domParser, this.$parseContext);
            
        if (this.callback) {
            this.callback({
                xmlNode : xmlNode,
                amlNode : this.parentNode
            })
        }
        
        this.parentNode.removeChild(this);
    }
    
    function loadIncludeFile(path){
        
        apf.console.info("Loading include file: " + path);
        

        var _self = this;
        apf.getData(path, apf.extend(this.options || {}, {
            callback : function(xmlString, state, extra){
                if (state != apf.SUCCESS) {
                    var oError = new Error(apf.formatErrorString(1007,
                        _self, "Loading Includes", "Could not load Include file '"
                        + (path || _self.src)
                        + "'\nReason: " + extra.message));

                    if (extra.tpModule.retryTimeout(extra, state, null, oError) === true)
                        return true;

                    apf.console.error(oError.message);

                    finish.call(_self, null);

                    //throw oError;
                    return;
                }

                //@todo apf3.0 please make one way of doing this
                xmlString = xmlString.replace(/\<\!DOCTYPE[^>]*>/, "")
                    .replace(/&nbsp;/g, " ").replace(/^[\r\n\s]*/, "");
                if (!apf.supportNamespaces)
                    xmlString = xmlString.replace(/xmlns\=\"[^"]*\"/g, "");
                
                if (xmlString.indexOf("<a:application") == -1)
                    xmlString = "<a:application xmlns:a='" + apf.ns.aml +"'>"
                      + xmlString + "</a:application>";

                var xmlNode = apf.getXml(xmlString, null, true);//apf.getAmlDocFromString(xmlString);
            
                if (!xmlNode) {
                    throw new Error(apf.formatErrorString(0, null,
                        "Loading skin",
                        "Could not parse include file. Maybe the file does not exist?", xmlNode));
                }
            
                xmlNode.setAttribute("filename", extra.url);

                
                apf.console.info("Loading of " + xmlNode[apf.TAGNAME].toLowerCase() + " include done from file: " + extra.url);
                
            
                finish.call(_self, xmlNode); //@todo add recursive includes support here
            },
            async         : true,
            ignoreOffline : true
        }));
    }
}).call(apf.XiInclude.prototype = new apf.AmlElement());


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xinclude/fallback.js)SIZE(1322)TIME(1264690337)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Defines a list of acceptable values
 */
apf.XiFallback = function(struct, tagName){
    this.$init(tagName || "fallback", apf.NODE_HIDDEN, struct);
};

apf.XiFallback.prototype = new apf.AmlElement();
apf.XiFallback.prototype.$parsePrio = "002";

apf.xinclude.setElement("fallback", apf.XiFallback);
apf.aml.setElement("fallback", apf.XiFallback);


/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/anchoring.js)SIZE(19084)TIME(1264896063)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__ANCHORING__ = 1 << 13;



/**
 * All elements inheriting from this {@link term.baseclass baseclass} have anchoring features. Each side of the
 * element can be attached at a certain distance to it's parent's rectangle.
 * When the parent is resized the anchored side of the element stays
 * at the specified distance at all times. If both sides are anchored the
 * element size is changed to make sure the specified distance is maintained.
 * Example:
 * This example shows a bar that has 10% as a margin around it and contains a
 * frame that is displayed using different calculations and settings.
 * <code>
 *  <a:bar width="80%" height="80%" top="10%" left="10%">
 *      <a:frame 
 *        caption = "Example" 
 *        left    = "50%+10"
 *        top     = "100"
 *        right   = "10%"
 *        bottom  = "Math.round(0.232*100)" />
 *  </a:bar>
 * </code>
 * Remarks:
 * This is one of three positioning methods.
 * See {@link baseclass.alignment}
 * See {@link element.grid}
 *
 * @constructor
 * @baseclass
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.3
 */
apf.Anchoring = function(){
    this.$regbase = this.$regbase | apf.__ANCHORING__;
    this.$anchors = [];

    var VERTICAL   = 1;
    var HORIZONTAL = 2;

    this.$updateQueue = 0;
    this.$inited      =
    this.$parsed      =
    this.$anchoringEnabled = false;
    this.$hordiff     = 
    this.$verdiff     = 0;
    this.$rule_v      =
    this.$rule_h      =
    this.$rule_header = "";

    var l = apf.layout;
    
    this.$supportedProperties.push("anchors");
    
    var propHandlers = {
        "right" : function(value, prop){
            if (!this.$anchoringEnabled && !this.$setLayout("anchoring"))
                return;
            
            if (!value)
                this.$ext.style[prop] = "";

            //@note Removed apf.isParsing here to activate general queuing
            if (!this.$updateQueue)
                l.queue(this.$pHtmlNode, this);
            this.$updateQueue = this.$updateQueue | HORIZONTAL;
        },

        "bottom" : function(value, prop){
            if (!this.$anchoringEnabled && !this.$setLayout("anchoring"))
                return;

            if (!value)
                this.$ext.style[prop] = "";

            //@note Removed apf.isParsing here to activate general queuing            
            if (!this.$updateQueue)
                l.queue(this.$pHtmlNode, this);
            this.$updateQueue = this.$updateQueue | VERTICAL;
        }
    };
    propHandlers.left = propHandlers.width = propHandlers.right;
    propHandlers.top = propHandlers.height = propHandlers.bottom;
    
    this.$propHandlers["anchors"] = function(value){
        this.$anchors = value ? value.splitSafe("(?:, *| )") : [];

        if (!this.$anchoringEnabled && !this.$setLayout("anchoring"))
            return;

        if (!this.$updateQueue && apf.loaded)
            l.queue(this.$pHtmlNode, this);
        this.$updateQueue = this.$updateQueue | HORIZONTAL | VERTICAL;
    };

    /**
     * Turns anchoring off.
     *
     */
    this.$disableAnchoring = function(activate){
        //!this.$parsed || 
        if (!this.$inited || !this.$anchoringEnabled || !this.$pHtmlNode)
            return;

        l.removeRule(this.$pHtmlNode, this.$uniqueId + "_anchors");
        if (l.queue)
            l.queue(this.$pHtmlNode);

        for (var prop in propHandlers) {
            delete this.$propHandlers[prop];
        }

        this.removeEventListener("DOMNodeRemoved", remove); 
        this.removeEventListener("DOMNodeInserted", reparent); 

        if (this.right)
            this.$ext.style.left = this.$ext.offsetLeft;

        if (this.bottom)
            this.$ext.style.top = this.$ext.offsetTop;

        this.removeEventListener("prop.visible", visibleHandler);

        this.$inited   = false;
        this.$anchoringEnabled = false; //isn't this redundant?
    };

    /**
     * Enables anchoring based on attributes set in the AML of this element
     *
     * @attribute {Number, String} [left]   a way to determine the amount of pixels from the left border of this element to the left edge of it's parent's border. This attribute can also contain percentages, arithmetic and even full expressions.
     * Example:
     * <a:bar left="(20% + 10) * SOME_JS_VAR" />
     * @attribute {Number, String} [right]  a way to determine the amount of pixels from the right border of this element to the right edge of it's parent's border.This attribute can also contain percentages, arithmetic and even full expressions.
     * Example:
     * <a:bar right="(20% + 10) * SOME_JS_VAR" />
     * @attribute {Number, String} [width]  a way to determine the amount of pixels from the left border to the right border of this element.This attribute can also contain percentages, arithmetic and even full expressions.
     * Example:
     * <a:bar width="(20% + 10) * SOME_JS_VAR" />
     * @attribute {Number, String} [top]    a way to determine the amount of pixels from the top border of this element to the top edge of it's parent's border.This attribute can also contain percentages, arithmetic and even full expressions.
     * Example:
     * <a:bar top="(20% + 10) * SOME_JS_VAR" />
     * @attribute {Number, String} [bottom] a way to determine the amount of pixels from the bottom border of this element to the bottom edge of it's parent's border.This attribute can also contain percentages, arithmetic and even full expressions.
     * Example:
     * <a:bar bottom="(20% + 10) * SOME_JS_VAR" />
     * @attribute {Number, String} [height] a way to determine the amount of pixels from the top border to the bottom border of this element.This attribute can also contain percentages, arithmetic and even full expressions.
     * Example:
     * <a:bar height="(20% + 10) * SOME_JS_VAR" />
     */
    this.$enableAnchoring = function(){
        if (this.$inited) //@todo add code to reenable anchoring rules (when showing)
            return;

        /**** Properties and Attributes ****/
        apf.extend(this.$propHandlers, propHandlers);

        /**** Event handlers ****/
        this.addEventListener("DOMNodeRemoved", remove); 
        this.addEventListener("DOMNodeInserted", reparent); 
        this.addEventListener("prop.visible", visibleHandler);

        this.$updateQueue = 0 
            | ((this.left || this.width || this.right || this.anchors) && HORIZONTAL) 
            | ((this.top || this.height || this.bottom || this.anchors) && VERTICAL) ;

        if (this.$updateQueue)
            l.queue(this.$pHtmlNode, this);

        this.$inited   = true;
        this.$anchoringEnabled = true;
    };
    
    function visibleHandler(e){
        if (!(this.$rule_header || this.$rule_v || this.$rule_h))
            return;

        if (e.value) {
            if (this.$rule_v || this.$rule_h) {
                var rules = this.$rule_header + "\n" + this.$rule_v + "\n" + this.$rule_h;
                l.setRules(this.$pHtmlNode, this.$uniqueId + "_anchors", rules);
                //this.$ext.style.display = "none";
                l.queue(this.$pHtmlNode, this);
            }
            l.processQueue();
        }
        else {
            l.removeRule(this.$pHtmlNode, this.$uniqueId + "_anchors");
            l.queue(this.$pHtmlNode)
        }
    }
    
    function remove(e){
        if (e && (e.$doOnlyAdmin || e.currentTarget == this))
            return;

        if (l.queue && this.$pHtmlNode) {
            l.removeRule(this.$pHtmlNode, this.$uniqueId + "_anchors");
            l.queue(this.$pHtmlNode)
        }
    }

    function reparent(e){
        if (!this.$amlLoaded || e.currentTarget != this)
            return;

        if (!e.$moveWithinParent && this.$parsed) //@todo hmm weird state check
            this.$moveAnchoringRules(e.$oldParentHtmlNode);
    }

    this.$moveAnchoringRules = function(oldParent, updateNow){
        var rules = oldParent && l.removeRule(oldParent, this.$uniqueId + "_anchors");
        if (rules)
            l.queue(oldParent);

        if (!this.$rule_v && !this.$rule_h)
            return;

        this.$rule_header = getRuleHeader.call(this);
        rules = this.$rule_header + "\n" + this.$rule_v + "\n" + this.$rule_h;

        this.$ext.style.display = "none";

        l.setRules(this.$pHtmlNode, this.$uniqueId + "_anchors", rules);
        l.queue(this.$pHtmlNode, this);
    };

    this.$hasAnchorRules = function(){
        return this.$rule_v || this.$rule_h ? true : false;
    };

    function getRuleHeader(){
        return "try{\
            var oHtml = " + (apf.hasHtmlIdsInJs
                ? this.$ext.getAttribute("id")
                : "document.getElementById('"
                    + this.$ext.getAttribute("id") + "')") + ";\
            \
            var pWidth = " + (this.$pHtmlNode == this.$pHtmlDoc.body
                ? "apf.getWindowWidth()" //@todo only needed for debug?
                : "oHtml.parentNode.offsetWidth") + ";\
            \
            var pHeight = " + (this.$pHtmlNode == this.$pHtmlDoc.body
                ? "apf.getWindowHeight()" //@todo only needed for debug?
                : "oHtml.parentNode.offsetHeight") + ";\
            }catch(e){\
            }";
    }

    /**
     * @macro
     */
    function setPercentage(expr, value){
        return String(expr).replace(apf.percentageMatch, "((" + value + " * $1)/100)");
    }

     
    this.$recalcAnchoring = function(queueDelay){
        var diff     = apf.getDiff(this.$ext);
        this.$hordiff = diff[0];
        this.$verdiff = diff[1];
        
        this.$updateQueue = this.$updateQueue | HORIZONTAL | VERTICAL;
        this.$updateLayout();
        l.queue(this.$pHtmlNode, this);
        
        if (!queueDelay)
            l.processQueue();
    };
    

    this.$updateLayout = function(){
        //@todo review if this can be improved
        
        if (!this.$ext.offsetHeight && !this.$ext.offsetWidth) {
            var _self      = this;
            var propChange = function (name, old, value){
                if (_self.$updateQueue && apf.isTrue(value) && (_self.$ext.offsetWidth || _self.$ext.offsetHeight)) {
                    _self.$updateLayout();
                    apf.layout.activateRules(_self.$ext.parentNode);
                    
                    var p = _self;
                    while (p) {
                        p.unwatch("visible", propChange);
                        p = p.parentNode;
                    }
                    
                    _self.$isWaitingOnDisplay = false;
                }
            }

            this.$isWaitingOnDisplay = true;
            this.watch("visible", propChange);
            
            var p = this.parentNode;
            while(p) {
                p.watch("visible", propChange);
                p = p.parentNode;
            }
            
            return;
        }
        
        
        if (!this.$parsed) {
            if (!this.$ext.getAttribute("id"))
                apf.setUniqueHtmlId(this.$ext);

            var diff    = apf.getDiff(this.$ext);
            this.$hordiff     = diff[0];
            this.$verdiff     = diff[1];
            if (this.$getOption) {
                this.$minheight    = Math.max(parseInt(this.$getOption("main", "minheight")) || 0, parseInt(this.getAttribute("minheight")) || 0) || 0;
                this.$maxheight    = Math.min(parseInt(this.$getOption("main", "maxheight")) || 0, parseInt(this.getAttribute("maxheight")) || 100000) || 100000;
                this.$minwidth     = Math.max(parseInt(this.$getOption("main", "minwidth")) || 0, parseInt(this.getAttribute("minwidth")) || 0) || 0;
                this.$maxwidth     = Math.min(parseInt(this.$getOption("main", "maxwidth")) || 0, parseInt(this.getAttribute("maxwidth")) || 100000) || 100000;
            }
            else {
                this.$minheight    = 0;
                this.$maxheight    = 100000;
                this.$minwidth     = 0;
                this.$maxwidth     = 100000;
            }
            this.$rule_header = getRuleHeader.call(this);
            this.$parsed      = true;
        }

        if (!this.$updateQueue) {
            if (this.visible)
                this.$ext.style.display = "";
            return;
        }

        if (this.draggable == "relative") {
            if ("absolute|fixed|relative".indexOf(apf.getStyle(this.$ext, "position")) == -1) //@todo apf3.1 the IDE doesn't like this
                this.$ext.style.position = "absolute";
        }
        else if (this.left || this.top || this.right || this.bottom || this.$anchors.length) {
            if ("absolute|fixed".indexOf(apf.getStyle(this.$ext, "position")) == -1)
                this.$ext.style.position = "absolute";
        }

        var rules;
        if (this.$updateQueue & HORIZONTAL) {
            rules = [];

            var left  = this.left  || this.$anchors[3],
                right = this.right || this.$anchors[1],
                width = this.width;

            if (right && typeof right == "string")
                right = setPercentage(right, "pWidth");

            if (left) {
                if (parseInt(left) != left) {
                    left = setPercentage(left,  "pWidth");
                    rules.push("oHtml.style.left = (" + left + ") + 'px'");
                }
                else
                    this.$ext.style.left = left + "px";
            }
            if (!left && right) {
                if (parseInt(right) != right) {
                    right = setPercentage(right, "pWidth");
                    rules.push("oHtml.style.right = (" + right + ") + 'px'");
                }
                else
                    this.$ext.style.right = right + "px";
            }
            if (width) {
                if (parseInt(width) != width) {
                    width = setPercentage(width, "pWidth");
                    rules.push("oHtml.style.width = Math.max(" + this.$minwidth 
                        + ", Math.min(" + this.$maxwidth + ", "
                        + width + " - " + this.$hordiff + ")) + 'px'");
                }
                else {
                    this.$ext.style.width = (width > this.$hordiff + this.$minwidth
                        ? (width < this.$hordiff + this.$maxwidth
                            ? width - this.$hordiff
                            : this.$maxwidth)
                        : this.$minwidth) + "px";
                }
            }

            if (right != null && left != null) {
                rules.push("oHtml.style.width = (pWidth - (" + right
                    + ") - (" + left + ") - " + this.$hordiff + ") + 'px'");
            }

            this.$rule_h = (rules.length
                ? "try{" + rules.join(";}catch(e){};try{") + ";}catch(e){};"
                : "");
        }

        if (this.$updateQueue & VERTICAL) {
            rules = [];

            var top    = this.top    || this.$anchors[0],
                bottom = this.bottom || this.$anchors[2],
                height = this.height;

            if (bottom && typeof bottom == "string")
                bottom = setPercentage(bottom, "pHeight");

            if (top) {
                if (parseInt(top) != top) {
                    top = setPercentage(top, "pHeight");
                    rules.push("oHtml.style.top = (" + top + ") + 'px'");
                }
                else
                    this.$ext.style.top = top + "px";
            }
            if (!top && bottom) {
                if (parseInt(bottom) != bottom) {
                    rules.push("oHtml.style.bottom = (" + bottom + ") + 'px'");
                }
                else
                    this.$ext.style.bottom = bottom + "px";
            }
            if (height) {
                if (parseInt(height) != height) {
                    height = setPercentage(height, "pHeight");
                    rules.push("oHtml.style.height = Math.max(" + this.$minheight 
                        + ", Math.min(" + this.$maxheight + ", "
                        + height + " - " + this.$verdiff + ")) + 'px'");
                }
                else {
                    this.$ext.style.height = (height > this.$verdiff + this.$minheight
                        ? (height < this.$verdiff + this.$maxheight
                            ? height - this.$verdiff
                            : this.$maxheight)
                        : this.$minheight) + "px";
                }
            }

            if (bottom != null && top != null) {
                rules.push("oHtml.style.height = (pHeight - (" + bottom +
                    ") - (" + top + ") - " + this.$verdiff + ") + 'px'");
            }

            this.$rule_v = (rules.length
                ? "try{" + rules.join(";}catch(e){};try{") + ";}catch(e){};"
                : "");
        }

        if (this.$rule_v || this.$rule_h) {
            l.setRules(this.$pHtmlNode, this.$uniqueId + "_anchors",
                this.$rule_header + "\n" + this.$rule_v + "\n" + this.$rule_h, true);
        }
        else {
            l.removeRule(this.$pHtmlNode, this.$uniqueId + "_anchors");
        }

        this.$updateQueue = 0;
    };

    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        //if (this.$updateQueue)
            //this.$updateLayout();
    });

    this.addEventListener("DOMNodeRemovedFromDocument", function(e){
        this.$disableAnchoring();
    });
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/alignment.js)SIZE(14461)TIME(1263910419)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__ALIGNMENT__ = 1 << 12;



/**
 * All elements inheriting from this {@link term.baseclass baseclass} have alignment features. 
 * An element can be aligned to any side of its parent's rectangle. Multiple elements can
 * be aligned to the same side; these are then stacked. Layouts created using
 * alignment, with or without vbox/hbox elements can be stored in xml format.
 * These can then be loaded and saved for later use. Using this technique it's
 * possible to offer a layout manager to your users from within your application.
 * This layout manager could then allow the user to choose between several
 * layouts and save new ones.
 * Example:
 * An Outlook-like layout in AML
 * <code>
 *  <a:toolbar   align = "top-1"          height = "40" />
 *  <a:tree      align = "left-splitter"  width  = "20%" />
 *  <a:datagrid  align = "right-splitter" height = "50%" />
 *  <a:text      align = "right" />
 *  <a:statusbar align = "bottom-2"       height = "20" />
 * </code>
 * Remarks:
 * This is one of three positioning methods.
 * See {@link element.grid}
 * See {@link baseclass.anchoring}
 *
 * @attribute {Boolean} dock whether this element can function as a dockable section of the layout.
 * @attrinfo  layout/align  dropdown
 * @default   false
 * @attribute {Boolean} dockable whether this element can be dragged to dock somewhere else
 * @attrinfo  layout/align  dropdown
 * @default   false

 * @attribute  {String} align       the edge of the parent to which this
 *                                  element aligns. Possible values are
 *                                  a combination of: "left", "middle",
 *                                  "right", "top", "bottom" and "slider"
 *                                  and optionally a size.
 * Example:
 * <code>
 *  <a:tree align="left-splitter-3" width="200" height="200">
 *      <a:item caption="root" icon="icoUsers.gif">
 *          <a:item icon="icoUsers.gif" caption="test">
 *              <a:item icon="icoUsers.gif" caption="test" />
 *              <a:item icon="icoUsers.gif" caption="test" />
 *              <a:item icon="icoUsers.gif" caption="test" />
 *          </a:item>
 *      </a:item>
 *  </a:tree>
 * </code>
 * @attrinfo  layout  textbox
 * @attribute  {String} lean        the position of element when it is ambiguous.
 *   Possible values:
 *   left   the element leans towards the left
 *   right  the element leans towards the right
 *   top    the element leans towards the top
 *   bottom the element leans towards the bottom
 * @attrinfo  layout/align  dropdown
 * @default   left
 * @attribute  {Number} edge        the size of the edge of the space between
 *                                  this and the neighbouring element to the
 *                                  right or top. If the value of this attribute
 *                                  is smaller than that of the splitter,
 *                                  the edge will be the size of the splitter.
 * @attrinfo  layout/align  slider
 * @default   4
 * @attribute  {Number} weight      the factor (between 0 and 1) this element
 *                                  takes when no width is specified. The factor
 *                                  is calculated by doing (weight/totalweight)
 *                                  * space available in parent. Based on
 *                                  the parent being a vbox or hbox this
 *                                  attribute calculates either the element's
 *                                  width or height.
 * @attrinfo  layout/align  slider
 * @default   1
 * @attribute  {Number} splitter    the size of splitter that is placed between
 *                                  this and the neighbouring element to the
 *                                  right or top. When not specified, the
 *                                  splitter is not displayed.
 * @attrinfo  layout/align  slider
 * @default   0
 * @attribute  {Number} minwidth    the minimum horizontal size of this element.
 * @attrinfo  layout  slider
 * @default   0
 * @attribute  {Number} minheight   the minimum vertical size of this element.
 * @attrinfo  layout  slider
 * @default   0

 * @constructor
 * @baseclass
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @default_private
 */
apf.Alignment = function(){
    this.$regbase = this.$regbase | apf.__ALIGNMENT__;

    var l = apf.layout;

    if (typeof this.dock == "undefined")
        this.dock = false;
    if (typeof this.dockable == "undefined")
        this.dockable = false;
    this.$booleanProperties["dock"] = true;
    this.$booleanProperties["dockable"] = true;
    this.$supportedProperties.push("dock", "dockable", "align", "lean", "edge",
        "weight", "splitter", "minwidth", "minheight");

    /**** DOM Hooks ****/

    /**
     * Turns the alignment features off.
     * @param  {Boolean} [purge] whether alignment is recalculated right after setting the property.
     */
    //var lastPosition, amlNode = this;
    this.$disableAlignment = function(purge){
        if (!this.aData || !this.$alignmentEnabled) 
            return;

        for (var prop in propHandlers)
            delete this.$propHandlers[prop];
        
        this.removeEventListener("DOMNodeRemoved", remove); 
        this.removeEventListener("DOMNodeInserted", reparent); 
        
        this.removeEventListener("prop.visible", visibleHandler);

        remove.call(this);
    };

    /**
     * Turns the alignment features on.
     *
     */
    this.$enableAlignment = function(purge){
        this.$alignmentEnabled = true;

        var buildParent = "vbox|hbox".indexOf(this.parentNode.tagName) == -1
            && !this.parentNode.pData;

        apf.extend(this.$propHandlers, propHandlers);

        this.addEventListener("DOMNodeRemoved", remove); 
        this.addEventListener("DOMNodeInserted", reparent); 
        this.addEventListener("prop.visible", visibleHandler);

        var layout = l.get(this.$pHtmlNode, buildParent
            ? apf.getBox(this.parentNode.margin || this.$pHtmlNode.getAttribute("margin") || "")
            : null);

        if (buildParent) {
            this.parentNode.pData = l.parseXml(
                this.parentNode || apf.getXml("<vbox />"),
                layout, "vbox", true);

            layout.root = this.parentNode.pData;
        }

        if (!this.aData)
            this.aData = l.parseXml(this, layout, this, true); //not recur?

        
        if (this.align) {
            l.addAlignNode(this, layout.root);

            if (this.aData.hidden || this.visible === false)
                this.aData.prehide(true);

            //@note Removed apf.isParsing here to activate general queuing
            this.$purgeAlignment();
        }
        else
        
        {
            var pData = this.parentNode.aData || this.parentNode.pData;
            this.aData.stackId = pData.children.push(this.aData) - 1;
            this.aData.parent  = pData;
        }
    };
    
    function visibleHandler(e){
        if (!this.aData) return;

        if (!this.aData.hidden == e.value) //useless changing to same state
            return;

        if (e.value) {
            if (this.aData.preshow() !== false)
                this.$ext.style.display = "none";
            this.$purgeAlignment();
        }
        else {
            this.$ext.style.display = "block";
            this.aData.prehide();
            this.$purgeAlignment();
        }
        
        apf.layout.processQueue(); //@todo apf3.0 might not be the best but fixes trunk/test/toc.html
    };

    /**
     * Calculates the rules for this element and activates them.
     * @private
     */
    this.$purgeAlignment = function(){
        var layout = l.get(this.$pHtmlNode);
        
        //@todo review if this can be improved
        
        if (this.$ext && this.$ext.style.display == "block" 
          && !this.$ext.offsetHeight && !this.$ext.offsetWidth) {
            var _self      = this;
            var propChange = function (name, old, value){
                if (_self.$ext.offsetWidth || _self.$ext.offsetHeight) {
                    l.queue(_self.$pHtmlNode, null, layout.root);
                    //apf.layout.activateRules(_self.$ext.parentNode);
                    
                    var p = _self;
                    while (p) {
                        p.unwatch("visible", propChange);
                        p = p.parentNode;
                    }
                    
                    _self.$isWaitingOnDisplay = false;
                }
            }

            this.$isWaitingOnDisplay = true;
            this.watch("visible", propChange);
            
            var p = this.parentNode;
            while(p) {
                p.watch("visible", propChange);
                p = p.parentNode;
            }
            
            return;
        }
        
        
        l.queue(this.$pHtmlNode, null, layout.root);
    };

    function remove(e){
        if (e && (e.$doOnlyAdmin || e.currentTarget != this))
            return;

        if (this.aData) {
            this.aData.remove();
            this.$purgeAlignment();

            if (this.parentNode.pData && !this.parentNode.pData.children.length) {
                l.removeAll(this.parentNode.pData);
                this.parentNode.pData = null;
            }

            if (this.$ext)
                this.$ext.style.display = "none";
        }
    }

    //@todo support inserbefore for align templates
    function reparent(e){ //@todo domnodeinserted should be called before intodoc then use $amlLoaded to check
        if (!this.$amlLoaded || e.currentTarget != this)
            return;

        if (!e.$moveWithinParent && this.aData 
          && this.aData.pHtml != this.$pHtmlNode) {
            this.aData.pHtml = this.$pHtmlNode;
            //this.aData = null;
            this.$enableAlignment();
        }
    }

    //@todo problem with determining when aData.parent | also with weight and minwidth
    //@todo move the prophandlers to inside the constructor
    
    var propHandlers = {
        
        "align" : function(value){
            this.aData.remove();
            this.aData.template   = value;
            this.splitter         = undefined;
            this.aData.edgeMargin = this.edge || 0;
            this.$enableAlignment();
        },
        

        "lean" : function(value){
            this.aData.isBottom = (value || "").indexOf("bottom") > -1;
            this.aData.isRight = (value || "").indexOf("right") > -1;
            this.$purgeAlignment();
        },

        "edge" : function(value){
            this.aData.edgeMargin = Math.max(this.aData.splitter || 0, value != "splitter" ? value : 0);
            this.aData.splitter   = value == "splitter" ? 5 : false;
            this.$purgeAlignment();
        },

        "weight" : function(value){
            this.aData.weight = parseFloat(value);
            this.$purgeAlignment();
        },

        "splitter" : function(value){
            this.aData.splitter = value ? 5 : false;
            this.aData.edgeMargin = Math.max(this.aData.splitter || 0, this.edge || 0);

            if (!value && this.align && this.align.indexOf("-splitter"))
                this.align = this.aData.template = this.align.replace("-splitter", "");

            this.$purgeAlignment();
        },

        "width" : function(value){
            //resetting this property because else we can't reset, when we have
            //a fast JIT we'll do setProperty in onresize
            this.width = null;
            this.aData.fwidth = value || false;

            if (this.aData.fwidth && this.aData.fwidth.indexOf("/") > -1) {
                this.aData.fwidth = eval(this.aData.fwidth);
                if (this.aData.fwidth <= 1)
                    this.aData.fwidth = (this.aData.fwidth * 100) + "%";
            }

            this.$purgeAlignment();
        },

        "height" : function(value){
            //resetting this property because else we can't reset, when we have a
            //fast JIT we'll do setProperty in onresize
            this.height = null;
            this.aData.fheight = String(value) || false;

            if (this.aData.fheight && this.aData.fheight.indexOf("/") > -1) {
                this.aData.fheight = eval(this.aData.fheight);
                if (this.aData.fheight <= 1)
                    this.aData.fheight = (this.aData.fheight * 100) + "%";
            }

            this.$purgeAlignment();
        },

        "minwidth" : function(value){
            this.aData.minwidth = value;
            this.$purgeAlignment();
        },

        "minheight" : function(value){
            this.aData.minheight = value;
            this.$purgeAlignment();
        }
    };

    this.addEventListener("DOMNodeRemovedFromDocument", function(e){
        this.$disableAlignment();
        this.aData = null;
    });
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/guielement.js)SIZE(29801)TIME(1263859264)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__GUIELEMENT__ = 1 << 15;
apf.__VALIDATION__ = 1 << 6;



/**
 * All elements inheriting from this {@link term.baseclass baseclass} are a aml component.
 *
 * @attribute {String} span     the number of columns this element spans. Only used inside a table element.
 */
 // @attribute {String} margin   
/**
 *
 * @constructor
 * @baseclass
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @attribute {mixed} left the left position of this element. Depending
 * on the choosen layout method the unit can be pixels, a percentage or an
 * expression.
 *
 * @attribute {mixed} top the top position of this element. Depending
 * on the choosen layout method the unit can be pixels, a percentage or an
 * expression.
 *
 * @attribute {mixed} right the right position of this element. Depending
 * on the choosen layout method the unit can be pixels, a percentage or an
 * expression.
 *
 * @attribute {mixed} bottom the bottom position of this element. Depending
 * on the choosen layout method the unit can be pixels, a percentage or an
 * expression.
 *
 * @attribute {mixed} width the different between the left edge and the
 * right edge of this element. Depending on the choosen layout method the
 * unit can be pixels, a percentage or an expression.
 * Remarks:
 * When used as a child of a grid element the width can also be set as '*'. 
 * This will fill the rest space.
 *
 * @attribute {mixed} height the different between the top edge and the
 * bottom edge of this element. Depending on the choosen layout method the
 * unit can be pixels, a percentage or an expression.
 * Remarks:
 * When used as a child of a grid element the height can also be set as '*'. 
 * This will fill the rest space.
 *
 * @event resize Fires when the element changes width or height. This event
 * currently only fires when anchoring (left, top, width, height, right, bottom), 
 * alignment (align, vbox, hbox) or the table layout is used.
 * 
 * @event contextmenu Fires when the user requests a context menu. Either
 * using the keyboard or mouse.
 *   bubbles: yes
 *   cancelable:  Prevents the default contextmenu from appearing.
 *   object:
 *   {Number} x         the x coordinate where the contextmenu is requested on.
 *   {Number} y         the y coordinate where the contextmenu is requested on.
 *   {Event}  htmlEvent the html event object that triggered this event from being called.
 * @event focus       Fires when this element receives focus.
 * @event blur        Fires when this element loses focus.
 * @event keydown     Fires when this element has focus and the user presses a key on the keyboard.
 *   cancelable: Prevents the default key action.
 *   bubbles:
 *   object:
 *   {Boolean} ctrlKey   whether the ctrl key was pressed.
 *   {Boolean} shiftKey  whether the shift key was pressed.
 *   {Boolean} altKey    whether the alt key was pressed.
 *   {Number}  keyCode   which key was pressed. This is an ascii number.
 *   {Event}   htmlEvent the html event object that triggered this event from being called.
 */
apf.GuiElement = function(){
    this.$init(true);
};

(function(){
    this.$regbase    = this.$regbase | apf.__GUIELEMENT__;
    
    this.$focussable = apf.KEYBOARD_MOUSE; // Each GUINODE can get the focus by default
    this.visible     = true; //default value;
    
    
    this.$booleanProperties["disable-keyboard"] = true;
    
    this.$booleanProperties["visible"]          = true;
    this.$booleanProperties["focussable"]       = true;
    
    
    this.$supportedProperties.push("draggable", "resizable");
    
    this.$supportedProperties.push(
        "focussable", "zindex", "disabled", "tabindex",
        "disable-keyboard", "contextmenu", "visible", "autosize", 
        "loadaml", "actiontracker", "alias",
        "width", "left", "top", "height"
    );

    this.$setLayout = function(type){
        if (!this.$drawn || !this.$pHtmlNode)
            return false;

        if (this.parentNode) {
            
            if (this.parentNode.localName == "table") {
                this.parentNode.register(this);
                this.$disableCurrentLayout = null;
                return type == "table";
            }
            
            
            
            else if (this.aData || this.align || "vbox|hbox".indexOf(this.parentNode.localName) > -1) {
                if (!this.$alignmentEnabled) {
                    if (this.$disableCurrentLayout)
                        this.$disableCurrentLayout();
                    this.$enableAlignment();
                    this.$disableCurrentLayout = this.$disableAlignment;
                }
                return type == "alignment";
            }
            
        }
        
        
        if (!this.$anchoringEnabled) {
            if (this.$disableCurrentLayout)
                this.$disableCurrentLayout();
            this.$enableAnchoring();
            this.$disableCurrentLayout = this.$disableAnchoring;
        }
        return type == "anchoring";
        
    }

    /**
     * @inherits apf.DelayedRender
     * @inherits apf.Anchoring
     * @inherits apf.Alignment
     */
    this.implement(
        
        apf.Anchoring
        
        
        ,apf.Alignment
        
    );
    
    /**** Convenience functions for gui nodes ****/

    

    /**** Geometry ****/

    /**
     * Sets the different between the left edge and the right edge of this
     * element. Depending on the choosen layout method the unit can be
     * pixels, a percentage or an expression.
     * Call-chaining is supported.
     * @param {Number} value the new width of this element.
     */
    this.setWidth = function(value){
        this.setProperty("width", value, false, true);
        return this;
    };

    /**
     * Sets the different between the top edge and the bottom edge of this
     * element. Depending on the choosen layout method the unit can be
     * pixels, a percentage or an expression.
     * Call-chaining is supported.
     * @param {Number} value the new height of this element.
     */
    this.setHeight = function(value){
        this.setProperty("height", value, false, true);
        return this;
    };

    /**
     * Sets the left position of this element. Depending on the choosen
     * layout method the unit can be pixels, a percentage or an expression.
     * Call-chaining is supported.
     * @param {Number} value the new left position of this element.
     */
    this.setLeft   = function(value){
        this.setProperty("left", value, false, true);
        return this;
    };

    /**
     * Sets the top position of this element. Depending on the choosen
     * layout method the unit can be pixels, a percentage or an expression.
     * Call-chaining is supported.
     * @param {Number} value the new top position of this element.
     */
    this.setTop    = function(value){
        this.setProperty("top", value, false, true);
        return this;
    };

    if (!this.show) {
        /**
         * Makes the elements visible. Call-chaining is supported.
         */
        this.show = function(){
            this.setProperty("visible", true, false, true);
            return this;
        };
    }

    if (!this.hide) {
        /**
         * Makes the elements invisible. Call-chaining is supported.
         */
        this.hide = function(){
            this.setProperty("visible", false, false, true);
            return this;
        };
    }

    /**
     * Retrieves the calculated width in pixels for this element
     */
    this.getWidth  = function(){
        return (this.$ext || {}).offsetWidth;
    };

    /**
     * Retrieves the calculated height in pixels for this element
     */
    this.getHeight = function(){
        return (this.$ext || {}).offsetHeight;
    };

    /**
     * Retrieves the calculated left position in pixels for this element
     * relative to the offsetParent.
     */
    this.getLeft   = function(){
        return (this.$ext || {}).offsetLeft;
    };

    /**
     * Retrieves the calculated top position in pixels for this element
     * relative to the offsetParent.
     */
    this.getTop    = function(){
        return (this.$ext || {}).offsetTop;
    };

    /**** Disabling ****/

    /**
     * Activates the functions of this element. Call-chaining is supported.
     */
    this.enable  = function(){
        this.setProperty("disabled", false, false, true);
        return this;
    };

    /**
     * Deactivates the functions of this element.
     * Call-chaining is supported.
     */
    this.disable = function(){
        this.setProperty("disabled", true, false, true);
        return this;
    };

    /**** z-Index ****/

    /**
     * Moves this element to the lowest z ordered level.
     * Call-chaining is supported.
     */
    this.sendToBack = function(){
        this.setProperty("zindex", 0, false, true);
        return this;
    };

    /**
     * Moves this element to the highest z ordered level.
     * Call-chaining is supported.
     */
    this.bringToFront  = function(){
        this.setProperty("zindex", apf.all.length + 1, false, true);
        return this;
    };

    /**
     * Moves this element one z order level deeper.
     * Call-chaining is supported.
     */
    this.sendBackwards = function(){
        this.setProperty("zindex", this.zindex - 1, false, true);
        return this;
    };

    /**
     * Moves this element one z order level higher.
     * Call-chaining is supported.
     */
    this.bringForward  = function(){
        this.setProperty("zindex", this.zindex + 1, false, true);
        return this;
    };

    
    
    this.hasFocus = function(){}

    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var x = this.$aml;

        // will $pHtmlNode be deprecated soon?
        // check used to be:
        //if (!this.$pHtmlNode && this.parentNode)
        if (this.parentNode && this.parentNode.$int != this.$pHtmlNode)
            this.$pHtmlNode = this.parentNode.$int; //@todo apf3.0 change this in the mutation events

        if (!this.$pHtmlNode) //@todo apf3.0 retry on DOMNodeInserted
            return;
        
        this.$pHtmlDoc  = this.$pHtmlNode.ownerDocument || document;

        if (this.$initSkin)
            this.$initSkin(x);

        if (this.$draw)
            this.$draw();

        if (e.id)
            this.$ext.setAttribute("id", e.id);

        if (typeof this.visible == "undefined")
            this.visible = true;

        
        if (apf.debug && this.$ext && this.$ext.nodeType)
            this.$ext.setAttribute("uniqueId", this.$uniqueId);
        

        
        if (this.$focussable && typeof this.focussable == "undefined")
            apf.GuiElement.propHandlers.focussable.call(this);
        
        
        this.$drawn = true;
    }, true);
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (!this.$pHtmlNode) //@todo apf3.0 retry on DOMInsert or whatever its called
            return;
        
        this.$setLayout();

        if (this.$loadAml)
            this.$loadAml(this.$aml); //@todo replace by event
    });
    
    
    var f;
    this.addEventListener("$event.resize", f = function(c){
        apf.layout.setRules(this.$ext, "resize", "var o = apf.all[" + this.$uniqueId + "];\
            if (o) o.dispatchEvent('resize');", true);

        apf.layout.queue(this.$ext);
        this.removeEventListener("$event.resize", f);
    });
    

    
    this.addEventListener("contextmenu", function(e){
        if (!this.contextmenus) return;
        
        if (this.hasFeature(apf.__DATABINDING__)) {
            var contextmenu;
            var xmlNode = this.hasFeature(apf.__MULTISELECT__)
                ? this.selected
                : this.xmlRoot;

            var i, l, m, isRef, sel, menuId, cm, result;
            for (i = 0, l = this.contextmenus.length; i < l; i++) {
                isRef  = (typeof (cm = this.contextmenus[i]) == "string");
                result = null;
                if (!isRef && cm.match && xmlNode) {//@todo apf3.0 cache this statement
                    result = (cm.cmatch || (cm.cmatch = apf.lm.compile(cm.match, {
                        xpathmode  : 3,
                        injectself : true
                    })))(xmlNode)
                }

                if (isRef || xmlNode && result || !cm.match) { //!xmlNode && 
                    menuId = isRef
                        ? cm
                        : cm.menu

                    if (!self[menuId]) {
                        
                        throw new Error(apf.formatErrorString(0, this,
                            "Showing contextmenu",
                            "Could not find contextmenu by name: '" + menuId + "'"),
                            this.$aml);
                        
                        
                        return;
                    }

                    self[menuId].display(e.x, e.y, null, this, xmlNode);

                    e.returnValue  = false;//htmlEvent.
                    e.cancelBubble = true;
                    break;
                }
            }

            //IE6 compatiblity
            /*
            @todo please test that disabling this is OK
            if (!apf.config.disableRightClick) {
                document.oncontextmenu = function(){
                    document.oncontextmenu = null;
                    e.cancelBubble = true;
                    return false;
                }
            }*/
        }
        else {
            menuId = typeof this.contextmenus[0] == "string"
                ? this.contextmenus[0]
                : this.contextmenus[0].getAttribute("menu")

            if (!self[menuId]) {
                
                throw new Error(apf.formatErrorString(0, this,
                    "Showing contextmenu",
                    "Could not find contextmenu by name: '" + menuId + "'",
                    this.$aml));
                
                
                return;
            }

            self[menuId].display(e.x, e.y, null, this);

            e.returnValue = false;//htmlEvent.
            e.cancelBubble = true;
        }
    });
    
}).call(apf.GuiElement.prototype = new apf.AmlElement());

/**
 * @for apf.amlNode
 * @private
 */
apf.GuiElement.propHandlers = {
    
    /**
     * @attribute {Boolean} focussable whether this element can receive the focus.
     * The focussed element receives keyboard event.s
     */
    "focussable": function(value){
        if (typeof value == "undefined")
            this.focussable = true;

        if (!this.hasFeature(apf.__FOCUSSABLE__)) //@todo should this be on the prototype
            this.implement(apf.Focussable);

        if (this.focussable) {
            apf.window.$addFocus(this, this.tabindex);
        }
        else {
            apf.window.$removeFocus(this);
        }
    },
    

    /**
     * @attribute {Number} zindex the z ordered layer in which this element is
     * drawn.
     */
    "zindex": function(value){
        this.$ext.style.zIndex = value;
    },

    /**
     * @attribute {Boolean} visible whether this element is shown.
     */
    "visible": function(value){
        if (apf.isFalse(value) || typeof value == "undefined") {
            this.$ext.style.display = "none";
            
            if (apf.document.activeElement == this || this.canHaveChildren
              && apf.isChildOf(this, apf.document.activeElement, false)) {
                if (apf.config.allowBlur && this.hasFeature(apf.__FOCUSSABLE__))
                    this.blur();
                else
                    apf.window.moveNext();
            }
            
            this.visible = false;
        }
        else { //if (apf.isTrue(value)) default
            this.$ext.style.display = "block"; //Some form of inheritance detection
            
            if (apf.layout && this.$int) //apf.hasSingleRszEvent)
                apf.layout.forceResize(this.$int);//this.$int
            
            this.visible = true;
        }
    },

    /**
     * @attribute {Boolean} disabled whether this element's functions are active.
     * For elements that can contain other apf.NODE_VISIBLE elements this
     * attribute applies to all it's children.
     */
    "disabled": function(value){
        if (!this.$drawn) {
            var _self     = this;
            this.disabled = false;

            apf.queue.add("disable" + this.$uniqueId, function(e){
                _self.disabled = value;
                apf.GuiElement.propHandlers.disabled.call(_self, value);
            });
            return;
        }

        //For child containers we only disable its children
        if (this.canHaveChildren) {
            //@todo Fix focus here first.. else it will jump whilst looping
            if (value != -1)
                value = this.disabled = apf.isTrue(value);

            var nodes = this.childNodes;
            for (var node, i = 0, l = nodes.length; i < l; i++) {
                node = nodes[i];
                if (node.nodeFunc == apf.NODE_VISIBLE) {
                    if (value && node.disabled != -1)
                        node.$disabled = node.disabled || false;
                    node.setProperty("disabled", value ? -1 : false);
                }
            }

            //this.disabled = undefined;
            if (this.$isWindowContainer)
                return;
        }

        if (value == -1 || value == false) {
            //value = true;
        }
        else if (typeof this.$disabled == "boolean") {
            if (value === null) {
                value = this.$disabled;
                this.$disabled = null;
            }
            else {
                this.$disabled = value || false;
                return;
            }
        }

        if (apf.isTrue(value) || value == -1) {
            this.disabled = false;
            if (apf.document.activeElement == this) {
                apf.window.moveNext(true); //@todo should not include window
                if (apf.document.activeElement == this)
                    this.$blur();
            }

            if (this.hasFeature(apf.__PRESENTATION__))
                this.$setStyleClass(this.$ext, this.$baseCSSname + "Disabled");

            if (this.$disable)
                this.$disable();

            

            this.disabled = value;
        }
        else {
            if (this.hasFeature(apf.__DATABINDING__) && apf.config.autoDisable
              && !(!this.$bindings || this.xmlRoot))
                return false;

            this.disabled = false;

            if (apf.document.activeElement == this)
                this.$focus();

            if (this.hasFeature(apf.__PRESENTATION__))
                this.$setStyleClass(this.$ext, null, [this.$baseCSSname + "Disabled"]);

            if (this.$enable)
                this.$enable();

            
        }
    },

    /**
     * @attribute {Boolean} enables whether this element's functions are active.
     * For elements that can contain other apf.NODE_VISIBLE elements this
     * attribute applies to all it's children.
     */
    "enabled" : function(value){
       this.setProperty("disabled", !value);
    },

    /**
     * @attribute {Boolean} disable-keyboard whether this element receives
     * keyboard input. This allows you to disable keyboard independently from
     * focus handling.
     */
    "disable-keyboard": function(value){
        this.disableKeyboard = apf.isTrue(value);
    },

    
    /**
     * @attribute {String} contextmenu the name of the menu element that will
     * be shown when the user right clicks or uses the context menu keyboard
     * shortcut.
     * Example:
     * <code>
     *  <a:menu id="mnuExample" />
     *
     *  <a:list contextmenu="mnuExample" />
     *  <a:bar contextmenu="mnuExample" />
     * </code>
     */
    "contextmenu": function(value){
        this.contextmenus = [value];
    },
    

    
    /**
     * @attribute {String} actiontracker the name of the actiontracker that
     * is used for this element and it's children. If the actiontracker doesn't
     * exist yet it is created.
     * Example:
     * In this example the list uses a different actiontracker than the two
     * textboxes which determine their actiontracker based on the one that
     * is defined on the bar.
     * <code>
     *  <a:list actiontracker="newAT" />
     *
     *  <a:bar actiontracker="someAT">
     *      <a:textbox />
     *      <a:textbox />
     *  </a:bar>
     * </code>
     */
    "actiontracker": function(value){
        if (!value) {
            this.$at = null;
        }
        else if (value.tagName == "actiontracker") {
            this.$at = value;
        }
        else {
            this.$at = typeof value == "string" && self[value]
              ? apf.nameserver.get("actiontracker", value) || self[value].getActionTracker()
              : apf.setReference(value,
                  apf.nameserver.register("actiontracker",
                      value, new apf.actiontracker()));

            if (!this.$at.name)
                this.$at.name = value;
        }
    },
    
    
    //Load subAML
    /**
     * @attribute {String} aml the {@link term.datainstruction data instruction} 
     * that loads new aml as children of this element.
     */
    "aml": function(value){
        //Clear??
        this.insertMarkup(value);
    },

    /**
     * @attribute {String} sets this aml element to be editable
     * that loads new aml as children of this element.
     */
    
    "editable": function(value){
        this.implement(apf.ContentEditable2);
        this.$propHandlers["editable"].apply(this, arguments);
    },
    
    /**
     * @attribute {String} sets this aml element to be contenteditable
     * that loads new aml as children of this element.
     */
    "contenteditable": function(value) {
        this.implement(apf.ContentEditable);
        if (!this.hasFeature(apf.__VALIDATION__))
            this.implement(apf.Validation);
        this.$propHandlers["contenteditable"].apply(this, arguments);
    }
    
   
    
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/presentation.js)SIZE(19210)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__PRESENTATION__ = 1 << 9;


/**
 * All elements inheriting from this {@link term.baseclass baseclass} have skinning features. A skin is a description
 * of how the element is rendered. In the web browser this is done using html
 * elements and css.
 * Remarks:
 * The skin is set using the skin attribute. The skin of each element can be
 * changed at run time. Other than just changing the look of an element, a skin
 * change can help the user to perceive information in a different way. For 
 * example a list element has a default skin, but can also use the thumbnail 
 * skin to display thumbnails of the {@link term.datanode data nodes}.
 *
 * A skin for an element is always build up out of a standard set of parts.
 * <code>
 *   <a:textbox name="textbox">
 *      <a:alias>
 *          ...
 *      </a:alias>
 *      <a:style><![CDATA[
 *          ...
 *      ]]></a:style>
 *  
 *      <a:presentation>
 *          <a:main>
 *              ...
 *          </a:main>
 *          ...
 *      </a:presentation>
 *   </a:textbox>
 * </code>
 * The alias contains a name that contains alternative names for the skin. The
 * style tags contain the css. The main tag contains the html elements that are
 * created when the component is created. Any other skin items are used to render
 * other elements of the widget. In this reference guide you will find these
 * skin items described on the pages of each widget.
 *
 * @constructor
 * @baseclass
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.5
 */
apf.Presentation = function(){
    this.$init(true);
};

(function(){
    this.$regbase = this.$regbase | apf.__PRESENTATION__;
    
    /**** Properties and Attributes ****/

    this.$supportedProperties.push("skin");
    
    /**
     * @attribute {string} skinset the skinset for
     * this element. If none is specified the skinset attribute
     * of <a:appsettings /> is used. When not defined the default skinset
     * is accessed.
     * Example:
     * <code>
     *  <a:list skinset="perspex" />
     * </code>
     */
    this.$propHandlers["skinset"] =

    /**
     * @attribute {string} skin the name of the skin in the skinset that defines 
     * how this element is rendered. When a skin is changed the full state of the
     * element is kept including it's selection, all the
     * aml attributes, loaded data, focus and disabled state.
     * Example:
     * <code>
     *  <a:list id="lstExample" skin="thumbnails" />
     * </code>
     * Example:
     * <code>
     *  lstExample.setAttribute("skin", "list");
     * </code>
     */
    
    this.$propHandlers["skin"] = function(value){
        if (!this.$amlLoaded) //If we didn't load a skin yet, this will be done when we attach to a parent
            return;

        if (!this.$skinTimer) {
            var _self = this;
            clearTimeout(this.$skinTimer);
            this.$skinTimer = $setTimeout(function(){
                changeSkin.call(_self, value);
                delete _self.$skinTimer;
            });
        }
    }
    

    /**
     * @attribute {String} style the css style applied to the this element. This can be a string containing one or more css rules.
     */
    this.$propHandlers["style"] = function(value){
        if (!this.styleAttrIsObj && this.$amlLoaded)
            this.$ext.setAttribute("style", value);
    }

    var oldClass;
    /**
     * @attribute {String} class the name of the css style class applied to the this element.
     */
    this.$propHandlers["class"] = function(value){
        this.$setStyleClass(this.$ext, value, [oldClass || ""])
    }

    
    this.$forceSkinChange = function(skin, skinset){
        changeSkin.call(this, skin, skinset);
    }

    function changeSkin(skin, skinset){
        clearTimeout(this.$skinTimer);

        //var skinName = (skinset || this.skinset || apf.config.skinset)
        //    + ":" + (skin || this.skin || this.localName);

        
        //Store selection
        if (this.selectable)
            var valueList = this.getSelection();//valueList;
        

        //Store needed state information
        var oExt       = this.$ext,
            oInt       = this.$int,
            beforeNode = oExt.nextSibling,
            id         = this.$ext.getAttribute("id"),
            oldBase    = this.$baseCSSname;

        if (oExt.parentNode)
            oExt.parentNode.removeChild(oExt);

        //@todo changing skin will leak A LOT, should call $destroy here, with some extra magic
        if (this.$destroy)
            this.$destroy(true);

        //Load the new skin
        this.skin = skin;
        this.$loadSkin(skinset ? skinset + ":" + skin : null);

        //Draw
        if (this.$draw)
            this.$draw(true);

        if (id)
            this.$ext.setAttribute("id", id);

        if (beforeNode)
            this.$ext.parentNode.insertBefore(this.$ext, beforeNode);

        //Copy classes
        var i, l, newclasses = [],
               classes    = (oExt.className || "").splitSafe("\s+");
        for (i = 0; i < classes; i++) {
            if (classes[i] && classes[i] != oldBase)
                newclasses.push(classes[i].replace(oldBase, this.$baseCSSname));
        }
        apf.setStyleClass(this.$ext, newclasses.join(" "));

        //Copy events
        var en, ev = apf.skins.events;
        for (i = 0, l = ev.length; i < l; i++) {
            en = ev[i];
            if (typeof oExt[en] == "function" && !this.$ext[en])
                this.$ext[en] = oExt[en];
        }

        //Copy css state (dunno if this is best)
        this.$ext.style.left     = oExt.style.left;
        this.$ext.style.top      = oExt.style.top;
        this.$ext.style.width    = oExt.style.width;
        this.$ext.style.height   = oExt.style.height;
        this.$ext.style.right    = oExt.style.right;
        this.$ext.style.bottom   = oExt.style.bottom;
        this.$ext.style.zIndex   = oExt.style.zIndex;
        this.$ext.style.position = oExt.style.position;
        this.$ext.style.display  = oExt.style.display;

        //Widget specific
        if (this.$loadAml)
            this.$loadAml(this.$aml);
        
        if (this.$int && this.$int != oInt) {
            var node, newNode = this.$int, nodes = oInt.childNodes;
            for (var i = nodes.length - 1; i >= 0; i--) {
                if ((node = nodes[i]).host) {
                    node.host.$pHtmlNode = newNode;
                    if (node.host.$isLeechingSkin)
                        setLeechedSkin.call(node.host);
                }
                newNode.insertBefore(node, newNode.firstChild);
            }
            this.$int.onresize = oInt.onresize;
        }
        
        
        //DragDrop
        if (this.hasFeature(apf.__DRAGDROP__)) {
            if (document.elementFromPointAdd) {
                document.elementFromPointRemove(oExt);
                document.elementFromPointAdd(this.$ext);
            }
        }
        

        //Check disabled state
        if (this.disabled)
            this.$disable(); //@todo apf3.0 test

        //Check focussed state
        if (this.$focussable && apf.document.activeElement == this)
            this.$focus(); //@todo apf3.0 test

        
        //Reload data
        if (this.hasFeature(apf.__DATABINDING__) && this.xmlRoot)
            this.reload();
        else
        
        if (this.value)
            this.$propHandlers["value"].call(this, this.value);

        //Dispatch event
        this.dispatchEvent("$skinchange");

        
        //Set Selection
        if (this.hasFeature(apf.__MULTISELECT__)) {
            if (this.selectable)
                this.selectList(valueList, true);
        }
        

        
        if (this.hasFeature(apf.__ANCHORING__))
            this.$recalcAnchoring();
        

        
        if (this.hasFeature(apf.__ALIGNMENT__)) {
            if (this.aData)
                this.aData.oHtml = this.$ext;

            if (this.pData) {
                this.pData.oHtml = this.$ext;
                this.pData.pHtml = this.$int;

                var nodes = this.pData.childNodes;
                for (i = 0; i < nodes.length; i++)
                    nodes[i].pHtml = this.$int; //Should this be recursive??
            }
        }
        

        
        if (this.draggable && this.$propHandlers["draggable"]) //@todo move these to the event below apf3.0)
            this.$propHandlers["draggable"].call(this, this.draggable);
        if (this.resizable && this.$propHandlers["resizable"])
            this.$propHandlers["resizable"].call(this, this.resizable);
        

        
        apf.layout.forceResize(this.$ext);
        
    };
    

    /**** Private methods ****/

    this.$setStyleClass = apf.setStyleClass;

    function setLeechedSkin(e){
        if (!this.$amlLoaded || e && (e.$moveWithinParent 
          || e.currentTarget != this))
            return;

        this.$setInheritedAttribute(this, "skinset");

        if (this.attributes.getNamedItem("skin"))
            return;

        //e.relatedNode
        var skinName, pNode = this.parentNode, skinNode;
        if ((skinName = this.$canLeechSkin.dataType 
          == apf.STRING ? this.$canLeechSkin : this.localName)
          && pNode.$originalNodes 
          && (skinNode = pNode.$originalNodes[skinName])
          && skinNode.getAttribute("inherit")) {
            var link = skinNode.getAttribute("link");
            this.$isLeechingSkin = true;
            if (link) {
                this.$forceSkinChange(link);
            }
            else {
                var skin = pNode.skinName.split(":");
                this.$forceSkinChange(skin[1], skin[0]);
            }
        }
        else if (this.$isLeechingSkin) {
            delete this.kin;
            this.$forceSkinChange();
        }
    }

    //Skin Inheritance
    //@todo Probably requires some cleanup
    this.$initSkin = function(x){
        if (this.$canLeechSkin) {
            this.addEventListener("DOMNodeInserted", setLeechedSkin);
        }
        
        if (!this.skin)
            this.skin = this.getAttribute("skin");
        
        var skinName, pNode = this.parentNode, skinNode;
        if (this.$canLeechSkin && !this.skin 
          && (skinName = this.$canLeechSkin.dataType == apf.STRING 
            ? this.$canLeechSkin 
            : this.localName)
          && pNode.$originalNodes 
          && (skinNode = pNode.$originalNodes[skinName])
          && skinNode.getAttribute("inherit")) {
            var link = skinNode.getAttribute("link");
            this.$isLeechingSkin = true;
            if (link) {
                this.skin = link;
                this.$loadSkin();
            }
            else {
                this.$loadSkin(pNode.skinName);
            }
        }
        else {
            if (!this.skinset)
                this.skinset = this.getAttribute("skinset");
            
            this.$loadSkin(null, this.$canLeechSkin);
        }
    }

    /**
     * Initializes the skin for this element when none has been set up.
     *
     * @param  {String}  skinName  required  Identifier for the new skin (for example: 'default:List' or 'win').
     * @param  {Boolean} [noError]
     */
    this.$loadSkin = function(skinName, noError){
        //this.skinName || //where should this go and why?
        this.baseSkin = skinName || (this.skinset 
            || this.$setInheritedAttribute("skinset")) 
            + ":" + (this.skin || this.localName);

        clearTimeout(this.$skinTimer);

        if (this.skinName) {
            this.$blur();
            this.$baseCSSname = null;
        }

        this.skinName = this.baseSkin; //Why??
        //this.skinset  = this.skinName.split(":")[0];

        this.$pNodes = {}; //reset the this.$pNodes collection
        this.$originalNodes = apf.skins.getTemplate(this.skinName, true);

        if (!this.$originalNodes) {
            var skin = this.skin;
            if (skin) {
                var skinset = this.skinName.split(":")[0];
                this.baseName = this.skinName = "default:" + skin;
                this.$originalNodes = apf.skins.getTemplate(this.skinName);
                
                if (!this.$originalNodes && skinset != "default") {
                    this.baseName = this.skinName = skinset + ":" + this.localName;
                    this.$originalNodes = apf.skins.getTemplate(this.skinName, true);
                }
            }
            
            if (!this.$originalNodes) {
                this.baseName = this.skinName = "default:" + this.localName;
                this.$originalNodes = apf.skins.getTemplate(this.skinName);
            }

            if (!this.$originalNodes) {
                if (noError) {
                    return (this.baseName = this.skinName = 
                        this.originalNode = null);
                }
                
                throw new Error(apf.formatErrorString(1077, this,
                    "Presentation",
                    "Could not load skin: " + this.baseSkin));
            }
            
            //this.skinset = this.skinName.split(":")[0];
        }

        if (this.$originalNodes)
            apf.skins.setSkinPaths(this.skinName, this);
    };

    this.$getNewContext = function(type, amlNode){
        
        if (type != type.toLowerCase()) {
            throw new Error("Invalid layout node name ('" + type + "'). lowercase required");
        }

        if (!this.$originalNodes[type]) {
            throw new Error(apf.formatErrorString(0, this,
                "Getting new skin item",
                "Missing node in skin description '" + type + "'"));
        }
        

        this.$pNodes[type] = this.$originalNodes[type].cloneNode(true);
    };

    this.$hasLayoutNode = function(type){
        
        if (type != type.toLowerCase()) {
            throw new Error("Invalid layout node name ('" + type + "'). lowercase required");
        }
        

        return this.$originalNodes[type] ? true : false;
    };

    this.$getLayoutNode = function(type, section, htmlNode){
        
        if (type != type.toLowerCase()) {
            throw new Error("Invalid layout node name ('" + type + "'). lowercase required");
        }
        

        var node = this.$pNodes[type] || this.$originalNodes[type];
        if (!node) {
            
            if (!this.$dcache)
                this.$dcache = {}

            if (!this.$dcache[type + "." + this.skinName]) {
                this.$dcache[type + "." + this.skinName] = true;
                apf.console.info("Could not find node '" + type
                                 + "' in '" + this.skinName + "'", "skin");
            }
            
            return false;
        }

        if (!section)
            return apf.getFirstElement(node);

        var textNode = node.selectSingleNode("@" + section);
        if (!textNode)
            return null;

        return (htmlNode
            ? apf.queryNode(textNode.nodeValue, htmlNode)
            : apf.getFirstElement(node).selectSingleNode(textNode.nodeValue));
    };

    this.$getOption = function(type, section){
        type = type.toLowerCase(); //HACK: lowercasing should be solved in the comps.

        //var node = this.$pNodes[type];
        var node = this.$pNodes[type] || this.$originalNodes[type];
        if (!section || !node)
            return node;//apf.getFirstElement(node);
        var option = node.selectSingleNode("@" + section);

        return option ? option.nodeValue : "";
    };

    this.$getExternal = function(tag, pNode, func, aml){
        if (!pNode)
            pNode = this.$pHtmlNode;
        if (!tag)
            tag = "main";
        //if (!aml)
            //aml = this.$aml;

        tag = tag.toLowerCase(); //HACK: make components case-insensitive

        this.$getNewContext(tag);
        var oExt = this.$getLayoutNode(tag);
        
        var node;
        if (node = (aml || this).getAttributeNode("style"))
            oExt.setAttribute("style", node.nodeValue);

        if (node = (aml || this).getAttributeNode("class"))
            this.$setStyleClass(oExt, (oldClass = node.nodeValue));

        if (func)
            func.call(this, oExt);

        oExt = apf.insertHtmlNode(oExt, pNode);
        oExt.host = this;
        if (node = (aml || this).getAttributeNode("bgimage"))
            oExt.style.backgroundImage = "url(" + apf.getAbsolutePath(
                this.mediaPath, node.nodeValue) + ")";

        if (!this.$baseCSSname)
            this.$baseCSSname = oExt.className.trim().split(" ")[0];

        return oExt;
    };

    /**** Focus ****/
    this.$focus = function(){
        if (!this.$ext)
            return;

        this.$setStyleClass(this.oFocus || this.$ext, this.$baseCSSname + "Focus");
    };

    this.$blur = function(){
        
        if (this.renaming)
            this.stopRename(null, true);
        

        if (!this.$ext)
            return;

        this.$setStyleClass(this.oFocus || this.$ext, "", [this.$baseCSSname + "Focus"]);
    };

    this.$fixScrollBug = function(){
        if (this.$int != this.$ext)
            this.oFocus = this.$int;
        else {
            this.oFocus =
            this.$int   =
                this.$ext.appendChild(document.createElement("div"));

            this.$int.style.height = "100%";
            this.$int.className = "focusbug"
        }
    };

    /**** Caching ****/
    /*
    this.$setClearMessage    = function(msg){};
    this.$updateClearMessage = function(){}
    this.$removeClearMessage = function(){};*/
}).call(apf.Presentation.prototype = new apf.GuiElement());

apf.config.$inheritProperties["skinset"] = 1;




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/validation.js)SIZE(27488)TIME(1264550463)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__VALIDATION__ = 1 << 6;



//if checkequal then notnull = true
apf.validator = {
    macro : {
        
        "datatype"  : "apf.xsd.matchType(value, '",
        "datatype_" : "')",
        

        //var temp
        "pattern"     : "value.match(",
        "pattern_"    : ")",
        "custom"      : "(",
        "custom_"     : ")",
        "min"         : "parseInt(value) >= ",
        "max"         : "parseInt(value) <= ",
        "maxlength"   : "value.toString().length <= ",
        "minlength"   : "value.toString().length >= ",
        "notnull"     : "value.toString().length > 0",
        "checkequal"  : "!(temp = ",
        "checkequal_" : ").isValid() || temp.getValue() == value"
    },
    
    compile : function(options){
        var m = this.macro, s = ["var temp, valid = true; \
            if (!validityState) \
                validityState = new apf.validator.validityState(); "];

        if (options.required) {
            s.push("if (checkRequired && (!value || value.toString().trim().length == 0)) {\
                validityState.$reset();\
                validityState.valueMissing = true;\
                valid = false;\
            }")
        }
        
        s.push("validityState.$reset();\
            if (value) {");
        
        for (prop in options) {
            if (!m[prop]) continue;
            s.push("if (!(", m[prop], options[prop], m[prop + "_"] || "", ")){\
                validityState.$set('", prop, "');\
                valid = false;\
            }");
        }

        s.push("};validityState.valid = valid; return validityState;");
        return new Function('value', 'checkRequired', 'validityState', s.join(""));
    }
}

/**
 * Object containing information about the validation state. It contains
 * properties that specify whether a certain validation was passed.
 * Remarks:
 * This is part of {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#validitystatethe HTML 5 specification}.
 */
apf.validator.validityState = function(){
    this.valueMissing    = false,
    this.typeMismatch    = false,
    this.patternMismatch = false,
    this.tooLong         = false,
    this.rangeUnderflow  = false,
    this.rangeOverflow   = false,
    this.stepMismatch    = false,
    this.customError     = false,
    this.valid           = true,

    this.$reset = function(){
        for (var prop in this) {
            if (prop.substr(0,1) == "$") 
                continue;
            this[prop] = false;
        }
        this.valid = true;
    },

    this.$set = function(type) {
        switch (type) {
            case "min"         : this.rangeUnderflow  = true; break;
            case "max"         : this.rangeOverflow   = true; break;
            case "minlength"   : this.tooShort        = true; break;
            case "maxlength"   : this.tooLong         = true; break;
            case "pattern"     : this.patternMismatch = true; break;
            case "datatype"    : this.typeMismatch    = true; break;
            case "notnull"     : this.typeMismatch    = true; break;
            case "checkequal"  : this.typeMismatch    = true; break;
        }
    }
};

/**
 * All elements inheriting from this {@link term.baseclass baseclass} have validation support.
 * Example:
 * <code>
 *  <a:bar validgroup="vgExample">
 *      <a:label>Number</a:label>
 *      <a:textbox required="true" min="3" max="10" 
 *        invalidmsg="Invalid Entry;Please enter a number between 3 and 10" />
 *      <a:label>Name</a:label>
 *      <a:textbox required="true" minlength="3" 
 *        invalidmsg="Invalid Entry;Please enter your name" />
 *      <a:label>Message</a:label>
 *      <a:textarea required="true" 
 *        invalidmsg="Invalid Message;Please enter a message!" />
 *
 *      <a:button onclick="if(vgExample.isValid()) alert('valid!')">
 *          Validate
 *      </a:button>
 *  </a:bar>
 * </code>
 *
 * @event invalid    Fires when this component goes into an invalid state.
 *
 * @constructor
 * @baseclass
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.5
 */
apf.Validation = function(){
    this.$regbase = this.$regbase | apf.__VALIDATION__;

    /**
     * Checks if this element's value is valid.
     *
     * @param  {Boolean} [checkRequired] whether this check also adheres to the 'required' ruled.
     * @return  {Boolean} specifying whether the value is valid
     * @see  baseclass.validationgroup
     * @see  element.submitform
     */
    this.isValid = function(checkRequired){
        if (!this.$vOptions)
            return true;
        
        (this.$vOptions.isValid || (this.$vOptions.isValid
          = apf.validator.compile(this.$vOptions))).call(this,
            typeof this.getValue == "function" ? this.getValue(null, true) : null, 
            checkRequired, this.validityState || 
            (this.validityState = new apf.validator.validityState()));
        
        var valid = this.validityState.valid;
        
        
        
        if (!valid)
            this.dispatchEvent("invalid", this.validityState);
            
        return valid;
    };

    /**
     * @private
     */
    this.setCustomValidity = function(message){
        //do stuff
    }

    /**
     * @private
     * @todo This method should also scroll the element into view
     */
    this.showMe = function(){
        var p = this.parentNode;
        while (p) {
            if (p.show)
                p.show();
            p = p.parentNode;
        }
    };

    /**
     * Puts this element in the error state, optionally showing the
     * error box if this element's is invalid.
     *
     * @param  {Boolean} [ignoreReq]  whether this element required check is turned on.
     * @param  {Boolean} [nosetError] whether the error box is displayed if this component does not validate.
     * @param  {Boolean} [force]      whether this element in the error state and don't check if the element's value is invalid.
     * @return  {Boolean}  boolean specifying whether the value is valid
     * @see  object.validationgroup
     * @see  element.submitform
     * @method
     */
    
    this.checkValidity =
    
    
    /**
     * Puts this element in the error state, optionally showing the
     * error box if this element is invalid.
     *
     * @param  {Boolean} [ignoreReq]  whether this element required check is turned on.
     * @param  {Boolean} [nosetError] whether the error box is displayed if this component does not validate.
     * @param  {Boolean} [force]      whether this element in the error state and don't check if the element's value is invalid.
     * @return  {Boolean}  boolean specifying whether the value is valid
     * @see  object.validationgroup
     * @see  element.submitform
     * @method
     */
    this.validate = function(ignoreReq, nosetError, force){
        //if (!this.$validgroup) return this.isValid();

        if (force || !this.isValid(!ignoreReq) && !nosetError) {
            this.setError();
            return false;
        }
        else {
            this.clearError();
            return true;
        }
    };

    /**
     *    @private
     */
    this.setError = function(value){
        if (!this.$validgroup)
            this.$propHandlers["validgroup"].call(this, "vg" + this.parentNode.$uniqueId);

        var errBox = this.$validgroup.getErrorBox(this);

        if (!this.$validgroup.allowMultipleErrors)
            this.$validgroup.hideAllErrors();

        errBox.setMessage(this.invalidmsg);
        
        apf.setStyleClass(this.$ext, this.$baseCSSname + "Error");
        this.showMe(); //@todo scroll refHtml into view

        errBox.display(this);
        
        
        if (this.hasFeature(apf.__MULTISELECT__) && this.validityState.$errorXml)
            this.select(this.validityState.$errorXml);
        
        
        if (apf.document.activeElement && apf.document.activeElement != this)
            this.focus(null, {mouse:true}); //arguable...
    };

    /**
     *    @private
     */
    this.clearError = function(value){
        if (this.$setStyleClass)
            this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Error"]);

        if (this.$validgroup) {
            var errBox = this.$validgroup.getErrorBox(null, true);
            if (!errBox || errBox.host != this)
                return;

            errBox.hide();
        }
    };

    this.addEventListener("DOMNodeRemovedFromDocument", function(e){
        if (this.$validgroup)
            this.$validgroup.unregister(this);
    });

    /**
     *
     * @attribute  {Boolean}  required     whether a valid value for this element is required.
     * @attribute  {RegExp}   pattern      the pattern tested against the value of this element to determine it's validity.
     * @attribute  {String}   datatype     the datatype that the value of this element should adhere to. This can be any 
     * of a set of predefined types, or a simple type created by an XML Schema definition.
     *   Possible values:
     *   {String} xsd:dateTime
     *   {String} xsd:time
     *   {String} xsd:date
     *   {String} xsd:gYearMonth
     *   {String} xsd:gYear
     *   {String} xsd:gMonthDay
     *   {String} xsd:gDay
     *   {String} xsd:gMonth
     *   {String} xsd:string
     *   {String} xsd:boolean
     *   {String} xsd:base64Binary
     *   {String} xsd:hexBinary
     *   {String} xsd:float
     *   {String} xsd:decimal
     *   {String} xsd:double
     *   {String} xsd:anyURI
     *   {String} xsd:integer
     *   {String} xsd:nonPositiveInteger
     *   {String} xsd:negativeInteger
     *   {String} xsd:long
     *   {String} xsd:int
     *   {String} xsd:short
     *   {String} xsd:byte
     *   {String} xsd:nonNegativeInteger
     *   {String} xsd:unsignedLong
     *   {String} xsd:unsignedInt
     *   {String} xsd:unsignedShort
     *   {String} xsd:unsignedByte
     *   {String} xsd:positiveInteger
     *   {String} apf:url
     *   {String} apf:website
     *   {String} apf:email
     *   {String} apf:creditcard
     *   {String} apf:expdate
     *   {String} apf:wechars
     *   {String} apf:phonenumber
     *   {String} apf:faxnumber
     *   {String} apf:mobile
     * @attribute  {Integer}  min          the minimal value for which the value of this element is valid.
     * @attribute  {Integer}  max          the maximum value for which the value of this element is valid.
     * @attribute  {Integer}  minlength    the minimal length allowed for the value of this element.
     * @attribute  {Integer}  maxlength    the maximum length allowed for the value of this element.
     * @attribute  {Boolean}  notnull      whether the value is filled. Same as {@link baseclass.validation.attribute.required} but this rule is checked realtime when the element looses the focus, instead of at specific request (for instance when leaving a form page).
     * @attribute  {String}   checkequal   the id of the element to check if it has the same value as this element.
     * @attribute  {String}   invalidmsg   the message displayed when this element has an invalid value. Use a ; character to seperate the title from the message.
     * @attribute  {String}   validgroup   the identifier for a group of items to be validated at the same time. This identifier can be new. It is inherited from a AML node upwards.
     * @attribute  {String}   validtest    the instruction on how to test for success. This attribute is generally used to check the value on the server.
     * Example:
     * This example shows how to check the username on the server. In this case
     * comm.loginCheck is an async rpc function that checks the availability of the
     * username. If it exists it will return 0, otherwise 1. The value variable
     * contains the current value of the element (in this case the textbox). It
     * can be used as a convenience variable.
     * <pre class="code">
     *  <a:label>Username</a:label>
     *  <a:textbox
     *    validtest  = "{comm.loginCheck(value) == 1}"
     *    pattern    = "/^[a-zA-Z0-9_\-. ]{3,20}$/"
     *    invalidmsg = "Invalid username;Please enter a valid username." />
     * </pre>
     */
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        //this.addEventListener(this.hasFeature(apf.__MULTISELECT__) ? "onafterselect" : "onafterchange", onafterchange);
        /* Temp disabled, because I don't understand it (RLD)
        this.addEventListener("beforechange", function(){
            if (this.xmlRoot && apf.getBoundValue(this) === this.getValue())
                return false;
        });*/
        
        // validgroup
        if (!this.validgroup)
            this.$setInheritedAttribute("validgroup");
    });
    
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        pattern : 1,
        validtest : 3
    }, this.$attrExcludePropBind);

    this.$booleanProperties["required"] = true;
    this.$supportedProperties.push("validgroup", "required", "datatype",
        "pattern", "min", "max", "maxlength", "minlength", "validtest",
        "notnull", "checkequal", "invalidmsg", "requiredmsg");

    this.$fValidate = function(){
        if (this.contenteditable)
            return;
        
        if (!this.$validgroup)
            this.validate(true);
        else {
             var errBox = this.$validgroup.getErrorBox(this);
             if (!errBox.visible || errBox.host != this)
                this.validate(true);
        }
    };
    this.addEventListener("blur", this.$fValidate);
    
    this.$propHandlers["validgroup"] = function(value){
        if (value) {
            var vgroup;
            if (typeof value != "string") {
                this.$validgroup = value.name;
                vgroup = value;
            }
            else {
                vgroup = apf.nameserver.get("validgroup", value);
            }

            this.$validgroup = vgroup || new apf.ValidationGroup(value);
            this.$validgroup.register(this);
            /*
                @todo What about children, when created after start
                See button login action
            */
        }
        else {
            this.$validgroup.unregister(this);
            this.$validgroup = null;
        }
    };
    
    this.$propHandlers["pattern"]    = function(value, prop){
        if (value.substr(0, 1) != "/")
            value = "/" + value + "/";

        (this.$vOptions || (this.$vOptions = {}))[prop] = value;
        delete this.$vOptions.isValid;
    };
    
    
    this.$propHandlers["datatype"]   =
    
    this.$propHandlers["required"]   = 
    this.$propHandlers["custom"]     = 
    this.$propHandlers["min"]        = 
    this.$propHandlers["max"]        = 
    this.$propHandlers["maxlength"]  = 
    this.$propHandlers["minlength"]  = 
    this.$propHandlers["notnull"]    = 
    this.$propHandlers["checkequal"] = function(value, prop){
        (this.$vOptions || (this.$vOptions = {}))[prop] = value;
        delete this.$vOptions.isValid;
    };
    
    //@todo rewrite this for apf3.0
    this.$propHandlers["validtest"] = function(value){
        var _self = this, rvCache = {};
        /**
         * Removes the validation cache created by the validtest rule.
         */
        this.removeValidationCache = function(){
            rvCache = {};
        }
        
        this.$checkRemoteValidation = function(){
            var value = this.getValue();
            if(typeof rvCache[value] == "boolean") return rvCache[value];
            if(rvCache[value] == -1) return true;
            rvCache[value] = -1;

            apf.getData(this.validtest, {
               xmlNode : this.xmlRoot,
               value   : this.getValue(),
               callback : function(data, state, extra){
                  if (state != apf.SUCCESS) {
                      if (state == apf.TIMEOUT && extra.retries < apf.maxHttpRetries)
                          return extra.tpModule.retry(extra.id);
                      else {
                          var commError = new Error(apf.formatErrorString(0, _self, 
                            "Validating entry at remote source", 
                            "Communication error: \n\n" + extra.message));

                          if (_self.dispatchEvent("error", apf.extend({
                            error : commError, 
                            state : status
                          }, extra)) !== false)
                              throw commError;
                          return;
                      }
                  }

                  rvCache[value] = apf.isTrue(data);//instr[1] ? data == instr[1] : apf.isTrue(data);
                  
                  if(!rvCache[value]){
                    if (!_self.hasFocus())
                        _self.setError();
                  }
                  else _self.clearError();
              }
            });
            
            return true;
        };
        
        (this.$vOptions || (this.$vOptions = {})).custom = "apf.lookup(" + this.$uniqueId + ").$checkRemoteValidation()";
        delete this.$vOptions.isValid;
    };
};


apf.GuiElement.propHandlers["datatype"]   =

apf.GuiElement.propHandlers["required"]   = 
apf.GuiElement.propHandlers["pattern"]    = 
apf.GuiElement.propHandlers["min"]        = 
apf.GuiElement.propHandlers["max"]        = 
apf.GuiElement.propHandlers["maxlength"]  = 
apf.GuiElement.propHandlers["minlength"]  = 
apf.GuiElement.propHandlers["notnull"]    = 
apf.GuiElement.propHandlers["checkequal"] = 
apf.GuiElement.propHandlers["validtest"]  = function(value, prop){
    this.implement(apf.Validation);
    this.$propHandlers[prop].call(this, value, prop);
}

/**
 * Object allowing for a set of AML elements to be validated, an element that 
 * is not valid shows the errorbox.
 * Example:
 * <code>
 *  <a:bar validgroup="vgForm">
 *      <a:label>Phone number</a:label>
 *      <a:textbox id="txtPhone"
 *        required   = "true"
 *        pattern    = "(\d{3}) \d{4} \d{4}"
 *        invalidmsg = "Incorrect phone number entered" />
 *
 *      <a:label>Password</a:label>
 *      <a:textbox
 *        required   = "true"
 *        mask       = "password"
 *        minlength  = "4"
 *        invalidmsg = "Please enter a password of at least four characters" />
 *  </a:bar>
 * </code>
 *
 * To check if the element has valid information entered, leaving the textbox
 * (focussing another element) will trigger a check. Programmatically a check
 * can be done using the following code:
 * <code>
 *  txtPhone.validate();
 *
 *  //Or use the html5 syntax
 *  txtPhone.checkValidity();
 * </code>
 *
 * To check for the entire group of elements use the validation group. For only
 * the first non-valid element the errorbox is shown. That element also receives
 * focus.
 * <code>
 *  vgForm.validate();
 * </code>
 *
 * @event validation Fires when the validation group isn't validated.
 *
 * @inherits apf.Class
 * @constructor
 * @default_private
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.9
 */
apf.ValidationGroup = function(name){
    this.$init();
    
    this.childNodes = [];
    
    if (name)
        apf.setReference(name, this);
    
    this.name = name || "validgroup" + this.$uniqueId;
    apf.nameserver.register("validgroup", this.name, this);
};

(function(){
    /**
     * When set to true, only visible elements are validated. Default is false.
     * @type Boolean
     */
    this.validateVisibleOnly = false;
    
    /**
     * When set to true, validation doesn't stop at the first invalid element. Default is false.
     * @type Boolean
     */
    this.allowMultipleErrors = false;

    /**
     * Adds a aml element to this validation group.
     */
    this.register   = function(o){ 
        if (o.hasFeature(apf.__VALIDATION__)) 
            this.childNodes.push(o);
    };
    
    /**
     * Removes a aml element from this validation group.
     */
    this.unregister = function(o){
        this.childNodes.remove(o); 
    };

    /**
     * Returns a string representation of this object.
     */
    this.toString = function(){
        return "[APF Validation Group]";
    };

    //Shared among all validationgroups
    var errbox;
    /**
     * Retrieves {@link element.errorbox} used for a specified element.
     *
     * @param  {AmlNode}  o  required  AmlNode specifying the element for which the Errorbox should be found. If none is found, an Errorbox is created. Use the {@link object.validationgroup.property.allowMultipleErrors} to influence when Errorboxes are created.
     * @param  {Boolean}  no_create    Boolean that specifies whether new Errorbox may be created when it doesn't exist already
     * @return  {Errorbox}  the found or created Errorbox;
     */
    this.getErrorBox = function(o, no_create){
        if (this.allowMultipleErrors || !errbox && !no_create) {
            errbox            = new apf.errorbox();
            errbox.$pHtmlNode = o.$ext.parentNode;
            errbox.skinset    = apf.getInheritedAttribute(o.parentNode, "skinset"); //@todo use skinset here. Has to be set in presentation
            errbox.dispatchEvent("DOMNodeInsertedIntoDocument");
        }
        return errbox;
    };

    /**
     * Hide all Errorboxes for the elements using this element as their validation group.
     *
     */
    this.hideAllErrors = function(){
        if (errbox && errbox.host)
            errbox.host.clearError();
    };

    function checkValidChildren(oParent, ignoreReq, nosetError){
        var found;
        //Per Element
        for (var v, i = 0; i < oParent.childNodes.length; i++) {
            var oEl = oParent.childNodes[i];

            if (!oEl)
                continue;
            if (!oEl.disabled
              && (!this.validateVisibleOnly && oEl.visible || !oEl.$ext || oEl.$ext.offsetHeight)
              && (oEl.hasFeature(apf.__VALIDATION__) && oEl.isValid && !oEl.isValid(!ignoreReq))) {
                //|| !ignoreReq && oEl.required && (!(v = oEl.getValue()) || new String(v).trim().length == 0)
                
                if (!nosetError) {
                    if (!found) {
                        oEl.validate(true, null, true);
                        found = true;
                        if (!this.allowMultipleErrors)
                            return true; //Added (again)
                    }
                    else if (oEl.errBox && oEl.errBox.host == oEl)
                        oEl.errBox.hide();
                }
                else if (!this.allowMultipleErrors)
                    return true;
            }
            if (oEl.canHaveChildren && oEl.childNodes.length) {
                found = checkValidChildren.call(this, oEl, ignoreReq, nosetError) || found;
                if (found && !this.allowMultipleErrors)
                    return true; //Added (again)
            }
        }
        return found;
    }

    /**
     * Checks if (part of) the set of element's registered to this element are
     * valid. When an element is found with an invalid value the error state can
     * be set for that element.
     *
     * @param  {Boolean}    [ignoreReq]  whether to adhere to the 'required' check.
     * @param  {Boolean}    [nosetError  whether to not set the error state of the element with an invalid value
     * @param  {AMLElement} [page]           the page for which the children will be checked. When not specified all elements of this validation group will be checked.
     * @return  {Boolean}  specifying whether the checked elements are valid.
     * @method isValid, validate, checkValidity
     */
    
    this.checkValidity =
    
    
    /**
     * Checks if (part of) the set of element's registered to this element are
     * valid. When an element is found with an invalid value the error state can
     * be set for that element.
     *
     * @param  {Boolean}    [ignoreReq]  whether to adhere to the 'required' check.
     * @param  {Boolean}    [nosetError  whether to not set the error state of the element with an invalid value
     * @param  {AMLElement} [page]           the page for which the children will be checked. When not specified all elements of this validation group will be checked.
     * @return  {Boolean}  specifying whether the checked elements are valid.
     * @method isValid, validate, checkValidity
     */
    this.validate =
    
    /**
     * Checks if (part of) the set of element's registered to this element are
     * valid. When an element is found with an invalid value the error state can
     * be set for that element.
     *
     * @param  {Boolean}    [ignoreReq]  whether to adhere to the 'required' check.
     * @param  {Boolean}    [nosetError  whether to not set the error state of the element with an invalid value
     * @param  {AMLElement} [page]           the page for which the children will be checked. When not specified all elements of this validation group will be checked.
     * @return  {Boolean}  specifying whether the checked elements are valid.
     * @method isValid, validate, checkValidity
     */
    this.isValid = function(ignoreReq, nosetError, page){
        var found = checkValidChildren.call(this, page || this, ignoreReq,
            nosetError);

        if (page) {
            
            try {
            
                if (page.validation && !eval(page.validation)) {
                    alert(page.invalidmsg);
                    found = true;
                }
            
            }
            catch(e) {
                throw new Error(apf.formatErrorString(0, this,
                    "Validating Page",
                    "Error in javascript validation string of page: '"
                    + page.validation + "'", page.$aml));
            }
            
        }

        //Global Rules
        //
        //if (!found)
            //found = this.dispatchEvent("validation");

        return !found;
    };
}).call(apf.ValidationGroup.prototype = new apf.Class());

apf.config.$inheritProperties["validgroup"] = 1;




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/databinding.js)SIZE(52710)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__DATABINDING__ = 1 << 1;



/**
 * Baseclass adding data binding features to this element. Databinding takes
 * care of automatically going from data to representation and establishing a
 * permanent link between the two. In this way data that is changed will
 * change the representation as well. Furthermore, actions that are executed on
 * the representation will change the underlying data.
 * Example:
 * <code>
 *  <a:list>
 *      <a:model>
 *          <data>
 *              <item icon="ajax_org.gif">Item 1</item>
 *              <item icon="ajax_org.gif">Item 2</item>
 *          </data>
 *      </a:model>
 *      <a:bindings>
 *          <a:icon match="[@icon]" />
 *          <a:caption match="[text()]" />
 *          <a:each match="[item]" />
 *      </a:bindings>
 *  </a:list>
 * </code>
 *
 * @event error             Fires when a communication error has occured while
 *                          making a request for this element.
 *   cancelable: Prevents the error from being thrown.
 *   bubbles:
 *   object:
 *   {Error}          error     the error object that is thrown when the event
 *                              callback doesn't return false.
 *   {Number}         state     the state of the call
 *     cancellable: Prevents the error from being thrown.
 *     Possible values:
 *     apf.SUCCESS  the request was successfull
 *     apf.TIMEOUT  the request has timed out.
 *     apf.ERROR    an error has occurred while making the request.
 *     apf.OFFLINE  the request was made while the application was offline.
 *   {mixed}          userdata  data that the caller wanted to be available in
 *                              the callback of the http request.
 *   {XMLHttpRequest} http      the object that executed the actual http request.
 *   {String}         url       the url that was requested.
 *   {Http}           tpModule  the teleport module that is making the request.
 *   {Number}         id        the id of the request.
 *   {String}         message   the error message.
 * @event beforeretrieve    Fires before a request is made to retrieve data.
 *   cancelable: Prevents the data from being retrieved.
 * @event afterretrieve     Fires when the request to retrieve data returns both
 *                          on success and failure.
 * @event receive           Fires when data is successfully retrieved
 *   object:
 *   {String} data  the retrieved data
 *
 * @constructor
 * @inherits apf.Presentation
 * @baseclass
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 * @default_private
 */
apf.DataBinding = function(){
    this.$init(true);
    
    this.$loadqueue = 
    this.$dbTimer   = null;
    this.$regbase   = this.$regbase | apf.__DATABINDING__;
    this.$mainBind  = "value";
    
    this.$bindings     = 
    this.$cbindings    = 
    this.$attrBindings = false;

    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        model     : 1,
        taverse   : 1,
        valuerule : 1
    }, this.$attrExcludePropBind);

    /**** Public Methods ****/

    /**
     * Sets a value of an XMLNode based on an xpath statement executed on the data of this model.
     *
     * @param  {String}  xpath  the xpath used to select a XMLNode.
     * @param  {String}  value  the value to set.
     * @return  {XMLNode}  the changed XMLNode
     */
    this.setQueryValue = function(xpath, value, type){
        var node = apf.createNodeFromXpath(this[type || 'xmlRoot'], xpath);
        if (!node)
            return null;

        apf.setNodeValue(node, value, true);
        //apf.xmldb.setTextNode(node, value);
        return node;
    };

    /**
     * Queries the bound data for a string value
     *
     * @param {String} xpath  the xpath statement which queries on the data this element is bound on.
     * @param {String} type   the node that is used as the context node for the query.
     * Possible values:
     * selected     the selected data anode of this element.
     * xmlRoot      the root data node that this element is bound on.
     * indicator    the data node that is highlighted for keyboard navigation.
     * @return {String} value of the selected XML Node
     * @todo
     *  lstRev.query('revision/text()', 'selected');
     *  lstRev.query('revision/text()', 'xmlRoot');
     *  lstRev.query('revision/text()', 'indicator');
     */
    this.queryValue = function(xpath, type){
        return apf.queryValue(this[type || 'xmlRoot'], xpath );
    };
	/**
     * Queries the bound data for an array of string values
     *
     * @param {String} xpath the xpath statement which queries on the data this element is bound on.
     * @param {String} type   the node that is used as the context node for the query.
     * Possible values:
     * selected     the selected data anode of this element.
     * xmlRoot      the root data node that this element is bound on.
     * indicator    the data node that is highlighted for keyboard navigation.
     * @return {String} value of the selected XML Node
     */
    this.queryValues = function(xpath, type){
        return apf.queryValues(this[type || 'xmlRoot'], xpath );
    };
	
    /**
     * Executes an xpath statement on the data of this model
     *
     * @param  {String}   xpath    the xpath used to select the XMLNode(s).
     * @param {String} type   the node that is used as the context node for the query.
     * Possible values:
     * selected     the selected data anode of this element.
     * xmlRoot      the root data node that this element is bound on.
     * indicator    the data node that is highlighted for keyboard navigation.
     * @return  {variant}  XMLNode or NodeList with the result of the selection
     */
    this.queryNode = function(xpath, type){
        var n = this[type||'xmlRoot'];
		return n ? n.selectSingleNode(xpath) : null;
    };

    /**
     * Executes an xpath statement on the data of this model
     *
     * @param  {String}   xpath    the xpath used to select the XMLNode(s).
     * @param {String} type   the node that is used as the context node for the query.
     * Possible values:
     * selected     the selected data anode of this element.
     * xmlRoot      the root data node that this element is bound on.
     * indicator    the data node that is highlighted for keyboard navigation.
     * @return  {variant}  XMLNode or NodeList with the result of the selection
     */
    this.queryNodes = function(xpath, type){
        var n = this[type||'xmlRoot'];
		return n ? n.selectNodes(xpath) : [];
    };
	
    this.$checkLoadQueue = function(){
        // Load from queued load request
        if (this.$loadqueue) {
            this.xmlRoot = null;
            var q = this.load(this.$loadqueue[0], {cacheId: this.$loadqueue[1]});
            if (!q || q.dataType != apf.ARRAY || q != this.$loadqueue)
                this.$loadqueue = null;
        }
    };
    
    //setProp
    this.$execProperty = function(prop, xmlNode){
        var attr = this.$attrBindings[prop];
        
        
        apf.$lm_has_lang = false;
        
        
        
            if (attr.cvalue.asyncs) { //if async
                var _self = this;
                return attr.cvalue.call(this, xmlNode, function(value){
                    _self.setProperty(prop, value, true);
                    
                    
                    //@todo apf3.0
                    if (apf.$lm_has_lang)
                        apf.language.addProperty(this, prop, attr.cvalue); //@todo should auto remove
                    
                
                }); 
            }
            else {
                var value = attr.cvalue.call(this, xmlNode);
            }
        
        
        this.setProperty(prop, value, true);
        
        
        //@todo apf3.0
        if (apf.$lm_has_lang)
            apf.language.addProperty(this, prop, attr.cvalue); //@todo should auto remove
        
    };
    
    //@todo apf3.0 contentEditable support
    this.$applyBindRule = function(name, xmlNode, defaultValue, callback){
        var handler = this.$attrBindings[name] 
          && this.$attrBindings[name].cvalue || this.$cbindings[name];

        return handler ? handler.call(this, xmlNode, callback) : defaultValue || "";
    };
    
    this.$hasBindRule = function(name){
        return this.$attrBindings[name] || this.$bindings 
          && this.$bindings[name];
    };
    
    this.$getBindRule = function(name, xmlNode){
        return this.$attrBindings[name] || this.$bindings 
          && this.$bindings.getRule(name, xmlNode);
    };
    
    var ruleIsMatch = {"drag":1,"drop":1,"dragcopy":1}
    this.$getDataNode = function(name, xmlNode, createNode, ruleList, multiple){
        var node, rule = this.$attrBindings[name];
        if (rule) { //@todo apf3.0 find out why drag and drop rules are already compiled here
            if (rule.cvalue.type != 3) //@todo warn here?
                return false;
            
            var func = rule.cvalue2 || rule.compile("value", {
                xpathmode  : multiple ? 4 : 3,
                parsecode  : 1,
                injectself : ruleIsMatch[name]
            });
            if (func && (node = func(xmlNode, createNode))) {
                if (ruleList)
                    ruleList.push(rule);

                return node;
            }
            
            return false;
        }
        
        return this.$bindings 
           && this.$bindings.getDataNode(name, xmlNode, createNode, ruleList, multiple);
    };
    
    /**
     * Sets the model of the specified element
     *
     * @param  {Model}  The model this element is going to connect to.
     * 
     */
    
    this.setModel = function(model){
        this.setAttribute("model", model, false, true);
    };
    
    
    /**
     * Gets the model to which this element is connected.
     * This is the model which acts as a datasource for this element.
     *
     * @param {Boolean} doRecur whether the model should be searched recursively up the data tree.
     * @returns  {Model}  The model this element is connected to.
     * @see  element.smartbinding
     */
    this.getModel = function(doRecur){
        if (doRecur && !this.$model)
            return this.dataParent ? this.dataParent.parent.getModel(true) : null;

        return this.$model;
    };
    
    /**
     * Reloads the data in this element.
     *
     */
    this.reload = function(){
        this.load(this.xmlRoot, {cacheId: this.cacheId, force: true});
    };

    /**
     * Loads data in to this element using binding rules to transform the
     * data in to a presentation.
     * Example:
     * <code>
     *  <a:list id="lstExample">
     *      <a:bindings>
     *          <a:caption match="[text()]" />
     *          <a:icon match="[@icon]" />
     *          <a:each match="[image]" />
     *      </a:bindings>
     *  </a:list>
     * 
     *  <a:script>
     *      lstExample.load('<images>\
     *          <image icon="icoTest.gif">image 1</image>\
     *          <image icon="icoTest.gif">image 2</image>\
     *          <image icon="icoTest.gif">image 3</image>\
     *          </images>');
     *  </a:script>
     * </code>
     *
     * @param {mixed}  [xmlNode]
     *   Possible Values:
     *   {XMLElement}  an xml element loaded in to this element.
     *   {String}      an xml string which is loaded in this element.
     *   {String}      an instruction to load data from a remote source.
     *   {Null}        null clears this element from it's data {@link baseclass.cache.method.clear}.
     * @param {Object} [options]
     *   Properties:
     *   {XMLElement} [xmlNode]    the {@link term.datanode data node} that provides
     *                             context to the data instruction.
     *   {Function}   [callback]   the code executed when the data request returns.
     *   {mixed}      []           Custom properties available in the data instruction.
     *   {String}     [cacheId]    the xml element to which the binding rules are applied.
     *   {Boolean}    [force]      whether cache is checked before loading the data.
     *   {Boolean}    [noClearMsg] wether a message is set when clear is called.
     *
     * @event beforeload  Fires before loading data in this element.
     *   cancelable: Prevents the data from being loaded.
     *   object:
     *   {XMLElement} xmlNode the node that is loaded as the root {@link term.datanode data node}.
     * @event afterload   Fires after loading data in this element.
     *   object:
     *   {XMLElement} xmlNode the node that is loaded as the root {@link term.datanode data node}.
     * @see  element.smartbinding
     * @see  baseclass.cache.method.clear
     */
    this.load = function(xmlNode, options){
        if (options) {
            var cacheId      = options.cacheId,
                forceNoCache = options.force,
                noClearMsg   = options.noClearMsg;
        }

        if (cacheId && cacheId == this.cacheId && !forceNoCache)
            return;

        
        if (apf.popup.isShowing(this.$uniqueId))
            apf.popup.forceHide(); //This should be put in a more general position
        

        // Convert first argument to an xmlNode we can use;
        if (xmlNode) {
            if (typeof xmlNode == "string") {
                if (xmlNode.charAt(0) == "<")
                    xmlNode = apf.getXmlDom(xmlNode).documentElement;
                else {
                    return apf.model.prototype.$loadFrom.call(this, xmlNode, options);
                }
            }
            else if (xmlNode.nodeType == 9) {
                xmlNode = xmlNode.documentElement;
            }
            else if (xmlNode.nodeType == 3 || xmlNode.nodeType == 4) {
                xmlNode = xmlNode.parentNode;
            }
            else if (xmlNode.nodeType == 2) {
                xmlNode = xmlNode.ownerElement 
                    || xmlNode.parentNode 
                    || xmlNode.selectSingleNode("..");
            }
        }

        // If control hasn't loaded databinding yet, queue the call
        if (this.$preventDataLoad || !this.$canLoadData 
          && ((!this.$bindings && !this.$canLoadDataAttr) || !this.$amlLoaded) 
          && (!this.hasFeature(apf.__MULTISELECT__) || !(this.each || this.$template)) 
          || this.$canLoadData && !this.$canLoadData()) {
            this.xmlRoot = xmlNode;
            
            
            if (this.$amlLoaded && !this.$attrBindings) {
                apf.console.warn("Could not load data yet in " + (this.localName
                  ? this.localName + "[" + (this.name || "") + "]"
                  : this.nodeName) + ". The loaded data is queued "
                      + "until smartbinding rules are loaded or set manually.");
            }
            

            return this.$loadqueue = [xmlNode, cacheId];
        }

        // If no xmlNode is given we clear the control, disable it and return
        if (this.dataParent && this.dataParent.xpath)
            this.dataParent.parent.signalXmlUpdate[this.$uniqueId] = !xmlNode;

        if (!xmlNode && (!cacheId || !this.$isCached || !this.$isCached(cacheId))) {
            
            apf.console.warn("No xml root node was given to load in "
                + this.localName + "[" + (this.name || '') + "]. Clearing any "
                + "loaded xml in this component");
            

            this.clear(noClearMsg);

            
            if (apf.config.autoDisable && this.$createModel === false)
                this.setProperty("disabled", true);

            //@todo apf3.0 remove , true in clear above
            //this.setProperty("selected", null);
            
            return;
        }

        var disabled = this.disabled;
        this.disabled = false;

        //Run onload event
        if (this.dispatchEvent("beforeload", {xmlNode : xmlNode}) === false)
            return false;

        
        apf.console.info("Loading XML data in "
          + (this.localName 
            ? this.localName + "[" + (this.name || '') + "]"
            : this.nodeName));
        

        // If reloading current document, and caching is disabled, exit
        if (this.caching && !forceNoCache && xmlNode && xmlNode == this.xmlRoot)
            return;

        this.clear(true, true);

        this.cacheId = cacheId;

        if (this.dispatchEvent("$load", {
          forceNoCache : forceNoCache, 
          xmlNode  : xmlNode
        }) === false) {
            delete this.cacheId;
            return;
        }
        
        //Set usefull vars
        this.documentId = apf.xmldb.getXmlDocId(xmlNode);
        this.xmlRoot    = xmlNode;
        
        
        this.setProperty("root", this.xmlRoot);
        

        
        apf.$lm_has_lang = false;
        

        // Draw Content
        this.$load(xmlNode);
        
        
        //@todo apf3.0
        if (apf.$lm_has_lang)
            apf.language.addBinding(this); //@todo should auto remove
        else
            apf.language.removeBinding(this);
        

        // Check if subtree should be loaded
        this.$loadSubData(xmlNode);

        if (this.$createModel === false) {
            this.disabled = true;
            this.setProperty("disabled", false);
        }
        else
            this.disabled = disabled;

        // Run onafteronload event
        this.dispatchEvent('afterload', {xmlNode : xmlNode});
    };
    
    /**
     * @binding load Determines how new data is loaded data is loaded into this
     * element. Usually this is only the root node containing no children.
     * Example:
     * This example shows a load rule in a text element. It gets its data from
     * a list. When a selection is made on the list the data is loaded into the
     * text element.
     * <code>
     *  <a:list id="lstExample" width="200" height="200">
     *      <a:bindings>
     *          <a:caption match="[text()]" />
     *          <a:value match="[text()]" />
     *          <a:each match="[message]" />
     *      </a:bindings>
     *      <a:model>
     *          <messages>
     *              <message id="1">message 1</message>
     *              <message id="2">message 2</message>
     *          </messages>
     *      </a:model>
     *  </a:list>
     * 
     *  <a:text model="{lstExample.selected}" width="200" height="150">
     *      <a:bindings>
     *          <a:load get="http://localhost/getMessage.php?id=[@id]" />
     *          <a:contents match="[message/text()]" />
     *      </a:bindings>
     *  </a:text>
     * </code>
     * @attribute {string} get the {@link term.datainstruction data instruction}
     *                     that is used to load data into the xmlRoot of this component.
     */
    this.$loadSubData = function(xmlRootNode){
        if (this.$hasLoadStatus(xmlRootNode)) return;

        //var loadNode = this.$applyBindRule("load", xmlRootNode);
        var loadNode, rule = this.$getBindRule("load", xmlRootNode);
        if (rule && (!rule[1] || rule[1](xmlRootNode))) {
            
            if (typeof apf.offline != "undefined" && !apf.offline.onLine) {
                apf.offline.transactions.actionNotAllowed();
                this.$loadedWhenOffline = true;
    
                //this.hasFeature(apf.__MULTISELECT__)
                if (this.$setClearMessage && !this.getTraverseNodes().length)
                    this.$setClearMessage(this["offline-message"], "offline");
    
                return;
            }
            
            
            this.$setLoadStatus(xmlRootNode, "loading");

            if (this.$setClearMessage)
                this.$setClearMessage(this["loading-message"], "loading");

            //||apf.xmldb.findModel(xmlRootNode)
            var mdl = this.getModel(true);
            
            if (!mdl)
                throw new Error("Could not find model");
            

            var amlNode = this;
            if (mdl.$insertFrom(rule.getAttribute("get"), {
              xmlNode     : loadNode,  //@todo apf3.0
              insertPoint : xmlRootNode, //this.xmlRoot,
              amlNode     : this,
              callback    : function(){
                    
                    amlNode.setProperty(amlNode.hasFeature(apf.__MULTISELECT__) 
                        ? "selected" 
                        : "root", xmlRootNode);
                    
                }
              }) === false
            ) {
                this.clear(true);
                
                if (apf.config.autoDisable)
                    this.setProperty("disabled", true);

                //amlNode.setProperty("selected", null); //@todo is this not already done in clear?
                
            }
        }
    };
    
    /**
     * Unloads data from this element and resets state displaying an empty message.
     * Empty message is set on the {@link baseclass.guielement.property.msg}.
     *
     * @param {Boolean} [nomsg]   whether to display the empty message.
     * @param {Boolean} [doEvent] whether to sent select events.
     * @see baseclass.databinding.method.load
     * @private
     */
    //@todo this function is call way too much for a single load of a tree
    //@todo should clear listener
    this.clear = function(nomsg, doEvent, fakeClear){
        if (!this.$int)
            return;//@todo apf3.0

        if (this.clearSelection)
            this.clearSelection(!doEvent);

        var lastHeight = this.$int.offsetHeight;

        if (this.dispatchEvent("$clear") !== false)
            this.$int.innerHTML = ""; //@todo apf3.0

        if (typeof nomsg == "string") {
            var msgType = nomsg;
            nomsg = false;
            
            //@todo apf3.0 please use attr. inheritance
            if (!this[msgType + "-message"]) {
                this.$setInheritedAttribute(msgType + "-message");
            }
        }
        this.$lastClearType = msgType || null;

        if (!nomsg && this.$setClearMessage) {
            this.$setClearMessage(msgType 
              ? this[msgType + "-message"] 
              : this["empty-message"], msgType || "empty", lastHeight);

            //this.setProperty("selected", null); //@todo apf3.0 get the children to show loading... as well (and for each selected, null
            //c[i].o.clear(msgType, doEvent);
        }
        else if(this.$removeClearMessage)
            this.$removeClearMessage();

        if (!fakeClear)
            this.documentId = this.xmlRoot = this.cacheId = null;

        
        if (!nomsg) {
            if (this.hasFeature(apf.__MULTISELECT__)) //@todo this is all wrong
                this.setProperty("length", 0);
            //else 
                //this.setProperty("value", ""); //@todo redo apf3.0
        }
        
    };
    
    this.clearMessage = function(msg){
        this.customMsg = msg;
        this.clear("custom");
    };

    /**
     * @private
     */
    this.$setLoadStatus = function(xmlNode, state, remove){
        //remove old status if any
        var ostatus = xmlNode.getAttribute("a_loaded");
        ostatus = ostatus
            ? ostatus.replace(new RegExp("\\|\\w+\\:" + this.$uniqueId + "\\|", "g"), "")
            : "";

        if (!remove)
            ostatus += "|" + state + ":" + this.$uniqueId + "|";

        xmlNode.setAttribute("a_loaded", ostatus);
    };

    /**
     * @private
     */
    this.$removeLoadStatus = function(xmlNode){
        this.$setLoadStatus(xmlNode, null, true);
    };

    /**
     * @private
     */
    this.$hasLoadStatus = function(xmlNode, state){
        var ostatus = xmlNode.getAttribute("a_loaded");
        if (!ostatus) return false;

        return (ostatus.indexOf((state || "") + ":" + this.$uniqueId + "|") != -1)
    };

    /**
     * @event beforeinsert Fires before data is inserted.
     *   cancelable: Prevents the data from being inserted.
     *   object:
     *   {XMLElement} xmlParentNode the parent in which the new data is inserted
     * @event afterinsert Fires after data is inserted.
     */

    /**
     * @private
     */
    this.insert = function(xmlNode, options){
        if (typeof xmlNode == "string") {
            if (xmlNode.charAt(0) == "<") {
                xmlNode = apf.getXmlDom(xmlNode).documentElement;
            }
            else {
                if (!options.insertPoint)
                    options.insertPoint = this.xmlRoot;
                return apf.model.prototype.$insertFrom.call(this, xmlNode, options);
            }
        }
        
        var insertPoint = options.insertPoint || this.xmlRoot;

        if (this.dispatchEvent("beforeinsert", {
          xmlParentNode : insertPoint
        }) === false)
            return false;

        //Integrate XMLTree with parentNode
        if (typeof options.copyAttributes == "undefined")
            options.copyAttributes = true;
            
        var newNode = apf.mergeXml(xmlNode, insertPoint, options);

        //Call __XMLUpdate on all listeners
        apf.xmldb.applyChanges("insert", insertPoint);

        //Select or propagate new data
        if (this.selectable && this.autoselect) {
            if (this.xmlNode == newNode)
                this.$selectDefault(this.xmlNode);
        }
        
        else if (this.xmlNode == newNode) {
            this.setProperty("root", this.xmlNode);
        }
        

        if (this.$hasLoadStatus(insertPoint, "loading"))
            this.$setLoadStatus(insertPoint, "loaded");

        this.dispatchEvent("afterinsert");

        //Check Connections
        //this one shouldn't be called because they are listeners anyway...(else they will load twice)
        //if(this.selected) this.setConnections(this.selected, "select");
    };
    
    /**
     * @attribute {Boolean} render-root whether the xml element loaded into this
     * element is rendered as well. Default is false.
     * Example:
     * This example shows a tree which also renders the root element.
     * <code>
     *  <a:tree render-root="true">
     *      <a:model>
     *          <root name="My Computer">
     *              <drive name="C">
     *                  <folder name="/Program Files" />
     *                  <folder name="/Desktop" />
     *              </drive>
     *          </root>
     *      </a:model>
     *      <a:bindings>
     *          <a:caption match="[@name]"></a:caption>
     *          <a:each match="[root|drive|folder]"></a:each>
     *      </a:bindings>
     *  </a:tree>
     * </code>
     */
    this.$booleanProperties["render-root"] = true;
    this.$supportedProperties.push("empty-message", "loading-message",
        "offline-message", "render-root", "smartbinding",
        "bindings", "actions");

    /**
     * @attribute {Boolean} render-root wether the root node of the data loaded
     * into this element is rendered as well. 
     * @see element.tree
     */
    this.$propHandlers["render-root"] = function(value){
        this.renderRoot = value;
    };
    
    /**
     * @attribute {String} empty-message the message displayed by this element
     * when it contains no data. This property is inherited from parent nodes.
     * When none is found it is looked for on the appsettings element. Otherwise
     * it defaults to the string "No items".
     */
    this.$propHandlers["empty-message"] = function(value){
        this["empty-message"] = value;

        if (this.$updateClearMessage) 
            this.$updateClearMessage(this["empty-message"], "empty");
    };

    /**
     * @attribute {String} loading-message  the message displayed by this
     * element when it's loading. This property is inherited from parent nodes.
     * When none is found it is looked for on the appsettings element. Otherwise
     * it defaults to the string "Loading...".
     * Example:
     * This example uses property binding to update the loading message. The
     * position of the progressbar should be updated by the script taking care
     * of loading the data.
     * <code>
     *  <a:list loading-message="{'Loading ' + Math.round(progress1.value*100) + '%'}" />
     *  <a:progressbar id="progress1" />
     * </code>
     * Remarks:
     * Usually a static loading message is displayed for only 100 milliseconds
     * or so, whilst loading the data from the server. This is done for instance
     * when the load binding rule is used. In the code example below a list
     * binds on the selection of a tree displaying folders. When the selection
     * changes, the list loads new data by extending the model. During the load
     * of this new data the loading message is displayed.
     * <code>
     *  <a:list model="#trFolders">
     *      <a:bindings>
     *          ...
     *          <a:load load="{comm.getFiles([@path])}" />
     *      </bindings>
     *  </a:list>
     * </code>
     */
    this.$propHandlers["loading-message"] = function(value){
        this["loading-message"] = value;

        if (this.$updateClearMessage)
            this.$updateClearMessage(this["loading-message"], "loading");
    };

    /**
     * @attribute {String} offline-message  the message displayed by this
     * element when it can't load data because the application is offline.
     * This property is inherited from parent nodes. When none is found it is
     * looked for on the appsettings element. Otherwise it defaults to the
     * string "You are currently offline...".
     */
    this.$propHandlers["offline-message"] = function(value){
        this["offline-message"] = value;

        if (this.$updateClearMessage)
            this.$updateClearMessage(this["offline-message"], "offline");
    };

    /**
     * @attribute {String} smartbinding  the name of the SmartBinding for this
     * element. A smartbinding is a collection of rules which define how data
     * is transformed into representation, how actions on the representation are
     * propagated to the data and it's original source, how drag&drop actions
     * change the data and where the data is loaded from. Each of these are
     * optionally defined in the smartbinding set and can exist independently
     * of the smartbinding object.
     * Example:
     * This example shows a fully specified smartbinding. Usually only parts
     * are used. This example shows a tree with files and folders.
     * <code>
     *  <a:tree smartbinding="sbExample" />
     *
     *  <a:smartbinding id="sbExample">
     *      <a:bindings>
     *          <a:caption  select = "@name"/>
     *          <a:icon     select = "self::file"
     *                      value  = "icoFile.gif" />
     *          <a:icon     value  = "icoFolder.gif" />
     *          <a:each select = "file|folder|root" />
     *          <a:drag select = "folder|file" />
     *          <a:drop select = "folder" 
     *                  target = "root"
     *                  operation = "tree-append" />
     *          <a:drop select = "folder" 
     *                  target = "folder"
     *                  operation = "insert-before" />
     *          <a:drop select = "file"   
     *                  target = "folder|root" 
     *                  soperation = "tree-append" />
     *          <a:drop select = "file"   
     *                  target = "file"        
     *                  operation = "insert-before" />
     *      </bindings>
     *      <a:actions>
     *          <a:remove set = "remove.php?path=[@path]" />
     *          <a:rename set = "move.php?from=oldValue&to=[@path]" />
     *      </actions>
     *      <a:model load="get_listing.php" />
     *  </a:smartbinding>
     * </code>
     * Remarks:
     * The smartbinding parts can also be assigned to an element by adding them
     * directly as a child in aml.
     * <code>
     *  <a:tree>
     *      <a:bindings>
     *          ...
     *      </bindings>
     *      <a:model />
     *  </a:tree>
     * </code>
     *
     * See:
     * There are several ways to be less verbose in assigning certain rules.
     * <ul>
     *  <li>{@link baseclass.multiselectbinding.binding.each}</li>
     *  <li>{@link baseclass.dragdrop.attribute.drag}</li>
     *  <li>{@link element.bindings}</li>
     *  <li>{@link element.actions}</li>
     *  <li>{@link element.dragdrop}</li>
     * </ul>
     */
    this.$propHandlers["smartbinding"] = 
    
    /**
     * @attribute {String} actions the id of the actions element which
     * provides the action rules for this element. Action rules are used to
     * send changes on the bound data to a server.
     * Example:
     * <code>
     *  <a:tree 
     *     id             = "tree" 
     *     height         = "200" 
     *     width          = "250" 
     *     actions        = "actExample"
     *     model          = "filesystem.xml"
     *     actiontracker  = "atExample"
     *     startcollapsed = "false" 
     *     onerror        = "alert('Sorry this action is not permitted');return false">
     *       <a:each match="[folder|drive]">
     *           <a:caption match="[@caption]" />
     *           <a:icon value="Famfolder.gif" />
     *       </a:each>
     *   </a:tree>
     *   
     *   <a:actions id="actExample">
     *       <a:rename match = "[file]"   
     *                set    = "rename_folder.php?id=[@fid]" />
     *       <a:rename match = "[folder]" 
     *                set    = "rename_file.php?id=[@fid]" />
     *   </a:actions>
     *   
     *   <a:button 
     *     caption = "Rename"
     *     right   = "10" 
     *     top     = "10"
     *     onclick = "tree.startRename()" />
     *   <a:button onclick="tree.getActionTracker().undo();">Undo</a:button>
     * </code>
     */
    this.$propHandlers["actions"] = 

    /**
     * @attribute {String} bindings the id of the bindings element which
     * provides the binding rules for this element.
     * Example:
     * This example shows a set of binding rules that transform data into the
     * representation of a list. In this case it displays the names of
     * several email accounts, with after each account name the number of unread
     * mails in that account. It uses JSLT to transform the caption.
     * <code>
     *  <a:model id="mdlExample">
     *      <data>
     *          <account icon="application.png">Account 1
     *              <mail read="false" />
     *              <mail read="false" />
     *              <mail read="true" />
     *          </account>
     *          <account icon="application.png">Account 2</account>
     *      </data>
     *  </a:model>
     *  <a:list bindings="bndExample" model="mdlExample" />
     * 
     *   <a:bindings id="bndExample">
     *      <a:caption>[text()] (#[mail[@read != 'true']])</a:caption>
     *      <a:icon match="[@icon]" />
     *      <a:each match="[account]" sort="[text()]" />
     *  </a:bindings>
     * </code>
     * Remarks:
     * Bindings can also be assigned directly by putting the bindings tag as a
     * child of this element.
     *
     * If the rule only contains a select attribute, it can be written in a
     * short way by adding an attribute with the name of the rule to the
     * element itself:
     * <code>
     *  <a:list 
     *    caption = "[text()] (#[mail[@read != 'true']])"
     *    icon    = "[@icon]"
     *    each    = "[account]"
     *    sort    = "[text()]" />
     * </code>
     */
    this.$propHandlers["bindings"] = function(value, prop){
        var local = "$" + prop;
        if (this[local])
            this[local].unregister(this);
        
        if (!value)
            return;

        
        if (!apf.nameserver.get(prop, value))
            throw new Error(apf.formatErrorString(1064, this,
                "Setting " + prop,
                "Could not find " + prop + " by name '" + value + "'"));
        

        apf.nameserver.get(prop, value).register(this);
        
        if (prop != "actions")
            this.$checkLoadQueue();
    };

    
    var eachBinds = {"caption":1, "icon":1, "select":1, "css":1, "sort":1,
                     "drop":2, "drag":2, "dragcopy":2, "eachvalue":1}; //Similar to apf.Class
    
    this.$addAttrBind = function(prop, fParsed, expression) {
        //Detect if it uses an external model
        if (fParsed.models) {
            
            if (this.hasFeature(apf.__MULTISELECT__)) {
                
                if (eachBinds[prop]) {
                    throw new Error("Cannot use external model inside " + prop + " rule"); //@todo apf3.0 convert to apf error
                }
                
            }
            
        }

        //Set listener for all models
        var i, xpath, modelId, model,
            paths = fParsed.xpaths,
            list  = {};
        for (i = 0; i < paths.length; i+=2) {
            if (!list[(modelId = paths[i])])
                list[modelId] = 1;
            else list[modelId]++
        }
        
        if (!this.$propsUsingMainModel)
            this.$propsUsingMainModel = {};

        var rule = (this.$attrBindings || (this.$attrBindings = {}))[prop] = {
            cvalue  : fParsed,
            value   : expression,
            compile : apf.BindingRule.prototype.$compile,
            models  : []
        };

        delete this.$propsUsingMainModel[prop];
        for (xpath, i = 0; i < paths.length; i+=2) {
            modelId = paths[i];
            if (list[modelId] == -1)
                continue;

            xpath = paths[i + 1];

            if (modelId == "#" || xpath == "#") {
                var m = (rule.cvalue3 || (rule.cvalue3 = apf.lm.compile(rule.value, {
                    xpathmode: 5
                })))(this.xmlRoot);
                
                //@todo apf3 this needs to be fixed in live markup
                if (typeof m != "string") {
                    model = m.model && m.model.nodeFunc && m.model;
                    if (model)
                        xpath = m.xpath;
                    else {
                        model = apf.xmldb.findModel(m.model);
                        xpath = apf.xmlToXpath(m.model, model.data) + (m.xpath ? "/" + m.xpath : ""); //@todo make this better
                    }
                }
                else model = null;
            }
            else model = null;

            if (!model) {
                if (modelId) {
                    //@todo apf3.0 how is this cleaned up???
                    //Add change listener to the data of the model
                    model = apf.nameserver.get("model", modelId) //is model creation useful here?
                        || apf.setReference(modelId, apf.nameserver.register("model", modelId, new apf.model()));
                }
                else {
                    if (!this.$model && !this.$initingModel)
                        initModel.call(this);
    
                    model = this.$model;
                    this.$propsUsingMainModel[prop] = {
                        xpath    : xpath,
                        optimize : list[modelId] == 1
                    };
                }
            }
            
            //@todo warn here if no model??
            if (model && (!this.hasFeature(apf.__MULTISELECT__) 
              && eachBinds[prop] != 2 || !eachBinds[prop])) {
                //Create the attribute binding
                model.$bindXmlProperty(this, prop, xpath, list[modelId] == 1, expression.indexOf("*[") > -1);
                rule.models.push(model);
            }
            
            list[modelId] = -1;
        }
        
        rule.xpath = xpath;

        this.$canLoadDataAttr = eachBinds[prop] == 1; //@todo apf3.0 remove
        this.$checkLoadQueue();
    }
    
    this.$removeAttrBind = function(prop){
        //@todo apf3.0
        //$model.$unbindXmlProperty
        var rule = this.$attrBindings[prop]
        if (!rule)
            return;
        
        delete this.$attrBindings[prop];
        
        var models = rule.models;
        for (var i = 0; i < models.length; i++) {
            models[i].$unbindXmlProperty(this, prop);
        }
    };
    
    this.$initingModel;
    function initModel(){
        this.$initingModel = true;
        this.$setInheritedAttribute("model");
    }
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        //Set empty message if there is no data
        if (!this.model && this.$setClearMessage && !this.value)
            this.$setClearMessage(this["empty-message"], "empty");
        
        /*var hasInitSb = apf.AmlParser.sbInit[this.$uniqueId] ? true : false;
        if ((!hasInitSb || !hasModel) && this.$setClearMessage
          && (!this.$loadqueue && !this.xmlRoot && (this.hasFeature(apf.__MULTISELECT__)
          || this.ref || hasInitSb)))*/

        this.$amlLoaded = true; //@todo this can probably be removed
        this.$checkLoadQueue();
    });
    
    
    this.addEventListener("DOMNodeRemovedFromDocument", function(e){
        apf.language.removeBinding(this);
    });
    

    /**
     * @attribute {String} model the name of the model to load data from or a
     * datainstruction to load data.
     * Example:
     * <code>
     *  <a:model id="mdlExample" src="filesystem.xml" />
     *   <a:tree 
     *     height         = "200" 
     *     width          = "250" 
     *     model          = "mdlExample">
     *       <a:each match="[folder|drive]">
     *           <a:caption match="[@caption]" />
     *           <a:icon value="Famfolder.gif" />
     *       </a:each>
     *   </a:tree>
     * </code>
     * Example:
     * <code>
     *  <a:tree 
     *    height         = "200" 
     *    width          = "250" 
     *    model          = "filesystem.xml">
     *      <a:each match="[folder|drive]">
     *          <a:caption match="[@caption]" />
     *          <a:icon value="Famfolder.gif" />
     *      </a:each>
     *  </a:tree>
     * </code>
     * Example:
     * <code>
     *  <a:tree 
     *     id             = "tree"
     *     height         = "200" 
     *     width          = "250" 
     *     model          = "filesystem.xml">
     *       <a:each match="[folder|drive]">
     *           <a:caption match="[@caption]" />
     *           <a:icon value="Famfolder.gif" />
     *       </a:each>
     *   </a:tree>
     *   <a:text 
     *     model  = "{tree.selected}" 
     *     value  = "[@caption]" 
     *     width  = "250" 
     *     height = "100" />
     * </code>
     * Remarks:
     * This attribute is inherited from a parent when not set. You can use this
     * to tell sets of elements to use the same model.
     * <code>
     *  <a:bar model="mdlForm">
     *      <a:label>Name</a:label>
     *      <a:textbox value="[name]" />
     * 
     *      <a:label>Happiness</a:label>
     *      <a:slider value="[happiness]" min="0" max="10" />
     *  </a:bar>
     * 
     *  <a:model id="mdlForm">
     *      <data />
     *  </a:model>
     * </code>
     * When no model is specified the default model is choosen. The default
     * model is the first model that is found without a name, or if all models
     * have a name, the first model found.
     * Example:
     * This example shows a dropdown from which the user can select a country.
     * The list of countries is loaded from a model. Usually this would be loaded
     * from a seperate url, but for clarity it's inlined. When the user selects
     * a country in the dropdown the value of the item is stored in the second
     * model (mdlForm) at the position specified by the ref attribute. In this
     * case this is the country element.
     * <code>
     *  <a:label>Name</a:label>
     *  <a:textbox value="[name]" model="mdlForm" />
     * 
     *  <a:label>Country</a:label>
     *  <a:dropdown
     *    value   = "[mdlForm::country]"
     *    each    = "[mdlCountries::country]"
     *    caption = "[text()]">
     *  </a:dropdown>
     * 
     *  <a:model id="mdlCountries">
     *      <countries>
     *          <country value="USA">USA</country>
     *          <country value="GB">Great Brittain</country>
     *          <country value="NL">The Netherlands</country>
     *      </countries>
     *  </a:model>
     * 
     *  <a:model id="mdlForm">
     *      <data>
     *          <name />
     *          <country />
     *      </data>
     *  </a:model>
     * </code>
     * @see baseclass.databinding.attribute.model
     */
    this.$propHandlers["model"] = function(value){
        //Unset model
        if (!value && !this.$modelParsed) {
            if (this.$model) {
                this.clear();
                this.$model.unregister(this);
                this.$model = null;
                this.lastModelId = "";
            }
            else if (this.dataParent)
                this.dataParent.parent = null; //Should be autodisconnected by property binding

            return;
        }
        
        this.$initingModel = true;

        var fParsed;
        //Special case for property binding
        if ((fParsed = this.$modelParsed) && fParsed.type != 2) {
            var found, pb = fParsed.props;
            
            if (this.dataParent)
                this.dataParent = null; //Should be autodisconnected by property binding

            //Try to figure out who is the dataParent
            for (var prop in pb){
                
                if (typeof pb[prop] == "function")
                    continue;
                

                this.dataParent = {
                    parent : self[prop.split(".")[0]],
                    xpath  : null,
                    model  : this.$modelParsed.instruction
                };
        
                found = true;
                break; // We currently only support one data parent
            }
            
            if (found) {
                //@todo this statement doesnt make sense
                /*//Maybe a compound model is found
                if (!this.dataParent && (pb = fParsed.xpaths && fParsed.xpaths[0])) {
                    this.dataParent = {
                        parent : self[pb.split(".")[0]],
                        xpath  : fParsed.xpaths[1],
                        model  : this.$modelParsed.instruction
                    };
                }*/
                
                if (this.dataParent && !this.dataParent.signalXmlUpdate)
                    this.dataParent.signalXmlUpdate = {};
            }
            
            this.$modelParsed = null;
        }

        //Analyze the data
        var model;
        if (typeof value == "object") {
            if (value.dataType == apf.ARRAY) { //Optimization used for templating
                model = apf.nameserver.get("model", value[0]);
                model.register(this, value[1]);
                return;
            }
            else if (value.nodeFunc) { // A model node is passed
                //Convert model object to value;
                model = value;
                value = this.model = model.name;
                if (!value)
                    model.setProperty("id", value = this.model = "model" + model.$uniqueId);
                
                //@todo why not set directly here?
            }
            else if (this.dataParent) { //Data came through data parent
                this.model = this.dataParent.model; //reset this property

                model = apf.xmldb.findModel(value);
                var xpath = apf.xmlToXpath(value, model.data, true) || ".";
                
                
                if (model.queryNode(xpath) != value)
                    throw new Error("xml data node is not attached to model");
                
                
                model.register(this, xpath);
                return;
            }
            else {
                //@todo Error ??
            }
        }

        //Optimize xmlroot position and set model async (unset the old one)
        //@todo apf3.0 is this timer necessary?
        //clearTimeout(this.$dbTimer);
        //this.$dbTimer = $setTimeout(function(){
            apf.setModel(value, this);
        //});
    };

    
    /**
     * @attribute {String} viewport the way this element renders its data.
     * Possible values:
     * virtual  this element only renders data that it needs to display.
     * normal   this element renders all data at startup.
     * @experimental
     */
    this.$propHandlers["viewport"] = function(value){
        if (value != "virtual")
            return;

        this.implement(apf.VirtualViewport);
    };
    
};

    apf.DataBinding.prototype = apf.Presentation ? new apf.Presentation() : new apf.AmlElement();

apf.config.$inheritProperties["model"]           = 1;
apf.config.$inheritProperties["empty-message"]   = 1;
apf.config.$inheritProperties["loading-message"] = 1;
apf.config.$inheritProperties["offline-message"] = 1;
apf.config.$inheritProperties["noloading"]       = 1;

apf.Init.run("databinding");




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/databinding/multiselect.js)SIZE(42196)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * All elements inheriting from this {@link term.baseclass baseclass} can bind to data 
 * which contains multiple nodes.
 *
 * @allowchild  item, choices
 * @define  choices     Container for item nodes which receive presentation. 
 * This element is part of the XForms specification. It is not necesary for 
 * the Ajax.org Markup Language.
 * Example:
 * <code>
 *  <a:list>
 *      <a:choices>
 *          <a:item>red</a:item>
 *          <a:item>blue</a:item>
 *          <a:item>green</a:item>
 *      </a:choices>
 *  </a:list>
 * </code>
 * @allowchild  item
 *
 * @constructor
 * @baseclass
 * @default_private
 */
apf.MultiselectBinding = function(){
    if (!this.setQueryValue)
        this.implement(apf.DataBinding);

    this.$init(function(){
        this.$selectTimer = {};
    });
};

(function(){
    this.length = 0;
    
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        caption   : 2,
        icon      : 2,
        eachvalue : 2,
        select    : 2,
        css       : 2,
        sort      : 2,
        drag      : 2,
        drop      : 2,
        dragcopy  : 2,
        selected  : 2,
        //caret     : 2,
        each      : 1,
        "selection"             : 3, //only databound when has an xpath
        "selection-unique"      : 3, //only databound when has an xpath
        "selection-constructor" : 3 //only databound when has an xpath
    }, this.$attrExcludePropBind);

     
    /**
     * Change the sorting order of this element
     *
     * @param {Object}  options  the new sort options. These are applied incrementally.
     *                           Any property not set is maintained unless the clear
     *                           parameter is set to true.
     *   Properties:
     *   {String}   order        see {@link baseclass.multiselectbinding.binding.each.attribute.order}
     *   {String}   [xpath]      see {@link baseclass.multiselectbinding.binding.each.attribute.sort}
     *   {String}   [type]       see {@link baseclass.multiselectbinding.binding.each.attribute.data-type}
     *   {String}   [method]     see {@link baseclass.multiselectbinding.binding.each.attribute.sort-method}
     *   {Function} [getNodes]   Function that retrieves a list of nodes.
     *   {String}   [dateFormat] see {@link baseclass.multiselectbinding.binding.each.attribute.date-format}
     *   {Function} [getValue]   Function that determines the string content based
     *                           on an xml node as it's first argument.
     * @param {Boolean} clear    removes the current sort options.
     * @param {Boolean} noReload whether to reload the data of this component.
     * @see   baseclass.multiselectbinding.binding.each
     */
    this.resort = function(options, clear, noReload){
        if (!this.$sort)
            this.$sort = new apf.Sort();
 
        this.$sort.set(options, clear);
        
        if (this.clearAllCache)
            this.clearAllCache();

        if (noReload)
            return;

        
        /*if(this.hasFeature(apf.__VIRTUALVIEWPORT__)){
            this.$clearVirtualDataset(this.xmlRoot);
            this.reload();

            return;
        }*/
        

        var _self = this;
        (function sortNodes(xmlNode, htmlParent) {
            var sNodes = _self.$sort.apply(
                apf.getArrayFromNodelist(xmlNode.selectNodes(_self.each)));

            for (var i = 0; i < sNodes.length; i++) {
                if (_self.$isTreeArch || _self.$withContainer){
                    var htmlNode = apf.xmldb.findHtmlNode(sNodes[i], _self);

                    
                    if (!_self.$findContainer){
                        throw new Error(apf.formatErrorString(_self,
                            "Sorting Nodes",
                            "This component does not \
                             implement _self.$findContainer"));
                    }
                    

                    var container = _self.$findContainer(htmlNode);

                    htmlParent.appendChild(htmlNode);
                    if (!apf.isChildOf(htmlNode, container, true))
                        htmlParent.appendChild(container);

                    sortNodes(sNodes[i], container);
                }
                else
                    htmlParent.appendChild(apf.xmldb.findHtmlNode(sNodes[i], _self));
            }
        })(this.xmlRoot, this.$int);

        return options;
    };

    /**
     * Change sorting from ascending to descending and vice versa.
     */
    this.toggleSortOrder = function(){
        return this.resort({"ascending" : !this.$sort.get().ascending}).ascending;
    };

    /**
     * Retrieves the current sort options
     *
     * @returns {Object}  the current sort options.
     *   Properties:
     *   {String}   order      see {@link baseclass.multiselectbinding.binding.each.attribute.order}
     *   {String}   xpath      see {@link baseclass.multiselectbinding.binding.each.attribute.sort}
     *   {String}   type       see {@link baseclass.multiselectbinding.binding.each.attribute.data-type}
     *   {String}   method     see {@link baseclass.multiselectbinding.binding.each.attribute.sort-method}
     *   {Function} getNodes   Function that retrieves a list of nodes.
     *   {String}   dateFormat see {@link baseclass.multiselectbinding.binding.each.attribute.date-format}
     *   {Function} getValue   Function that determines the string content based on
     *                         an xml node as it's first argument.
     * @see    baseclass.multiselectbinding.binding.each
     */
    this.getSortSettings = function(){
        return this.$sort.get();
    };
    

    /**
     * Retrieves a nodelist containing the {@link term.datanode data nodes} which
     * are rendered by this element (see each nodes, see
     * {@link baseclass.multiselectbinding.binding.each}).
     *
     * @param {XMLElement} [xmlNode] the parent element on which the each query is applied.
     */
    this.getTraverseNodes = function(xmlNode){
        
        if (!this.each) {
            throw new Error("Could not render bound data. Missing 'each' rule for " 
                + this.localName + (this.id && "[" + this.id + "]" || "")); //@todo apf3.0 make into proper apf error
        }
        
        
        
        if (this.$sort) {
            var nodes = apf.getArrayFromNodelist((xmlNode || this.xmlRoot).selectNodes(this.each));
            return this.$sort.apply(nodes);
        }
        

        return (xmlNode || this.xmlRoot).selectNodes(this.each);
    };

    /**
     * Retrieves the first {@link term.datanode data node} which gets representation
     * in this element
     * (see each nodes, see {@link baseclass.multiselectbinding.binding.each}).
     *
     * @param {XMLElement} [xmlNode] the parent element on which the each query is executed.
     * @return {XMLElement}
     */
    this.getFirstTraverseNode = function(xmlNode){
        
        if (this.$sort) {
            var nodes = (xmlNode || this.xmlRoot).selectNodes(this.each);
            return this.$sort.apply(nodes)[0];
        }
        

        return (xmlNode || this.xmlRoot).selectSingleNode(this.each);
    };

    /**
     * Retrieves the last {@link term.datanode data node} which gets representation
     * in this element
     * (see each nodes, see {@link baseclass.multiselectbinding.binding.each}).
     *
     * @param {XMLElement} [xmlNode] the parent element on which the each query is executed.
     * @return {XMLElement} the last {@link term.datanode data node}
     * @see    baseclass.multiselectbinding.binding.each
     */
    this.getLastTraverseNode = function(xmlNode){
        var nodes = this.getTraverseNodes(xmlNode || this.xmlRoot);
        return nodes[nodes.length-1];
    };

    /**
     * Determines whether an {@link term.datanode data node} is a each node (see
     * {@link baseclass.multiselectbinding.binding.each})
     *
     * @param {XMLElement} [xmlNode] the parent element on which the each query is executed.
     * @return  {Boolean}  whether the xml element is a each node.
     * @see  baseclass.multiselectbinding.binding.each
     */
    this.isTraverseNode = function(xmlNode){
        /*
            Added optimization, only when an object has a tree architecture is it
            important to go up to the each parent of the xmlNode, else the node
            should always be based on the xmlroot of this component
        */
        //this.$isTreeArch
        var nodes = this.getTraverseNodes(
          this.getTraverseParent(xmlNode) || this.xmlRoot);
        for (var i = 0; i < nodes.length; i++)
            if (nodes[i] == xmlNode)
                return true;
        return false;
    };

    /**
     * Retrieves the next each node (see {@link baseclass.multiselectbinding.binding.each})
     * to be selected
     * from a given each node. The method can do this in either direction and
     * also return the Nth node for this algorithm.
     *
     * @param {XMLElement}  xmlNode  the starting point for determining the next selection.
     * @param {Boolean}     [up]     the direction of the selection. Default is false.
     * @param {Integer}     [count]  the distance in number of nodes. Default is 1.
     * @return  {XMLElement} the {@link term.datanode data node} to be selected next.
     * @see  baseclass.multiselectbinding.binding.each
     */
    this.getNextTraverseSelected = function(xmlNode, up, count){
        if (!xmlNode)
            xmlNode = this.selected;
        if (!count)
            count = 1;

        var i = 0;
        var nodes = this.getTraverseNodes(this.getTraverseParent(xmlNode) || this.xmlRoot);
        while (nodes[i] && nodes[i] != xmlNode)
            i++;

        var node = (up == null)
            ? nodes[i + count] || nodes[i - count]
            : (up ? nodes[i + count] : nodes[i - count]);

        //arguments[2]
        return node || count && (i < count || (i + 1) > Math.floor(nodes.length / count) * count)
            ? node
            : (up ? nodes[nodes.length-1] : nodes[0]);
    };

    /**
     * Retrieves the next each node (see {@link baseclass.multiselectbinding.binding.each}).
     * The method can do this in either direction and also return the Nth next node.
     *
     * @param {XMLElement}  xmlNode     the starting point for determining the next node.
     * @param {Boolean}     [up]        the direction. Default is false.
     * @param {Integer}     [count]     the distance in number of nodes. Default is 1.
     * @return  {XMLElement} the next each node
     * @see  baseclass.multiselectbinding.binding.each
     */
    this.getNextTraverse = function(xmlNode, up, count){
        if (!count)
            count = 1;
        if (!xmlNode)
            xmlNode = this.selected;

        var i = 0;
        var nodes = this.getTraverseNodes(this.getTraverseParent(xmlNode) || this.xmlRoot);
        while (nodes[i] && nodes[i] != xmlNode)
            i++;

        return nodes[i + (up ? -1 * count : count)];
    };

    /**
     * Retrieves the parent each node (see {@link baseclass.multiselectbinding.binding.each}).
     * In some cases the each rules has a complex form like 'children/item'. In
     * those cases the generated tree has a different structure from that of the xml
     * data. For these situations the xmlNode.parentNode property won't return
     * the each parent, this method will give you the right parent.
     *
     * @param {XMLElement} xmlNode the node for which the parent element will be determined.
     * @return  {XMLElement} the parent node or null if none was found.
     * @see  baseclass.multiselectbinding.binding.each
     */
    this.getTraverseParent = function(xmlNode){
        if (!xmlNode.parentNode || xmlNode == this.xmlRoot) return false;

        var x, id = xmlNode.getAttribute(apf.xmldb.xmlIdTag);
        if (!id) {
            //return false;
            xmlNode.setAttribute(apf.xmldb.xmlIdTag, "temp");
            id = "temp";
        }

        /*
        do {
            xmlNode = xmlNode.parentNode;
            if (xmlNode == this.xmlRoot)
                return false;
            if (this.isTraverseNode(xmlNode))
                return xmlNode;
        } while (xmlNode.parentNode);
        */

        //This is not 100% correct, but good enough for now

        x = xmlNode.selectSingleNode("ancestor::node()[(("
            + this.each + ")/@" + apf.xmldb.xmlIdTag + ")='"
            + id + "']");

        if (id == "temp")
            xmlNode.removeAttribute(apf.xmldb.xmlIdTag);
        return x;
    };
    
    /**
     * Finds HTML presentation node in cache by ID
     *
     * @param  {String} id  the id of the HTMLElement which is looked up.
     * @return {HTMLElement} the HTMLElement found. When no element is found, null is returned.
     */
    if (!this.$findHtmlNode) { //overwritten by apf.Cache
        this.$findHtmlNode = function(id){
            return this.$pHtmlDoc.getElementById(id);
        };
    }
    
    this.$setClearMessage = function(msg, className, lastHeight){
        if (!this.$empty) {
            if (!this.$hasLayoutNode("empty"))
                return;
            
            this.$getNewContext("empty");

            var xmlEmpty = this.$getLayoutNode("empty");
            if (!xmlEmpty) return;

            this.$empty = apf.insertHtmlNode(xmlEmpty, this.$int);
        }
        else {
            this.$int.appendChild(this.$empty);
        }

        var empty = this.$getLayoutNode("empty", "caption", this.$empty);

        if (empty)
            apf.setNodeValue(empty, msg || "");

        this.$empty.setAttribute("id", "empty" + this.$uniqueId);
        apf.setStyleClass(this.$empty, className, ["loading", "empty", "offline"]);
        
        //@todo apf3.0 cleanup?
        this.$empty.style.height = (lastHeight && !apf.getStyle(this.$ext, "height") && className != "empty")
            ? (Math.max(10, (lastHeight
               - apf.getHeightDiff(this.$empty)
               - apf.getHeightDiff(this.$ext))) + "px")
            : "";
    };

    this.$updateClearMessage = function(msg, className) {
        if (!this.$empty || this.$empty.parentNode != this.$int
          || this.$empty.className.indexOf(className) == -1)
            return;

        var empty = this.$getLayoutNode("empty", "caption", this.$empty);
        if (empty)
            apf.setNodeValue(empty, msg || "");
    }

    this.$removeClearMessage = function(){
        if (!this.$empty)
            this.$empty = document.getElementById("empty" + this.$uniqueId);
        if (this.$empty && this.$empty.parentNode)
            this.$empty.parentNode.removeChild(this.$empty);
    };
    
    /**
     * Set listeners, calls HTML creation methods and
     * initializes select and focus states of object.
     */
    this.$load = function(XMLRoot){
        //Add listener to XMLRoot Node
        apf.xmldb.addNodeListener(XMLRoot, this);

        var length = this.getTraverseNodes(XMLRoot).length;
        if (!this.renderRoot && !length)
            return this.clear(null, null, true); //@todo apf3.0 this should clear and set a listener

        //Traverse through XMLTree
        var nodes = this.$addNodes(XMLRoot, null, null, this.renderRoot);

        //Build HTML
        this.$fill(nodes);

        //Select First Child
        if (this.selectable) {
            
            //@todo move this to multiselect event handler inside multiselect.js
            var sel, bHasOffline = (typeof apf.offline != "undefined");
            if (!this.firstLoad && bHasOffline && apf.offline.state.enabled
              && apf.offline.state.realtime) {
                sel = apf.offline.state.get(this, "selection");
                this.firstLoad = true;
            }

            if (sel) {
                var selstate = apf.offline.state.get(this, "selstate");

                if (sel.length == 0) {
                    this.clearSelection();
                }
                else {
                    for (var i = 0; i < sel.length; i++) {
                        sel[i] = apf.xpathToXml(sel[i],
                            this.xmlRoot);
                    }

                    if (selstate[1]) {
                        var selected = apf.remote
                            .xpathToXml(selstate[1], this.xmlRoot);
                    }

                    this.selectList(sel, null, selected);
                }

                if (selstate[0]) {
                    this.setCaret(apf.remote
                        .xpathToXml(selstate[0], this.xmlRoot));
                }
            }
            else
            
            //@todo apf3.0 optimize to not set selection when .selection or .selected is set on initial load
            if (this.autoselect) {
                if (!this.selected) {
                    if (this.renderRoot)
                        this.select(XMLRoot, null, null, null, true);
                    else if (nodes.length)
                        this.$selectDefault(XMLRoot);
                    //else @todo apf3.0 this one doesnt seem needed
                        //this.clearSelection();
                }
            }
            else {
                this.clearSelection(true);
                var xmlNode = this.renderRoot
                    ? this.xmlRoot
                    : this.getFirstTraverseNode(); //should this be moved to the clearSelection function?
                if (xmlNode)
                    this.setCaret(xmlNode);
                
                if (this.selected)
                    this.setProperty("selected", null);
                if (this.choosen)
                    this.setProperty("choosen", null);
                
            }
        }

        if (this.focussable)
            apf.document.activeElement == this ? this.$focus() : this.$blur();

        
        if (length != this.length)
            this.setProperty("length", length);
        
    };

    var actionFeature = {
        "insert"      : 127,//1111111
        "add"         : 123,//1111011
        "remove"      : 46, //0101110
        "redo-remove" : 79, //1001111
        "synchronize" : 127,//1111111
        "move-away"   : 105,//1101001
        "move"        : 77  //1001101
    };

    /**
     * Loops through parents of changed node to find the first
     * connected node. Based on the action it will change, remove
     * or update the representation of the data.
     *
     * @event xmlupdate Fires when xml of this element is updated.
     *   object:
     *   {String}     action   the action that was executed on the xml.
     *      Possible values:
     *      text        a text node is set.
     *      update      an xml node is updated.
     *      insert      xml nodes are inserted.
     *      add         an xml node is added.
     *      remove      an xml node is removed (parent still set).
     *      redo-remove an xml node is removed (parent not set).
     *      synchronize unknown update.
     *      move-away   an xml node is moved (parent not set).
     *      move        an xml node is moved (parent still set).
     *   {XMLElement} xmlNode  the node that is subject to the update.
     *   {Mixed}      result   the result.
     *   {UndoObj}    UndoObj  the undo information.
     */
    this.$xmlUpdate = function(action, xmlNode, listenNode, UndoObj, lastParent){
        if (!this.xmlRoot)
            return; //@todo think about purging cache when xmlroot is removed

        var result, length, pNode, htmlNode,
            startNode = xmlNode;
        if (!listenNode)
            listenNode = this.xmlRoot;

        if (action == "redo-remove") {
            lastParent.appendChild(xmlNode); //ahum, i'm not proud of this one
            var eachNode = this.isTraverseNode(xmlNode);
            lastParent.removeChild(xmlNode);
            
            if (!eachNode)
                xmlNode = lastParent;
        }

        //Get First ParentNode connected
        do {
            if (action == "add" && this.isTraverseNode(xmlNode)
              && startNode == xmlNode)
                break; //@todo Might want to comment this out for adding nodes under a eachd node

            if (xmlNode.getAttribute(apf.xmldb.xmlIdTag)) {
                htmlNode = this.$findHtmlNode(
                    xmlNode.getAttribute(apf.xmldb.xmlIdTag)
                    + "|" + this.$uniqueId);

                if (htmlNode
                  && (startNode != xmlNode || xmlNode == this.xmlRoot)
                  && actionFeature[action] & 1)
                    action = "update";

                if (xmlNode == listenNode) {
                    if (xmlNode == this.xmlRoot && action != "insert") {
                        //@todo apf3.0 - fix this for binding on properties
                        this.dispatchEvent("xmlupdate", {
                            action : action,
                            xmlNode: xmlNode,
                            UndoObj: UndoObj
                        });
                        return;
                    }
                    break;
                }

                if (htmlNode && actionFeature[action] & 2
                  && !this.isTraverseNode(xmlNode))
                    action = "remove"; //@todo why not break here?

                if (!htmlNode && actionFeature[action] & 4
                  && this.isTraverseNode(xmlNode)){
                    action = "add";
                    break;
                }

                if (htmlNode  || action == "move")
                    break;
            }
            else if (actionFeature[action] & 8 && this.isTraverseNode(xmlNode)){
                action = "add";
                break;
            }

            if (xmlNode == listenNode) break;
            xmlNode = xmlNode.parentNode;
        }
        while (xmlNode && xmlNode.nodeType != 9);

        
        apf.$lm_has_lang = false;
        

        
        /**
         * @todo Think about not having this code here
         */
        if (this.hasFeature(apf.__VIRTUALVIEWPORT__)) {
            if(!this.$isInViewport(xmlNode)) //xmlNode is a eachd node
                return;
        }
        

        //if(xmlNode == listenNode && !action.match(/add|synchronize|insert/))
        //    return; //deleting nodes in parentData of object

        var foundNode = xmlNode;
        if (xmlNode && xmlNode.nodeType == 9)
            xmlNode = startNode;

        if (action == "replacechild"
          && (UndoObj ? UndoObj.args[0] == this.xmlRoot : !this.xmlRoot.parentNode)) {
            return this.load(UndoObj ? UndoObj.args[1] : listenNode); //Highly doubtfull this is exactly right...
        }

        //Action Tracker Support - && xmlNode correct here??? - UndoObj.xmlNode works but fishy....
        if (UndoObj && xmlNode && !UndoObj.xmlNode)
            UndoObj.xmlNode = xmlNode;

        //Check Move -- if value node isn't the node that was moved then only perform a normal update
        if (action == "move" && foundNode == startNode) {
            //if(!htmlNode) alert(xmlNode.getAttribute("id")+"|"+this.$uniqueId);
            var isInThis  = apf.isChildOf(this.xmlRoot, xmlNode.parentNode, true);
            var wasInThis = apf.isChildOf(this.xmlRoot, UndoObj.extra.parent, true);

            //Move if both previous and current position is within this object
            if (isInThis && wasInThis)
                this.$moveNode(xmlNode, htmlNode);
            else if (isInThis) //Add if only current position is within this object
                action = "add";
            else if (wasInThis) //Remove if only previous position is within this object
                action = "remove";
        }
        else if (action == "move-away") {
            var goesToThis = apf.isChildOf(this.xmlRoot, UndoObj.extra.parent, true);
            if (!goesToThis)
                action = "remove";
        }

        //Remove loading message
        if (this.$removeClearMessage && this.$setClearMessage) {
            if (this.getFirstTraverseNode())
                this.$removeClearMessage();
            else
                this.$setClearMessage(this["empty-message"], "empty")
        }

        //Check Insert
        if (action == "insert" && (this.$isTreeArch || xmlNode == this.xmlRoot)) {
            if (!xmlNode)
                return;
            
            if (this.$hasLoadStatus(xmlNode) && this.$removeLoading)
                this.$removeLoading(htmlNode);

            if (this.$int.firstChild && !apf.xmldb.getNode(this.$int.firstChild)) {
                //Appearantly the content was cleared
                this.$int.innerHTML = "";

                if (!this.renderRoot) {
                    length = this.getTraverseNodes().length;
                    if (!length)
                        this.clear();
                }
            }

            result = this.$addNodes(xmlNode, (this.$getParentNode
                ? this.$getParentNode(htmlNode)
                : htmlNode), true, false);//this.$isTreeArch??

            this.$fill(result);

            
            if (this.selectable && !this.xmlRoot.selectSingleNode(this.each))
                apf.console.warn("No traversable nodes were found for "
                                 + this.name + " [" + this.localName + "]\n\
                                  Traverse Rule : " + this.$getBindRule("each")[4].getAttribute("match"));
            

            if (this.selectable && (length === 0 || !this.xmlRoot.selectSingleNode(this.each)))
                return;
        }
        else if (action == "add") {// || !htmlNode (Check Add)
            var parentHTMLNode;
            pNode = this.getTraverseParent(xmlNode);
            
            if (pNode == this.xmlRoot)
                parentHTMLNode = this.$int;
            
            if (!parentHTMLNode && this.$isTreeArch) {
                parentHTMLNode = this.$findHtmlNode(
                    pNode.getAttribute(apf.xmldb.xmlIdTag) + "|" + this.$uniqueId); 
            }
            
            //This should be moved into a function (used in setCache as well)
            
            if (!parentHTMLNode && this.getCacheItem)
                parentHTMLNode = this.getCacheItem(pNode.getAttribute(apf.xmldb.xmlIdTag)
                    || (pNode.getAttribute(apf.xmldb.xmlDocTag)
                         ? "doc" + pNode.getAttribute(apf.xmldb.xmlDocTag)
                         : false));
            

            //Only update if node is in current representation or in cache
            if (parentHTMLNode || this.$isTreeArch 
              && apf.isChildOf(this.xmlRoot, xmlNode)) {
                parentHTMLNode = (this.$findContainer && parentHTMLNode
                    ? this.$findContainer(parentHTMLNode)
                    : parentHTMLNode) || this.$int; //@todo I think this is wrong for non rendered sub tree nodes that get changed

                result = this.$addNodes(xmlNode, parentHTMLNode, true, true,
                    apf.xmldb.getHtmlNode(this.getNextTraverse(xmlNode), this));

                if (parentHTMLNode)
                    this.$fill(result);
            }
        }
        else if (action == "remove") { //Check Remove
            //&& (!xmlNode || foundNode == xmlNode && xmlNode.parentNode
            if (!xmlNode || startNode != xmlNode) //@todo unsure if I can remove above commented out statement
                return;
            
            //Remove HTML Node
            if (htmlNode)
                this.$deInitNode(xmlNode, htmlNode);
            else if (xmlNode == this.xmlRoot) {
                return this.load({
                    noClearMsg: !this.dataParent || !this.dataParent.autoselect
                });
            }
        }
        else if (htmlNode) {
            this.$updateNode(xmlNode, htmlNode);

            //Transaction 'niceties'
            if (action == "replacechild" && this.hasFeature(apf.__MULTISELECT__)
              && this.selected && xmlNode.getAttribute(apf.xmldb.xmlIdTag)
              == this.selected.getAttribute(apf.xmldb.xmlIdTag)) {
                this.selected = xmlNode;
            }

            //if(action == "synchronize" && this.autoselect) this.reselect();
        }
        else if (action == "redo-remove") { //Check Remove of the data (some ancestor) that this component is bound on
            var testNode = this.xmlRoot;
            while (testNode && testNode.nodeType != 9)
                testNode = testNode.parentNode;

            if (!testNode) {
                //Set Component in listening state until data becomes available again.
                var model = this.getModel(true);

                
                if (!model)
                    throw new Error(apf.formatErrorString(0, this,
                        "Setting change notifier on component",
                        "Component without a model is listening for changes",
                        this.$aml));
                

                return model.$waitForXml(this);
            }
        }
        
        
        //@todo apf3.0
        if (apf.$lm_has_lang)
            apf.language.addBinding(this); //@todo should auto remove
        

        //For tree based nodes, update all the nodes up
        pNode = xmlNode ? xmlNode.parentNode : lastParent;
        if (this.$isTreeArch && pNode && pNode.nodeType == 1) {
            do {
                htmlNode = this.$findHtmlNode(pNode.getAttribute(
                    apf.xmldb.xmlIdTag) + "|" + this.$uniqueId);

                if (htmlNode)
                    this.$updateNode(pNode, htmlNode);
            }
            while ((pNode = this.getTraverseParent(pNode)) && pNode.nodeType == 1);
        }

        //Make sure the selection doesn't become corrupted
        if (actionFeature[action] & 32 && this.selectable
          && startNode == xmlNode
          && (action != "insert" || xmlNode == this.xmlRoot)) {

            clearTimeout(this.$selectTimer.timer);
            // Determine next selection
            if (action == "remove" && apf.isChildOf(xmlNode, this.selected, true)
              || xmlNode == this.$selectTimer.nextNode)
                this.$selectTimer.nextNode = this.getDefaultNext(xmlNode, this.$isTreeArch);

            //@todo Fix this by putting it after xmlUpdate when its using a timer
            var _self = this;
            this.$selectTimer.timer = $setTimeout(function(){
                _self.$checkSelection(_self.$selectTimer.nextNode);
                _self.$selectTimer.nextNode = null;
            });
        }

        
        //Set dynamic properties that relate to the changed content
        if (actionFeature[action] & 64) {
            if (!length)
                length = this.xmlRoot.selectNodes(this.each).length;
            if (length != this.length)
                this.setProperty("length", length);
        }
        

        //Let's signal components that are waiting for xml to appear (@todo what about clearing the signalXmlUpdate)
        if (this.signalXmlUpdate && actionFeature[action] & 16) {
            var uniqueId;
            for (uniqueId in this.signalXmlUpdate) {
                if (parseInt(uniqueId) != uniqueId) continue; //safari_old stuff

                var o = apf.lookup(uniqueId);
                if (!this.selected) continue;

                xmlNode = this.selected.selectSingleNode(o.dataParent.xpath);
                if (!xmlNode) continue;

                o.load(xmlNode);
            }
        }

        this.dispatchEvent("xmlupdate", {
            action : action,
            xmlNode: xmlNode,
            result : result,
            UndoObj: UndoObj
        });
    };

    /**
     * Loop through NodeList of selected Traverse Nodes
     * and check if it has representation. If it doesn't
     * representation is created via $add().
     */
    this.$addNodes = function(xmlNode, parent, checkChildren, isChild, insertBefore){
        
        if (!this.each) {
            throw new Error(apf.formatErrorString(1060, this,
                "adding Nodes for load",
                "No each SmartBinding rule was specified. This rule is \
                 required for a " + this.localName + " component.", this.$aml));
        }
        

        var htmlNode, lastNode;
        isChild          = (isChild && (this.renderRoot && xmlNode == this.xmlRoot
            || this.isTraverseNode(xmlNode)));
        var nodes        = isChild ? [xmlNode] : this.getTraverseNodes(xmlNode);
        /*var loadChildren = nodes.length && this.$bindings["insert"]
            ? this.$applyBindRule("insert", xmlNode)
            : false; << UNUSED */

        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].nodeType != 1) continue;

            if (checkChildren)
                htmlNode = this.$findHtmlNode(nodes[i].getAttribute(apf.xmldb.xmlIdTag)
                    + "|" + this.$uniqueId);

            if (!htmlNode) {
                //Retrieve DataBind ID
                var Lid = apf.xmldb.nodeConnect(this.documentId, nodes[i], null, this);

                //Add Children
                var beforeNode = isChild
                        ? insertBefore
                        : (lastNode ? lastNode.nextSibling : null),//(parent || this.$int).firstChild);
                    parentNode = this.$add(nodes[i], Lid, isChild ? xmlNode.parentNode : xmlNode,
                        beforeNode ? parent || this.$int : parent, beforeNode,
                        (!beforeNode && i == nodes.length - 1));//Should use getTraverParent

                //Exit if component tells us its done with rendering
                if (parentNode === false) {
                    //Tag all needed xmlNodes for future reference
                    // @todo apf3.0 code below looks harmful... hence commented out (Mike)
                    /*for (var j = i; j < nodes.length; j++)
                        apf.xmldb.nodeConnect(this.documentId, nodes[j],
                            null, this);*/
                    break;
                }

                //Parse Children Recursively -> optimize: don't check children that can't exist
                //if(this.$isTreeArch) this.$addNodes(nodes[i], parentNode, checkChildren);
            }

            if (checkChildren)
                lastNode = htmlNode;// ? htmlNode.parentNode.parentNode : null;
        }

        return nodes;
    };

    this.$handleBindingRule = function(value, prop){
        if (!value)
            this[prop] = null;

        //@todo apf3.0 fix parsing
        if (prop == "each") {
            if (value.indexOf("::") > -1) {
                value = value.replace(/^\[|\]$/g, "").split("::"); //@todo could be optimized
                this.setProperty("model", value[0]);
                this.each = value[1];
            }
            else
                this.each = value.replace(/^\[|\]$/g, ""); 
        }

        //@todo apf3.0 find a better heuristic (portal demo)
        if (false && this.xmlRoot && !this.$bindRuleTimer && this.$amlLoaded) {
            var _self = this;
            apf.queue.add("reload" + this.$uniqueId, function(){
                _self.reload();
            });
        }
    };
    
    this.$select = function(o){
        
        if (this.renaming)
            this.stopRename(null, true);
        

        if (!o || !o.style)
            return;
        return this.$setStyleClass(o, "selected");
    };

    this.$deselect = function(o){
        
        if (this.renaming) {
            this.stopRename(null, true);

            if (this.ctrlselect)
                return false;
        }
        

        if (!o)
            return;
        return this.$setStyleClass(o, "", ["selected", "indicate"]);
    };

    this.$indicate = function(o){
        
        if (this.renaming)
            this.stopRename(null, true);
        

        if (!o)
            return;
        return this.$setStyleClass(o, "indicate");
    };

    this.$deindicate = function(o){
        
        if (this.renaming)
            this.stopRename(null, true);
        

        if (!o)
            return;
        return this.$setStyleClass(o, "", ["indicate"]);
    };

    
    /**
     * @attribute {String} each the xpath statement that determines which
     * {@link term.datanode data nodes} are rendered by this element (also known
     * as {@link term.eachnode each nodes}. See
     * {@link baseclass.multiselectbinding.binding.each} for more information.
     * Example:
     * <code>
     *  <a:label>Country</a:label>
     *  <a:dropdown
     *      model     = "mdlCountries"
     *      each      = "[country]"
     *      eachvalue = "[@value]"
     *      caption   = "[text()]">
     *  </a:dropdown>
     *
     *  <a:model id="mdlCountries">
     *      <countries>
     *          <country value="USA">USA</country>
     *          <country value="GB">Great Brittain</country>
     *          <country value="NL">The Netherlands</country>
     *          ...
     *      </countries>
     *  </a:model>
     * </code>
     * @see  baseclass.multiselectbinding.binding.each
     */
    this.$propHandlers["each"] =

    /**
     * @attribute {String} caption the xpath statement that determines from
     * which xml node the caption is retrieved.
     * Example:
     * <code>
     *  <a:list caption="[text()]" each="[item]" />
     * </code>
     */
    this.$propHandlers["caption"]  =
    
    /**
     * @attribute {String} valuerule the xpath statement that determines from
     * which xml node the value is retrieved.
     * Example:
     * <code>
     *  <a:list valuerule="@value" each="[item]" />
     * </code>
     * @see  baseclass.multiselect.binding.value
     */
    this.$propHandlers["eachvalue"]  =

    /**
     * @attribute {String} icon the xpath statement that determines from
     * which xml node the icon url is retrieved.
     * Example:
     * <code>
     *  <a:list icon="[@icon]" each="[item]" />
     * </code>
     */
    this.$propHandlers["icon"]     =

    /**
     * @attribute {String} tooltip the xpath statement that determines from
     * which xml node the tooltip text is retrieved.
     * Example:
     * <code>
     *  <a:list tooltip="[text()]" each="[item]" />
     * </code>
     */
    this.$propHandlers["tooltip"]  = this.$handleBindingRule;

    
    /**
     * @attribute {String} sort the xpath statement that selects the sortable value.
     * Example:
     * <code>
     *  <a:list sort="[@name]" each="[person]" />
     * </code>
     * @see  element.each.attribute.sort
     */
    this.$propHandlers["sort"] = function(value){
        if (value) {
            this.$sort = new apf.Sort()
            this.$sort.set({
                getValue : apf.lm.compile(value)
            });
        }
        else {
            this.$sort = null;
        }
    }
    

    /**
     * @attribute {String} select the xpath statement that determines whether
     * this node is selectable.
     * Example:
     * <code>
     *  <a:list select="{[@disabled] != 1}" each="[item]" />
     * </code>
     * @see  baseclass.multiselect.binding.select
     */
    //this.$propHandlers["select"]   = 
    
}).call(apf.MultiselectBinding.prototype = new apf.DataBinding());


/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/databinding/standard.js)SIZE(6499)TIME(1263859264)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @constructor
 * @private
 * @baseclass
 */
apf.StandardBinding = function(){
    this.$init(true);
    
    
    if (apf.Validation)
        this.implement(apf.Validation);
    
    
    if (!this.setQueryValue)
        this.implement(apf.DataBinding);

    if (!this.defaultValue) //@todo please use this in a sentence
        this.defaultValue = "";

    /**
     * Load XML into this element
     * @private
     */
    this.$load = function(xmlNode){
        //Add listener to XMLRoot Node
        apf.xmldb.addNodeListener(xmlNode, this);
        //Set Properties

        
        var b, lrule, rule, bRules, bRule, value;
        if (b = this.$bindings) {
	        for (rule in b) {
	            lrule = rule.toLowerCase();
	            if (this.$supportedProperties.indexOf(lrule) > -1) {
	                bRule = (bRules = b[lrule]).length == 1 
                      ? bRules[0] 
                      : this.$getBindRule(lrule, xmlNode);

                    value = bRule.value || bRule.match;

	                
                    //Remove any bounds if relevant
                    this.$clearDynamicProperty(lrule);
            
                    if (value.indexOf("{") > -1 || value.indexOf("[") > -1)
                        this.$setDynamicProperty(lrule, value);
                    else 
                    
                    if (this.setProperty)
                        this.setProperty(lrule, value, true);
	            }
	        }
	    }
        

        //Think should be set in the event by the Validation Class
        if (this.errBox && this.isValid && this.isValid())
            this.clearError();
    };

    /**
     * Set xml based properties of this element
     * @private
     */
    this.$xmlUpdate = function(action, xmlNode, listenNode, UndoObj){
        //Clear this component if some ancestor has been detached
        if (action == "redo-remove") {
            var retreatToListenMode = false, model = this.getModel(true);
            if (model) {
                var xpath = model.getXpathByAmlNode(this);
                if (xpath) {
                    xmlNode = model.data.selectSingleNode(xpath);
                    if (xmlNode != this.xmlRoot)
                        retreatToListenMode = true;
                }
            }
            
            if (retreatToListenMode || this.xmlRoot == xmlNode) {
                
                //RLD: Disabled because sometimes indeed components do not 
                //have a model when their xmlRoot is removed.
                if (!model) {
                    throw new Error(apf.formatErrorString(0, this, 
                        "Setting change notifier on component", 
                        "Component without a model is listening for changes", 
                        this.$aml));
                }
                

                //Set Component in listening state untill data becomes available again.
                return model.$waitForXml(this);
            }
        }

        //Action Tracker Support
        if (UndoObj && !UndoObj.xmlNode)
            UndoObj.xmlNode = this.xmlRoot;

        //Set Properties

        
        var b, lrule, rule, bRules, bRule, value;
        if (b = this.$bindings) {
	        for (rule in b) {
	            lrule = rule.toLowerCase();
	            if (this.$supportedProperties.indexOf(lrule) > -1) {
                    bRule = (bRules = b[lrule]).length == 1 
                      ? bRules[0] 
                      : this.$getBindRule(lrule, xmlNode);

                    value = bRule.value || bRule.match;

	                
                    //Remove any bounds if relevant
                    this.$clearDynamicProperty(lrule);
            
                    if (value.indexOf("{") > -1 || value.indexOf("[") > -1)
                        this.$setDynamicProperty(lrule, value);
                    else 
                    
                    if (this.setProperty)
                        this.setProperty(lrule, value);
	            }
	        }
	    }
        

        //@todo Think should be set in the event by the Validation Class
        if (this.errBox && this.isValid && this.isValid())
            this.clearError();
        
        this.dispatchEvent("xmlupdate", {
            action : action,
            xmlNode: xmlNode,
            UndoObj: UndoObj
        });
    };

    /**
     * Clears the data loaded into this element resetting it's value.
     */
    //@todo apf3.0 this is wrong
    this.addEventListener("$clear", function(nomsg, do_event){
        if (this.$propHandlers && this.$propHandlers["value"]) {
            this.value = -99999; //force resetting
            this.$propHandlers["value"].call(this, "");
        }
    });
};
apf.StandardBinding.prototype = new apf.DataBinding();

apf.Init.run("standardbinding");


/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/multiselect.js)SIZE(68826)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__MULTISELECT__ = 1 << 8;



/**
 * @term eachnode A each node is a {@link term.datanode data node} that is in the set selected by the 
 * {@link baseclass.multiselectbinding.binding.each each binding rule}.
 * These {@link term.datanode data nodes} get representation within the visual element. For instance
 * each item in a list is connected to such a each node. A each node
 * can be selected, removed, added, dragged, dropped and so on. 
 * Example:
 * In this example the person nodes that have the show attribute set to 1 are the 
 * each nodes of the list. This list will display three items.
 * <code>
 *  <a:list>
 *      <a:bindings>
 *          <a:caption match="[@name]" />
 *          <a:each match="[person[@show='1']]" />
 *      </a:bindings>
 *      <a:model>
 *          <data>
 *              <person name="test 5"/>
 *              <person show="1" name="test 3"/>
 *              <person name="test 4"/>
 *              <person show="1" name="test 2"/>
 *              <person show="1" name="test 1"/>
 *          </data>
 *      </a:model>
 *  </a:list>
 * </code>
 * Remarks:
 * A somewhat advanced topic is understanding how an element can use the 
 * each {@link term.binding binding rule}. For the tree this binding rules
 * can be used to create a virtual tree mapping of the xml.
 */

/**
 * @term caret When selecting nodes in a list using the keyboard, the caret is 
 * the indication of the position within that list. The item that the caret is
 * on might or might not be selected. This feature is especially useful when 
 * holding the control key or using the shift key to multi select items.
 */

/**
 * All elements inheriting from this {@link term.baseclass baseclass} have selection features. This includes handling
 * for multiselect and several keyboard based selection interaction. It also
 * takes care of {@link term.caret caret} handling when multiselect is enabled. Furthermore features 
 * for dealing with multinode component are included like adding and removing 
 * {@link term.datanode data nodes}.
 *
 * @constructor
 * @baseclass
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.5
 *
 * @inherits apf.MultiselectBinding
 *
 * @binding select Determines whether the {@link term.eachnode each node} can be selected.
 * Example:
 * In this example the tree contains nodes that have a disabled flag set. 
 * These nodes cannot be selected
 * <code>
 *  <a:tree width="200">
 *      <a:bindings>
 *          <a:select match="[self::node()[not(@disabled) or @disabled != 'true']]" />
 *          <a:each match="[person]"></a:each>
 *          <a:caption match="[@name]"></a:caption>
 *      </a:bindings>
 *      <a:model>
 *          <data>
 *              <person disabled="false" name="test 5"/>
 *              <person disabled="true" name="test 3"/>
 *              <person name="test 4"/>
 *              <person disabled="true" name="test 2"/>
 *              <person disabled="true" name="test 1"/>
 *          </data>
 *      </a:model>
 *  </a:tree>
 * </code>
 * @binding value  Determines the way the value for the element is retrieved
 * from the selected node. The value property contains this value.
 * Example:
 * <code>
 *  <a:dropdown onafterchange="alert(this.value)">
 *      <a:bindings>
 *          <a:caption match="[text()]" />
 *          <a:value match="[@value]" />
 *          <a:each match="[item]" />
 *      </a:bindings>
 *      <a:model>
 *          <items>
 *              <item value="#FF0000">red</item>
 *              <item value="#00FF00">green</item>
 *              <item value="#0000FF">blue</item>
 *          </items>
 *      </a:model>
 *  </a:dropdown>
 * </code>
 */
apf.MultiSelect = function(){
    this.$init(function(){
        this.$valueList       = [];
        this.$selectedList    = [];
    });
};

//@todo investigate if selectedList can be deprecated
(function() {
    this.$regbase    = this.$regbase|apf.__MULTISELECT__;

    /**** Properties ****/

    /**
     * the last selected item of this element.
     * @type {XMLElement} 
     */
    this.sellength    = 0;
    this.selected     = null;
    this.$selected    = null;
    
    /**
     * the xml element that has the {@link term.caret caret}.
     * @type {XMLElement} 
     */
    this.caret    = null;
    this.$caret   = null;
    
    /**
     * whether to use a {@link term.caret caret} in the interaction of this element.
     * @type {Boolean} 
     */
    this.useindicator = true;

    

    /**
     * Removes an {@link term.datanode data node} from the data of this element.
     * Example:
     * A simple list showing products. This list is used in all following examples.
     * <code>
     *  <a:list id="myList">
     *      <a:bindings>
     *          <a:caption match="[@name]" />
     *          <a:value match="[@id]" />
     *          <a:icon>[@type].png</a:icon>
     *          <a:each match="[product]" />
     *      </a:bindings>
     *      <a:model>
     *          <products>
     *              <product name="Soundblaster" type="audio"    id="product10" />
     *              <product name="Teapot"       type="3d"       id="product13" />
     *              <product name="Coprocessor"  type="chips"    id="product15" />
     *              <product name="Keyboard"     type="input"    id="product17" />
     *              <product name="Diskdrive"    type="storage"  id="product20" />
     *          </products>
     *      </a:model>
     *  </a:list>
     * </code>
     * Example:
     * This example selects a product by it's value and then removes the
     * selection.
     * <code>
     *  <a:script>
     *      myList.setValue("product20");
     *      myList.remove();
     *  </a:script>
     * </code>
     * Example:
     * This example gets a product by it's value and then removes it.
     * <code>
     *  <a:script>
     *      var xmlNode = myList.findXmlNodeByValue("product20");
     *      myList.remove(xmlNode);
     *  </a:script>
     * </code>
     * Example:
     * This example retrieves all nodes from a list. All items with a length
     * greater than 10 are singled out and removed.
     * <code>
     *  <a:script><![CDATA[
     *      apf.onload = function() {
     *          var list = myList.getTraverseNodes();
     * 
     *          var removeList = [];
     *          for (var i = 0; i < list.length; i++) {
     *              if (list[i].getAttribute("length") > 10)
     *                  removeList.push(list[i]);
     *          }
     *          myList.remove(removeList);
     *      }
     *   ]]></a:script>
     * </code>
     * Remarks:
     * Another way to trigger this method is by using the action attribute on a
     * button.
     * <code>
     *  <a:button action="remove" target="myList">Remove item</a:button>
     * </code>
     * Using the action methodology you can let the original data source
     * (usually the server) know that the user removed an item.
     * <code>
     *     <a:list>
     *         <a:bindings />
     *         <a:remove set="remove_product.php?id=[@id]" />
     *     </a:list>
     * </code>
     * For undo this action should be extended and the server should maintain a
     * copy of the deleted item.
     * <code>
     *  <a:list actiontracker="atList">
     *      <a:bindings />
     *      <a:remove set  = "remove_product.php?id=[@id]"
     *                undo = "undo_remove_product.php?id=[@id]" />
     *  </a:list>
     *  <a:button 
     *    action = "remove" 
     *    target = "myList">Remove item</a:button>
     *   <a:button 
     *     caption  = "Undo"
     *     disabled = "{!atList.undolength}" 
     *     onclick  = "atList.undo()" />
     * </code>
     * @action
     * @param  {mixed} [nodeList]  the {@link term.datanode data node}(s) to be removed. If none are specified, the current selection is removed.
     *   Possible values:
     *   {NodeList}   the {@link term.datanode data nodes} to be removed.
     *   {XMLElement} the {@link term.datanode data node} to be removed.
     * @return  {Boolean}  specifies if the removal succeeded
     */
    this.remove = function(nodeList){
        //Use the current selection if no xmlNode is defined
        if (!nodeList)
            nodeList = this.$valueList;

        //If we're an xml node let's convert
        if (nodeList.nodeType)
            nodeList = [nodeList];

        //If there is no selection we'll exit, nothing to do
        if (!nodeList || !nodeList.length)
            return;

        
        //We're not removing the XMLRoot, that would be suicide ;)
        if (nodeList.contains(this.xmlRoot)) {
            throw new Error(apf.formatErrorString(0,
                "Removing nodes",
                "You are trying to delete the xml root of this \
                 element. This is not allowed."));
        }
        

        var changes = [];
        for (var i = 0; i < nodeList.length; i++) {
            changes.push({
                func : "removeNode",
                args : [nodeList[i]]
            });
        }

        if (this.$actions["removegroup"])
            return this.$executeAction("multicall", changes, "removegroup", nodeList[0]);
        else {
            return this.$executeAction("multicall", changes, "remove", 
              nodeList[0], null, null, nodeList.length > 1 ? nodeList : null);
        }
    };
    
    /**
     * Adds an {@link term.datanode data node} to the data of this element.
     * Example:
     * A simple list showing products. This list is used in all following examples.
     * <code>
     *  <a:list id="myList">
     *      <a:bindings>
     *          <a:caption match="[@name]" />
     *          <a:value match="[@id]" />
     *          <a:icon>[@type].png</a:icon>
     *          <a:each match="[product]" />
     *      </a:bindings>
     *      <a:model>
     *          <products>
     *              <product name="Soundblaster" type="audio"    id="product10" />
     *              <product name="Teapot"       type="3d"       id="product13" />
     *              <product name="Coprocessor"  type="chips"    id="product15" />
     *              <product name="Keyboard"     type="input"    id="product17" />
     *              <product name="Diskdrive"    type="storage"  id="product20" />
     *          </products>
     *      </a:model>
     *  </a:list>
     * </code>
     * Example:
     * This example adds a product to this element.
     * selection.
     * <code>
     *  <a:script><![CDATA[
     *      apf.onload = function() {
     *          myList.add('<product name="USB drive" type="storage" />');
     *      }
     *  ]]></a:script>
     * </code>
     * Example:
     * This example copy's the selected product, changes it's name and then
     * adds it. After selecting the new node the user is offered a rename input
     * box.
     * <code>
     *  var xmlNode = apf.xmldb.copy(myList.selected);
     *  xmlNode.setAttribute("name", "New product");
     *  myList.add(xmlNode);
     *  myList.select(xmlNode);
     *  myList.startRename();
     * </code>
     * Remarks:
     * Another way to trigger this method is by using the action attribute on a
     * button.
     * <code>
     *  <a:list>
     *      <a:bindings />
     *      <a:model />
     *      <a:add>
     *          <product name="New item" />
     *      </a:add>
     *  </a:list>
     *  <a:button action="add" target="myList">Add new product</a:button>
     * </code>
     * Using the action methodology you can let the original data source
     * (usually the server) know that the user added an item.
     * <code>
     *  <a:add set="{comm.addProduct([.])}" />
     * </code>
     * For undo this action should be extended as follows.
     * <code>
     *  <a:list id="myList" actiontracker="atList">
     *      <a:bindings />
     *      <a:model />
     *      <a:add set  = "add_product.php?xml=%[.]"
     *             undo = "remove_product.php?id=[@id]">
     *          <product name="New product" id="productId" />
     *      </a:add>
     *  </a:list>
     *  <a:button 
     *    action = "add" 
     *    target = "myList">Add new product</a:button>
     *  <a:button
     *     caption  = "Undo"
     *     disabled = "{!atList.undolength}" 
     *     onclick  = "atList.undo()" />
     * </code>
     * In some cases the server needs to create the new product before it's
     * added. This is done as follows.
     * <code>
     *  <a:add get="{comm.createNewProduct()}" />
     * </code>
     * Alternatively the template for the addition can be provided as a child of
     * the action rule.
     * <code>
     *  <a:add set="add_product.php?xml=%[.]">
     *      <product name="USB drive" type="storage" />
     *  </a:add>
     * </code>
     * @action
     * @param  {XMLElement} [xmlNode]    the {@link term.datanode data node} which is added. If none is specified the action will use the action rule to try to retrieve a new node to add.
     * @param  {XMLElement} [pNode]      the parent node of the added {@link term.datanode data node}.
     * @param  {XMLElement} [beforeNode] the position where the xml element should be inserted.
     * @return  {XMLElement} the added {@link term.datanode data node} or false on failure.
     */
    this.add = function(xmlNode, pNode, beforeNode, userCallback){
        var rule;

        if (this.$actions) {
            if (xmlNode && xmlNode.nodeType)
                rule = this.$actions.getRule("add", xmlNode);
            else if (typeof xmlNode == "string") {
                if (xmlNode.trim().charAt(0) == "<") {
                    xmlNode = apf.getXml(xmlNode);
                    rule = this.$actions.getRule("add", xmlNode);
                }
                else {
                    var rules = this.$actions["add"];
                    for (var i = 0, l = rules.length; i < l; i++) {
                        if (rules[i][2].getAttribute("type") == xmlNode) {
                            xmlNode = null;
                            rule = rules[i];
                            break;
                        }
                    }
                }
            }

            if (!rule) 
                rule = (this.$actions["add"] || {})[0];
        }
        else
            rule = null;
            
        
        var bHasOffline = (typeof apf.offline != "undefined");
        if (bHasOffline && !apf.offline.canTransact())
            return false;

        if (bHasOffline && !apf.offline.onLine && (!xmlNode || !rule.get))
            return false;
        
        
        var refNode  = this.$isTreeArch ? this.selected || this.xmlRoot : this.xmlRoot,
            amlNode  = this,
        callback = function(addXmlNode, state, extra){
            if (state != apf.SUCCESS) {
                var oError;

                oError = new Error(apf.formatErrorString(1032, amlNode,
                    "Loading xml data",
                    "Could not add data for control " + amlNode.name
                    + "[" + amlNode.tagName + "] \nUrl: " + extra.url
                    + "\nInfo: " + extra.message + "\n\n" + xmlNode));

                if (extra.tpModule.retryTimeout(extra, state, amlNode, oError) === true)
                    return true;

                throw oError;
            }

            /*if (apf.supportNamespaces && node.namespaceURI == apf.ns.xhtml) {
                node = apf.getXml(node.xml.replace(/xmlns\=\"[^"]*\"/g, ""));
                //@todo import here for webkit?
            }*/

            if (typeof addXmlNode != "object")
                addXmlNode = apf.getXmlDom(addXmlNode).documentElement;
            if (addXmlNode.getAttribute(apf.xmldb.xmlIdTag))
                addXmlNode.setAttribute(apf.xmldb.xmlIdTag, "");

            var actionNode = amlNode.$actions &&
              amlNode.$actions.getRule("add", amlNode.$isTreeArch
                ? amlNode.selected
                : amlNode.xmlRoot);
            if (!pNode) {
                if (actionNode && actionNode.parent) {
                    pNode = (actionNode.cparent 
                      || actionNode.compile("parent", {
                        xpathmode  : 2, 
                        injectself : true
                      }))(amlNode.$isTreeArch
                          ? amlNode.selected || amlNode.xmlRoot
                          : amlNode.xmlRoot);
                }
                else {
                    pNode = amlNode.$isTreeArch
                      ? amlNode.selected || amlNode.xmlRoot
                      : amlNode.xmlRoot
                }
            }

            if (!pNode)
                pNode = amlNode.xmlRoot;

            //Safari issue not auto importing nodes:
            if (apf.isWebkit && pNode.ownerDocument != addXmlNode.ownerDocument)
                addXmlNode = pNode.ownerDocument.importNode(addXmlNode, true); 

            
            if (!pNode) {
                throw new Error(apf.formatErrorString(0, amlNode,
                    "Executing add action",
                    "Missing parent node. You can only add nodes to a list if it\
                     has data loaded. Unable to perform action."));
            }
            

            if (amlNode.$executeAction("appendChild",
              [pNode, addXmlNode, beforeNode], "add", addXmlNode) !== false
              && amlNode.autoselect)
                amlNode.select(addXmlNode);

            if (userCallback)
                userCallback.call(amlNode, addXmlNode);

            return addXmlNode;
        };

        if (xmlNode)
            return callback(xmlNode, apf.SUCCESS);
        else {
            if (rule.get)
                return apf.getData(rule.get, {xmlNode: refNode, callback: callback})
            else {
                
                throw new Error(apf.formatErrorString(0, this,
                    "Executing add action",
                    "Missing add action defined in action rules. Unable to \
                     perform action."));
                
            }
        }

        return addXmlNode;
    };

    if (!this.setValue) {
        /**
         * Sets the value of this element.The value
         * corresponds to an item in the list of loaded {@link term.datanode data nodes}. This
         * element will receive the selection. If no {@link term.datanode data node} is found, the
         * selection is cleared.
         *
         * @param  {String}  value  the new value for this element.
         * @param  {Boolean} disable_event
         * @see baseclass.multiselect.method.getValue
         */
        this.setValue = function(value, disable_event){
            // @todo apf3.0 what does noEvent do? in this scope it's useless and
            // doesn't improve codeflow with a global lookup and assignment
            noEvent = disable_event;
            this.setProperty("value", value, false, true);
            noEvent = false;
        };
    }

    /**
     * Retrieves an {@link term.datanode data node} that has a value that corresponds to the
     * string that is searched on.
     * @param {String} value the value to match.
     */
    this.findXmlNodeByValue = function(value){
        var nodes   = this.getTraverseNodes(),
            bindSet = this.$attrBindings["eachvalue"]
                && "eachvalue" || this.$bindings["value"]
                && "value" || this.$hasBindRule("caption") && "caption";
        
        if (!bindSet)
            return false;
            
        for (var i = 0; i < nodes.length; i++) {
            if (this.$applyBindRule(bindSet, nodes[i]) == value)
                return nodes[i];
        }
    };

    if (!this.getValue) {
        /**
         * Retrieves the value of this element. This is the value of the
         * first selected {@link term.datanode data node}.
         * @see #setValue
         */
        this.getValue = function(xmlNode, noError){
            return this.value;
            /*
            if (!this.bindingRules && !this.caption) 
                return false;

            
            if (!this.caption && !this.bindingRules[this.$mainBind] && !this.bindingRules["caption"]) {
                if (noError)
                    return false;
                
                throw new Error(apf.formatErrorString(1074, this,
                    "Retrieving the value of this component.",
                    "No value rule has been defined. There is no way \
                     to determine the value of the selected item."));
            }
            

            return this.$applyBindRule(this.$mainBind, xmlNode || this.selected, null, true)
                || this.$applyBindRule("caption", xmlNode || this.selected, null, true);
            */
        };
    }

    /**
     * Select the current selection again.
     *
     * @todo Add support for multiselect
     */
    this.reselect = function(){
        if (this.selected) this.select(this.selected, null, this.ctrlselect,
            null, true);//no support for multiselect currently.
    };

    /**
     * Selects a single, or set of {@link term.eachnode each nodes}.
     * The selection can be visually represented in this element.
     *
     * @param {mixed}   xmlNode      the identifier to determine the selection.
     *   Possible values:
     *   {XMLElement}  the {@link term.datanode data node} to be used in the selection as a start/end point or to toggle the selection on the node.
     *   {HTMLElement} the html element node used as visual representation of {@link term.datanode data node}. Used to determine the {@link term.datanode data node} for selection.
     *   {String}      the value of the {@link term.datanode data node} to be select.
     * @param {Boolean} [ctrlKey]    whether the Ctrl key was pressed
     * @param {Boolean} [shiftKey]   whether the Shift key was pressed
     * @param {Boolean} [fakeselect] whether only visually a selection is made
     * @param {Boolean} [force]      whether reselect is forced.
     * @param {Boolean} [noEvent]    whether to not call any events
     * @return  {Boolean}  whether the selection could be made
     *
     * @event  beforeselect  Fires before a {@link baseclass.multiselect.method.select selection} is made
     *   object:
     *   {XMLElement}  selected the {@link term.datanode data node} that will be selected.
     *   {Array}       selection an array of {@link term.datanode data node} that will be selected.
     *   {HTMLElement} htmlNode the html element that visually represents the {@link term.datanode data node}.
     * @event  afterselect  Fires after a {@link baseclass.multiselect.method.select selection} is made
     *   object:
     *   {XMLElement}  selected  the {@link term.datanode data node} that was selected.
     *   {Array}       selection an array of {@link term.datanode data node} that are selected.
     *   {HTMLElement} htmlNode the html element that visually represents the {@link term.datanode data node}.
     */
    this.select  = function(xmlNode, ctrlKey, shiftKey, fakeselect, force, noEvent){
        if (!this.selectable || this.disabled) return;

        if (this.$skipSelect) {
            this.$skipSelect = false;
            return;
        }

        if (this.ctrlselect && !shiftKey)
            ctrlKey = true;

        if (!this.multiselect)
            ctrlKey = shiftKey = false;
        
        // Selection buffering (for async compatibility)
        if (!this.xmlRoot) {
            if (!this.$buffered) {
                var f;
                this.addEventListener("afterload", f = function(){
                    this.select.apply(this, this.$buffered);
                    this.removeEventListener("afterload", f);
                    delete this.$buffered;
                });
            }

            this.$buffered = Array.prototype.slice.call(arguments);
            return;
        }

        var htmlNode;

        /**** Type Detection ****/
        if (!xmlNode) {
            
            throw new Error(apf.formatErrorString(1075, this,
                "Making a selection",
                "No selection was specified"))
            

            return false;
        }

        if (typeof xmlNode != "object") {
            var str = xmlNode; xmlNode = null;
            if (typeof xmlNode == "string")
                xmlNode = apf.xmldb.getNodeById(str);

            //Select based on the value of the xml node
            if (!xmlNode) {
                xmlNode = this.findXmlNodeByValue(str);
                if (!xmlNode) {
                    this.clearSelection(noEvent);
                    return;
                }
            }
        }
        
        if (!xmlNode.style) {
            htmlNode = this.$findHtmlNode(xmlNode.getAttribute(
                    apf.xmldb.xmlIdTag) + "|" + this.$uniqueId);
        }
        else {
            var id = (htmlNode = xmlNode).getAttribute(apf.xmldb.htmlIdTag);
            while (!id && htmlNode.parentNode)
                id = (htmlNode = htmlNode.parentNode).getAttribute(
                    apf.xmldb.htmlIdTag);

            xmlNode = apf.xmldb.getNodeById(id);//, this.xmlRoot);
        }

        if(this.dispatchEvent('beforeselect', {
            selected    : xmlNode,
            htmlNode    : htmlNode,
            ctrlKey     : ctrlKey,
            shiftKey    : shiftKey,
            force       : force,
            captureOnly : noEvent
        }) === false)
              return false;

        /**** Selection ****/

        var lastIndicator = this.caret;
        this.caret        = xmlNode;

        //Multiselect with SHIFT Key.
        if (shiftKey) {
            var range = this.$calcSelectRange(
              this.$valueList[0] || lastIndicator, xmlNode);

            if (this.$caret)
                this.$deindicate(this.$caret);

            this.selectList(range);

            this.$selected  =
            this.$caret     = this.$indicate(htmlNode);
        }
        else if (ctrlKey) { //Multiselect with CTRL Key.
            //Node will be unselected
            if (this.$valueList.contains(xmlNode)) {
                if (this.selected == xmlNode) {
                    this.$deselect(this.$findHtmlNode(this.selected.getAttribute(
                        apf.xmldb.xmlIdTag) + "|" + this.$uniqueId));
                    
                    this.$deindicate(this.$caret);

                    if (this.$valueList.length && !fakeselect) {
                        //this.$selected = this.$selectedList[0];
                        this.selected = this.$valueList[0];
                    }
                }
                else
                    this.$deselect(htmlNode, xmlNode);

                if (!fakeselect) {
                    this.$selectedList.remove(htmlNode);
                    this.$valueList.remove(xmlNode);
                }

                if (htmlNode != this.$caret)
                    this.$deindicate(this.$caret);

                this.$selected  =
                this.$caret     = this.$indicate(htmlNode);
            }
            // Node will be selected
            else {
                if (this.$caret)
                    this.$deindicate(this.$caret);
                this.$caret = this.$indicate(htmlNode, xmlNode);

                this.$selected   = this.$select(htmlNode, xmlNode);
                this.selected    = xmlNode;

                if (!fakeselect) {
                    this.$selectedList.push(htmlNode);
                    this.$valueList.push(xmlNode);
                }
            }
        }
        else if (fakeselect && htmlNode && this.$selectedList.contains(htmlNode)) {//Return if selected Node is htmlNode during a fake select
            return;
        }
        else { //Normal Selection
            //htmlNode && this.$selected == htmlNode && this.$valueList.length <= 1 && this.$selectedList.contains(htmlNode)
            if (!force && !this.reselectable && this.$valueList.length <= 1 
              && this.$valueList.indexOf(xmlNode) > -1)
                return;

            if (this.$selected)
                this.$deselect(this.$selected);
            if (this.$caret)
                this.$deindicate(this.$caret);
            if (this.selected)
                this.clearSelection(true);

            this.$caret = this.$indicate(htmlNode, xmlNode);
            this.$selected  = this.$select(htmlNode, xmlNode);
            this.selected   = xmlNode;

            this.$selectedList.push(htmlNode);
            this.$valueList.push(xmlNode);
        }

        if (this.delayedselect && (typeof ctrlKey == "boolean")){
            var _self = this;
            $setTimeout(function(){
                _self.dispatchEvent("afterselect", {
                    selection   : _self.$valueList,
                    selected    : xmlNode,
                    caret       : _self.caret,
                    captureOnly : noEvent
                });
            }, 10);
        }
        else {
            this.dispatchEvent("afterselect", {
                selection   : this.$valueList,
                selected    : xmlNode,
                caret       : this.caret,
                captureOnly : noEvent
            });
        }

        return true;
    };

    /**
     * Choose a selected item. This is done by double clicking on the item or
     * pressing the Enter key.
     *
     * @param {mixed}   xmlNode      the identifier to determine the selection.
     *   Possible values:
     *   {XMLElement}  the {@link term.datanode data node} to be choosen.
     *   {HTMLElement} the html element node used as visual representation of {@link term.datanode data node}. Used to determine the {@link term.datanode data node}.
     *   {String}      the value of the {@link term.datanode data node} to be choosen.
     * @event  beforechoose  Fires before a choice is made.
     *   object:
     *   {XMLElement} xmlNode   the {@link term.datanode data node} that was choosen.
     * @event  afterchoose   Fires after a choice is made.
     *   object:
     *   {XMLElement} xmlNode   the {@link term.datanode data node} that was choosen.
     */
    this.choose = function(xmlNode){
        if (!this.selectable || this.disabled) return;

        if (this.dispatchEvent("beforechoose", {xmlNode : xmlNode}) === false)
            return false;

        if (xmlNode && !xmlNode.style)
            this.select(xmlNode);

        
        if (this.hasFeature(apf.__DATABINDING__)
          && this.dispatchEvent("afterchoose", {xmlNode : this.selected}) !== false)
            this.setProperty("chosen", this.selected);
        
    };

    /**
     * Removes the selection of one or more selected nodes.
     *
     * @param {Boolean} [singleNode] whether to only deselect the indicated node
     * @param {Boolean} [noEvent]    whether to not call any events
     */
    this.clearSelection = function(noEvent){
        if (!this.selectable || this.disabled || !this.$valueList.length)
            return;

        if (!noEvent) {
            if (this.dispatchEvent("beforeselect", {
                selection : [],
                selected  : null,
                caret     : this.caret
            }) === false)
                return false;
        }
        
        //Deselect html nodes
        var htmlNode;
        for (var i = this.$valueList.length - 1; i >= 0; i--) {
            htmlNode = this.$findHtmlNode(this.$valueList[i].getAttribute(
                    apf.xmldb.xmlIdTag) + "|" + this.$uniqueId);
            this.$deselect(htmlNode);
        }
        
        //Reset internal variables
        this.$selectedList.length = 0;
        this.$valueList.length    = 0;
        this.$selected            =
        this.selected             = null;

        //Redraw indicator
        if (this.caret) {
            htmlNode = this.$findHtmlNode(this.caret.getAttribute(
                    apf.xmldb.xmlIdTag) + "|" + this.$uniqueId);

            this.$caret = this.$indicate(htmlNode);
        }

        if (!noEvent) {
            this.dispatchEvent("afterselect", {
                selection : this.$valueList,
                selected  : null,
                caret     : this.caret
            });
        }
    };

    /**
     * Selects a set of items
     *
     * @param {Array} xmlNodeList the {@link term.datanode data nodes} that will be selected.
     */
    //@todo I think there are missing events here?
    this.selectList = function(xmlNodeList, noEvent, selected){
        if (!this.selectable || this.disabled) return;

        if (this.dispatchEvent("beforeselect", {
            selection   : xmlNodeList,
            selected    : selected || xmlNodeList[0],
            caret       : this.caret,
            captureOnly : noEvent
          }) === false)
            return false;

        this.clearSelection(true);

        for (var sel, i = 0; i < xmlNodeList.length; i++) {
            //@todo fix select state in unserialize after removing
            if (!xmlNodeList[i] || xmlNodeList[i].nodeType != 1) continue;
            var htmlNode,
                xmlNode = xmlNodeList[i];

            //Type Detection
            if (typeof xmlNode != "object")
                xmlNode = apf.xmldb.getNodeById(xmlNode);
            if (!xmlNode.style)
                htmlNode = this.$pHtmlDoc.getElementById(xmlNode.getAttribute(
                    apf.xmldb.xmlIdTag) + "|" + this.$uniqueId);
            else {
                htmlNode = xmlNode;
                xmlNode  = apf.xmldb.getNodeById(htmlNode.getAttribute(
                    apf.xmldb.htmlIdTag));
            }

            if (!xmlNode) {
                
                apf.console.warn("Component : " + this.name + " ["
                    + this.localName + "]\nMessage : xmlNode whilst selecting a "
                    + "list of xmlNodes could not be found. Ignoring.")
                
                continue;
            }

            //Select Node
            if (htmlNode) {
                if (!sel && selected == htmlNode)
                    sel = htmlNode;

                this.$select(htmlNode, xmlNode);
                this.$selectedList.push(htmlNode);
            }
            this.$valueList.push(xmlNode);
        }

        this.$selected = sel || this.$selectedList[0];
        this.selected  = selected || this.$valueList[0];

        this.dispatchEvent("afterselect", {
            selection   : this.$valueList,
            selected    : this.selected,
            caret       : this.caret,
            captureOnly : noEvent
        });
    };

    /**
     * Sets the {@link term.caret caret} on an item to indicate to the user that the keyboard
     * actions are done relevant to that item. Using the keyboard
     * a user can change the position of the indicator using the Ctrl and arrow
     * keys while not making a selection. When making a selection with the mouse
     * or keyboard the indicator is always set to the selected node. Unlike a
     * selection there can be only one indicator item.
     *
     * @param {mixed}   xmlNode      the identifier to determine the indicator.
     *   Possible values:
     *   {XMLElement}  the {@link term.datanode data node} to be set as indicator.
     *   {HTMLElement} the html element node used as visual representation of
     *                 {@link term.datanode data node}. Used to determine the {@link term.datanode data node}.
     *   {String}      the value of the {@link term.datanode data node} to be set as indicator.
     * @event indicate Fires when an item becomes the indicator.
     */
    this.setCaret = function(xmlNode){
        if (!xmlNode) {
            if (this.$caret)
                this.$deindicate(this.$caret);
            this.caret  =
            this.$caret = null;
            return;
        }

        /**** Type Detection ****/
        var htmlNode;
        if (typeof xmlNode != "object")
            xmlNode = apf.xmldb.getNodeById(xmlNode);
        if (!xmlNode.style) {
            htmlNode = this.$findHtmlNode(xmlNode.getAttribute(
                    apf.xmldb.xmlIdTag) + "|" + this.$uniqueId);
        }
        else {
            var id = (htmlNode = xmlNode).getAttribute(apf.xmldb.htmlIdTag);
            while (!id && htmlNode.parentNode)
                id = (htmlNode = htmlNode.parentNode).getAttribute(
                    apf.xmldb.htmlIdTag);

            xmlNode = apf.xmldb.getNodeById(id);
        }

        if (this.$caret) {
            //this.$deindicate(this.$findHtmlNode(this.caret.getAttribute(
                //apf.xmldb.xmlIdTag) + "|" + this.$uniqueId));
            this.$deindicate(this.$caret);
        }
        
        this.$caret = this.$indicate(htmlNode);
        this.setProperty("caret", this.caret = xmlNode);
    };

    /**
     * @private
     */
    this.$setTempSelected = function(xmlNode, ctrlKey, shiftKey, down){
        clearTimeout(this.timer);

        if (this.$bindings.selectable) {
            while (xmlNode && !this.$getDataNode("selectable", xmlNode)) {
                xmlNode = this.getNextTraverseSelected(xmlNode, !down);
            }
            if (!xmlNode) return;
        }

        if (!this.multiselect)
            ctrlKey = shiftKey = false;

        if (ctrlKey || this.ctrlselect) {
            if (this.$tempsel) {
                this.select(this.$tempsel);
                this.$tempsel = null;
            }

            this.setCaret(xmlNode);
        }
        else if (shiftKey){
            if (this.$tempsel) {
                this.$selectTemp();
                this.$deselect(this.$tempsel);
                this.$tempsel = null;
            }

            this.select(xmlNode, null, shiftKey);
        }
        else if (!this.bufferselect || this.$valueList.length > 1) {
            this.select(xmlNode);
        }
        else {
            var id = apf.xmldb.getID(xmlNode, this);

            this.$deselect(this.$tempsel || this.$selected);
            this.$deindicate(this.$tempsel || this.$caret);
            this.$tempsel = this.$indicate(document.getElementById(id));
            this.$select(this.$tempsel);

            var _self = this;
            this.timer = $setTimeout(function(){
                _self.$selectTemp();
            }, 400);
        }
    };

    /**
     * @private
     */
    this.$selectTemp = function(){
        if (!this.$tempsel)
            return;

        clearTimeout(this.timer);
        this.select(this.$tempsel);

        this.$tempsel = null;
        this.timer    = null;
    };

    /**
     * Selects all the {@link term.eachnode each nodes} of this element
     *
     */
    this.selectAll = function(){
        if (!this.multiselect || !this.selectable
          || this.disabled || !this.xmlRoot)
            return;

        var nodes = this.$isTreeArch
            ? this.xmlRoot.selectNodes(".//" 
              + this.each.split("|").join("|.//"))
            : this.xmlRoot.selectNodes(this.each);
        
        this.selectList(nodes);
    };

    /**
     * Retrieves an array or a document fragment containing all the selected
     * {@link term.datanode data nodes} from this element.
     *
     * @param {Boolean} [xmldoc] whether the method should return a document fragment.
     * @return {mixed} the selection of this element.
     */
    this.getSelection = function(xmldoc){
        var i, r;
        if (xmldoc) {
            r = this.xmlRoot
                ? this.xmlRoot.ownerDocument.createDocumentFragment()
                : apf.getXmlDom().createDocumentFragment();
            for (i = 0; i < this.$valueList.length; i++)
                apf.xmldb.cleanNode(r.appendChild(
                    this.$valueList[i].cloneNode(true)));
        }
        else {
            for (r = [], i = 0; i < this.$valueList.length; i++)
                r.push(this.$valueList[i]);
        }

        return r;
    };
    
    this.$getSelection = function(htmlNodes){
        return htmlNodes ? this.$selectedList : this.$valueList;
    };

    /**
     * Selects the next {@link term.datanode data node} to be selected.
     *
     * @param  {XMLElement}  xmlNode  the context {@link term.datanode data node}.
     * @param  {Boolean}     isTree
     */
    this.defaultSelectNext = function(xmlNode, isTree){
        var next = this.getNextTraverseSelected(xmlNode);
        //if(!next && xmlNode == this.xmlRoot) return;

        //Why not use this.$isTreeArch ??
        if (next || !isTree)
            this.select(next ? next : this.getTraverseParent(xmlNode));
        else
            this.clearSelection(true);
    };

    /**
     * Selects the next {@link term.datanode data node} when available.
     */
    this.selectNext = function(){
        var xmlNode = this.getNextTraverse();
        if (xmlNode)
            this.select(xmlNode);
    };

    /**
     * Selects the previous {@link term.datanode data node} when available.
     */
    this.selectPrevious = function(){
        var xmlNode = this.getNextTraverse(null, -1);
        if (xmlNode)
            this.select(xmlNode);
    };

    /**
     * @private
     */
    this.getDefaultNext = function(xmlNode, isTree){  //@todo why is isTree an argument
        var next = this.getNextTraverseSelected(xmlNode);
        //if(!next && xmlNode == this.xmlRoot) return;

        return (next && next != xmlNode)
            ? next
            : (isTree
                ? this.getTraverseParent(xmlNode)
                : null); //this.getFirstTraverseNode()
    };

    /**
     * Determines whether a node is selected.
     *
     * @param  {XMLElement} xmlNode  The {@link term.datanode data node} to be checked.
     * @return  {Boolean} whether the element is selected.
     */
    this.isSelected = function(xmlNode){
        if (!xmlNode) return false;

        for (var i = 0; i < this.$valueList.length; i++) {
            if (this.$valueList[i] == xmlNode)
                return this.$valueList.length;
        }

        return false;
    };

    /**
     * This function checks whether the current selection is still correct.
     * Selection can become invalid when updates to the underlying data
     * happen. For instance when a selected node is removed.
     */
    this.$checkSelection = function(nextNode){
        if (this.$valueList.length > 1) {
            //Fix selection if needed
            for (var lst = [], i = 0, l = this.$valueList.length; i < l; i++) {
                if (apf.isChildOf(this.xmlRoot, this.$valueList[i]))
                    lst.push(this.$valueList[i]);
            }

            if (lst.length > 1) {
                this.selectList(lst);
                if(this.caret
                  && !apf.isChildOf(this.xmlRoot, this.caret)) {
                    this.setCaret(nextNode || this.selected);
                }
                return;
            }
            else if (lst.length) {
                //this.clearSelection(true); //@todo noEvents here??
                nextNode = lst[0];
            }
        }

        if (!nextNode) {
            if (this.selected
              && !apf.isChildOf(this.xmlRoot, this.selected)) {
                nextNode = this.getFirstTraverseNode();
            }
            else if(this.selected && this.caret
              && !apf.isChildOf(this.xmlRoot, this.caret)) {
                this.setCaret(this.selected);
            }
            else if (!this.selected){
                nextNode = this.xmlRoot
                    ? this.getFirstTraverseNode()
                    : null;
            }
            else {
                return; //Nothing to do
            }
        }

        if (nextNode) {
            if (this.autoselect) {
                this.select(nextNode);
            }
            else {
                if (!this.multiselect)
                    this.clearSelection();
                this.setCaret(nextNode);
            }
        }
        else
            this.clearSelection();

        //if(action == "synchronize" && this.autoselect) this.reselect();
    };

    /**
     * @attribute {Boolean} [multiselect]   whether the user may select multiple items. Default is true, false for dropdown. 
     * @attribute {Boolean} [autoselect]    whether a selection is made after data is loaded. Default is true, false for dropdown. When the string 'all' is set, all {@link term.datanode data nodes} are selected.
     * @attribute {Boolean} [selectable]    whether the {@link term.datanode data nodes} of this element can be selected. Default is true.
     * @attribute {Boolean} [ctrlselect]    whether when a selection is made as if the user is holding the Ctrl key. When set to true each mouse selection will add to the current selection. selecting an already selected element will deselect it.
     * @attribute {Boolean} [allowdeselect] whether the user can remove the selection of this element. When set to true it is possible for this element to have no selected {@link term.datanode data node}.
     * @attribute {Boolean} [reselectable]  whether selected nodes can be selected again and the selection events are called again. Default is false. When set to false a selected {@link term.datanode data node} cannot be selected again.
     * @attribute {String}  [default]       the value that this component has when no selection is made.
     * @attribute {String}  [eachvalue]     the {@link term.expression expression} that determines the value for each {@link term.datanode data nodes} in the dataset of the element.
     * Remarks:
     * 
     * Example:
     *
     * @see baseclass.multiselect.attribute.eachvalue
     */
    this.selectable = true;
    if (typeof this.ctrlselect == "undefined")
        this.ctrlselect = false;
    if (typeof this.multiselect == "undefined")
        this.multiselect = true;
    if (typeof this.autoselect == "undefined")
        this.autoselect = true;
    if (typeof this.delayedselect == "undefined")
        this.delayedselect = true;
    if (typeof this.allowdeselect == "undefined")
        this.allowdeselect = true;
    this.reselectable = false;

    this.$booleanProperties["selectable"]    = true;
    //this.$booleanProperties["ctrlselect"]    = true;
    this.$booleanProperties["multiselect"]   = true;
    this.$booleanProperties["autoselect"]    = true;
    this.$booleanProperties["delayedselect"] = true;
    this.$booleanProperties["allowdeselect"] = true;
    this.$booleanProperties["reselectable"]  = true;

    this.$supportedProperties.push("selectable", "ctrlselect", "multiselect",
        "autoselect", "delayedselect", "allowdeselect", "reselectable", 
        "selection", "selected", "default", "value", "caret");

    /**
     * @attribute {String} [value]   the value of the element that is selected.
     * Remarks:
     * 
     * Example:
     *
     * @see baseclass.multiselect.attribute.eachvalue
     */
    //@todo add check here
    this.$propHandlers["value"] = function(value){
        if (this.$lastValue == value) {
            delete this.$lastValue;
            return;
        }
        
        if (value || value === 0 || this["default"])
            this.select(String(value) || this["default"]);
    }
    
    /**
     * @attribute {String} [value]   the value of the element that is selected.
     * Remarks:
     * 
     * Example:
     *
     * @see baseclass.multiselect.attribute.selected, baseclass.multiselect.attribute.selection
     */
    //@todo fill this in
    this.$propHandlers["caret"] = function(value, prop){
        if (value)
            this.setCaret(value);
    }
    
    
    
    //@todo optimize this thing. Also implement virtual dataset support.
    /**
     * @attribute {String} [selection]   the {@link term.expression expression} that determines the selection for this element. A reference to an xml nodelist can be passed as well.
     * Remarks:
     * 
     * Example:
     *
     * @see baseclass.multiselect.attribute.selected, baseclass.multiselect.attribute.selection
     */
    this.$propHandlers["selection"] = 
    
    /**
     * @attribute {String} [selected]   the {@link term.expression expression} that determines the selected node for this element. A reference to an xml element can be passed as well.
     * Remarks:
     * 
     * Example:
     *
     * @see baseclass.multiselect.attribute.selected, baseclass.multiselect.attribute.selection
     */
    this.$propHandlers["selected"] = function(value, prop) {
        if (!value) value = this[prop] = null;

        if (prop == "selected" && typeof value != "string" && value == this.selected) {
            this.selected = null;
            return;
        }

        if (this.$isSelecting) {
            this.selection = this.$valueList;
            return false;
        }

        var nodes, bindSet, getValue, i, j, c, d;
        //Update the selection
        if (prop == "selection") {
            if (typeof value == "object" && value == this.$valueList) {
                var pNode;
                //We're using an external model. Need to update bound nodeset
                if ((c = this.$attrBindings[prop]) && c.cvalue.models) { //added check, @todo whats up with above assumption?
                    this.$isSelecting = true; //Prevent reentrance (optimization)
    
                    bindSet = this.$attrBindings["eachvalue"] 
                        && "eachvalue" || this.$bindings["value"]
                        && "value" || this.$hasBindRule("caption") && "caption";
                    
                    if (!bindSet)
                        throw new Error("Missing bind rule set: eachvalue, value or caption");//@todo apf3.0 make this into a proper error
                    
                    //@todo this may be optimized by keeping a copy of the selection
                    var selNodes = this.$getDataNode(prop, this.xmlRoot);
                    nodes        = value;
                    getValue     = (d = this.$attrBindings["selection-unique"]) && d.cvalue;
                    
                    if (selNodes.length) {
                        pNode = selNodes[0].parentNode;
                    }
                    else {
                        var model = apf.nameserver.get("model", c.cvalue.xpaths[0]),
                            path  = c.cvalue.xpaths[1];
                        if (!model.data) {
                            this.$isSelecting = false;
                            return false;
                        }
                        
                        pNode = model.queryNode(path.replace(/\/[^\/]+$|^[^\/]*$/, "") || ".");
                        
                        if (!pNode)
                            throw new Error("Missing parent node"); //@todo apf3.0 make this into a proper error
                    }
                    
                    //Nodes removed
                    remove_loop:
                    for (i = 0; i < selNodes.length; i++) {
                        //Value is either determined by special property or in the 
                        //same way as the value for the bound node.
                        value = getValue 
                          ? getValue(selNodes[i]) 
                          : this.$applyBindRule(bindSet, selNodes[i]);
    
                        //Compare the value with the traverse nodes
                        for (j = 0; j < nodes.length; j++) {
                            if (this.$applyBindRule(bindSet, nodes[j]) == value) //@todo this could be cached
                                continue remove_loop;
                        }
                        
                        //remove node
                        apf.xmldb.removeNode(selNodes[i]);
                    }
                    
                    //Nodes added
                    add_loop:
                    for (i = 0; i < nodes.length; i++) {
                        //Value is either determined by special property or in the 
                        //same way as the value for the bound node.
                        value = this.$applyBindRule(bindSet, nodes[i]);
    
                        //Compare the value with the traverse nodes
                        for (j = 0; j < selNodes.length; j++) {
                            if (getValue 
                              ? getValue(selNodes[j]) 
                              : this.$applyBindRule(bindSet, selNodes[j]) == value) //@todo this could be cached
                                continue add_loop;
                        }
                        
                        //add node
                        var node = this.$attrBindings["selection-constructor"] 
                          && this.$getDataNode("selection-constructor", nodes[i])
                          || apf.getCleanCopy(nodes[i]);
                        apf.xmldb.appendChild(pNode, node);
                    }
                    
                    //@todo above changes should be via the actiontracker
                    this.$isSelecting = false;
                }
                
                return;
            }
            this.selection = this.$valueList;
        }
        else {
            this.selected = null;
        }
        
        if (!this.xmlRoot) {
            if (!this.$buffered) {
                var f;
                this.addEventListener("afterload", f = function(){
                    this.removeEventListener("afterload", f);
                    this.$propHandlers["selected"].call(this, value, prop);
                    delete this.$buffered;
                });
                this.$buffered = true;
            }
            this[prop] = null;
            return false;
        }

        if (!value || typeof value != "object") {
            //this[prop] = null;

            if (this.$attrBindings[prop]) {
                //Execute the selection query
                nodes = this.$getDataNode(prop, this.xmlRoot);
                if (nodes)
                    this.setProperty("selection", nodes);
                
                //Current model, it's an init selection, we'll clear the bind
                /*if (typeof value == "string" 
                  && !this.$attrBindings[prop].cvalue.xpaths[0]) {
                    this.$removeAttrBind(prop);
                }*/
            }
            else if (!value) {
                this.clearSelection();
            }
            else {
                this.select(value);
            }

            return false; //Disable signalling the listeners to this property
        }
        else if (typeof value.length == "number") {
            nodes = value;
            if (!nodes.length) {
                this.selected = null;
                if (this.$valueList.length) { //dont clear selection when no selection exists (at prop init)
                    this.clearSelection();
                    return false; //Disable signalling the listeners to this property
                }
                else return;
            }
            
            //For when nodes are traverse nodes of this element
            if (this.isTraverseNode(nodes[0]) 
              && apf.isChildOf(this.xmlRoot, nodes[0])) {
                if (!this.multiselect) {
                    this.select(nodes[0]);
                }
                else {
                    //this[prop] = null; //??
                    this.selectList(nodes);
                }
                return false; //Disable signalling the listeners to this property
            }
            
            //if external model defined, loop through items and find mate by value
            if (this.$attrBindings[prop]) { //Can assume an external model is in place
                bindSet = this.$attrBindings["eachvalue"] 
                    && "eachvalue" || this.$bindings["value"]
                    && "value" || this.$hasBindRule("caption") && "caption";
                
                if (!bindSet)
                    throw new Error("Missing bind rule set: eachvalue, value or caption");//@todo apf3.0 make this into a proper error
                
                var tNodes = !this.each 
                    ? this.getTraverseNodes()
                    : this.xmlRoot.selectNodes("//" + this.each.split("|").join("|//"));
                
                getValue = (c = this.$attrBindings["selection-unique"]) && c.cvalue;
                var selList  = [];
                for (i = 0; i < nodes.length; i++) {
                    //Value is either determined by special property or in the 
                    //same way as the value for the bound node.
                    value = getValue 
                        ? getValue(nodes[i]) 
                        : this.$applyBindRule(bindSet, nodes[i]);

                    //Compare the value with the traverse nodes
                    for (j = 0; j < tNodes.length; j++) {
                        if (this.$applyBindRule(bindSet, tNodes[j]) == value) //@todo this could be cached
                            selList.push(tNodes[j]);
                    }
                }
                
                //this[prop] = null; //???
                this.selectList(selList);
                return false;
            }
            
            throw new Error("Show me which case this is");
        }
        else if (this.$valueList.indexOf(value) == -1) {
            //this.selected = null;
            this.select(value);
        }
    };
    
    
    
    this.$propHandlers["allowdeselect"] = function(value){
        if (value) {
            var _self = this;
            this.$int.onmousedown = function(e){
                if (!e)
                    e = event;
                if (e.ctrlKey || e.shiftKey)
                    return;

                var srcElement = e.srcElement || e.target;
                if (_self.allowdeselect && (srcElement == this
                  || srcElement.getAttribute(apf.xmldb.htmlIdTag)))
                    _self.clearSelection(); //hacky
            }
        }
        else {
            this.$int.onmousedown = null;
        }
    };

    this.$propHandlers["ctrlselect"] = function(value){
        if (value != "enter")
            this.ctrlselect = apf.isTrue(value);
    }

    function fAutoselect(){
        this.selectAll();
    }
    
    this.$propHandlers["autoselect"] = function(value){
        if (value == "all" && this.multiselect)
            this.addEventListener("afterload", fAutoselect);
        else
            this.removeEventListener("afterload", fAutoselect);
    };

    this.$propHandlers["multiselect"] = function(value){
        if (!value && this.$valueList.length > 1)
            this.select(this.selected);

        //if (value)
            //this.bufferselect = false; //@todo doesn't return to original value
    };

    // Select Bind class
    
    this.addEventListener("beforeselect", function(e){
        if (this.$bindings.selectable && !this.$getDataNode("selectable", e.selected))
            return false;
    }, true);
    

    
    this.addEventListener("afterselect", function (e){
        
        var combinedvalue = null;

        
        //@todo refactor below
        /*if (this.caret == this.selected || e.list && e.list.length > 1 && hasConnections) {
            //Multiselect databinding handling... [experimental]
            if (e.list && e.list.length > 1 && this.$getConnections().length) { //@todo this no work no more apf3.0
                var oEl  = this.xmlRoot.ownerDocument.createElement(this.selected.tagName);
                var attr = {};

                //Fill basic nodes
                var nodes = e.list[0].attributes;
                for (var j = 0; j < nodes.length; j++)
                    attr[nodes[j].nodeName] = nodes[j].nodeValue;

                //Remove nodes
                for (var prop, i = 1; i < e.list.length; i++) {
                    for (prop in attr) {
                        if (typeof attr[prop] != "string") continue;

                        if (!e.list[i].getAttributeNode(prop))
                            attr[prop] = undefined;
                        else if(e.list[i].getAttribute(prop) != attr[prop])
                            attr[prop] = "";
                    }
                }

                //Set attributes
                for (prop in attr) {
                    if (typeof attr[prop] != "string") continue;
                    oEl.setAttribute(prop, attr[prop]);
                }

                //missing is childnodes... will implement later when needed...

                oEl.setAttribute(apf.xmldb.xmlIdTag, this.$uniqueId);
                apf.MultiSelectServer.register(oEl.getAttribute(apf.xmldb.xmlIdTag),
                    oEl, e.list, this);
                apf.xmldb.addNodeListener(oEl, apf.MultiSelectServer);

                combinedvalue = oEl;
            }
        }*/
        
        
        //Set caret property
        this.setProperty("caret", e.caret);
        
        //Set selection length
        if (this.sellength != e.selection.length)
            this.setProperty("sellength", e.selection.length);
        
        //Set selection property
        delete this.selection;
        this.setProperty("selection", e.selection);
        if (!e.selection.length) {
            //Set selected property
            this.setProperty("selected", e.selected);
            
            //Set value property
            if (this.value)
                this.setProperty("value", "");
        }
        else {
            //Set selected property
            this.$chained = true;
            if (!e.force && (!this.dataParent || !this.dataParent.parent.$chained)) {
                var _self = this;
                $setTimeout(function(){
                    
                    _self.setProperty("selected", combinedvalue || e.selected);
                    
                    delete _self.$chained;
                }, 10);
            }
            else {
                
                this.setProperty("selected", combinedvalue || e.selected);
                
                delete this.$chained;
            }
            
            //Set value property
            var valueRule = this.$attrBindings["eachvalue"] && "eachvalue" 
                || this.$bindings["value"] && "value" 
                || this.$hasBindRule("caption") && "caption";

            if (valueRule) {
                //@todo this will call the handler again - should be optimized

                this.$lastValue = this.$applyBindRule(valueRule, e.selected)
                //this.$attrBindings["value"] && 
                if (this.$lastValue != 
                  (valueRule != "value" && (this.xmlRoot
                  && this.$applyBindRule("value", this.xmlRoot, null, true)) 
                  || this.value)) {
                    if (valueRule == "eachvalue" || this.xmlRoot != this)
                        this.change(this.$lastValue);
                    else
                        this.setProperty("value", this.$lastValue);
                }
                /*else {
                    this.setProperty("value", this.$lastValue);
                }*/
                delete this.$lastValue;
            }
        }
        
        
        //@todo this should be generalized and collapsed with setProperty
        if (typeof apf.offline != "undefined" && apf.offline.state.enabled
          && apf.offline.state.realtime) {  //@todo please optimize
            for (var sel = [], i = 0; i < e.selection.length; i++)
                sel.push(apf.xmlToXpath(e.selection[i], null, true));

            apf.offline.state.set(this, "selection", sel);
            fSelState.call(this);
        }
        

        
    }, true);
    
    
    
    function fSelState(){
        if (typeof apf.offline != "undefined" && apf.offline.state.enabled
          && apf.offline.state.realtime) {
            apf.offline.state.set(this, "selstate",
                [this.caret
                    ? apf.xmlToXpath(this.caret, null, true)
                    : "",
                 this.selected
                    ? apf.xmlToXpath(this.selected, null, true)
                    : ""]);
        }
    }

    this.addEventListener("prop.caret", fSelState);
    

}).call(apf.MultiSelect.prototype = new apf.MultiselectBinding());



//@todo refactor below
/**
 * @private
 */
/*
apf.MultiSelectServer = {
    objects : {},

    register : function(xmlId, xmlNode, selList, jNode){
        if (!this.$uniqueId)
            this.$uniqueId = apf.all.push(this) - 1;

        this.objects[xmlId] = {
            xml   : xmlNode,
            list  : selList,
            jNode : jNode
        };
    },

    $xmlUpdate : function(action, xmlNode, listenNode, UndoObj){
        if (action != "attribute") return;

        var data = this.objects[xmlNode.getAttribute(apf.xmldb.xmlIdTag)];
        if (!data) return;

        var nodes = xmlNode.attributes;

        for (var j = 0; j < data.list.length; j++) {
            //data[j].setAttribute(UndoObj.name, xmlNode.getAttribute(UndoObj.name));
            apf.xmldb.setAttribute(data.list[j], UndoObj.name,
                xmlNode.getAttribute(UndoObj.name));
        }

        //apf.xmldb.synchronize();
    }
};
*/




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable.js)SIZE(66477)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */
apf.__CONTENTEDITABLE__  = 1 << 23;




/**
 * Baseclass of an element whose content is editable. This is usually an
 * {@link element.editor}.
 *
 * @constructor
 * @baseclass
 *
 * @inherits apf.Presentation
 * @inherits apf.StandardBinding
 * @inherits apf.DataAction
 *
 * @author      Mike de Boer (mike AT javeline DOT com)
 * @version     %I%, %G%
 * @since       3.0
 */
apf.ContentEditable = function() {
    this.$regbase = this.$regbase | apf.__CONTENTEDITABLE__;

    
    this.implement(apf.DataAction);
    

    this.$activeDocument = document;
    this.$state          = apf.ON;
    this.$selection      = null;
    this.$buttons        = ["Bold", "Italic", "Underline"];
    this.$classToolbar   = "editor_Toolbar";
    this.$plugins        = {};
    this.$pluginsHooks   = {};
    this.$pluginsTypes   = {};
    this.$pluginsKeys    = [];
    this.$pluginsActive  = null;
    this.$pluginsOn      = ["pasteword", "tablewizard"];
    this.$nativeCommands = ["bold", "italic", "underline", "strikethrough",
                            "justifyleft", "justifycenter", "justifyright",
                            "justifyfull", "removeformat", "cut", "copy",
                            "paste", "outdent", "indent", "undo", "redo"];

    this.$supportedProperties.push("contenteditable", "state", "plugins",
        "realtime", "language");
    this.$booleanProperties["contenteditable"] = true;
    this.$booleanProperties["realtime"]        = true;
    this.$propHandlers["contenteditable"]      = function(value){
        var o = this.$edVars;
        if (apf.isTrue(value)) {
            var _self = this;
            apf.addListener(_self.$ext, "mouseover", o.mouseOver = function(e) {
                var el = e.srcElement || e.target;
                if (!el) return;
                while (el && (!el.className || el.className.indexOf("contentEditable") == -1) && el != _self.$ext) {
                    el = el.parentNode;
                }
                if (!el || el == _self.$ext || el == o.activeNode)
                    return;
                apf.setStyleClass(el, "contentEditable_over");
            });
            apf.addListener(_self.$ext, "mouseout",  o.mouseOut = function(e) {
                var el = e.srcElement || e.target;
                if (!el) return;
                while (el && (!el.className || el.className.indexOf("contentEditable") == -1) && el != _self.$ext) {
                    el = el.parentNode;
                }
                if (!el || el == _self.$ext || el == o.activeNode)
                    return;
                apf.setStyleClass(el, null, ["contentEditable_over"]);
            });
            apf.addListener(_self.$ext, "mousedown", o.mouseDown = function(e) {
                var el = e.srcElement || e.target;
                if (!el) return;
                if (o.activeNode && _self.$selection && apf.isChildOf(o.activeNode, el, true))
                    _self.$selection.cache();

                while (el && (!el.className || el.className.indexOf("contentEditable") == -1) && el != _self.$ext) {
                    el = el.parentNode;
                }

                if (!el || el == _self.$ext) {
                    if (o.activeNode)
                        removeEditor(o.activeNode, true);
                    return;
                }

                createEditor(el);
                if (!o.lastTemplate) {
                    e.cancelBubble = true;
                    apf.window.$mousedown({srcElement: o.activeNode});
                    $setTimeout(function(){
                        //@todo Mike. The cursor position is lost!!! Please help me!
                        _self.$selection.set();
                        if (o.activeNode)
                            o.activeNode.focus();
                    }, 10);
                }
                else {
                    $setTimeout(function(){
                        o.lastTemplate.childNodes[0].focus();
                    }, 100);
                    o.lastTemplate.childNodes[0].slideDown();
                }

                return false;
            });
            apf.addListener(_self.$ext, "mouseup", o.mouseUp = function(e) {
                var el = e.srcElement || e.target;
                if (o.activeNode && _self.$selection && apf.isChildOf(o.activeNode, el, true))
                    _self.$selection.cache();
            });

            o.wasFocussable = [this.$focussable,
                typeof this.focussable == "undefined" ? true : this.focussable];
            this.$focussable = true;
            this.setProperty("focussable", true);
        }
        else {
            apf.removeListener(this.$ext, "mouseover", o.mouseOver);
            apf.removeListener(this.$ext, "mouseout",  o.mouseOut);
            apf.removeListener(this.$ext, "mousedown", o.mouseDown);
            apf.removeListener(this.$ext, "mouseup",   o.mouseUp);

            if (o.docklet)
                o.docklet.hide();
            o.activeNode = null;
            o.lastActiveNode = null;

            this.$focussable = o.wasFocussable[0];
            this.setProperty("focussable", o.wasFocussable[1]);
        }

        o.tabStack = null; // redraw of editable region, invalidate cache
        this.reload();
    };

    this.$propHandlers["state"] = function(value){
        this.state = parseInt(value); // make sure it's an int
        // the state has changed, update the button look/ feel
        var _self = this;
        $setTimeout(function() {
            _self.$notifyAllButtons(value);
            if (_self.$pluginsActive == "code")
                _self.$notifyButton("code", apf.SELECTED);
        });
    };

    this.$propHandlers["plugins"] = function(value){
        this.$pluginsOn = value && value.splitSafe(value) || null;
        if (this.$pluginsOn && this.$pluginsOn.length) {
            for (var i = 0, l = this.$pluginsOn.length; i < l; i++)
                this.$addPlugin(this.$pluginsOn[i]);
        }
    };

    this.$propHandlers["language"] = function(value){
        // @todo implement realtime language switching
    };
    
    /**
     * @attribute {Boolean} realtime whether the value of the bound data is
     * updated as the user types it, or only when this element looses focus or
     * the user presses enter.
     */
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (typeof this.realtime == "undefined")
            this.$setInheritedAttribute("realtime");
    });

    this.$edVars = {
        lastActiveNode: null,
        wasFocussable : null,
        skipFocusOnce : null,
        lastTemplate  : null,
        lastValue     : null,
        mouseOver     : null,
        mouseOut      : null,
        mouseDown     : null,
        mouseUp       : null,
        docklet       : null,
        objectHandles : false,
        tableHandles  : false,
        bStandalone   : false,
        lastPos       : 0,
        activeNode    : null,
        tabStack      : null,
        changeTimer   : null,
        keyupTimer    : null,
        oButtons      : {}
    };

    this.addEventListener("focus", function(e){
        var o = this.$edVars;
        if (!this.contenteditable || o.skipFocusOnce && !(o.skipFocusOnce = false)) {
            o.lastActiveNode = null;
            return;
        }

        this.setProperty("state", (this.$pluginsActive == "code")
            ? apf.DISABLED
            : apf.OFF);

        if (o.lastActiveNode && o.lastActiveNode.parentNode
          || typeof e.shiftKey == "boolean") {
            createEditor(o.lastActiveNode || (o.tabStack
                || initTabStack())[e.shiftKey ? o.tabStack.length - 1 : 0]);

            if (o.lastActiveNode && !o.lastTemplate)
                o.lastActiveNode.focus();
        }
        o.lastActiveNode = null;
        
        if (o.lastTemplate) {
            o.lastTemplate.childNodes[0].focus();
        }
        else if (o.activeNode) {
            var node = o.activeNode;
            $setTimeout(function(){
                //this.$selection.selectNode(node);
                this.$selection.set();
                if (node.parentNode) //@todo why?
                    node.focus();
            }, 10);
        }
    });
    
    this.addEventListener("blur", function(e){
        if (!this.contenteditable)
            return;
        
        var o = this.$edVars;
        o.lastActiveNode = o.activeNode || o.lastActiveNode;
        //@todo should be recursive in refactor 
        if (e.toElement && (e.toElement == o.docklet
          || e.toElement.parentNode == o.lastTemplate))
            return;

        var pParent = apf.popup.last && apf.lookup(apf.popup.last);
        if (pParent && pParent.editor == this)
            apf.popup.forceHide();

        if (this.$selection)
            this.$selection.cache();
        removeEditor(o.activeNode, true);

        this.setProperty("state", apf.DISABLED);
    });

    this.addEventListener("load", function(){
        if (!this.contenteditable)
            return;

        createEditor(initTabStack()[0]);
    });

    this.addEventListener("xmlupdate", function(){
        this.$edVars.tabStack = null; // redraw of editable region, invalidate cache
    });
    //@todo skin change

    /**
     * Event handler; fired when the user pressed a key inside the editor IFRAME.
     * For IE, we apply some necessary behavior correction and for other browsers, like
     * Firefox and Safari, we enable some of the missing default keyboard shortcuts.
     *
     * @param {Event} e
     * @type {Boolean}
     * @private
     */
    this.addEventListener("keydown", function(e) {
        var o = this.$edVars;
        if (!this.contenteditable && !o.bStandalone)
            return;

        e = e || window.event;
        var isDone, found, code = e.which || e.keyCode;
        if (!o.activeNode && !o.bStandalone) {
            //F2 starts editing
            if (code == 113) {
                var oNode;
                if (this.$selected) {
                    var nodes = this.$selected.getElementsByTagName("*");
                    for (var i = nodes.length - 1; i >= 0; i--) {
                        if ((nodes[i].className || "").indexOf("contentEditable") > -1) {
                            oNode = nodes[i];
                            break;
                        }
                    }
                }
                
                createEditor(oNode || (o.tabStack || initTabStack())[0]);
                if (o.activeNode) {
                    o.activeNode.focus();
                    this.$selection.selectNode(o.activeNode);
                    this.$selection.collapse();
                    try {
                        this.$activeDocument.execCommand("SelectAll", false, true);
                    }
                    catch(e) {}
                }
            }

            return;
        }

        if (apf.isIE) {
            switch (code) {
                case 66:  // B
                case 98:  // b
                case 105: // i
                case 73:  // I
                case 117: // u
                case 85:  // U
                //case 86:  // V |_ See onPaste()
                //case 118: // v |  event handler...
                    if ((e.ctrlKey || (apf.isMac && e.metaKey)) && !e.shiftKey
                      && !e.altKey && this.realtime)
                        
                        this.change(this.getValue());
                        
                    break;
                case 8: // backspace
                    found = false;
                    if (this.$selection.getType() == "Control") {
                        this.$selection.remove();
                        found = true;
                    }
                    listBehavior.call(this, e, true); //correct lists, if any
                    if (found)
                        return false;
                    break;
                case 46:
                    listBehavior.call(this, e, true); //correct lists, if any
                    break;
                case 9: // tab
                    if (listBehavior.call(this, e))
                        return false;
                    break;
            }
        }
        else {
            this.$visualFocus();
            if ((e.ctrlKey || (apf.isMac && e.metaKey)) && !e.shiftKey && !e.altKey) {
                found = false;
                switch (code) {
                    case 66: // B
                    case 98: // b
                        this.$execCommand("Bold");
                        found = true;
                        break;
                    case 105: // i
                    case 73:  // I
                        this.$execCommand("Italic");
                        found = true;
                        break;
                    case 117: // u
                    case 85:  // U
                        this.$execCommand("Underline");
                        found = true;
                        break;
                    case 86:  // V
                    case 118: // v
                        if (!apf.isGecko)
                            onPaste.call(this);
                        //found = true;
                        break;
                    case 37: // left
                    case 39: // right
                        found = true;
                }
                if (found) {
                    apf.AbstractEvent.stop(e.htmlEvent || e);
                    if (this.realtime)
                        
                        this.change(this.getValue());
                        
                }
            }
        }
        if (!o.bStandalone && code == 13) { //Enter
            isDone = e.ctrlKey || (apf.isMac && e.metaKey);
            if (!isDone) {
                var model   = this.getModel(true),
                    xmlNode = this.xmlRoot.ownerDocument.selectSingleNode(o.activeNode.getAttribute("xpath")),
                    rule    = model && model.$validation && model.$validation.getRule(xmlNode) || {multiline: false};
                isDone      = !apf.isTrue(rule.multiline);
            }
            e.returnValue = true;
        }

        this.$visualFocus();
        if (e.metaKey || e.ctrlKey || e.altKey || e.shiftKey) {
            found = this.$notifyKeyBindings({
                code   : code,
                control: e.ctrlKey,
                alt    : e.altKey,
                shift  : e.shiftKey,
                meta   : e.metaKey
            });
        }

        // Tab navigation handling
        if (code == 9 || isDone) {
            if (o.bStandalone) {
                if (listBehavior.call(this, e.htmlEvent || e)) {
                    apf.AbstractEvent.stop(e.htmlEvent || e);
                    return false;
                }
            }
            else {
                var bShift = e.shiftKey,
                    // a callback is passed, because the call is a-sync
                    lastPos = (o.tabStack || initTabStack()).indexOf(o.activeNode),
                    oNode   = removeEditor(o.activeNode, true) || initTabStack()[lastPos];

                oNode = o.tabStack[
                    o.tabStack.indexOf(oNode) + (bShift ? -1 : 1)
                ];

                if (oNode) {
                    createEditor(oNode);
                    if (o.lastTemplate) {
                        o.lastTemplate.childNodes[0].focus();
                    }
                    else if (oNode.parentNode) { //lastTemplate
                        oNode.focus();
                        this.$selection.selectNode(oNode);
                        this.$selection.collapse();
                        try {
                            this.$activeDocument.execCommand("SelectAll", false, true);
                        }
                        catch(e) {}
                    }
                    found = true;
                }
            }
        }
        // Esc key handling
        else if (!o.bStandalone && code == 27) {
            removeEditor(o.activeNode);
            found = true;
        }
        else if (code == 8 || code == 46) { //backspace or del
            listBehavior.call(this, e.htmlEvent || e, true); //correct lists, if any
        }

        if (!e.ctrlKey && !e.altKey && (code < 112 || code > 122)
          && (code < 33  && code > 31 || code > 42 || code == 8 || code == 13)) {
            resumeChangeTimer();
        }

        if (found) {
            if (e.preventDefault)
                e.preventDefault();
            if (e.stopPropagation)
                e.stopPropagation();
            e.returnValue = false;
            return false;
        }
        else if (o.activeNode)
            e.returnValue = -1;
    }, true);

    /**
     * Event handler; fired when the user releases a key inside the editable area
     *
     * @see object.abstractevent
     * @param {Event} e
     * @type  {void}
     * @private
     */
    this.addEventListener("keyup", function(e) {
        var _self = this,
            o     = this.$edVars;
        if (!this.contenteditable && !o.bStandalone)
            return;

        if (this.$selection)
            this.$selection.cache();
        if (o.keyupTimer != null)
            return;

        e = e || window.event;

        function keyupHandler() {
            clearTimeout(o.keyupTimer);
            if (_self.state == apf.DISABLED) return;
            _self.$notifyAllButtons();
            _self.dispatchEvent("typing", {editor: _self, event: e});
            _self.$notifyAllPlugins("typing", e.code);
            o.keyupTimer = null;
        }

        o.keyupTimer = window.setTimeout(keyupHandler, 200);
    }, true);

    function createEditor(oNode) {
        var o = this.$edVars;
        if (!oNode || oNode.nodeType != 1 || o.activeNode == oNode)
            return;

        if (!this.$selection)
            this.$selection = new apf.selection(window, document);

        if (o.activeNode) {
            var lastPos = initTabStack().indexOf(oNode);//tabStack can be old...
            removeEditor(o.activeNode, true);
            oNode = initTabStack()[lastPos];
            $setTimeout(function(){oNode.focus();}, 10);
        }

        var _self = this;

        if (this.validityState && !this.validityState.valid) {
            oNode = initTabStack()[this.validityState.$lastPos];
            $setTimeout(function(){
                oNode.focus();
                _self.$selection.selectNode(oNode);
                // @todo need to select all contents here?
                _self.$selection.collapse();
                try {
                    _self.$activeDocument.execCommand("SelectAll", false, true);
                }
                catch(e) {}
                _self.getModel(true).validate(xmlNode, false, _self.validityState, _self);
            }, 10);
        }

        var xmlNode = apf.createNodeFromXpath(this.xmlRoot.ownerDocument,
            oNode.getAttribute("xpath")),
            v, rule;
        if (v = this.getModel(true).$validation)
            rule = v.getRule(xmlNode);

        if (!this.hasFocus())
            o.skipFocusOnce = true;

        o.activeNode = oNode;
        apf.setStyleClass(oNode, "contentEditable_active", ["contentEditable_over"]);
        
        
        if (rule && apf.isTrue(rule.richtext)) {
            o.lastValue = [];
            oNode.innerHTML = o.lastValue[0] = apf.htmlCleaner.prepare((o.lastValue[1] = oNode.innerHTML)
                .replace(/<p[^>]*>/gi, "").replace(/<\/p>/gi, 
                "<br _apf_marker='1' /><br _apf_marker='1' />"));
            this.$controlAgentBehavior(oNode);
        }
        else 
        
            o.lastValue = oNode.innerHTML;

        /**
         * @todo for template
         *  - Focus handling enters at the first and leaves at the last both entry/leave
         *    are from/to parent element
         *  - Parent focus/blur events aren't called ($focus / $blur should use event system)
         *  - Keyboard events for leave (both ends) are forwarded to parent
         *  - Attach manages height of container
         *  - Attach code / Detach code
         */
        if (rule && rule.type == "custom") {
            if (!rule.$template) {
                var nodes = rule.node.childNodes;
                // @todo fix this
                rule.$template = apf.document.appendChild(apf.document.createElement("template"));
                for (var i = 0, l = nodes.length; i < l; i++) {
                    if (nodes[i].nodeType != 1)
                        continue;
                    rule.$template.appendChild(apf.document.createElement(nodes[i]));
                }
            }
            rule.$lastHeight = oNode.style.height;
            rule.$template.attach(oNode, null, true);
            oNode.style.height = (oNode.scrollHeight - apf.getHeightDiff(oNode) + 2) + "px";

            rule.$template.childNodes[0].onblur = function(e){
                if (e.toElement && e.toElement != _self)
                    _self.dispatchEvent("blur");
                else {
                    if (e.toElement)
                        o.skipFocusOnce = true;
                    else
                        _self.dispatchEvent("blur");
                    _self.focus(null, null, true);
                }
            };
            //@todo buggy should be no events in refactor apf3.0
            rule.$template.childNodes[0].onafterchange = function(){
                //skipFocusOnce = true;
                //_self.focus();
            }
            rule.$template.childNodes[0].onkeydown = function(e){
                if (e.keyCode == 9) {
                    e.currentTarget = null;
                    _self.dispatchEvent("keydown", e, true);
                    return false;
                }
            }
            rule.$template.childNodes[0].setValue(apf.queryValue(xmlNode));
            //rule.$template.childNodes[0].focus(); //@todo general focus problem for subchildren
            o.lastTemplate = rule.$template;
            return;
        }
        
        if (apf.hasContentEditable) {
            oNode.contentEditable = true;
        }
        else {
            document.body.setAttribute("spellcheck", "false");
            document.designMode = "on";
        }
        if (apf.isGecko) {
            // On each return, insert a BR element
            document.execCommand("insertBrOnReturn", false, true);
            // Tell Gecko (Firefox 1.5+) to enable or not live resizing of objects
            document.execCommand("enableObjectResizing", false, o.objectHandles);
            // Disable the standard table editing features of Firefox.
            document.execCommand("enableInlineTableEditing", false, o.tableHandles);
        }

        
        if (apf.hasFocusBug) {
            //@todo this leaks like a ..
            apf.sanitizeTextbox(oNode);
            oNode.onselectstart = function(e) {
                e = e || window.event;
                e.cancelBubble = true;
            };
        }
        

        var showDocklet = rule && apf.isTrue(rule.richtext);
        if (showDocklet && !o.docklet)
            this.$editable();
        if (o.docklet)
            o.docklet.setProperty("visible", showDocklet);
        this.setProperty("state", apf.OFF);

        //this.$selection.cache();
    }

    function removeEditor(oNode, bProcess, callback) {
        var o = this.$edVars;
        if (!oNode) oNode = o.activeNode;
        if (!oNode || oNode.nodeType != 1) return false;
        
        var model   = this.getModel(true),
            xpath   = oNode.getAttribute("xpath"),
            xmlNode = this.xmlRoot.ownerDocument.selectSingleNode(xpath),
            v, rule;
        if (v = model.$validation)
            rule = v.getRule(xmlNode);
        
        if (o.lastTemplate) {
            if (o.lastTemplate.childNodes.indexOf(apf.document.activeElement) > -1)
                this.focus();
            o.lastTemplate.detach();
            oNode.innerHTML = o.lastTemplate.childNodes[0].getValue();
            o.lastTemplate = null;
            oNode.style.height = rule.$lastHeight;
        }
        else {
            this.$selection.collapse(true);
            
            if (apf.hasContentEditable)
                oNode.contentEditable = false;
            else
                document.designMode = "off";
        }

        o.activeNode = null;

        apf.setStyleClass(oNode, null, ["contentEditable_over", "contentEditable_active"]);

        if (o.docklet)
            o.docklet.setProperty("visible", false);

        if (!bProcess || o.lastValue && oNode.innerHTML.toLowerCase().replace(/[\r\n]/g, "")
          == (o.lastValue.dataType == apf.ARRAY ? o.lastValue[0] : o.lastValue).toLowerCase().replace(/[\r\n]/g, "")) {
            oNode.innerHTML = o.lastValue.dataType == apf.ARRAY ? o.lastValue[1] : o.lastValue;
            return false;
        }

        if (this.validityState)
            this.validityState.$reset();

        // do additional handling, first we check for a change in the data...
        // @todo this will not always work in IE
        if (apf.queryValue(this.xmlRoot.ownerDocument, xpath) != oNode.innerHTML) {
            var lastPos = (o.tabStack || initTabStack()).indexOf(oNode);

            this.edit(xmlNode, rule && apf.isTrue(rule.richtext)
                ? apf.htmlCleaner.parse(oNode.innerHTML)
                : oNode.innerHTML);

            if (v) {
                (this.validityState || (this.validityState =
                    new apf.validator.validityState())).$errorHtml = 
                        (o.tabStack || initTabStack())[lastPos]

                this.validityState.$lastPos = lastPos;

                if (rule)
                    this.invalidmsg = rule.invalidmsg;

                //@todo this can be improved later
                model.validate(xmlNode, false, this.validityState, this);
            }
        }

        if (callback)
            $setTimeout(callback);
    }

    function initTabStack() {
        var o = this.$edVars;
        o.tabStack = [];
        var aNodes = this.$ext.getElementsByTagName("*");
        for (var i = 0, l = aNodes.length; i < l && aNodes[i].nodeType == 1; i++) {
            if (aNodes[i].className
              && aNodes[i].className.indexOf("contentEditable") != -1) {
                o.tabStack.push(aNodes[i]);
            }
        }
        return o.tabStack;
    }

    /**
     * Turns an object of mapped keystrokes to a numeric representation.
     * Since ASCII numbers of character codes don't go above 255, we start
     * with 256 for modifier keys and shift bits around to the left until we
     * get a unique hash for each key combination.
     *
     * @param {Object} keyMap
     * @type  {Number}
     * @private
     */
    function createKeyHash(keyMap) {
        return (keyMap.meta ? 2048 : 0) | (keyMap.control ? 1024 : 0)
            |  (keyMap.alt  ? 512  : 0) | (keyMap.shift   ? 256  : 0)
            |  (keyMap.key || "").charCodeAt(0);
    }

    /**
     * Transform the state of a button node to "enabled"
     *
     * @type {void}
     * @private
     */
    function buttonEnable() {
        apf.setStyleClass(this, "editor_enabled",
            ["editor_selected", "editor_disabled"]);
        this.disabled = false;
    }

    /**
     * Transform the state of a button node to "disabled"
     *
     * @type {void}
     * @private
     */
    function buttonDisable() {
        apf.setStyleClass(this, "editor_disabled",
            ["editor_selected", "editor_enabled"]);
        this.disabled = true;
    }

    /**
     * Retrieve the state of a command and if the command is a plugin, retrieve
     * the state of the plugin
     *
     * @param  {String}  id
     * @param  {Boolean} isPlugin
     * @return The command state as an integer that maps to one of the editor state constants
     * @type   {Number}
     * @private
     */
    function getState(id, isPlugin) {
        if (isPlugin) {
            var plugin = this.$plugins[id];
            if (this.state == apf.DISABLED && !plugin.noDisable)
                return apf.DISABLED;
            return plugin.queryState
                ? plugin.queryState(this)
                : this.state;
        }

        if (this.state == apf.DISABLED)
            return apf.DISABLED;

        return this.$queryCommandState(id);
    }

    /**
     * Corrects the default/ standard behavior of list elements (&lt;ul&gt; and
     * &lt;ol&gt; HTML nodes) to match the general user experience match with
     * M$ Office Word.
     *
     * @param {Event}   e
     * @param {Boolean} bFix Flag set to TRUE if you want to correct list indentation
     * @type Boolean
     * @private
     */
    function listBehavior(e, bFix) {
        if (!this.$plugins["bullist"] || !this.$plugins["numlist"])
            return false;
        if (typeof e.shift != "undefined")
           e.shiftKey = e.shift;
        var pList = this.$plugins["bullist"].queryState(this) == apf.ON
            ? this.$plugins["bullist"]
            : this.$plugins["numlist"].queryState(this) == apf.ON
                ? this.$plugins["numlist"]
                : null;
        if (!pList) return false;
        if (bFix === true)
            pList.correctLists(this);
        else
            pList.correctIndentation(this, e.shiftKey ? "outdent" : "indent");

        return true;
    }

    /**
     * Firing change(), when the editor is databound, subsequently after each
     * keystroke, can have a VERY large impact on editor performance. That's why
     * we delay the change() call.
     *
     * @type {void}
     */
    function resumeChangeTimer() {
        var o = this.$edVars;
        if (!this.realtime || o.changeTimer !== null) return;
        o.changeTimer = $setTimeout(function() {
            clearTimeout(o.changeTimer);
            
            this.change(this.getValue());
            
            o.changeTimer = null;
        }, 200);
    }

    /**
     * Get the state of a command (on, off or disabled)
     *
     * @param {String} name
     * @type Number
     */
    this.$queryCommandState = function(name) {
        if (apf.isGecko && (name == "paste" || name == "copy" || name == "cut"))
            return apf.DISABLED;
        try {
            if (!this.$activeDocument.queryCommandEnabled(name))
                return apf.DISABLED;
            else
                return this.$activeDocument.queryCommandState(name)
                    ? apf.ON
                    : apf.OFF;
        }
        catch (e) {
            return apf.OFF;
        }
    };

    /**
     * Get the value of a command
     *
     * @param {String} name
     * @type Number
     */
    this.$queryCommandValue = function(name) {
        var val;
        if (typeof this.$activeDocument.queryCommand != "function")
            return null;
        try {
            val = this.$activeDocument.queryCommand(name);
        }
        catch (e) {}

        return val || null;
    };

    /**
     * Issue a command to the editable area.
     *
     * @param {String} name
     * @param {mixed}  param
     * @type  {void}
     */
    this.$execCommand = function(name, param) {
        if (this.$plugins[name] || this.state == apf.DISABLED)
            return;

        this.$selection.set();
        
        this.$visualFocus();

        if (name.toLowerCase() == "removeformat") {
            var c          = this.$selection.getContent(),
                disallowed = {FONT: 1, SPAN: 1, H1: 1, H2: 1, H3: 1, H4: 1,
                H5: 1, H6: 1, PRE: 1, ADDRESS: 1, BLOCKQUOTE: 1, STRONG: 1,
                B: 1, U: 1, I: 1, EM: 1, LI: 1, OL: 1, UL: 1, DD: 1, DL: 1,
                DT: 1};
            c = c.replace(/<\/?(\w+)(?:\s.*?|)>/g, function(m, tag) {
                return !disallowed[tag] ? m : "";
            });
            if (apf.isIE) {
                var htmlNode = this.$selection.setContent("<div>" + c
                    + "</div>");
                this.$selection.selectNode(htmlNode);
                htmlNode.removeNode(false);
                return;
            }
            else {
                this.$selection.setContent(c);
            }
        }

        this.$activeDocument.execCommand(name, false, param);

        // make sure that the command didn't leave any <P> tags behind (cleanup)
        name       = name.toLowerCase();
        var bNoSel = (name == "selectall");
        if (apf.isIE) {
            if ((name == "insertunorderedlist" || name == "insertorderedlist")
              && this.$queryCommandState(name) == apf.OFF) {
                bNoSel = true;
            }
            else if (name == "outdent") {
                bNoSel = true;
                if (this.$plugins["bullist"] && this.$plugins["numlist"]) {
                    if (this.$plugins["bullist"].queryState(this) != apf.OFF
                     && this.$plugins["numlist"].queryState(this) != apf.OFF)
                        bNoSel = false;
                }
                var oNode = this.$selection.getSelectedNode();
                if (bNoSel && oNode && oNode.tagName == "BLOCKQUOTE")
                    bNoSel = false;
            }

            if (bNoSel) {
                var el = this.$edVars.bStandalone
                    ? this.$activeDocument.body
                    : this.$edVars.activeNode;
                
                el.innerHTML = apf.htmlCleaner.prepare(el.innerHTML);
                
                this.$controlAgentBehavior(el);
            }
            var r = this.$selection.getRange();
            if (r)
                r.scrollIntoView();
        }

        this.$notifyAllButtons();
        
        
        this.change(this.getValue());
        

        var _self = this;
        $setTimeout(function() {
            //_self.$notifyAllButtons(); // @todo This causes pain, find out why
            if (!bNoSel)
               _self.$selection.set();
            _self.$visualFocus();
        });
    };

    /**
     * Add a plugin to the collection IF an implementation actually exists.
     *
     * @param {String} sPlugin The plugin identifier/ name
     * @type  {apf.ContentEditable.plugin}
     */
    this.$addPlugin = function(sPlugin) {
        if (this.$plugins[sPlugin])
            return this.$plugins[sPlugin];
        if (!apf.ContentEditable.plugin[sPlugin]) return null;
        // yay, plugin does exist, so we can instantiate it for the editor
        var plugin = new apf.ContentEditable.plugin[sPlugin](sPlugin);
        // add it to main plugin collection
        this.$plugins[plugin.name] = plugin;

        if (plugin.type) {
            // a type prop is set, push it up the type-collection
            if (!this.$pluginsTypes[plugin.type])
                this.$pluginsTypes[plugin.type] = [];
            this.$pluginsTypes[plugin.type].push(plugin);
        }
        if (plugin.subType) {
            // a subType prop is set, push it up the type-collection
            if (!this.$pluginsTypes[plugin.subType])
                this.$pluginsTypes[plugin.subType] = [];
            this.$pluginsTypes[plugin.subType].push(plugin);
        }
        if (plugin.hook) {
            // a hook prop is set, push it up the event hooks-collection
            plugin.hook = plugin.hook.toLowerCase();
            if (!this.$pluginsHooks[plugin.hook])
                this.$pluginsHooks[plugin.hook] = [];
            this.$pluginsHooks[plugin.hook].push(plugin);
        }

        if (typeof plugin.keyBinding == "string") {
            // a keyBinding prop has been set, parse it and push it up the
            // keys-collection
            plugin.keyBinding = {
                meta   : (plugin.keyBinding.indexOf("meta")  > -1),
                control: (plugin.keyBinding.indexOf("ctrl")  > -1),
                alt    : (plugin.keyBinding.indexOf("alt")   > -1),
                shift  : (plugin.keyBinding.indexOf("shift") > -1),
                key    : plugin.keyBinding.charAt(plugin.keyBinding.length - 1).toLowerCase()
            };
            plugin.keyHash = createKeyHash(plugin.keyBinding);
            if (!this.$pluginsKeys[plugin.keyHash])
                this.$pluginsKeys[plugin.keyHash] = [];
            this.$pluginsKeys[plugin.keyHash].push(plugin);
        }
        return plugin;
    };

    /**
     * Notify a plugin of any occuring Event, if it has subscribed to it
     *
     * @param {String} name
     * @param {String} hook
     * @type  {mixed}
     */
    this.$notifyPlugin = function(name, hook) {
        var item = this.$plugins[name];
        if (item && item.hook == hook && !item.busy)
            return item.execute(this, arguments);
        return null;
    };

    /**
     * Notify all plugins of an occuring Event
     *
     * @param {String} hook
     * @param {Event}  e
     * @type  {Array}
     */
    this.$notifyAllPlugins = function(hook, e) {
        var res = [];
        if (!this.$pluginsHooks)
            return res;

        var coll = this.$pluginsHooks[hook];
        for (var i in coll) {
            if (!coll[i].busy && coll[i].execute)
                res.push(coll[i].execute(this, e));
        }
        //this.active = res.length ? res : res[0];
        return res;
    };

    /**
     * Notify all plugins of an occuring keyboard Event with a certain key combo
     *
     * @param {Object} keyMap
     * @type  {Array}
     */
    this.$notifyKeyBindings = function(keyMap) {
        var hash = createKeyHash(keyMap);
        if (!this.$pluginsKeys[hash] || !this.$pluginsKeys[hash].length)
            return false;

        var coll = this.$pluginsKeys[hash];
        for (var i = 0, j = coll.length; i < j; i++)
            coll[i].execute(this, arguments);
        //this.active = coll.length ? coll : coll[0];
        return true;
    };

    /**
     * Notify a specific button item on state changes (on, off, disabled, visible or hidden)
     *
     * @param {String} item
     * @param {Number} state Optional.
     * @type  {void}
     */
    this.$notifyButton = function(item, state) {
        if (!this.$plugins) //We're in the process of being destroyed
            return;

        var oButton = this.$edVars.oButtons[item];
        if (!oButton)
            return;

        var oPlugin = this.$plugins[item];
        if (typeof state == "undefined" || state === null) {
            if (oPlugin && oPlugin.queryState)
                state = oPlugin.queryState(this);
            else
                state = this.$queryCommandState(item);
        }

        if (oButton.state === state)
            return;

        oButton.state = state;

        if (state == apf.DISABLED)
            buttonDisable.call(oButton);
        else if (state == apf.HIDDEN)
            oButton.style.display = "none";
        else if (state == apf.VISIBLE)
            oButton.style.display = "";
        else {
            if (oButton.style.display == "none")
                oButton.style.display = "";

            if (oButton.disabled)
                buttonEnable.call(oButton);

            var btnState = (oButton.selected)
                ? apf.ON
                : apf.OFF;

            if (state != btnState) {
                this.$buttonClick({
                    state   : state,
                    isPlugin: oPlugin ? true : false,
                    _bogus  : true
                }, oButton);
            }
        }
    };

    /**
     * Notify all button items on state changes (on, off or disabled)
     *
     * @param {Number} state Optional.
     * @type  {void}
     */
    this.$notifyAllButtons = function(state) {
        var item, o = this.$edVars.oButtons;
        for (item in o)
            this.$notifyButton(item, state);
    };

    /**
     * Give or return the focus to the editable area, hence 'visual' focus.
     *
     * @param {Boolean} bNotify Flag set to TRUE if plugins should be notified of this event
     * @type  {void}
     */
    this.$visualFocus = function(bNotify) {
        // setting focus to the iframe content, upsets the 'code' plugin
        var bCode = (this.$pluginsActive == "code"),
            o     = this.$edVars;
        if (o.bStandalone && apf.document.activeElement == this && !bCode) {
            try {
                this.$oWin.focus();
            }
            catch(e) {};
        }
        else if (!o.bStandalone && o.activeNode) {
            o.activeNode.focus();
        }

        if (bCode) {
            this.$notifyAllButtons(apf.DISABLED);
            this.$notifyButton("code", apf.SELECTED);
        }
        else if (bNotify)
            this.$notifyAllButtons();
    };

    /**
     * Handler function; invoked when a toolbar button node was clicked
     *
     * @see object.abstractevent
     * @param {Event}      e
     * @param {DOMElement} oButton
     * @type  {void}
     */
    this.$buttonClick = function(e, oButton) {
        if (this.$selection)
            this.$selection.cache();

        apf.setStyleClass(oButton, "active");
        var item = oButton.getAttribute("type");

        //context 'this' is the buttons' DIV domNode reference
        if (!e._bogus) {
            e.isPlugin = this.$plugins[item] ? true : false;
            e.state    = getState.call(this, item, e.isPlugin);
        }

        if (e.state == apf.DISABLED) {
            buttonDisable.call(oButton);
        }
        else {
            if (this.disabled)
                buttonEnable.call(oButton);

            if (e.state == apf.ON) {
                apf.setStyleClass(oButton, "editor_selected");
                oButton.selected = true;
            }
            else {
                apf.setStyleClass(oButton, "", ["editor_selected"]);
                oButton.selected = false;
            }

            if (!e._bogus) {
                if (e.isPlugin)
                    this.$plugins[(this.$pluginsActive = item)].execute(this);
                else
                    this.$execCommand(item);
                e.state = getState.call(this, item, e.isPlugin);
            }
        }
        apf.setStyleClass(oButton, "", ["active"]);
    };

    /**
     * Draw all HTML elements for the editor toolbar
     *
     * @param {HTMLElement} oParent     DOM element which the toolbars should be inserted into
     * @param {String}      [sSkinTag]  Tagname of a toolbar node inside the editor skin definition
     * @param {String}      [sBtnClick] JS that will be executed when a button node is clicked
     * @type  {void}
     */
    this.$drawToolbars = function(oParent, sSkinTag, sBtnClick, bAfterRender) {
        var tb, l, k, i, j, z, x, node, buttons, bIsPlugin, item, bNode,
            plugin, oButton,
            o       = this.$edVars,
            sButton = o.bStandalone ? "button" : "toolbarbutton",
            oNode   = o.docklet.$getOption("toolbars"),
            plugins = this.$plugins;

        if (!sSkinTag)
            sSkinTag = "toolbar";

        for (i = 0, l = oNode.childNodes.length; i < l; i++) {
            node = oNode.childNodes[i];
            if (node.nodeType != 1 || node[apf.TAGNAME] != sSkinTag)
                continue;

            
            /*if (node[apf.TAGNAME] != "toolbar") {
                throw new Error(apf.formatErrorString(0, this,
                    "Creating toolbars",
                    "Invalid element found in toolbars definition",
                    node));
            }*/
            

            for (j = 0, k = node.childNodes.length; j < k; j++) {
                bNode = node.childNodes[j];

                
                if (bNode.nodeType != 3 && bNode.nodeType != 4) {
                    throw new Error(apf.formatErrorString(0, this,
                        "Creating toolbars",
                        "Invalid element found in toolbar definition",
                        bNode));
                }
                

                buttons = bNode.nodeValue.splitSafe(",", -1, true);
            }

            if (!buttons || !buttons.length)
                continue;

            o.docklet.$getNewContext("toolbar");
            tb = bAfterRender
                ? apf.insertHtmlNode(o.docklet.$getLayoutNode("toolbar"), oParent)
                : oParent.appendChild(o.docklet.$getLayoutNode("toolbar"));//, oParent.lastChild

            for (z = 0, x = buttons.length; z < x; z++) {
                item = buttons[z];

                if (item == "|") { //seperator!
                    o.docklet.$getNewContext("divider");
                    if (bAfterRender)
                        apf.insertHtmlNode(o.docklet.$getLayoutNode("divider"), tb);
                    else
                        tb.appendChild(o.docklet.$getLayoutNode("divider"));
                }
                else {
                    o.docklet.$getNewContext(sButton);
                    oButton = bAfterRender
                        ? oButton = apf.insertHtmlNode(o.docklet.$getLayoutNode(sButton), tb)
                        : oButton = tb.appendChild(o.docklet.$getLayoutNode(sButton));

                    bIsPlugin = false;
                    // Plugin toolbarbuttons may only be placed inside the main toolbar
                    if (sSkinTag == "toolbar" && !this.$nativeCommands.contains(item)) {
                        plugin = this.$addPlugin(item);
                        
                        if (!plugin)
                            apf.console.error("Plugin '" + item + "' can not \
                                               be found and/ or instantiated.",
                                               "editor");
                        
                        bIsPlugin = true;
                    }

                    if (bIsPlugin) {
                        plugin = plugin || plugins[item];
                        if (!plugin)
                            continue;
                        if (!(plugin.type & apf.TOOLBARITEM))
                            continue;

                        o.docklet.$getLayoutNode(sButton, "label", oButton)
                            .setAttribute("class", "editor_icon editor_" + plugin.icon);

                        oButton.setAttribute("title", this.$translate(plugin.name));
                    }
                    else {
                        o.docklet.$getLayoutNode(sButton, "label", oButton)
                            .setAttribute("class", "editor_icon editor_" + item);

                        oButton.setAttribute("title", this.$translate(item));
                    }

                    oButton.setAttribute("onmousedown", sBtnClick || "apf.all["
                        + this.$uniqueId + "].$buttonClick(event, this);");
                    oButton.setAttribute("onmouseover", "apf.setStyleClass(this, 'hover');");
                    oButton.setAttribute("onmouseout", "apf.setStyleClass(this, '', ['hover']);");

                    oButton.setAttribute("type", item);
                }
            }

            buttons = null;
        }

        if (apf.isIE) {
            var nodes = oParent.getElementsByTagName("*");
            for (i = nodes.length - 1; i >= 0; i--)
                nodes[i].setAttribute("unselectable", "On");
        }
    };

    this.$editable = function(callback) {
        if (this.getAttribute("plugins")) {
            this.$propHandlers["plugins"]
                .call(this, this.getAttribute("plugins"));
        }
        if (this.getAttribute("language")) {
            this.$propHandlers["language"]
                .call(this, this.getAttribute("language"));
        }

        // no External representation yet, which means that we're dealing with
        // a full-mode editor.
        var o = this.$edVars;
        if (!this.$ext) {
            o.docklet     = this;
            o.bStandalone = true;
            this.$ext = this.$getExternal("main", null, function(oExt){
                var o = this.$getLayoutNode("main", "toolbar");
                this.$drawToolbars(o);
            });
            this.oToolbar = this.$getLayoutNode("main", "toolbar", this.$ext);
        }
        //@todo apf3.0 get this from portal.js
        else if (!o.docklet && !(apf.ContentEditable.toolwin = o.docklet)) {
            o.docklet = apf.ContentEditable.toolwin =
                new apf.modalwindow("toolwindow", document.body, null, true);

            o.docklet.parentNode = apf.document.documentElement;
            o.docklet.implement(apf.AmlNode);
            
            //Load docklet
            o.docklet.$aml        = apf.getXml("<toolwindow />");
            //@todo use skinset here. Has to be set in presentation
            //docklet.skinset   = apf.getInheritedAttribute(this.$aml.parentNode, "skinset");
            //xmlNode.setAttribute("skinset", docklet.skinset);
            //docklet.skin      = "docklet";
            //docklet.skinName  = null;
            o.docklet.$loadSkin();

            o.docklet.$draw();
            o.docklet.setProperty("buttons", "");
            o.docklet.setProperty("title", "Formatting");
            o.docklet.setProperty("icon", "application.png");
            o.docklet.setProperty("resizable", "horizontal");
            o.docklet.setProperty("draggable", true);
            o.docklet.setProperty("focussable", true);
            //docklet.setProperty("resizeoutline", true);

            var _self = this;
            o.docklet.onfocus = function(){
                _self.focus();
            }

            apf.AmlParser.parseLastPass();

            o.docklet.setProperty("left", 500);
            o.docklet.setProperty("top", 100);
            o.docklet.setProperty("width", 400);
            o.docklet.setProperty("zindex", 100000);
            
            var content, aNodes = o.docklet.$ext.getElementsByTagName("div");
            for (var j = 0, l = aNodes.length; j < l && !content; j++) {
                if (aNodes[j].className.indexOf("content") != -1)
                    content = aNodes[j];
            }
            this.$drawToolbars(this.oToolbar = content, "toolbar", null, true);
            // @todo make this hack disappear...
            this.oToolbar.innerHTML = this.oToolbar.innerHTML;
        }

        if (callback)
            callback.call(this);

        if (this.oToolbar) {
            // fetch the DOM references of all toolbar buttons and let the
            // respective plugins finish initialization
            var btns = this.oToolbar.getElementsByTagName("div");
            for (var item, plugin, i = btns.length - 1; i >= 0; i--) {
                item = btns[i].getAttribute("type");
                if (!item) continue;

                o.oButtons[item] = btns[i];
                plugin = this.$plugins[item];
                if (!plugin) continue;

                plugin.buttonNode = btns[i];

                if (plugin.init)
                    plugin.init(this);
            }
        }
    };

    this.$getPluginOption = function(node) {
        return this.$edVars.docklet.$getOption(node);
    };

    /**
     * Make an instance of apf.popup (identified with a pointer to the cached
     * DOM node - sCacheId) visible to the user.
     *
     * @param {apf.ContentEditable.plugin} oPlugin  The plugin instance
     * @param {String}            sCacheId Pointer to the cached DOM node
     * @param {DOMElement}        oRef     Button node to show popup below to
     * @param {Number}            iWidth   New width of the popup
     * @param {Number}            iHeight  New height of the popup
     * @type  {void}
     */
    this.$showPopup = function(oPlugin, sCacheId, oRef, iWidth, iHeight) {
        if (apf.popup.last && apf.popup.last != sCacheId) {
            var o = apf.lookup(apf.popup.last);
            if (o) {
                o.state = apf.OFF;
                this.$notifyPlugin(o.name, o.state);
            }
        }

        //this.$selection.cache();
        this.$selection.set();
        if (this.$visualFocus)
            this.$visualFocus();

        oPlugin.state = apf.ON;
        this.$notifyPlugin(oPlugin.name, apf.ON);

        if (apf.popup.isShowing(sCacheId))
            return;

        // using $setTimeout here, because I want the popup to be shown AFTER the
        // event bubbling is complete. Another click handler further up the DOM
        // tree may call a apf.popup.forceHide();
        $setTimeout(function() {
            apf.popup.show(sCacheId, {
                x        : 0,
                y        : 22,
                animate  : false,
                ref      : oRef,
                width    : iWidth,
                height   : iHeight,
                callback : function(oPopup) {
                    if (oPopup.onkeydown) return;
                    oPopup.onkeydown = function(e) {
                        e = e || window.event;
                        var key = e.which || e.keyCode;
                        if (key == 13 && typeof oPlugin["submit"] == "function") //Enter
                            return oPlugin.submit(new apf.AbstractEvent(e));
                    }
                }
            });
        });
    };

    /**
     * Returns the translated key from a locale pack/ collection
     *
     * @param {String}  key
     * @param {Boolean} bIsPlugin
     * @type  {String}
     * @private
     */
    this.$translate = function(key, bIsPlugin) {
        
        if ((!bIsPlugin && !apf.ContentEditable.i18n[this.language][key])
          || (bIsPlugin && !apf.ContentEditable.i18n[this.language]["plugins"][key]))
            apf.console.error("Translation does not exist"
                + (bIsPlugin ? " for plugin" : "") + ": " + key);
        

        return bIsPlugin
            ? apf.ContentEditable.i18n[this.language]["plugins"][key]
            : apf.ContentEditable.i18n[this.language][key];
    };

    /**
     * Inserts any given text (or HTML) at cursor position into the Editor
     *
     * @param {String}  html
     * @param {Boolean} [bNoParse] Prevents parsing the HTML, which might alter the string
     * @param {Boolean} [bNoFocus] Prevents setting the focus back to the editor area
     * @type  {void}
     */
    this.$insertHtml = function(html, bNoParse, bNoFocus) {
        //removed check: if (inited && complete)
        if (!bNoFocus)
            this.$selection.set();
        this.$visualFocus(true);
        
        html = bNoParse ? html : apf.htmlCleaner.prepare(html);
        
        this.$selection.setContent(html, true);
        // notify SmartBindings that we changed stuff...
        
        this.change(this.getValue());
        

        if (bNoFocus) return;
        var _self = this;
        $setTimeout(function() {
            _self.$selection.set();
            _self.$visualFocus();
        });
    };

    /**
     * Corrects the default/ standard behavior of user agents that do not match
     * our intentions or those of the user.
     *
     * @param {DOMElement} oParent ContentEditable element
     * @type  void
     * @private
     */
    this.$controlAgentBehavior = function(oParent) {
        if (apf.isGecko) {
            //var oParent = this.$activeDocument.body;
            var oNode;
            while (oParent.childNodes.length) {
                oNode = oParent.firstChild;
                if (oNode.nodeType == 1) {
                    if (oNode.nodeName == "BR"
                      && oNode.getAttribute("_moz_editor_bogus_node") == "TRUE") {
                        this.$selection.selectNode(oNode);
                        this.$selection.remove();
                        this.$selection.collapse(false);
                        break;
                    }
                }
                oParent = oNode;
            }
        }
        else if (apf.isWebkit) {
            this.$activeDocument.designMode = "on";
        }
        else if (apf.isIE) {
            // yes, we fix hyperlinks...%&$#*@*!
            var s, aLinks = oParent.getElementsByTagName("a");
            for (var i = 0, j = aLinks.length; i < j; i++) {
                s = aLinks[i].getAttribute("_apf_href");
                if (s) { //prefix 'http://' if it's not there yet...
                    aLinks[i].href = (s.indexOf("http://") == -1
                        ? "http://" : "") + s;
                }
            }
        }
    };

    this.language = "en_GB";//"nl_NL";
    this.state    = apf.OFF;

    this.edit = function(xmlNode, value) {
        this.$executeSingleValue("edit", "edit", xmlNode, value);
    }
};

apf.ON             = 1;
apf.OFF            = 0;
apf.DISABLED       = -1;
apf.VISIBLE        = 2;
apf.HIDDEN         = 3;
apf.SELECTED       = 4;

apf.ContentEditable.i18n = {
    "en_GB": {
        "cancel": "Cancel",
        "insert": "Insert",
        "bold": "Bold",
        "italic": "Italic",
        "underline": "Underline",
        "strikethrough": "Strikethrough",
        "justifyleft": "Align text left",
        "justifycenter": "Center",
        "justifyright": "Align text right",
        "justifyfull": "Justify",
        "removeformat": "Clear formatting",
        "cut": "Cut",
        "copy": "Copy",
        "paste": "Paste",
        "outdent": "Decrease indent",
        "indent": "Increase indent",
        "undo": "Undo",
        "redo": "Redo",
        // plugin keys:
        "anchor": "Insert anchor",
        "blockquote": "Blockquote",
        "charmap": "Character map",
        "code": "HTML source view",
        "listitem": "List item",
        "nbsp": "Non-breaking space",
        "break": "Linebreak",
        "paragraph": "Paragraph",
        "forecolor": "Font color",
        "backcolor": "Highlight color",
        "insertdate": "Insert current date",
        "inserttime": "Insert current time",
        "rtl": "Change text direction to right-to-left",
        "ltr": "Change text direction to left-to-right",
        "emotions": "Insert emotion",
        "fonts": "Font",
        "fontsize": "Font size",
        "fontstyle": "Font style",
        "blockformat": "Paragraph style",
        "help": "Help",
        "hr": "Insert horizontal rule",
        "image": "Insert image",
        "imagespecial": "Choose an image to insert",
        "link": "Insert hyperlink",
        "unlink": "Remove hyperlink",
        "bullist": "Bullets",
        "numlist": "Numbering",
        "media": "Insert medium",
        "pasteworddialog": "Paste from Word",
        "pastetext": "Paste plaintext",
        "paste_keyboardmsg": "Use %s on your keyboard to paste the text into the window.",
        "print": "Print document",
        "preview": "Preview document",
        "scayt": "Turn spellcheck on/ off",
        "search": "Search",
        "replace": "Search and Replace",
        "findnext": "Find next",
        "doreplace": "Replace",
        "replaceall": "Replace all",
        "sub": "Subscript",
        "sup": "Superscript",
        "table": "Insert table",
        "table_noun": "Table",
        "visualaid": "Toggle visual aid on/ off"
    },
     "nl_NL": {
        "cancel": "Annuleren",
        "insert": "Invoegen",
        "bold": "Vet",
        "italic": "Schuingedrukt",
        "underline": "Onderstreept",
        "strikethrough": "Doorgestreept",
        "justifyleft": "Recht uitlijnen",
        "justifycenter": "Centreren",
        "justifyright": "Rechts uitlijnen",
        "justifyfull": "Justify",
        "removeformat": "Stijlen verwijderen",
        "cut": "Knippen",
        "copy": "Kopieren",
        "paste": "Plakken",
        "outdent": "Inspringen verkleinen",
        "indent": "Inspringen vergroten",
        "undo": "Ongedaan maken",
        "redo": "Opnieuw",
        // plugin keys:
        "anchor": "Anchor invoegen",
        "blockquote": "Blockquote",
        "charmap": "Speciale tekens",
        "code": "HTML broncode",
        "listitem": "Lijst item",
        "nbsp": "Niet-brekende spatie",
        "break": "Regelafbreuk",
        "paragraph": "Paragraaf",
        "forecolor": "Tekstkleur",
        "backcolor": "Markeerkleur",
        "insertdate": "Huidige datum invoegen",
        "inserttime": "Huidige tijd invoegen",
        "rtl": "Verander tekstrichting naar rechts-naar-links",
        "ltr": "Verander tekstrichting naar links-naar-rechts",
        "emotions": "Emoticon invoegen",
        "fonts": "Lettertype",
        "fontsize": "Letter grootte",
        "fontstyle": "Tekststijl",
        "blockformat": "Paragraafstijl",
        "help": "Hulp",
        "hr": "Horizontale lijn invoegen",
        "image": "Afbeelding invoegen",
        "imagespecial": "Afbeelding kiezen",
        "link": "Link invoegen",
        "unlink": "Link verwijderen",
        "bullist": "Ongenummerd",
        "numlist": "Genummerd",
        "media": "Medium invoegen",
        "pasteworddialog": "Word Tekst Plakken",
        "pastetext": "Tekst Plakken",
        "paste_keyboardmsg": "Gebruik %s op uw toetsenbord om tekst in dit scherm te plakken.",
        "print": "Printen",
        "preview": "Voorbeeldvertoning",
        "scayt": "Spellingscontrole aan/ uit",
        "search": "Zoeken",
        "replace": "Zoeken en vervangen",
        "findnext": "Volgende",
        "doreplace": "Vervangen",
        "replaceall": "Vervang alle",
        "sub": "Subscript",
        "sup": "Superscript",
        "table": "Tabel invoegen",
        "table_noun": "Tabel",
        "visualaid": "Visuele hulp aan/ uit"
    }
};

apf.TOOLBARITEM   = 0x0001;//"toolbaritem";
apf.TOOLBARBUTTON = 0x0002;//"toolbarbutton";
apf.TOOLBARPANEL  = 0x0004;//"toolbarpanel";
apf.TEXTMACRO     = 0x0008;//"textmacro";
apf.CMDMACRO      = 0x0010;//"commandmacro";

/**
 * @class plugin
 * @constructor
 * @extends ContentEditable
 * @namespace apf
 * @author Mike de Boer  (mike AT javeline DOT com)
 *
 * Example plugin:
 * <code language=javascript>
 * apf.ContentEditable.plugin("sample", function() {
 *     this.name    = "SamplePluginName";
 *     this.type    = "PluginType";
 *     this.subType = "PluginSubType";
 *     this.hook    = "EventHook";
 *     this.params  = null;
 *
 *     this.execute = function(editor) {
 *         // code to be executed when the event hook is fired
 *     }
 *     // That's it! you can add more code below to your liking...
 * });
 * </code>
 */
apf.ContentEditable.plugin = function(sName, fExec) {
    apf.ContentEditable.plugin[sName] = function() {
        this.$uniqueId = apf.all.push(this) - 1;

        /**
         * Appends a new AML element - in its string representation - to an
         * existing AML node. A new AML node will be created as specified by the
         * contents of sNode and appended to oParent.
         *
         * @param {String}  sNode
         * @param {AmlNode} oParent
         * @type  {AmlNode}
         */
        this.appendAmlNode = function(sNode, oParent) {
            if (!sNode) return null;
            var domParser = new apf.DOMParser(),
                oFrag     = this.editor.ownerDocument.createDocumentFragment();
            oFrag.$int    = oParent;
            var oNode     = domParser.parseFromString(sNode, "text/xml", {
                doc     : this.editor.ownerDocument,
                docFrag : oFrag
            });
            return oNode.firstChild;
        };

        this.dispatchEvent = function() {
            var _self = this;
            window.setTimeout(function() {
                if (_self.type == apf.editor.CONTEXTPANEL
                  && _self.queryState(_self.editor) == apf.editor.ON)
                    return;
                _self.state = apf.editor.OFF;
                if (_self.editor)
                    _self.editor.$notifyButton(_self.name, _self.state);
                //@todo: add animation?
                apf.popup.hide();
                apf.popup.last = null;
            });

            return false;
        };

        this.$destroy = function() {
            // @todo should we keep this, or does apf.Popup destroy itself? what
            // if we removeNode() the editor?
            apf.popup.forceHide();
            this.buttonNode = this.editor = null;
            delete this.buttonNode;
            delete this.editor;
            if (this.destroy)
               this.destroy();
        }

        fExec.apply(this, arguments);
    };
};

apf.GuiElement.propHandlers["contenteditable"] = function(value) {
    this.implement(apf.ContentEditable);
    if (!this.hasFeature(apf.__VALIDATION__))
        this.implement(apf.Validation);
    this.$propHandlers["contenteditable"].apply(this, arguments);
}




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/links.js)SIZE(7733)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.ContentEditable.plugin("link", function(){
    this.name        = "link";
    this.icon        = "link";
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARPANEL;
    this.hook        = "ontoolbar";
    this.keyBinding  = "ctrl+shift+l";
    this.state       = apf.OFF;

    var panelBody;

    this.init = function(editor, btn) {
        this.buttonNode.className = this.buttonNode.className + " dropdown_small";
        var oArrow = this.buttonNode.insertBefore(document.createElement("span"),
            this.buttonNode.getElementsByTagName("div")[0]);
        oArrow.className = "selectarrow";
    };

    this.execute = function(editor) {
        if (!panelBody) {
            this.editor = editor;
            apf.popup.setContent(this.$uniqueId, this.createPanelBody());
        }

        editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});

        this.oUrl.value = "http://";
        this.editor.$showPopup(this, this.$uniqueId, this.buttonNode, 218, 95);
        if (panelBody.style.visibility == "hidden")
            panelBody.style.visibility = "visible";
        var _self = this;
        $setTimeout(function() {
            _self.oUrl.focus();
        });
        //return button id, icon and action:
        return {
            id: this.name,
            action: null
        };
    };

    this.queryState = function(editor) {
        if (editor.$selection.isCollapsed() || editor.$selection.getSelectedNode().tagName == "A")
            return apf.DISABLED;
        return this.state;
    };

    this.submit = function(e) {
        apf.popup.forceHide();

        if (!this.oUrl.value.replace("http://", "")) return;

        this.editor.$execCommand("CreateLink", "javascript:apftmp(0);");
        var oLink, aLinks = this.editor.$activeDocument.getElementsByTagName("a");
        for (var i = 0; i < aLinks.length && !oLink; i++)
            if (aLinks[i].href == "javascript:apftmp(0);")
                oLink = aLinks[i];
        if (oLink) {
            var val = this.oUrl.value;
            oLink.href   = (val.indexOf("http://") == -1 ? "http://" : "") + val;
            oLink.target = this.oTarget.value;
            oLink.title  = this.oTitle.value;
        }
        this.editor.$selection.collapse(false);
        
        // propagate the change AFTER changing back the link to its proper format
        this.editor.change(this.editor.getValue());

        if (e.stop)
            e.stop();
        return false;
    };

    this.createPanelBody = function() {
        panelBody = document.body.appendChild(document.createElement("div"));
        panelBody.className = "editor_popup";
        panelBody.style.display = "none";
        var idUrl    = "editor_" + this.$uniqueId + "_link_url";
        var idTarget = "editor_" + this.$uniqueId + "_link_target";
        var idTitle  = "editor_" + this.$uniqueId + "_link_title";
        var idBtns   = "editor_" + this.$uniqueId + "_link_btns";
        panelBody.innerHTML =
           '<div class="editor_panelrow editor_panelrowinput">\
                <label for="' + idUrl + '">Link URL</label>\
                <input type="text" id="' + idUrl + '" name="' + idUrl + '" class="editor_input" value="" />\
            </div>\
            <div class="editor_panelrow editor_panelrowinput">\
                <label for="' + idTarget + '">Target</label>\
                <select id="' + idTarget + '" name="' + idTarget + '">\
                    <option value="_self">Open in this window/ frame</option>\
                    <option value="_blank">Open in new window (_blank)</option>\
                    <option value="_parent">Open in parent window/ frame (_parent)</option>\
                    <option value="_top">Open in top frame (replaces all frames) (_top)</option>\
                </select>\
            </div>\
            <div class="editor_panelrow editor_panelrowinput">\
                <label for="' + idTitle + '">Title</label>\
                <input type="text" id="' + idTitle + '" name="' + idTitle + '" class="editor_input" value="" />\
            </div>\
            <div id="' + idBtns + '" class="editor_panelrow editor_panelrowbtns"></div>';

        //document.getElementById(idButton).onmousedown = this.submit.bindWithEvent(this);
        this.oUrl    = document.getElementById(idUrl);
        this.oTarget = document.getElementById(idTarget);
        this.oTitle  = document.getElementById(idTitle);

        
        if (apf.hasFocusBug) {
            apf.sanitizeTextbox(this.oUrl);
            apf.sanitizeTextbox(this.oTarget);
            apf.sanitizeTextbox(this.oTitle);
            this.oUrl.onselectstart   = this.oTarget.onselectstart =
            this.oTitle.onselectstart = function(e) {
                e = e || window.event;
                e.cancelBubble = true;
            };
        }
        

        new apf.toolbar({
            htmlNode: document.getElementById(idBtns),
            skinset: apf.getInheritedAttribute(this.editor.parentNode, "skinset"),
            childNodes: [
                new apf.bar({
                    childNodes: [new apf.button({
                        caption: this.editor.$translate("insert"),
                        onclick: "apf.lookup(" + this.$uniqueId + ").submit(event)"
                    })]
                })
            ]
        });

        return panelBody;
    };

    this.destroy = function() {
        panelBody = this.oUrl = this.oTarget = this.oTitle = null;
        delete panelBody;
        delete this.oUrl;
        delete this.oTarget;
        delete this.oTitle;
    };
});

apf.ContentEditable.plugin("unlink", function(){
    this.name        = "unlink";
    this.icon        = "unlink";
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARBUTTON;
    this.hook        = "ontoolbar";
    this.keyBinding  = "ctrl+shift+l";
    this.state       = apf.OFF;

    this.execute = function(editor) {
        if (this.queryState(editor) == apf.DISABLED)
            return;

        if (apf.isIE) {
            editor.$execCommand("Unlink");
        }
        else {
            var sel = editor.$selection;
            sel.set();
            var oNode = sel.getSelectedNode();
            if (oNode.tagName == "A") {
                var txt = oNode.innerHTML;
                sel.selectNode(oNode);
                sel.remove();
                sel.collapse();
                editor.$insertHtml(txt);
            }
        }
    };

    this.queryState = function(editor) {
        if (!editor.$selection)
            console.dir(editor);
        if (editor.$selection.getSelectedNode().tagName == "A")
            return apf.OFF;

        return apf.DISABLED;
    };
});




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/subsup.js)SIZE(1970)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.ContentEditable.subSupCommand = function(sName) {
    this.name        = sName;
    this.icon        = sName;
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARBUTTON;
    this.hook        = "ontoolbar";
    this.keyBinding  = sName == "sub" ? "ctrl+alt+s" : "ctrl+shift+s";
    this.state       = apf.OFF;

    this.execute = function(editor) {
        var other = this.name == "sub" ? "Superscript" : "Subscript";
        if (editor.$queryCommandState(other) == apf.ON)
            editor.$execCommand(other);
        editor.$execCommand(this.name == "sub" ? "Subscript" : "Superscript");

        editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});
    };

    this.queryState = function(editor) {
        return editor.$queryCommandState(this.name == "sub"
            ? "Subscript"
            : "Superscript");
    };
}
apf.ContentEditable.plugin("sub", apf.ContentEditable.subSupCommand);
apf.ContentEditable.plugin("sup", apf.ContentEditable.subSupCommand);




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/fontbase.js)SIZE(8632)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.ContentEditable.plugin("fonts", function() {
    this.name        = "fonts";
    this.icon        = "fonts";
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARPANEL;
    this.hook        = "ontoolbar";
    this.buttonNode  = null;
    this.state       = apf.OFF;
    this.colspan     = 1;
    this.fontNames   = {};

    var panelBody;

    this.init = function(editor) {
        this.buttonNode.className = this.buttonNode.className + " fontpicker";
        this.fontPreview = this.buttonNode.getElementsByTagName("span")[0];
        this.fontPreview.className += " fontpreview";
        var fontArrow = this.buttonNode.insertBefore(document.createElement("span"),
            this.buttonNode.getElementsByTagName("div")[0]);
        fontArrow.className = "selectarrow";

        this.editor = editor;

        // parse fonts
        var l, j, font, fonts, node;
        var oNode = editor.$getPluginOption("fonts").childNodes[0];
        while(oNode) {
            fonts = oNode.nodeValue.splitSafe("(?:;|=)");
            if (fonts[0]) {
                for (j = 0, l = fonts.length; j < l; j++)
                    this.fontNames[fonts[j]] = fonts[++j];
                break;
            }
            oNode = oNode.nextSibling
        }

        this.queryState(editor);
    };

    this.execute = function() {
        if (!panelBody) {
            apf.popup.setContent(this.$uniqueId, this.createPanelBody());
        }

        this.editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});
        
        this.editor.$showPopup(this, this.$uniqueId, this.buttonNode, 120);
        //return button id, icon and action:

        return {
            id: this.name,
            action: null
        };
    };

    this.queryState = function(editor) {
        this.state = editor.$queryCommandState("FontName");

        var currValue = editor.$queryCommandValue("FontName");
        if (!currValue || (this.fontNames[currValue] && this.fontPreview.innerHTML != currValue))
            this.fontPreview.innerHTML = currValue ? currValue : "Font";
    };

    this.submit = function(e) {
        e = new apf.AbstractEvent(e || window.event);
        while (e.target.tagName.toLowerCase() != "a" && e.target.className != "editor_popup")
            e.target = e.target.parentNode;
        var sFont = e.target.getAttribute("rel");
        if (sFont) {
            apf.popup.forceHide();
            if (apf.isIE) {
                this.editor.$selection.set();
                if (this.editor.$selection.isCollapsed()) {
                    this.editor.$visualFocus();
                    var r = this.editor.$selection.getRange();
                    r.moveStart("character", -1);
                    r.select();
                }
            }
            this.editor.$execCommand("FontName", sFont);
            if (apf.isIE)
                this.editor.$selection.collapse(false);
        }
    };

    this.createPanelBody = function() {
        panelBody = document.body.appendChild(document.createElement("div"));
        panelBody.className = "editor_popup";
        panelBody.style.display = "none";
        var aHtml = [];

        for (var i in this.fontNames) {
            aHtml.push('<a class="editor_panelcell editor_font" style="font-family:',
                this.fontNames[i], ';" rel="', i,
                '" href="javascript:;" onmouseup="apf.lookup(', this.$uniqueId,
                ').submit(event);">', i, "</a>");
        }
        panelBody.innerHTML = aHtml.join("");

        return panelBody;
    };

    this.destroy = function() {
        panelBody = this.fontPreview = null;
        delete panelBody;
        delete this.fontPreview;
    };
});

apf.ContentEditable.plugin("fontsize", function() {
    this.name        = "fontsize";
    this.icon        = "fontsize";
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARPANEL;
    this.hook        = "ontoolbar";
    this.buttonNode  = null;
    this.state       = apf.OFF;

    var panelBody;

    // this hashmap maps font size number to it's equivalent in points (pt)
    var sizeMap = {
        "1" : "8",
        "2" : "10",
        "3" : "12",
        "4" : "14",
        "5" : "18",
        "6" : "24",
        "7" : "36"
    };

    this.init = function(editor) {
        this.buttonNode.className = this.buttonNode.className + " fontsizepicker";
        this.sizePreview = this.buttonNode.getElementsByTagName("span")[0];
        this.sizePreview.className += " fontsizepreview";
        var sizeArrow = this.buttonNode.insertBefore(document.createElement("span"),
            this.buttonNode.getElementsByTagName("div")[0]);
        sizeArrow.className = "selectarrow";

        this.queryState(editor);
    };

    this.execute = function(editor) {
        if (!panelBody) {
            this.editor = editor;

            // parse font sizes
            var i, node, oNode = editor.$getPluginOption("fontsizes");
            for (i = 0; i < oNode.childNodes.length; i++) {
                node = oNode.childNodes[i];
                if (node.nodeType == 3 || node.nodeType == 4)
                    this.fontSizes = node.nodeValue.splitSafe(",");
            }

            apf.popup.setContent(this.$uniqueId, this.createPanelBody());
        }
        this.editor.$showPopup(this, this.$uniqueId, this.buttonNode, 203);
        //return button id, icon and action:
        return {
            id: this.name,
            action: null
        };
    };

    this.queryState = function(editor) {
        this.state = editor.$queryCommandState("FontSize");

        var currValue = editor.$queryCommandValue("FontSize")
        if (!currValue || this.sizePreview.innerHTML != currValue)
            this.sizePreview.innerHTML = currValue ? currValue : "Size";
    };

    this.submit = function(e) {
        e = new apf.AbstractEvent(e || window.event);
        while (e.target.tagName.toLowerCase() != "a" && e.target.className != "editor_popup")
            e.target = e.target.parentNode;
        var sSize = e.target.getAttribute("rel");
        if (sSize) {
            apf.popup.forceHide();
            if (apf.isIE) {
                this.editor.$selection.set();
                if (this.editor.$selection.isCollapsed()) {
                    this.editor.$visualFocus();
                    var r = this.editor.$selection.getRange();
                    r.moveStart("character", -1);
                    r.select();
                }
            }
            this.editor.$execCommand("FontSize", sSize);
            if (apf.isIE)
                this.editor.$selection.collapse(false);
        }
        e.stop();
        return false;
    };

    this.createPanelBody = function() {
        panelBody = document.body.appendChild(document.createElement("div"));
        panelBody.className = "editor_popup";
        panelBody.style.display = "none";
        var aHtml = [];

        var aSizes = this.fontSizes;
        for (var i = 0; i < aSizes.length; i++) {
            aHtml.push('<a class="editor_panelcell editor_fontsize" style="font-size:',
                sizeMap[aSizes[i]], "pt;height:", sizeMap[aSizes[i]], "pt;line-height:",
                sizeMap[aSizes[i]], 'pt;" rel="', aSizes[i],
                '" href="javascript:;" onmouseup="apf.lookup(', this.$uniqueId,
                ').submit(event);">', aSizes[i], " (", sizeMap[aSizes[i]], "pt)</a>");
        }
        panelBody.innerHTML = aHtml.join("");

        return panelBody;
    };

    this.destroy = function() {
        panelBody = this.sizePreview = null;
        delete panelBody;
        delete this.sizePreview;
    };
});




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/media.js)SIZE(1496)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.ContentEditable.plugin("media", function(){
    this.name        = "media";
    this.icon        = "media";
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARBUTTON;
    this.hook        = "ontoolbar";
    this.keyBinding  = "ctrl+m";
    this.state       = apf.OFF;

    this.execute = function(editor) {
        // @todo: implement this plugin
        editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});
    };

    this.queryState = function(editor) {
        return this.state;
    };
});




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/list.js)SIZE(4676)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.ContentEditable.listPlugin = function(sName) {
    this.name        = sName;
    this.icon        = sName;
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARBUTTON;
    this.hook        = "ontoolbar";
    this.keyBinding  = sName == "bullist" ? "ctrl+shift+u" : "ctrl+shift+o";
    this.state       = apf.OFF;

    var emptyRegex = apf.isIE
        ? /^(&nbsp;)?<DIV[^>]*_apf_placeholder(="1">&nbsp;)?<\/DIV>$/gi
        : /^(&nbsp;)?<BR\/?>$/gi;

    this.execute = function(editor) {
            editor.$execCommand(this.name == "bullist"
                ? "InsertUnorderedList"
                : "InsertOrderedList");

        this.correctLists(editor);
        editor.$visualFocus();

        editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});
    };

    function moveListItems(from, to) {
        var i, oNode, oLastNode,
            listNode = (this.name == "bullist") ? "OL" : "UL";
        for (i = from.childNodes.length; i >= 0; i--) {
            oNode = from.childNodes[i];
            if (!oNode) continue;
            if (oNode.tagName == listNode) break;
            if (!oLastNode)
                to.appendChild(oNode);
            else
                to.insertBefore(oNode, oLastNode);
            oLastNode = oNode;
        }
        from.parentNode.removeChild(from);
    }

    function getEmptyLi(oParent) {
        if (!oParent || oParent.nodeType != 1) return;
        var sHtml, aNodes = oParent.getElementsByTagName("li");
        for (var i = 0, j = aNodes.length; i < j; i++) {
            sHtml = aNodes[i].innerHTML.trim();
            if (sHtml == "" || sHtml == "&nbsp;" || sHtml.match(emptyRegex))
                return aNodes[i];
        }
        return null;
    }

    this.correctLists = function(editor) {
        editor.$selection.set();

        var oNode = editor.$selection.getSelectedNode();
        //window.console.log("correcting lists0: ", oNode);
        //window.console.dir(editor.$selection.getRange());
        if (oNode.tagName != "LI") {
            oNode = getEmptyLi(oNode);
            if (!oNode || oNode.tagName != "LI")
                return false;
        }
        var oParent   = oNode.parentNode,
            oSiblingP = oNode.parentNode.previousSibling,
            oHasBr    = null;
        if (!oSiblingP) return false
        if (oSiblingP && oSiblingP.tagName == "BR") {
            oHasBr    = oSiblingP;
            oSiblingP = oSiblingP.previousSibling;
        }
        var oSibling = (oSiblingP && oSiblingP.tagName == oParent.tagName)
            ? oSiblingP
            : null;
        if (!oSibling) return;
        if (oHasBr)
            oParent.removeChild(oHasBr);

        moveListItems(oParent, oSibling);

        //while (oSibling.nextSibling && oSibling.tagName == oSibling.nextSibling.tagName)
        //    moveListItems(oSibling.nextSibling, oSibling);

        editor.$selection.selectNode(oNode);
        if (!apf.isIE)
            editor.$selection.getRange().setStart(oNode, 0);
        editor.$selection.collapse(!apf.isIE);
        editor.$visualFocus();
        return true;
    };

    this.correctIndentation = function(editor, dir) {
        //this.correctLists(editor);
        editor.$execCommand(dir);
        this.correctLists(editor);
    };

    this.queryState = function(editor) {
        var state = editor.$queryCommandState(this.name == "bullist"
            ? "InsertUnorderedList"
            : "InsertOrderedList");
        if (state == apf.DISABLED)
            return apf.OFF;
        return state;
    };
};

apf.ContentEditable.plugin("bullist", apf.ContentEditable.listPlugin);
apf.ContentEditable.plugin("numlist", apf.ContentEditable.listPlugin);




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/fontstyle.js)SIZE(25787)TIME(1260921686)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.ContentEditable.plugin("fontstyle", function() {
    this.name         = "fontstyle";
    this.icon         = "fontstyle";
    this.type         = apf.TOOLBARITEM;
    this.subType      = apf.TOOLBARPANEL;
    this.hook         = "ontoolbar";
    this.buttonNode   = null;
    this.state        = apf.OFF;

    var panelBody, oStyles = null, oEditor = null;

    function getStyles(editor) {
        if (!oStyles) {
            // parse font styles from skin definition
            var node, aCss, bCss, oNode = editor.$getPluginOption("fontstyles");
            
            if (!oNode || !oNode.childNodes)
                throw new Error(apf.formatErrorString(0, editor,
                    "Initializing plugin: fontstyle",
                    "No fontstyle block found in skin definition"));
            
            for (var i = 0, j = oNode.childNodes.length; i < j && !oStyles; i++) {
                node = oNode.childNodes[i];
                if (node.nodeType == 3 || node.nodeType == 4) {
                    oStyles = {};
                    aCss    = [];
                    bCss    = [];

                    node.nodeValue.replace(/([\w ]+)\s*=\s*(([^\{]+?)\s*\{[\s\S]*?\})\s*/g,
                        function (m, caption, css, className) {
                            
                            if (!css || css.charAt(css.length - 1) != "}")
                                throw new Error(apf.formatErrorString(0, editor,
                                    "Initializing plugin: fontstyle",
                                    "Invalid fontstyle block, please check if formatting rules have been applied"));
                            
                            if (css.charAt(0) != ".")
                                css = "." + css;
                            css = css.trim().replace(/[\s]+/g, "");
                            className = className.trim().replace(/\./, "");
                            oStyles[className] = {
                                caption: caption.trim(),
                                cname  : className,
                                css    : css,
                                node   : null
                            };
                            aCss.push(css);
                            bCss.push(".editor_fontstyle " + css);
                        }
                    );
                }
            }

            if (aCss.length) {
                // insert resulting CSS into container document AND inside the
                // document of the editor's iframe
                apf.importCssString(bCss.join(""));
                apf.importCssString(aCss.join(""), editor.$activeDocument);
                if (apf.isIE) {
                    // removing text nodes from the HEAD section, which are added
                    // by IE in some cases.
                    var nodes = editor.$activeDocument.getElementsByTagName("head")[0].childNodes,
                        cnt   = nodes.length - 1;
                    while (cnt) {
                        if (nodes[cnt].nodeType == 3) //text
                            nodes[cnt].parentNode.removeChild(nodes[cnt]);
                        cnt--;
                    }
                }
            }
        }
        return oStyles;
    }

    this.init = function(editor) {
        oEditor = editor;
        
        this.buttonNode.className = this.buttonNode.className + " fontstylepicker";
        this.stylePreview = this.buttonNode.getElementsByTagName("span")[0];
        this.stylePreview.className += " fontstylepreview";
        var styleArrow = this.buttonNode.appendChild(document.createElement("span"));
        styleArrow.className = "selectarrow";

        this.queryState(editor);
    };

    this.execute = function(editor) {
        if (!panelBody) {
            oEditor = editor;

            apf.popup.setContent(this.$uniqueId, this.createPanelBody(editor));
        }

        editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});

        oEditor.$showPopup(this, this.$uniqueId, this.buttonNode, 203);
        //return button id, icon and action:
        return {
            id: this.name,
            action: null
        };
    };

    function getCurrentStyle() {
        getStyles(oEditor);

        var oNode = oEditor.$selection.getSelectedNode();
        while (oNode && oNode.nodeType != 1) // we need a block element
            oNode = oNode.parentNode;

        var oCurrent;
        while (!oCurrent && oNode && oNode.tagName != "BODY") {
            var cs = oNode.className;
            for (var i in oStyles) {
                if (cs.indexOf(i) > -1) {
                    oCurrent = oStyles[i];
                    oCurrent.node = oNode;
                }
            }
            oNode = oNode.parentNode;
        }

        return oCurrent;
    }

    this.submit = function(e, sStyle) {
        if (!sStyle) {
            e = new apf.AbstractEvent(e || window.event);
            while (e.target.tagName.toLowerCase() != "a" && e.target.className != "editor_popup")
                e.target = e.target.parentNode;
            sStyle = e.target.getAttribute("rel");
        }

        if (sStyle) {
            apf.popup.forceHide();
            var sel = oEditor.$selection;

            sel.set();
            oEditor.$visualFocus();
            
            var o = getCurrentStyle(oEditor);
            
            if (o && sStyle == "normal") {
                var n = o.node.childNodes, p = o.node.parentNode;
                while (n.length) {
                    p.insertBefore(n[0], o.node);
                }
                p.removeChild(o.node);
                
                this.queryState(oEditor);
            }
            else if (o && (sel.isCollapsed() 
              || sel.getContent("text") == o.node.innerHTML)
              && apf.isChildOf(o.node, sel.getSelectedNode(), true)) {
                if (o.cname == sStyle) return;
                apf.setStyleClass(o.node, sStyle, [o.cname]);
            }
            else {
                if (sel.isCollapsed()) {
                    if (apf.isIE) {
                        var oNode = sel.getRange().parentElement();
                        var p = oEditor.$activeDocument.createElement("span");
                        p.className = sStyle;
                        p.innerHTML = oNode.innerHTML;
                        if (oNode.tagName == "BODY") {
                            oNode.innerHTML = "";
                            oNode.appendChild(p);
                        }
                        else {
                            oNode.parentNode.insertBefore(p, oNode);
                            oNode.parentNode.removeChild(oNode);
                        }
                        sel.selectNode(p);
                    }
                    else {
                        var range  = sel.getRange();
                        var oCaret = range.commonAncestorContainer;
                        range.setStartBefore(oCaret);
                        range.setEndAfter(oCaret);
                        sel.setRange(range);
                        var htmlNode = sel.setContent('<span class="' + sStyle + '">'
                            + sel.getContent() + "</span>");
                        sel.selectNode(htmlNode);
                    }
                }
                else {
                    //s.match(/^([\s\S]*?)(<(?:normal|pre|p|address|h1|h2|h3|h4|h5|h6)[\s\S]*?<\/(?:normal|pre|p|address|h1|h2|h3|h4|h5|h6)>)([\s\S]*?)$/gi)
                    var s = sel.getContent().trim();
                    var shouldPrefixSpan = s.substr(0,5) == "<SPAN";
                    s = s.replace(/<SPAN class=.*?>|<\/SPAN>/gi, "");
                    if (s.charAt(0) == "<") {
                        s = s
                          .replace(/<(normal|pre|p|address|h1|h2|h3|h4|h5|h6)(?:\s.*?|)>(.+?)<\/(normal|pre|p|address|h1|h2|h3|h4|h5|h6)>/gi, 
                            '<$1><span class="' + sStyle + '">$2</span></$3>')
                          .replace(/^([\s\S]*?)(<(?:normal|pre|p|address|h1|h2|h3|h4|h5|h6)[\s\S]*<\/(?:normal|pre|p|address|h1|h2|h3|h4|h5|h6)>)([\s\S]*?)$/gi, 
                            function(m, m1, m2, m3){
                                return (m1 ? '<span class="' + sStyle + '">' + m1 + "</span>" : "") + m2 + (m3 ? '<span class="' + sStyle + '">' + m3 + "</span>" : "");
                            })
                          .replace(/^\s*<(?:normal|pre|p|address|h1|h2|h3|h4|h5|h6)(?:\s.*?|)>|<\/(?:normal|pre|p|address|h1|h2|h3|h4|h5|h6)>\s*$/gi, "");
                        if (apf.isIE) 
                            s = s.replace(/<\/P>/, "");
                    }
                    else {
                        s = '<span class="' + sStyle + '">' + s + "</span>";
                    }
                    
                    if (shouldPrefixSpan) 
                        s = "</SPAN>" + s.replace(/<\/SPAN>$/i, "");
                    
                    var htmlNode = sel.setContent(s, true);
                    sel.selectNode(htmlNode);
                }
            }
            
            // Notify the SmartBindings we've changed...
            
            oEditor.change(oEditor.getValue());
            
        }
    };

    this.queryState = function() {
        var o = getCurrentStyle();
        if (o) {
            if (this.stylePreview.innerHTML != o.caption)
                this.stylePreview.innerHTML = o.caption;
            this.state = apf.ON;
        }
        else {
            this.stylePreview.innerHTML = "Style";
            this.state = apf.OFF;
        }

        return this.state;
    };

    this.createPanelBody = function(editor) {
        panelBody = document.body.appendChild(document.createElement("div"));
        panelBody.className = "editor_popup";
        panelBody.style.display = "none";

        getStyles(editor);
        var aHtml = ['<a class="editor_panelcell editor_fontstyle" rel="normal" \
            href="javascript:;" onmouseup="apf.lookup(', this.$uniqueId, 
            ').submit(event);"><span>Normal</span></a>'];
        for (var i in oStyles) {
            aHtml.push('<a class="editor_panelcell editor_fontstyle" rel="',
                i, '" href="javascript:;" onmouseup="apf.lookup(',
                this.$uniqueId, ').submit(event);"><span class="', i, '">',
                oStyles[i].caption, "</span></a>")
        }
        panelBody.innerHTML = aHtml.join("");

        return panelBody;
    };

    this.destroy = function() {
        panelBody = this.stylePreview = oEditor = null;
        delete panelBody;
        delete this.stylePreview;
        delete oEditor;
    };
});

//##############################################################################

apf.ContentEditable.plugin("blockformat", function() {
    this.name         = "blockformat";
    this.icon         = "blockformat";
    this.type         = apf.TOOLBARITEM;
    this.subType      = apf.TOOLBARPANEL;
    this.hook         = "ontoolbar";
    this.buttonNode   = null;
    this.state        = apf.OFF;
    this.node         = null;

    var panelBody, oEditor,

    // this hashmap maps font size number to it's equivalent in points (pt)
    blocksMap = {
        "normal"  : "Normal",
        "p"       : "Paragraph",
        "pre"     : "Preformatted",
        "address" : "Address",
        "h1"      : "Header 1",
        "h2"      : "Header 2",
        "h3"      : "Header 3",
        "h4"      : "Header 4",
        "h5"      : "Header 5",
        "h6"      : "Header 6"
    },
    blocksRE, blocksRE2, blocksRE3, blocksRE4, blockFormats;

    function getFormats(editor) {
        if (!blockFormats) {
            // parse font styles from skin definition
            var i, j, node, oNode = editor.$getPluginOption("blockformats");
            
            if (!oNode || !oNode.childNodes)
                throw new Error(apf.formatErrorString(0, editor,
                    "Initializing plugin: Blockformat",
                    "No block formats found in skin definition"));
            
            for (i = 0, j = oNode.childNodes.length; i < j; i++) {
                node = oNode.childNodes[i];
                if (node.nodeType == 3 || node.nodeType == 4)
                    blockFormats = node.nodeValue.splitSafe(",");
            }

            var sJoin = "(" + blockFormats.join("|") + ")";
            blocksRE  = new RegExp("^" + sJoin + "$", "gi");
            blocksRE2 = new RegExp("<\\/?" + sJoin + ">", "gi");
            blocksRE3 = new RegExp("<\\/?(" + blockFormats.join("|") + "|p)>", "gi");
            blocksRE4 = new RegExp("^(" + blockFormats.join("|") + "|p)$", "gi");
        }
        return blockFormats;
    }

    this.init = function(editor) {
        oEditor = editor;
        this.buttonNode.className = this.buttonNode.className + " blockformatpicker";
        this.blockPreview = this.buttonNode.getElementsByTagName("span")[0];
        this.blockPreview.className += " blockformatpreview";
        var blockArrow = this.buttonNode.appendChild(document.createElement("span"));
        blockArrow.className = "selectarrow";

        this.queryState(editor);
    };

    this.execute = function(editor) {
        if (!panelBody) {
            oEditor = editor;

            apf.popup.setContent(this.$uniqueId, this.createPanelBody(editor));
        }
        oEditor.$showPopup(this, this.$uniqueId, this.buttonNode, 203);
        //return button id, icon and action:
        return {
            id: this.name,
            action: null
        };
    };
    
    this.queryState = function() {
        var oNode    = oEditor.$selection.getSelectedNode(),
            aFormats = getFormats(oEditor),
            /*bCurrent = (oNode && oNode.nodeType == 1
                && aFormats.contains(oNode.tagName.toLowerCase())),
            bParent  = (oNode && oNode.parentNode && oNode.parentNode.nodeType == 1
                && aFormats.contains(oNode.parentNode.tagName.toLowerCase())),*/
            tagName  = oNode.nodeType == 1 ? oNode.tagName.toLowerCase() : "";
        
        while (tagName && !tagName.match(blocksRE) && tagName != "body") {
            oNode   = oNode.parentNode;
            tagName = (oNode.tagName || "").toLowerCase();
        }
        if (tagName.match(blocksRE)) {//bCurrent || bParent) {
            var sBlock = blocksMap[tagName];
            if (this.blockPreview.innerHTML != sBlock)
                this.blockPreview.innerHTML = sBlock;
            this.state = apf.ON;
            this.node  = oNode;
        }
        else {
            this.blockPreview.innerHTML = "Normal";
            this.state = apf.OFF;
            this.node  = null;
        }
        return this.state;
    };

    this.submit = function(e, sBlock) {
        if (!sBlock) {
            e = new apf.AbstractEvent(e || window.event);
            while (e.target.tagName.toLowerCase() != "a" && e.target.className != "editor_popup")
                e.target = e.target.parentNode;
            sBlock = e.target.getAttribute("rel");
        }

        if (sBlock) {
            apf.popup.forceHide();
            var oNode, sel = oEditor.$selection;

            sel.set();
            oEditor.$visualFocus();
            var s = sel.getContent();
            if (sBlock == "normal" && this.queryState(oEditor) == apf.ON) {
                // revert style to NORMAL, i.e. no style at all.
                /*sel.selectNode(this.node);
                sel.setContent(this.node.innerHTML);*/
                
                var n = this.node.childNodes, p = this.node.parentNode;
                
                if (apf.isIE) {
                    //var textlength = sel.getContent("text").length;
                    var l = p.insertBefore(p.ownerDocument.createElement("p"), this.node);
                    
                    while (n.length) {
                        l.insertBefore(n[0], l.firstChild);
                    }
                    
                    p.removeChild(this.node);
                    sel.selectNode(l);
                    if (l.previousSibling && l.previousSibling.tagName == "P") {
                        if (l.previousSibling.innerHTML == "") {
                            l.parentNode.removeChild(l.previousSibling);
                        }
                    }
                }
                else {
                    while (n.length) {
                        p.insertBefore(n[0], this.node);
                    }
                    
                    p.removeChild(this.node);
                }
                
                this.state = apf.OFF;
                this.node  = null;
                this.blockPreview.innerHTML = "Normal";
            }
            else if (sel.isCollapsed() || s.trim() == "") {
                if (apf.isIE) {
                    var startNode, oNode;
                    oNode = startNode = sel.getRange().parentElement();
                    while(!oNode.tagName.match(blocksRE4) && oNode.tagName != "BODY") {
                        oNode = oNode.parentNode;
                    }
                    
                    if (oNode && oNode.tagName == "BODY") {
                        if (startNode != oNode)
                            oNode = startNode;
                        else  {
                            //r = sel.getRange();r.moveEnd("character", 500); r.htmlText
                        }
                    }
                    
                    var p = oEditor.$activeDocument.createElement(sBlock);
                    p.innerHTML = oNode.innerHTML;
                    if (oNode.tagName == "BODY") {
                        oNode.innerHTML = "";
                        oNode.appendChild(p);
                    }
                    else {
                        oNode.parentNode.insertBefore(p, oNode);
                        oNode.parentNode.removeChild(oNode);
                    }
                    sel.selectNode(p);
                }
                else {
                    oEditor.$execCommand("FormatBlock", sBlock);
                }
                
                this.blockPreview.innerHTML = blocksMap[sBlock];
            }
            else {
                oNode = sel.getSelectedNode();
                while (oNode.nodeType != 1)
                    oNode = oNode.parentNode;

                // @todo FF is DEFINITELY b0rking when we try to nest HTML 4.01 block elements...
                //       REALLY not like Word does it...
                if (oNode.tagName.match(blocksRE4) && s.length == oNode[apf.hasInnerText ? "innerText" : "textContent"].length) {
                    var p = oEditor.$activeDocument.createElement(sBlock);
                    p.innerHTML = oNode.innerHTML;
                    oNode.parentNode.insertBefore(p, oNode);
                    oNode.parentNode.removeChild(oNode);
                    sel.selectNode(p);
                }
                else {
                    while(!oNode.tagName.match(blocksRE4) && oNode.tagName != "BODY") {
                        oNode = oNode.parentNode;
                    }
                    if (oNode && oNode.tagName != "BODY") {
                        var s2;
                        if (oNode.tagName == "P" && apf.isIE) {
                            s2 = "<" + sBlock + ">" + s.trim().replace(blocksRE3, "") + "</" + sBlock + ">";
                            addedNode = sel.setContent(s2);
                        }
                        else {
                            s2 = '<P __apf_placeholder="true">' + s + "</P>";
                            sel.setContent(s2);
                            
                            var sBlock2 = oNode.tagName;
                            var html = [], first, last;
                            var strHtml = oNode.innerHTML.replace(s2, function(m, pos){
                                return (pos != 0 
                                        ? (first = true) && "</" + sBlock2 + ">"
                                        : "") +
                                    "<" + sBlock + ' __apf_placeholder="true">' + s.replace(blocksRE3, "") +
                                    "</" + sBlock + ">" +
                                    (pos < oNode.innerHTML.length - s.length 
                                        ? (last = true) && "<" + sBlock2 + ">"
                                        : "");
                            });
                            if (first)
                                html.push("<" + sBlock2 + ">");
                            html.push(strHtml);
                            if (last)
                                html.push("</" + sBlock2 + ">");
                            
                            oNode.innerHTML = html.join("");
                            var addedNode, n = oNode.getElementsByTagName(sBlock);
                            for (var i = 0; i < n.length; i++) {
                                if (n[i].getAttribute("__apf_placeholder")) {
                                    n[i].removeAttribute("__apf_placeholder");
                                    addedNode = n[i];
                                    break;
                                }
                            }
                            
                            n = oNode.childNodes, p = oNode.parentNode;
                            while (n.length)
                                p.insertBefore(n[0], oNode);
                            p.removeChild(oNode);
                        }
                        
                        if (addedNode) {
                            if (apf.isIE) {
                                var prev = addedNode.previousSibling
                                if (prev && prev.tagName == "P" && prev.innerHTML == "&nbsp;")
                                    prev.parentNode.removeChild(prev);
                                
                                //@todo make this a setting?
                                /*addedNode.parentNode.insertBefore(
                                    addedNode.ownerDocument.createElement("P"),
                                    addedNode);*/
                            }
                            sel.selectNode(addedNode);
                        }
                    }
                    else {
                        var addedNode = sel.setContent("<" + sBlock + ">"
                            + s.replace(/<p>(.*?)<\/p>(.)/gi, "$1<br />$2")
                               .replace(blocksRE3, "") + "</" + sBlock + ">");
                       
                        if (apf.isIE) {
                            var prev = addedNode.previousSibling
                            if (prev && prev.tagName == "P" && prev.innerHTML == "&nbsp;")
                                prev.parentNode.removeChild(prev);
                                    
                            //@todo make this a setting?
                                /*addedNode.parentNode.insertBefore(
                                addedNode.ownerDocument.createElement("P"),
                                addedNode);*/
                        }
                       
                        sel.selectNode(addedNode);
                    }
                }
                
                this.blockPreview.innerHTML = blocksMap[sBlock];
            }
            
            // Notify the SmartBindings we've changed...
            
            oEditor.change(oEditor.getValue());
            
        }
    };

    this.createPanelBody = function(editor) {
        panelBody = document.body.appendChild(document.createElement("div"));
        panelBody.className = "editor_popup";
        panelBody.style.display = "none";

        var aHtml = [],
            aFormats = getFormats(editor);
        for (var i = 0, j = aFormats.length; i < j; i++) {
            aHtml.push('<a class="editor_panelcell editor_blockformat" rel="',
                aFormats[i], '" href="javascript:;" onmouseup="apf.lookup(',
                this.$uniqueId, ').submit(event);"><', aFormats[i], ">",
                blocksMap[aFormats[i]], "</", aFormats[i], "></a>");
        }
        panelBody.innerHTML = aHtml.join("");

        return panelBody;
    };

    this.destroy = function() {
        panelBody = oEditor = this.blockPreview = this.node = null;
        delete panelBody;
        delete oEditor;
        delete this.blockPreview;
        delete this.node;
    };
});





/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/hr.js)SIZE(1600)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.ContentEditable.plugin("hr", function(){
    this.name        = "hr";
    this.icon        = "hr";
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARBUTTON;
    this.hook        = "ontoolbar";
    this.keyBinding  = "ctrl+h";
    this.state       = apf.OFF;

    this.execute = function(editor) {
        if (apf.isGecko || apf.isIE)
            editor.$insertHtml("<hr />", true);
        else
            editor.$execCommand("InsertHorizontalRule");

        editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});
    };

    this.queryState = function(editor) {
        return this.state;
    };
});




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/tables.js)SIZE(26820)TIME(1259708671)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.ContentEditable.plugin("table", function() {
    this.name        = "table";
    this.icon        = "table";
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARPANEL;
    this.hook        = "ontoolbar";
    this.keyBinding  = "ctrl+alt+shift+t";
    this.state       = apf.OFF;

    var panelBody, oTableCont, oTableSel, oTable, oStatus, oTablePos, oDoc,
        iCurrentX = 0,
        iCurrentY = 0,
        _self = this;

    this.init = function(editor, btn) {
        this.buttonNode.className = this.buttonNode.className + " dropdown_small";
        var oArrow = this.buttonNode.insertBefore(document.createElement("span"),
            this.buttonNode.getElementsByTagName("div")[0]);
        oArrow.className = "selectarrow";
    };

    this.execute = function(editor) {
        if (!panelBody) {
            this.editor = editor;
            oDoc = editor.useIframe ? document : editor.$activeDocument;
            apf.popup.setContent(this.$uniqueId, this.createPanelBody());
        }
        else
            resetTableMorph();

        //this.storeSelection();

        editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});

        this.editor.$showPopup(this, this.$uniqueId, this.buttonNode);
        window.setTimeout(function() {
            panelBody.style.width  = (oTableCont.offsetWidth + 8) + "px";
            panelBody.style.height = (oTableCont.offsetWidth + 20) + "px";
            oTablePos = apf.getAbsolutePosition(oTable);
        });
    };

    this.queryState = function(editor) {
        return this.state;
    };

    this.submit = function(oSize) {
        apf.popup.forceHide();

        if (oSize[0] < 0 || oSize[1] < 0) return;

        var i, j, k, l, aOut = ['<table border="0" width="50%">'];
        for (i = 0, j = oSize[0]; i < j; i++) {
            aOut.push("<tr>");
            for (k = 0, l = oSize[1]; k < l; k++)
                aOut.push("<td>", (apf.isIE ? "" : '&nbsp;<br _apf_placeholder="1" />'),"</td>");
            aOut.push("</tr>")
        }
        aOut.push("</table>")

        //this.restoreSelection();
        //if (apf.isIE)
        //this.editor.$selection.set();
        this.editor.$insertHtml(aOut.join(""), true);
        this.editor.$selection.collapse(false);
        this.editor.$visualFocus();
    };

    var bMorphing = false, oMorphCurrent, iMorphXCount, iMorphYCount;
    function mouseDown(e) {
        bMorphing     = true;
        oMorphCurrent = e.client;
        iMorphXCount  = iMorphYCount = 0;
        //apf.plane.show(panelBody, true);
        document.onmousemove = function(e) {
            if (!bMorphing) return;
            e = new apf.AbstractEvent(e || window.event);
            // only morph the table when the mouse reaches beyond the table
            if (e.client.x > oTablePos[0] + oTable.offsetWidth
              || e.client.y > oTablePos[1] + oTable.offsetHeight)
                morphTable(e);
            e.stop();
            return false;
        }
        document.onmouseup = function(e) {
            e = new apf.AbstractEvent(e || window.event);
            mouseUp.call(_self, e);
            e.stop();
            return false;
        }
        //e.stop();
        return false;
    }

    function mouseUp(e) {
        if (bMorphing) {
            bMorphing     = false;
            oMorphCurrent = document.onmousemove = document.onmouseup = null;
            iMorphXCount  = iMorphYCount = 0;
            //apf.plane.hide();
        }
        mouseOver.call(this, e);
        if (iCurrentX > 0 && iCurrentY > 0)
            this.submit([iCurrentY, iCurrentX]);
        e.stop();
        return false;
    }

    function morphTable(e) {
        oMorphCurrent = e.client;
        iMorphXCount  = (Math.floor((oMorphCurrent.x - oTablePos[0]) / 23) * 23) + 23;
        if (iMorphXCount > oTable.offsetWidth) {
            panelBody.style.width  = (iMorphXCount + 10) + "px";
            oTableCont.style.width = (iMorphXCount + 4) + "px";
            oTable.style.width     = (iMorphXCount) + "px";
            oTableSel.style.width  = (iMorphXCount) + "px";
        }
        iMorphYCount = (Math.floor((oMorphCurrent.y - oTablePos[1]) / 23) * 23) + 23;
        if (iMorphYCount > oTable.offsetHeight) {
            panelBody.style.height  = (iMorphYCount + 20) + "px";
            oTableCont.style.height = (iMorphYCount + 4) + "px";
            oTable.style.height     = (iMorphYCount) + "px";
            oTableSel.style.height  = (iMorphYCount) + "px";
        }
    }

    function resetTableMorph() {
        oTableCont.style.width = oTableCont.style.height = "164px";
        oTableSel.style.width  = oTableSel.style.height  = "0px";
        oTable.style.width     = oTable.style.height     = "160px";
    }

    var sCurrentCaption = "";

    function mouseOver(e) {
        if (typeof oTablePos == "undefined") return;
        iCurrentX = Math.ceil((e.page.x - oTablePos[0]) / 23);
        iCurrentY = Math.ceil((e.page.y - oTablePos[1]) / 23);
        if (iCurrentX > 0 && iCurrentY > 0) {
            oTableSel.style.width  = Math.min((iCurrentX * 23), oTable.offsetWidth)  + "px";
            oTableSel.style.height = Math.min((iCurrentY * 23), oTable.offsetHeight) + "px";
            var sCaption = iCurrentY + " x " + iCurrentX + " " 
                + _self.editor.$translate("table_noun");
            if (sCurrentCaption != sCaption)
                oStatus.innerHTML = sCurrentCaption = sCaption;
        }
        else
            iCurrentX = iCurrentY = 0;
    }

    function mouseOut(e) {
        if (bMorphing) return;
        oTableSel.style.width = oTableSel.style.height = "0px";
        iCurrentX = iCurrentY = 0;
        oStatus.innerHTML = sCurrentCaption = _self.editor.$translate("cancel");
    }

    function statusClick(e) {
        mouseOut.call(this, e);
        apf.popup.forceHide();
    }

    this.createPanelBody = function() {
        panelBody = document.body.appendChild(document.createElement("div"));
        panelBody.className = "editor_popup editor_tablepopup";
        panelBody.style.display = "none";

        var idTableCont = "editor_" + this.$uniqueId + "_tablecont";
        var idTableSel  = "editor_" + this.$uniqueId + "_tablesel";
        var idTable     = "editor_" + this.$uniqueId + "_table";
        var idStatus    = "editor_" + this.$uniqueId + "_table_status";
        panelBody.innerHTML =
           '<div id="' + idTableCont + '" class="editor_paneltable_cont">\
                <div id="' + idTableSel + '" class="editor_paneltable_sel"></div>\
                <div id="' + idTable + '" class="editor_paneltable"></div>\
            </div>\
            <div id="' + idStatus + '" class="editor_paneltablecancel">' 
                + this.editor.$translate("cancel") + '</div>';

        oTableCont = document.getElementById(idTableCont);
        oTableSel  = document.getElementById(idTableSel);
        oTable     = document.getElementById(idTable);
        oTable.onmousedown  = mouseDown.bindWithEvent(this);
        oTable.onmouseup    = mouseUp.bindWithEvent(this);
        oTable.onmousemove  = mouseOver.bindWithEvent(this);
        oTable.onmouseout   = mouseOut.bindWithEvent(this);
        oStatus = document.getElementById(idStatus);
        oStatus.onmousedown = statusClick.bindWithEvent(this);
        panelBody.onselectstart = function() { return false; };
        resetTableMorph();

        return panelBody;
    };

    this.destroy = function() {
        //oTableCont, oTableSel, oTable, oStatus, oTablePos, oDoc
        panelBody = oTableCont = oTableSel = oTable = oStatus = oTablePos
            = oDoc = null;
        delete panelBody;
        delete oTableCont;
        delete oTableSel;
        delete oTable;
        delete oStatus;
        delete oTablePos;
        delete oDoc;
    };
});

apf.ContentEditable.plugin("tablewizard", function() {
    this.name        = "tablewizard";
    this.icon        = "tablewizard";
    this.type        = apf.CONTEXTPANEL;
    this.hook        = "context";
    this.state       = apf.OFF;
    this.oTable      = null;
    this.oRow        = null;
    this.oCell       = null;

    var activeNode, oDoc, _self = this;

    this.execute = function(editor, e) {
        if (this.queryState(editor) != apf.ON)
            return;
        // get the active table, row and cell nodes:
        this.oTable = this.oRow = this.oCell = null;
        while (activeNode.tagName != "TABLE") {
            if (activeNode.tagName == "TD")
                this.oCell = activeNode;
            else if (activeNode.tagName == "TR")
                this.oRow = activeNode;
            activeNode = activeNode.parentNode;
        }
        this.oTable = activeNode;

        if (!this.editor)
            this.editor = editor;
        if (!apf.editor.oMenu)
            this.createContextMenu();
        if (!oDoc)
            oDoc = editor.useIframe ? document : editor.$activeDocument;
        apf.editor.oMenu.tablePlugin = this;

        var pos = apf.getAbsolutePosition(editor.iframe);
        if (!e.client)
            e = new apf.AbstractEvent(e);
        apf.editor.oMenu.display(e.client.x + pos[0], e.client.y + pos[1], true);

        e.stop();

        editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});
        
        return false;
    };

    this.queryState = function(editor) {
        var oNode = editor.$selection.getSelectedNode();
        while (oNode.nodeType != 1 || oNode.tagName != "BODY") {
            if (oNode.tagName == "TABLE" || oNode.tagName == "TBODY"
              || oNode.tagName == "TR" || oNode.tagName == "TD") {
                activeNode = oNode;
                return apf.ON;
            }
            oNode = oNode.parentNode;
        }

        return apf.OFF;
    };

    function addRows(td_elm, tr_elm, rowspan) {
        // Add rows
        td_elm.rowSpan = 1;
        var trNext = nextElm(tr_elm, ["TR"]);
        for (var i = 1; i < rowspan && trNext; i++) {
            var newTD = oDoc.createElement("td");
            if (!apf.isIE)
                newTD.innerHTML = '<br mce_bogus="1"/>';
            if (apf.isIE)
                trNext.insertBefore(newTD, trNext.cells(td_elm.cellIndex));
            else
                trNext.insertBefore(newTD, trNext.cells[td_elm.cellIndex]);
            trNext = nextElm(trNext, ["TR"]);
        }
    }

    function getColRowSpan(td) {
        var colspan = td.getAttribute("colspan") || "";
        var rowspan = td.getAttribute("rowspan") || "";

        return {
            colspan : colspan == "" ? 1 : parseInt(colspan),
            rowspan : rowspan == "" ? 1 : parseInt(rowspan)
        };
    }

    function getTableGrid(table) {
        var grid = [], rows = table.rows, x, y, td, sd, xstart, x2, y2;

        for (y = 0; y < rows.length; y++) {
            for (x = 0; x < rows[y].cells.length; x++) {
                td = rows[y].cells[x];
                sd = getColRowSpan(td);

                // All ready filled
                for (xstart = x; grid[y] && grid[y][xstart]; xstart++){}

                // Fill box
                for (y2 = y; y2 < y + sd.rowspan; y2++) {
                    if (!grid[y2])
                        grid[y2] = [];

                    for (x2 = xstart; x2 < xstart + sd.colspan; x2++)
                        grid[y2][x2] = td;
                }
            }
        }

        return grid;
    }

    function getCellPos(grid, td) {
        for (var i = 0; i < grid.length; i++) {
            for (var j = 0; j < grid[i].length; j++) {
                if (grid[i][j] == td)
                    return {cellindex : j, rowindex : i};
            }
        }

        return null;
    }

    function getCell(grid, row, col) {
        if (grid[row] && grid[row][col])
            return grid[row][col];
        return null;
    }

    function nextElm(node, names) {
        while ((node = node.nextSibling) != null) {
            for (var i = 0; i < names.length; i++) {
                if (node.nodeName.toLowerCase() == names[i].toLowerCase())
                    return node;
            }
        }
        return null;
    }

    this.createContextMenu = function(){
        var idMenu = "editor_" + this.$uniqueId + "_menu";
        this.appendAmlNode('\
            <a:menu xmlns:a="' + apf.ns.aml + '" id="' + idMenu + '">\
                <a:item value="rowbefore">Insert row before</a:item>\
                <a:item value="rowbefore">Insert row after</a:item>\
                <a:item value="deleterow">Delete row</a:item>\
                <a:divider />\
                <a:item value="colbefore">Insert column before</a:item>\
                <a:item value="colafter">Insert column after</a:item>\
                <a:item value="deletecol">Delete column</a:item>\
                <a:divider />\
                <a:item value="splitcells">Split merged table cells</a:item>\
                <a:item value="mergecells">Merge table cells</a:item>\
            </a:menu>', document.body);
        //nodes disabled:
        // <a:divider />\
        // <a:item value="rowprops">Table row properties</a:item>\
        // <a:item value="colprops">Table column properties</a:item>\
        var oMenu = apf.editor.oMenu = self[idMenu];
        oMenu.addEventListener("onitemclick", function(e){
            if (this.tablePlugin != _self)
                return;

            var oRow, i, j, idx = 0;

            if (_self.oCell) {
                for (i = 0, j = _self.oRow.cells.length; i < j; i++)
                    if (_self.oRow.cells[i] == _self.oCell)
                        idx = i;
            }

            _self.editor.$selection.set();

            switch (e.value) {
                case "rowbefore":
                    oRow = oDoc.createElement("tr");
                    _self.oRow.parentNode.insertBefore(oRow, _self.oRow);
                    for (i = 0, j = _self.oRow.cells.length; i < j; i++)
                        oRow.insertCell(0);
                    break;
                case "rowafter":
                    oRow = oDoc.createElement("tr");
                    _self.oRow.parentNode.insertBefore(oRow, _self.oRow.nextSibling);
                    for (i = 0, j = _self.oRow.cells.length; i < j; i++)
                        oRow.insertCell(0);
                    break;
                case "deleterow":
                    if (!_self.oRow || !_self.oRow.parentNode) return;
                    _self.oRow.parentNode.removeChild(_self.oRow);
                    break;
                case "colbefore":
                    if (!_self.oCell) return;
                    for (i = 0, j = _self.oTable.rows.length; i < j; i++)
                        _self.oTable.rows[i].insertCell(idx);
                    break;
                case "colafter":
                    if (!_self.oCell) return;
                    idx += 1;
                    for (i = 0, j = _self.oTable.rows.length; i < j; i++)
                        _self.oTable.rows[i].insertCell(idx);
                    break;
                case "deletecol":
                    if (!_self.oCell || _self.oTable.rows[0].cells.length == 1)
                        return;
                    //@todo: fix this to understand cell spanning
                    for (i = 0, j = _self.oTable.rows.length; i < j; i++) {
                        if (_self.oTable.rows[i].cells[idx])
                            _self.oTable.rows[i].deleteCell(idx);
                    }
                    break;
                case "splitcells":
                    if (!_self.oRow || !_self.oCell)
                        return true;

                    var spandata = getColRowSpan(_self.oCell);

                    var colspan = spandata["colspan"];
                    var rowspan = spandata["rowspan"];

                    // Needs splitting
                    if (colspan > 1 || rowspan > 1) {
                        // Generate cols
                        _self.oCol.colSpan = 1;
                        for (i = 1; i < colspan; i++) {
                            var newTD = oDoc.createElement("td");
                            if (!apf.isIE)
                                newTD.innerHTML = '<br _apf_placeholder="1"/>';

                            _self.oRow.insertBefore(newTD, nextElm(_self.oCell, ["TD","TH"]));

                            if (rowspan > 1)
                                addRows(newTD, _self.oRow, rowspan);
                        }

                        addRows(_self.oCell, _self.oRow, rowspan);
                    }
                    break;
                case "mergecells":
                    var rows = [], cells = [],
                        oSel = _self.editor.$selection.get(),
                        grid = getTableGrid(_self.oTable),
                        oCellPos, aRows, aRowCells, aBrs, oTd, k;

                    if (apf.isIE || oSel.rangeCount == 1) {
                        var numRows = 1;
                        var numCols = 1;
                        oCellPos = getCellPos(grid, _self.oCell);

                        // Get rows and cells
                        aRows = _self.oTable.rows;
                        for (i = oCellPos.rowindex; i < grid.length; i++) {
                            aRowCells = [];

                            for (j = oCellPos.cellindex; j < grid[i].length; j++) {
                                oTd = getCell(grid, i, j);

                                if (oTd && !rows.contains(oTd) && !aRowCells.contains(oTd)) {
                                    var cp = getCellPos(grid, oTd);
                                    // Within range
                                    if (cp.cellindex < oCellPos.cellindex + numCols
                                      && cp.rowindex < oCellPos.rowindex + numRows)
                                        aRowCells[aRowCells.length] = oTd;
                                }
                            }
                            if (aRowCells.length > 0)
                                rows[rows.length] = aRowCells;

                            oTd = getCell(grid, oCellPos.rowindex, oCellPos.cellindex);
                            aBrs = oTd.getElementsByTagName("br");
                            if (aBrs.length > 1) {
                                for (j = aBrs.length; j >= 1; j--) {
                                    if (aBrs[j].getAttribute("_apf_placeholder"))
                                        aBrs[j].parentNode.removeChild(aBrs[j]);
                                }
                            }
                        }
                    }
                    else {
                        var x1 = -1, y1 = -1, x2, y2;

                        // Only one cell selected, whats the point?
                        if (oSel.rangeCount < 2)
                            return true;

                        // Get all selected cells
                        for (i = 0; i < oSel.rangeCount; i++) {
                            var rng = oSel.getRangeAt(i);
                            _self.oCell = rng.startContainer.childNodes[rng.startOffset];
                            if (!_self.oCell)
                                break;
                            if (_self.oCell.nodeName == "TD" || _self.oCell.nodeName == "TH")
                                cells.push(_self.oCell);
                        }

                        // Get rows and cells
                        aRows = _self.oTable.rows;
                        for (i = 0; i < aRows.length; i++) {
                            aRowCells = [];
                            for (j = 0; j < aRows[i].cells.length; j++) {
                                oTd = aRows[i].cells[j];
                                for (k = 0; k < cells.length; k++) {
                                    if (oTd != cells[k]) continue;
                                    aRowCells.push(oTd);
                                }
                            }
                            if (aRowCells.length > 0)
                                rows.push(aRowCells);
                        }

                        // Find selected cells in grid and box
                        for (i = 0; i < grid.length; i++) {
                            for (j = 0; j < grid[i].length; j++) {
                                grid[i][j]._selected = false;
                                for (k = 0; k < cells.length; k++) {
                                    if (grid[i][j] != cells[k]) continue;
                                    // Get start pos
                                    if (x1 == -1) {
                                        x1 = j;
                                        y1 = i;
                                    }
                                    // Get end pos
                                    x2 = j;
                                    y2 = i;
                                    grid[i][j]._selected = true;
                                }
                            }
                        }

                        // Is there gaps, if so deny
                        for (i = y1; i <= y2; i++) {
                            for (j = x1; j <= x2; j++) {
                                if (!grid[i][j]._selected) {
                                    alert("Invalid selection for merge.");
                                    return true;
                                }
                            }
                        }
                    }

                    // Validate selection and get total rowspan and colspan
                    var rowSpan = 1, colSpan = 1;

                    // Validate horizontal and get total colspan
                    var sd, lastRowSpan = -1;
                    for (i = 0; i < rows.length; i++) {
                        var rowColSpan = 0;
                        for (j = 0, k = rows[i].length; j < k; j++) {
                            sd = getColRowSpan(rows[i][j]);
                            rowColSpan += sd.colspan;
                            if (lastRowSpan != -1 && sd.rowspan != lastRowSpan) {
                                alert("Invalid selection for merge.");
                                return true;
                            }
                            lastRowSpan = sd.rowspan;
                        }
                        if (rowColSpan > colSpan)
                            colSpan = rowColSpan;
                        lastRowSpan = -1;
                    }

                    // Validate vertical and get total rowspan
                    var lastColSpan = -1;
                    for (j = 0; j < rows[0].length; j++) {
                        var colRowSpan = 0;
                        for (i = 0; i < rows.length; i++) {
                            sd = getColRowSpan(rows[i][j]);
                            colRowSpan += sd.rowspan;
                            if (lastColSpan != -1 && sd.colspan != lastColSpan) {
                                alert("Invalid selection for merge.");
                                return true;
                            }
                            lastColSpan = sd.colspan;
                        }
                        if (colRowSpan > rowSpan)
                            rowSpan = colRowSpan;
                        lastColSpan = -1;
                    }

                    // Setup td
                    _self.oCell = rows[0][0];
                    _self.oCell.rowSpan = rowSpan;
                    _self.oCell.colSpan = colSpan;

                    // Merge cells
                    for (i = 0; i < rows.length; i++) {
                        for (j = 0; j < rows[i].length; j++) {
                            var html = rows[i][j].innerHTML;
                            var chk = html.replace(/[ \t\r\n]/g, "");
                            if (chk != "<br/>" && chk != '<br _apf_placeholder="1"/>'
                              && (j + i > 0))
                                _self.oCell.innerHTML += html;

                            // Not current cell
                            if (rows[i][j] == _self.oCell && rows[i][j]._deleted)
                                continue;
                            oCellPos = getCellPos(grid, rows[i][j]);
                            var tr = rows[i][j].parentNode;

                            tr.removeChild(rows[i][j]);
                            rows[i][j]._deleted = true;

                            if (tr.hasChildNodes()) continue;
                            // Empty TR, remove it
                            tr.parentNode.removeChild(tr);

                            var cellElm, lastCell = null;
                            for (k = 0; cellElm = getCell(grid, oCellPos.rowindex, k); k++) {
                                if (cellElm != lastCell && cellElm.rowSpan > 1)
                                    cellElm.rowSpan--;
                                lastCell = cellElm;
                            }
                            if (_self.oCell.rowSpan > 1)
                                _self.oCell.rowSpan--;
                        }
                    }

                    // Remove all but one bogus br
                    aBrs = _self.oCell.getElementsByTagName("br");
                    if (aBrs.length > 1) {
                        for (i = aBrs.length; i >= 1; i--) {
                            if (aBrs[i] && aBrs[i].getAttribute("_apf_placeholder"))
                                aBrs[i].parentNode.removeChild(aBrs[i]);
                        }
                    }
                    break;
           }
           
            _self.editor.change(_self.editor.getValue());
            
        });
    };
});




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/help.js)SIZE(1492)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.ContentEditable.plugin("help", function(){
    this.name        = "help";
    this.icon        = "help";
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARBUTTON;
    this.hook        = "ontoolbar";
    this.keyBinding  = "ctrl+h";
    this.state       = apf.OFF;

    this.execute = function(editor) {
        // @todo: implement this plugin
        editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});
    };

    this.queryState = function(editor) {
        return this.state;
    };
});




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/charmap.js)SIZE(6999)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.ContentEditable.plugin("charmap", function() {
    this.name        = "charmap";
    this.icon        = "charmap";
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARPANEL;
    this.hook        = "ontoolbar";
    this.buttonNode  = null;
    this.state       = apf.OFF;
    this.colspan     = 20;

    var panelBody;

    this.init = function(editor, btn) {
        this.buttonNode.className = this.buttonNode.className + " dropdown_small";
        var oArrow = this.buttonNode.insertBefore(document.createElement("span"),
            this.buttonNode.getElementsByTagName("div")[0]);
        oArrow.className = "selectarrow";
    };

    this.execute = function(editor) {
        if (!panelBody) {
            this.editor = editor;
            apf.popup.setContent(this.$uniqueId, this.createPanelBody());
        }

        editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});

        this.editor.$showPopup(this, this.$uniqueId, this.buttonNode, apf.isIE6 ? 469 : 466, 318);
        //return button id, icon and action:
        return {
            id: this.name,
            action: null
        };
    };

    this.queryState = function() {
        return this.state;
    };

    var chars = ["!","&#34;","#","$","%","&#38;","\\'","(",")","*","+","-",".",
        "/","0","1","2","3","4","5","6","7","8","9",":",";","&#60;","=","&#62;",
        "?","@","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P",
        "Q","R","S","T","U","V","W","X","Y","Z","[","]","^","_","`","a","b","c",
        "d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u",
        "v","w","x","y","z","{","|","}","~","&#161;","&#162;","&#163;","&#164;",
        "&#165;","&#166;","&#167;","&#168;","&#169;","&#170;","&#171;","&#172;",
        "&#174;","&#175;","&#176;","&#177;","&#178;","&#179;","&#180;","&#181;",
        "&#182;","&#183;","&#184;","&#185;","&#186;","&#187;","&#188;","&#189;",
        "&#190;","&#191;","&#192;","&#193;","&#194;","&#195;","&#196;","&#197;",
        "&#198;","&#199;","&#200;","&#201;","&#202;","&#203;","&#204;","&#205;",
        "&#206;","&#207;","&#208;","&#209;","&#210;","&#211;","&#212;","&#213;",
        "&#214;","&#215;","&#216;","&#217;","&#218;","&#219;","&#220;","&#221;",
        "&#222;","&#223;","&#224;","&#225;","&#226;","&#227;","&#228;","&#229;",
        "&#230;","&#231;","&#232;","&#233;","&#234;","&#235;","&#236;","&#237;",
        "&#238;","&#239;","&#241;","&#242;","&#243;","&#244;","&#245;","&#246;",
        "&#247;","&#248;","&#249;","&#250;","&#251;","&#252;","&#253;","&#254;",
        "&#255;","&#338;","&#339;","&#352;","&#353;","&#376;","&#402;","&#710;",
        "&#732;","&#913;","&#914;","&#915;","&#916;","&#917;","&#918;","&#919;",
        "&#920;","&#921;","&#922;","&#923;","&#924;","&#925;","&#926;","&#927;",
        "&#928;","&#929;","&#931;","&#932;","&#933;","&#934;","&#935;","&#936;",
        "&#937;","&#945;","&#946;","&#947;","&#948;","&#949;","&#950;","&#951;",
        "&#952;","&#953;","&#954;","&#955;","&#956;","&#957;","&#958;","&#959;",
        "&#960;","&#961;","&#962;","&#963;","&#964;","&#965;","&#966;","&#967;",
        "&#968;","&#969;","&#977;","&#978;","&#982;","&#8201;","&#8211;","&#8212;",
        "&#8216;","&#8217;","&#8218;","&#8220;","&#8221;","&#8222;","&#8224;",
        "&#8225;","&#8226;","&#8230;","&#8240;","&#8242;","&#8243;","&#8249;",
        "&#8250;","&#8254;","&#8260;","&#8364;","&#8465;","&#8472;","&#8476;",
        "&#8482;","&#8501;","&#8592;","&#8593;","&#8594;","&#8595;","&#8596;",
        "&#8629;","&#8656;","&#8657;","&#8658;","&#8659;","&#8660;","&#8704;",
        "&#8706;","&#8707;","&#8709;","&#8711;","&#8712;","&#8713;","&#8715;",
        "&#8719;","&#8721;","&#8722;","&#8727;","&#8730;","&#8733;","&#8734;",
        "&#8736;","&#8743;","&#8744;","&#8745;","&#8746;","&#8747;","&#8756;",
        "&#8764;","&#8773;","&#8776;","&#8800;","&#8801;","&#8804;","&#8805;",
        "&#8834;","&#8835;","&#8836;","&#8838;","&#8839;","&#8853;","&#8855;",
        "&#8869;","&#8901;","&#8968;","&#8969;","&#8970;","&#8971;","&#9001;",
        "&#9002;","&#9674;","&#9824;","&#9827;","&#9829;","&#9830;"];

    this.submit = function(e) {
        e = new apf.AbstractEvent(e || window.event);
        while (e.target.tagName.toLowerCase() != "a" && e.target.className != "editor_popup")
            e.target = e.target.parentNode;
        var sCode = e.target.getAttribute("rel");
        if (sCode) {
            apf.popup.forceHide();
            //this.storeSelection();
            this.editor.$insertHtml(sCode, true);
            var _self = this;
            $setTimeout(function() { //make sure the 'change' is notified to the smartbindings
                
                _self.editor.change(_self.editor.getValue());
                
            });
            //this.restoreSelection();
        }
    };

    this.createPanelBody = function() {
        panelBody = document.body.appendChild(document.createElement("div"));
        panelBody.className = "editor_popup";
        panelBody.style.display = "none";
        var aHtml  = [];
        var rowLen = this.colspan - 1;
        for (var i = 0; i < chars.length; i++) {
            if (i % this.colspan == 0)
                aHtml.push('<div class="editor_panelrow">');
            aHtml.push('<a class="editor_panelcell editor_largecell" style="background-color:#',
                chars[i], ';" rel="', chars[i], '" href="javascript:;" onmousedown="apf.lookup(',
                this.$uniqueId, ').submit(event);">\
                <span>', chars[i],"</span>\
                </a>");
            if (i % this.colspan == rowLen)
                aHtml.push("</div>");
        }
        panelBody.innerHTML = aHtml.join("");
        return panelBody;
    };

    this.destroy = function() {
        panelBody = null;
        delete panelBody;
    };
});




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/blockquote.js)SIZE(1601)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.ContentEditable.plugin("blockquote", function(){
    this.name        = "blockquote";
    this.icon        = "blockquote";
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARBUTTON;
    this.hook        = "ontoolbar";
    this.keyBinding  = "ctrl+shift+b";
    this.buttonBuilt = false;
    this.state       = apf.OFF;

    this.execute = function(editor) {
        editor.$execCommand("FormatBlock", "BLOCKQUOTE");

        editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});
    };

    this.queryState = function(editor) {
        return editor.$queryCommandState("FormatBlock");
    };
});




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/clipboard.js)SIZE(13473)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.ContentEditable.pasteDialog = function(sName) {
    this.name        = sName;
    this.icon        = sName == "pasteworddialog" ? "pasteword" : sName;
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARPANEL;
    this.hook        = "ontoolbar";
    this.keyBinding  = sName == "pastetext" ? "ctrl+shift+v" : "ctrl+shift+w";
    this.state       = apf.OFF;

    var panelBody;

    this.init = function() {
        this.buttonNode.className = this.buttonNode.className + " dropdown_small";
        this.buttonNode.insertBefore(document.createElement("span"),
            this.buttonNode.getElementsByTagName("div")[0])
          .className = "selectarrow";
    };

    this.execute = function(editor) {
        if (!panelBody) {
            this.editor = editor;
            apf.popup.setContent(this.$uniqueId, this.createPanelBody());
        }

        editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});

        this.editor.$showPopup(this, this.$uniqueId, this.buttonNode, 300, 270);
        if (panelBody.style.visibility == "hidden")
            panelBody.style.visibility = "visible";
        var _self = this;
        $setTimeout(function() {
            _self.oArea.focus();
        }, 100); // 100ms, because of the $focusfix code...
        //return button id, icon and action:
        return {
            id: this.name,
            action: null
        };
    };

    this.queryState = function(editor) {
        return this.state;
    };

    this.submit = function(e) {
        apf.popup.forceHide();

        var sContent = this.oArea.value;
        if (!sContent || sContent.length == 0) return;

        if (this.name == "pastetext") {
            var rl = ["\u2122", "<sup>TM</sup>", "\u2026", "...", "\u201c|\u201d",
                "\"", "\u2019,'", "\u2013|\u2014|\u2015|\u2212", "-"];
            sContent = sContent.replace(/\u2122/gi, "<sup>TM</sup>")
                .replace(/\u2026/gi, "...")
                .replace(/\u201c|\u201d/gi, "\"")
                .replace(/\u2019,'/gi, "'")
                .replace(/\u2013|\u2014|\u2015|\u2212/gi, "-")
                .replace(/\r\n/g, "<br />")
                .replace(/\r/g, "<br />")
                .replace(/\n/g, "<br />");
        }
        else {
            sContent = this.editor.$plugins["pasteword"].parse(sContent);
        }
        this.editor.$insertHtml(sContent);

        if (e.stop)
            e.stop();
        else
            e.cancelBubble = true;
        return false;
    };

    this.createPanelBody = function() {
        panelBody = document.body.appendChild(document.createElement("div"));
        panelBody.className = "editor_popup";
        panelBody.style.display = "none";
        var idArea = "editor_" + this.$uniqueId + "_input",
            idBtns = "editor_" + this.$uniqueId + "_btns";
        panelBody.innerHTML =
           '<label for="' + idArea + '">' +
           this.editor.$translate("paste_keyboardmsg").sprintf(apf.isMac ? "CMD+V" : "CTRL+V")
           + '</label>\
            <textarea id="' + idArea + '" name="' + idArea + '"  wrap="soft" dir="ltr" \
              cols="60" rows="10" class="editor_textarea"></textarea>\
            <div class="editor_panelrow" style="position:absolute;bottom:0;width:100%" id="' + idBtns + '"></div>';

        this.oArea = document.getElementById(idArea);

        
        apf.sanitizeTextbox(this.oArea);
        

        if (apf.isIE) {
            this.oArea.onselectstart = this.oArea.onpaste = function(e) {
                e = e || window.event;
                e.cancelBubble = true;
            };
        }

        new apf.toolbar({
            htmlNode: document.getElementById(idBtns),
            skinset: apf.getInheritedAttribute(this.editor.parentNode, "skinset"),
            childNodes: [
                new apf.bar({
                    childNodes: [new apf.button({
                        caption: this.editor.$translate("insert"),
                        onclick: "apf.lookup(" + this.$uniqueId + ").submit(event)"
                    })]
                })
            ]
        });

        return panelBody;
    };

    this.destroy = function() {
        panelBody = this.oArea = null;
        delete panelBody;
        delete this.oArea;
    };
};

apf.ContentEditable.plugin("pasteworddialog", apf.ContentEditable.pasteDialog);
apf.ContentEditable.plugin("pastetext", apf.ContentEditable.pasteDialog);

apf.ContentEditable.plugin("pasteword", function() {
    this.name        = "pasteword";
    this.icon        = "pasteword";
    this.type        = apf.CMDMACRO;
    this.hook        = "onpaste";
    this.keyBinding  = "ctrl+shift+v";
    this.state       = apf.OFF;
    
    this.parse = function(sContent) {
        var bull   = String.fromCharCode(8226),
            middot = String.fromCharCode(183);

        // Remove comments [SF BUG-1481861].
        sContent = sContent.replace(new RegExp("<p class=MsoHeading.*?>(.*?)<\/p>", "gi"), "<p><b>$1</b></p>")
            .replace(new RegExp("tab-stops: list [0-9]+.0pt\">", "gi"), "\">--list--")
            .replace(new RegExp(bull + "(.*?)<BR>", "gi"), "<p>" + middot + "$1</p>")
            // Covert to bull list
            .replace(new RegExp('<SPAN style="mso-list: Ignore">', "gi"), "<span>" + bull)
            // Replace pagebreaks.replace(/<\!--[\s\S]*?-->/g, "")
            .replace(new RegExp('<br style="page-break-before: always;.*>', "gi"), "-- page break --")
            .replace(/<o:p>\s*<\/o:p>/g, "")
            .replace(/<o:p>[\s\S]*?<\/o:p>/g, "&nbsp;")
            // Remove mso-xxx styles.
            .replace(/\s*mso-[^:]+:[^;"]+;?/gi, "")
            // Remove margin styles.
            .replace(/\s*MARGIN: 0(?:cm|in) 0(?:cm|in) 0pt\s*;/gi, "")
            .replace(/\s*MARGIN: 0(?:cm|in) 0(?:cm|in) 0pt\s*"/gi, "\"")
            .replace(/\s*TEXT-INDENT: 0cm\s*;/gi, "")
            .replace(/\s*TEXT-INDENT: 0cm\s*"/gi, "\"")
            .replace(/\s*TEXT-ALIGN: [^\s;]+;?"/gi, "\"")
            .replace(/\s*PAGE-BREAK-BEFORE: [^\s;]+;?"/gi, "\"")
            .replace(/\s*FONT-VARIANT: [^\s;]+;?"/gi, "\"")
            .replace(/\s*tab-stops:[^;"]*;?/gi, "")
            .replace(/\s*tab-stops:[^"]*/gi, "")
            // Remove Class attributes
            .replace(/<(\w[^>]*) class=([^ |>]*)([^>]*)/gi, "<$1$3")
            // Remove pagebreaks
            .replace(/-- page break --\s*<p>&nbsp;<\/p>/gi, "")
            // Remove pagebreaks
            .replace(/-- page break --/gi, "")
            //convert <p> newlines to <br> ones
            .replace(/<\/p>/gi, "<br /><br />")
            .replace(/<TABLE[^>]*cellPadding=[^>]*>/gi, '<table border="0">') //correct tables
            .replace(/<td[^>]*vAlign=[^>]*>/gi, "<td>");;

        // Remove FONT face attributes.
        // @todo make this a checkbox in the UI
        if (true) {//ignoreFont) {
            sContent = sContent.replace(/\s*face="[^"]*"/gi, "")
                .replace(/\s*face=[^ >]*/gi, "")
                .replace(/\s*FONT-FAMILY:[^;"]*;?/gi, "");
        }

        // Remove styles.
        // @todo make this a checkbox in the UI
        if (true)//removeStyles)
            sContent = sContent.replace(/<(\w[^>]*) style="([^\"]*)"([^>]*)/gi, "<$1$3" );

        // Remove style, meta and link tags
        sContent = sContent.replace(/<STYLE[^>]*>[\s\S]*?<\/STYLE[^>]*>/gi, "")
            .replace(/<(?:META|LINK)[^>]*>\s*/gi, "")
            // Remove empty styles.
            .replace(/\s*style="\s*"/gi, "")
            .replace(/<SPAN\s*[^>]*>\s*&nbsp;\s*<\/SPAN>/gi, "&nbsp;")
            .replace(/<SPAN\s*[^>]*><\/SPAN>/gi, "")
            // Remove Lang attributes
            .replace(/<(\w[^>]*) lang=([^ |>]*)([^>]*)/gi, "<$1$3")
            .replace(/<SPAN\s*>([\s\S]*?)<\/SPAN>/gi, "$1")
            .replace(/<FONT\s*>([\s\S]*?)<\/FONT>/gi, "$1")
            // Remove XML elements and declarations
            .replace(/<\\?\?xml[^>]*>/gi, "")
            // Remove w: tags with contents.
            .replace(/<w:[^>]*>[\s\S]*?<\/w:[^>]*>/gi, "")
            // Remove Tags with XML namespace declarations: <o:p><\/o:p>
            .replace(/<\/?\w+:[^>]*>/gi, "")
            .replace(/<(U|I|STRIKE)>&nbsp;<\/\1>/g, "&nbsp;")
            .replace(/<H\d>\s*<\/H\d>/gi, "")
            // Remove "display:none" tags.
            .replace(/<(\w+)[^>]*\sstyle="[^"]*DISPLAY\s?:\s?none[\s\S]*?<\/\1>/ig, "")
            // Remove language tags
            .replace(/<(\w[^>]*) language=([^ |>]*)([^>]*)/gi, "<$1$3")
            // Remove onmouseover and onmouseout events (from MS Word comments effect)
            .replace(/<(\w[^>]*) onmouseover="([^\"]*)"([^>]*)/gi, "<$1$3")
            .replace(/<(\w[^>]*) onmouseout="([^\"]*)"([^>]*)/gi, "<$1$3")
            // The original <Hn> tag send from Word is something like this: <Hn style="margin-top:0px;margin-bottom:0px">
            .replace(/<H(\d)([^>]*)>/gi, "<h$1>")
            // Word likes to insert extra <font> tags, when using MSIE. (Wierd).
            .replace(/<(H\d)><FONT[^>]*>([\s\S]*?)<\/FONT><\/\1>/gi, "<$1>$2<\/$1>")
            .replace(/<(H\d)><EM>([\s\S]*?)<\/EM><\/\1>/gi, "<$1>$2<\/$1>");

        // Convert all middlot lists to UL lists
        var div = document.createElement("div");
        div.innerHTML = sContent;
        // Convert all middot paragraphs to li elements
        while (this._convertMiddots(div, "--list--")); // bull
        while (this._convertMiddots(div, middot, "unIndentedList")); // Middot
        while (this._convertMiddots(div, bull)); // bull
        sContent = div.innerHTML;
    
        return sContent.replace(/--list--/gi, ""); // Remove temporary --list--
    };

    this._convertMiddots = function(div, search, class_name) {
        var mdot = String.fromCharCode(183),
            bull = String.fromCharCode(8226),
            nodes, prevul, i, p, ul, li, np, cp;

        nodes = div.getElementsByTagName("p");
        for (i = 0; i < nodes.length; i++) {
            p = nodes[i];

            // Is middot
            if (p.innerHTML.indexOf(search) != 0) continue;

            ul = document.createElement("ul");
            if (class_name)
                ul.className = class_name;

            // Add the first one
            li = document.createElement("li");
            li.innerHTML = p.innerHTML.replace(new RegExp("" + mdot + "|" + bull + "|--list--|&nbsp;", "gi"), "");
            ul.appendChild(li);

            // Add the rest
            np = p.nextSibling;
            while (np) {
                // If the node is whitespace, then
                // ignore it and continue on.
                if (np.nodeType == 3 && new RegExp("^\\s$", "m").test(np.nodeValue)) {
                    np = np.nextSibling;
                    continue;
                }

                if (search == mdot) {
                    if (np.nodeType == 1 && new RegExp("^o(\\s+|&nbsp;)").test(np.innerHTML)) {
                        // Second level of nesting
                        if (!prevul) {
                            prevul = ul;
                            ul = document.createElement("ul");
                            prevul.appendChild(ul);
                        }
                        np.innerHTML = np.innerHTML.replace(/^o/, "");
                    }
                    else {
                        // Pop the stack if we're going back up to the first level
                        if (prevul) {
                            ul = prevul;
                            prevul = null;
                        }
                        // Not element or middot paragraph
                        if (np.nodeType != 1 || np.innerHTML.indexOf(search) != 0)
                            break;
                    }
                }
                else {
                    // Not element or middot paragraph
                    if (np.nodeType != 1 || np.innerHTML.indexOf(search) != 0)
                        break;
                }

                cp = np.nextSibling;
                li = document.createElement("li");
                li.innerHTML = np.innerHTML.replace(new RegExp("" + mdot + "|" + bull + "|--list--|&nbsp;", "gi"), "");
                np.parentNode.removeChild(np);
                ul.appendChild(li);
                np = cp;
            }
            p.parentNode.replaceChild(ul, p);
            return true;
        }
        return false;
    };
});




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/datetime.js)SIZE(3620)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.ContentEditable.dateTimePlugin = function(sName) {
    this.name        = sName;
    this.icon        = sName;
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARBUTTON;
    this.hook        = "ontoolbar";
    this.keyBinding  = sName == "insertdate" ? "ctrl+shift+d" : "ctrl+shift+t";
    this.state       = apf.OFF;
    this.i18n        = { //default English (en_GB)
        date_format  :"%Y-%m-%d",
        time_format  :"%H:%M:%S",
        months_long  :"January,February,March,April,May,June,July,August,September,October,November,December",
        months_short :"Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec",
        days_long    :"Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday",
        days_short   :"Sun,Mon,Tue,Wed,Thu,Fri,Sat,Sun"
    };

    this.execute = function(editor) {
        if (typeof this.i18n.months_long == "string") {
            this.i18n.months_long  = this.i18n.months_long.split(",");
            this.i18n.months_short = this.i18n.months_short.split(",");
            this.i18n.days_long    = this.i18n.days_long.split(",");
            this.i18n.days_short   = this.i18n.days_short.split(",");
        }
        var d = new Date();
        var fmt = (this.name == "insertdate") ? this.i18n.date_format : this.i18n.time_format;
        fmt = fmt.replace("%D", "%m/%d/%y")
                 .replace("%r", "%I:%M:%S %p")
                 .replace("%Y", "" + d.getFullYear())
                 .replace("%y", "" + d.getYear())
                 .replace("%m", ("" + d.getMonth() + 1).pad(2, "0"))
                 .replace("%d", ("" + d.getDate()).pad(2, "0"))
                 .replace("%H", ("" + d.getHours()).pad(2, "0"))
                 .replace("%M", ("" + d.getMinutes()).pad(2, "0"))
                 .replace("%S", ("" + d.getSeconds()).pad(2, "0"))
                 .replace("%I", "" + (d.getHours() + 11) % 12 + 1)
                 .replace("%p", "" + (d.getHours() < 12 ? "AM" : "PM"))
                 .replace("%B", "" + this.i18n.months_long[d.getMonth()])
                 .replace("%b", "" + this.i18n.months_short[d.getMonth()])
                 .replace("%A", "" + this.i18n.days_long[d.getDay()])
                 .replace("%a", "" + this.i18n.days_short[d.getDay()])
                 .replace("%%", "%");

        editor.$insertHtml(fmt, true);

        editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});
    };

    this.queryState = function() {
        return this.state;
    };
};

apf.ContentEditable.plugin("insertdate", apf.ContentEditable.dateTimePlugin);
apf.ContentEditable.plugin("inserttime", apf.ContentEditable.dateTimePlugin);




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/code.js)SIZE(11906)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.ContentEditable.plugin("code", function() {
    this.name        = "code";
    this.icon        = "code";
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARBUTTON;
    this.hook        = "ontoolbar";
    this.keyBinding  = "ctrl+shift+h";
    this.state       = apf.OFF;
    this.noDisable   = true;
    this.regex       = null;

    var oCont, oToolbar, oButtons = {}, oPreview, protectedData, lastLoaded,
        _self = this;

    this.execute = function(editor) {
        //this.buttonNode.onclick(editor.mimicEvent());
        if (!oPreview)
            this.drawPreview(editor);

        if (oCont.style.display == "none") {
            // remember the selection for IE
            editor.$selection.cache();

            this.update(editor);

            editor.$pluginsActive = this.name;
            // disable the editor...
            editor.setProperty("state", apf.DISABLED);

            // show the textarea and position it correctly...
            this.setSize(editor);
            oCont.style.display = "";

            oPreview.focus();
        }
        else {
            editor.$pluginsActive = null;
            
            oCont.style.display = "none";
            editor.setProperty("state", apf.OFF);
            
            propagateChange();
            
            $setTimeout(function() {
                editor.$selection.set();
                editor.$visualFocus();
            });
        }
        editor.$notifyButton("code", this.queryState(editor));

        editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});
    };

    this.update = function(editor, sHtml) {
        if (changeTimer) {
            lastLoaded = sHtml;
            return;
        }
        // update the contents of the (hidden) textarea
        oPreview.value = format.call(this, sHtml 
            ? apf.htmlCleaner.parse(sHtml)
            : (lastLoaded = editor.getValue()));
    };

    this.getValue = function() {
        return oPreview.value;
    };

    function propagateChange() {
        //if (lastLoaded == oPreview.value) return false;
        var html = apf.htmlCleaner.parse(oPreview.value
            .replace(/<\/p>/gi, "</p><p></p>")
            .replace(/\n/g, ""));

        try{
            apf.getXml("<source>" + html.replace(/&.{3,5};/g, "") + "</source>");
        }
        catch(e){
            if (confirm("Er zit een fout in de html. Klik op OK om deze \
                         te corrigeren, of op Cancel om door te gaan")){
                //@todo mike: finish this
                return false;
            }
        }

        if (lastLoaded == oPreview.value 
          || _self.editor.$value.replace(/[\r\n]/g, "") == html.replace(/[\r\n]/g, "")) {
            _self.editor.$value = "";
            _self.editor.$propHandlers["value"].call(_self.editor, html);
        }
        else
            
            _self.editor.change(html);
            

        return true;
    }

    var changeTimer = null;

    function resumeChangeTimer() {
        if (!_self.editor.realtime || changeTimer !== null) return;
        changeTimer = $setTimeout(function() {
            clearTimeout(changeTimer);
            _self.editor.change(oPreview.value);
            changeTimer = null;
        }, 200);
    }

    function onKeydown(e) {
        e = e || window.event;
        var code = e.which || e.keyCode;
        if (!e.ctrlKey && !e.altKey && (code < 112 || code > 122)
          && (code == 32 || code > 42 || code == 8 || code == 13)) {
            resumeChangeTimer();
        }
    }

    this.drawPreview = function(editor) {
        this.editor = editor;

        //this.editor.$getNewContext("code");
        oCont = editor.$getExternal("code", editor.$ext);

        oToolbar = oCont.getElementsByTagName("div")[0];
        //oToolbar.className = "";
        this.editor.$drawToolbars(oToolbar, "codetoolbar",
            "apf.all[" + this.$uniqueId + "].$buttonClick(event, this);", true);
        // @todo make this hack disappear...
        oToolbar.innerHTML = oToolbar.innerHTML;
        var btns = oToolbar.getElementsByTagName("div");
        for (var item, i = btns.length - 1; i >= 0; i--) {
            item = btns[i].getAttribute("type");
            if (!item) continue;

            oButtons[item] = btns[i];
            apf.setStyleClass(btns[i], "editor_enabled",
                ["editor_selected", "editor_disabled"]);
            btns[i].disabled = false;
        }

        oPreview = oCont.getElementsByTagName("textarea")[0];//oCont.appendChild(document.createElement("textarea"));
        // make selections in IE possible.
        if (apf.isIE)
            oPreview.onselectstart = function(e) {
                e = e || window.event;
                e.cancelBubble = true;
            };
        oPreview.onkeydown = onKeydown;

        this.setSize(editor);
        oCont.style.display  = "none";
        
        
        apf.sanitizeTextbox(oPreview);
        
    }

    this.setSize = function(editor) {
        if (!oPreview || !editor) return;
        
        var w = editor.$ext.offsetWidth - 2;
        var h = editor.$ext.offsetHeight - editor.oToolbar.offsetHeight - 4;
        oCont.style.top       = editor.oToolbar.offsetHeight + "px";
        oCont.style.width     = 
        oToolbar.style.width  = w + "px";
        oPreview.style.width  = w - (apf.isIE ? 2 : 0) + "px";
        oCont.style.height    = h + (apf.isIE ? 2 : 3) + "px";
        oPreview.style.height = h - (apf.isIE ? 26 : 24) + "px";
    };

    var elements = {
        "bullist"   : ["<ul>", "</ul>"],
        "numlist"   : ["<ol>", "</ol>"],
        "listitem"  : ["<li>", "</li>"],
        "nbsp"      : ["&nbsp;", null],
        "break"     : ["<br />", null],
        "paragraph" : ["<p>", "</p>"]
    };

    this.$buttonClick = function(e, oButton) {
        apf.setStyleClass(oButton, "active");
        var item = oButton.getAttribute("type");
        if (elements[item])
            insertElement.apply(this, elements[item]);

        this.editor.$visualFocus();
        oPreview.focus();

        apf.setStyleClass(oButton, "", ["active"]);
    }

    function insertElement(sStart, sEnd) {
        if (!sStart) return;
        var range, val, end;
        if (!sEnd) {
            // no end tag provided, so insert sStart at the current caret position
            if (apf.hasMsRangeObject) {
                range = document.selection.createRange();
                range.collapse();
                range.text = sStart;
                range.moveEnd("character", sStart.length);
                range.collapse();
                if (apf.document.activeElement == this.editor)
                    range.select();
            }
            else {
                val = oPreview.value;
                end = oPreview.selectionEnd;
                oPreview.selectionStart = end;
                oPreview.value          = val.substr(0, end) + sStart
                    + val.substr(end);
                oPreview.selectionStart = oPreview.selectionEnd = end
                    + sStart.length;
            }
        }
        else {
            // end tag provided, so we need to encapsulate the selection with
            // sStart and sEnd
            if (apf.hasMsRangeObject) {
                range = document.selection.createRange();
                val   = range.text;
                range.text = sStart + val + sEnd;
                range.moveStart("character", -(val.length + sEnd.length));
                range.moveEnd("character", -sEnd.length);
                if (apf.document.activeElement == this.editor)
                    range.select();
            }
            else {
                var start  = oPreview.selectionStart;
                val        = oPreview.value;
                end        = oPreview.selectionEnd;
                oPreview.value = val.substr(0, start) + sStart
                    + val.substr(start, end - start) + sEnd + val.substr(end);
                oPreview.selectionStart = start + sStart.length;
                oPreview.selectionEnd   = end + sEnd.length - 1;
            }
        }
    }

    function protect(outer, opener, data, closer) {
        return opener + "apf.___JPFpd___" + protectedData.push(data) + closer;
    }

    function format(sHtml) {
        if (!this.regex)
            setupRegex.call(this);
        protectedData = [];

        var sFmt = sHtml.replace(this.regex.protectedTags, protect);
        // Line breaks.
        sFmt = sFmt.replace(this.regex.blocksOpener, "\n$&")
                   .replace(this.regex.blocksCloser, "$&\n")
                   .replace(this.regex.newLineTags,  "$&\n")
                   .replace(this.regex.mainTags,     "\n$&\n");

        // Indentation.
        var i, j,
            sIdt    = "",
            asLines = sFmt.split(this.regex.lineSplitter);
        sFmt        = "";
        for (i = 0, j = asLines.length; i < j; i++) {
            var sLn = asLines[i];
            if (sLn.length == 0)
                continue ;
            if (this.regex.decreaseIndent.test(sLn))
                sIdt = sIdt.replace(this.regex.formatIndentatorRemove, "");
            sFmt += sIdt + sLn + "\n";
            if (this.regex.increaseIndent.test(sLn))
                sIdt += "    ";
        }

        // Now we put back the protected data.
        for (i = 0, j = protectedData.length; i < j; i++) {
            var oRegex = new RegExp("apf.___JPFpd___" + i);
            sFmt = sFmt.replace(oRegex, protectedData[i].replace(/\$/g, "$$$$"));
        }

        return sFmt.trim();
    }

    function setupRegex() {
        // Regex for line breaks.
        this.regex = {
            blocksOpener  : /\<(P|DIV|H1|H2|H3|H4|H5|H6|ADDRESS|PRE|OL|UL|LI|TITLE|META|LINK|BASE|SCRIPT|LINK|TD|TH|AREA|OPTION)[^\>]*\>/gi,
            blocksCloser  : /\<\/(P|DIV|H1|H2|H3|H4|H5|H6|ADDRESS|PRE|OL|UL|LI|TITLE|META|LINK|BASE|SCRIPT|LINK|TD|TH|AREA|OPTION)[^\>]*\>/gi,
            newLineTags   : /\<(BR|HR)[^\>]*\>/gi,
            mainTags      : /\<\/?(HTML|HEAD|BODY|FORM|TABLE|TBODY|THEAD|TR)[^\>]*\>/gi,
            lineSplitter  : /\s*\n+\s*/g,
            // Regex for indentation.
            increaseIndent: /^\<(HTML|HEAD|BODY|FORM|TABLE|TBODY|THEAD|TR|UL|OL)[ \/\>]/i,
            decreaseIndent: /^\<\/(HTML|HEAD|BODY|FORM|TABLE|TBODY|THEAD|TR|UL|OL)[ \>]/i,
            protectedTags : /(<PRE[^>]*>)([\s\S]*?)(<\/PRE>)/gi,
            formatIndentatorRemove: /^    /
        };
    }

    this.queryState = function(editor) {
        if (editor.$pluginsActive == this.name)
            return apf.SELECTED;
        return apf.OFF;
    };

    this.destroy = function() {
        oPreview = this.regex = null;
        delete oPreview;
        delete this.regex;
    };
});




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/color.js)SIZE(7293)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.ContentEditable.colorPlugin = function(sName) {
    this.name        = sName;
    this.icon        = sName;
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARPANEL;
    this.hook        = "ontoolbar";
    this.buttonNode  = null;
    this.state       = apf.OFF;
    this.colspan     = 18;

    var panelBody;

    var colorAtoms = ["00", "33", "66", "99", "CC", "FF"];
    function generatePalette() {
        apf.ContentEditable.colorPlugin.palette = [];
        var r, g, b, iCol;
        for (r = 0; r < colorAtoms.length; r++) {
            for (g = 0; g < colorAtoms.length; g++) {
                iCol = (r % 3) * 6 + g;
                for (b = 0; b < colorAtoms.length; b++) {
                    if (!apf.ContentEditable.colorPlugin.palette[iCol])
                        apf.ContentEditable.colorPlugin.palette[iCol] = [];
                    apf.ContentEditable.colorPlugin.palette[iCol][(r < 3 ? 0 : 6) + b] = {
                        red  : colorAtoms[r],
                        green: colorAtoms[g],
                        blue : colorAtoms[b]
                    };
                }
            }
        }
    }

    /**
     * Color code from MS sometimes differ from RGB; it's BGR. This method
     * converts both ways
     *
     * @param {color} c code - RGB-->BGR or BGR-->RGB
     * @type String
     * @return RGB<-->BGR
     */
    function RGBToBGRToRGB(c) {
        if (typeof c == "string" && c.length > 0) {
            //c = c.parseColor();
            var tmp = [];
            var ch1 = c.charAt(0);
            var ch2 = c.charAt(4);
            tmp[0] = ch2;
            tmp[4] = ch1;
            ch1 = c.charAt(1);
            ch2 = c.charAt(5);
            tmp[1] = ch2;
            tmp[5] = ch1;
            return tmp[0] + tmp[1] + c.charAt(2) + c.charAt(3) + tmp[4] + tmp[5];
        }
        return c;
    }

    function int2Color(intVal) {
        var colorVal = (intVal & 0xFFFFFF).toString(16);
        return ("000000").substring(0, 6 - colorVal.length) + colorVal;
    }

    this.init = function(editor, btn) {
        this.buttonNode.className = this.buttonNode.className + " dropdown_small";
        var oArrow = this.buttonNode.getElementsByTagName("div")[0];
        this.colorPreview = this.buttonNode.insertBefore(document.createElement("div"),
            oArrow);
        this.colorPreview.className = "colorpreview";
        var colorArrow = this.buttonNode.insertBefore(document.createElement("span"),
            oArrow);
        colorArrow.className = "selectarrow";
    };

    this.execute = function(editor) {
        if (!panelBody) {
            this.editor = editor;
            apf.popup.setContent(this.$uniqueId, this.createPanelBody());
        }

        editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});

        this.editor.$showPopup(this, this.$uniqueId, this.buttonNode, apf.isIE6 ? 296 : 292, 167);
        //return button id, icon and action:
        return {
            id: this.name,
            action: null
        };
    };

    this.setStyleMethod = function(useSpan) {
        if (typeof useSpan == "undefined")
            useSpan = true;
        // Tell Gecko to use or not the <SPAN> tag for the bold, italic and underline.
        try {
            this.editor.$activeDocument.execCommand("styleWithCSS", false, useSpan);
        }
        catch (ex) {
            this.editor.$activeDocument.execCommand("useCSS", false, !useSpan);
        }
    };

    this.queryState = function(editor) {
        var cmdName   = this.name == "forecolor"
            ? "ForeColor"
            : apf.isIE ? "BackColor" : "HiliteColor";
        this.state    = editor.$queryCommandState(cmdName);
        var currValue = "";
        try {
            currValue = editor.$queryCommandValue(cmdName);
        }
        catch (ex) {}
        if (apf.isIE)
            currValue = "#" + RGBToBGRToRGB(int2Color(currValue));
        if (currValue != this.colorPreview.style.backgroundColor)
            this.colorPreview.style.backgroundColor = currValue;
    };

    this.submit = function(e) {
        e = new apf.AbstractEvent(e || window.event);
        while (e.target.tagName.toLowerCase() != "a" && e.target.className != "editor_popup")
            e.target = e.target.parentNode;
        var sColor = e.target.getAttribute("rel");
        if (sColor) {
            apf.popup.forceHide();
//            if (this.name == "backcolor" && apf.isGecko)
//                this.setStyleMethod(true);
            this.editor.$execCommand(this.name == "forecolor"
                ? "ForeColor"
                : apf.isIE ? "BackColor" : "HiliteColor",
                "#" + sColor);
//            if (this.name == "backcolor" && apf.isGecko)
//                this.setStyleMethod(false);
        }
    };

    this.createPanelBody = function() {
        if (!apf.ContentEditable.colorPlugin.palette)
            generatePalette();

        panelBody = document.body.appendChild(document.createElement("div"));
        panelBody.className = "editor_popup";
        panelBody.style.display = "none";
        var aHtml = [];

        var row, col, colorCode, palette = apf.ContentEditable.colorPlugin.palette;
        for (row = 0; row < palette[0].length; row++) {
            aHtml.push('<div class="editor_panelrow">');
            for (col= 0; col < palette.length; col++) {
                colorCode = palette[col][row].red +
                    palette[col][row].green +
                    palette[col][row].blue;
                aHtml.push('<a class="editor_smallcell editor_panelcell" style="background-color:#',
                    colorCode, ';" rel="', colorCode,
                    '" href="javascript:;" onmousedown="apf.lookup(', this.$uniqueId,
                    ').submit(event);">\
                    &nbsp;</a>');
            }
            aHtml.push("</div>");
        }
        panelBody.innerHTML = aHtml.join("");

        return panelBody;
    }

    this.destroy = function() {
        panelBody = this.colorPreview = null;
        delete panelBody;
        delete this.colorPreview;
    };
};
apf.ContentEditable.colorPlugin.palette = null;

apf.ContentEditable.plugin("forecolor", apf.ContentEditable.colorPlugin);
apf.ContentEditable.plugin("backcolor", apf.ContentEditable.colorPlugin);




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/printing.js)SIZE(2105)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.ContentEditable.plugin("print", function(){
    this.name        = "print";
    this.icon        = "print";
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARBUTTON;
    this.hook        = "ontoolbar";
    this.keyBinding  = "ctrl+p";
    this.state       = apf.OFF;

    this.execute = function(editor) {
        if (apf.print)
            apf.print(editor.getValue());

        editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});
    };

    this.queryState = function() {
        return this.state;
    };
});

apf.ContentEditable.plugin("preview", function(){
    this.name        = "preview";
    this.icon        = "preview";
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARBUTTON;
    this.hook        = "ontoolbar";
    this.keyBinding  = "ctrl+shift+p";
    this.state       = apf.OFF;

    this.execute = function(editor) {
        if (apf.printer)
            apf.printer.preview(editor.getValue());

        editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});
    };

    this.queryState = function() {
        return this.state;
    };
});




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/anchor.js)SIZE(4572)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.ContentEditable.plugin("anchor", function() {
    this.name        = "anchor";
    this.icon        = "anchor";
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARPANEL;
    this.hook        = "ontoolbar";
    this.keyBinding  = "ctrl+shift+a";
    this.state       = apf.OFF;

    this.editor      = null;

    var panelBody;

    this.init = function(editor, btn) {
        this.editor = editor;
        this.buttonNode.className = this.buttonNode.className + " dropdown_small";
        var oArrow = this.buttonNode.insertBefore(document.createElement("span"),
            this.buttonNode.getElementsByTagName("div")[0]);
        oArrow.className = "selectarrow";
    };

    this.execute = function(editor) {
        if (!panelBody) {
            this.editor = editor;
            apf.popup.setContent(this.$uniqueId, this.createPanelBody());
        }

        this.editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});

        this.editor.$showPopup(this, this.$uniqueId, this.buttonNode, 218, 47);
        if (panelBody.style.visibility == "hidden")
            panelBody.style.visibility = "visible";
        var _self = this;
        $setTimeout(function() {
            _self.oName.focus();
        });
        //return button id, icon and action:
        return {
            id: this.name,
            action: null
        };
    };

    this.queryState = function() {
        // @todo: for webkit compat, we need to insert images instead of inline an elements
        var oNode = this.editor.$selection.getSelectedNode();
        if (oNode.tagName == "A" && oNode.getAttribute("name"))
            return apf.ON;

        return this.state;
    };

    this.submit = function(e) {
        apf.popup.forceHide();

        if (!this.oName.value) return;

        //this.storeSelection();
        this.editor.$insertHtml('<a name="' + this.oName.value + '" class="itemAnchor" />');
        //this.restoreSelection();
        this.editor.$selection.collapse(false);
    };

    this.createPanelBody = function() {
        panelBody = document.body.appendChild(document.createElement("div"));
        panelBody.className = "editor_popup";
        panelBody.style.display = "none";
        var idName   = "editor_" + this.$uniqueId + "_anchor_url",
            idButton = "editor_" + this.$uniqueId + "_anchor_button";
        panelBody.innerHTML =
           '<div class="editor_panelrow editor_panelrowinput">\
                <label for="' + idName + '">Anchor name</label>\
                <input type="text" id="' + idName + '" name="' + idName + '" class="editor_input" value="" />\
            </div>\
            <div id="' + idButton + '" class="editor_panelrow editor_panelrowbtns"></div>';

        new apf.toolbar({
            htmlNode: document.getElementById(idButton),
            skinset: apf.getInheritedAttribute(this.editor.parentNode, "skinset"),
            childNodes: [
                new apf.bar({
                    childNodes: [new apf.button({
                        caption: this.editor.$translate("insert"),
                        onclick: "apf.lookup(" + this.$uniqueId + ").submit(event)"
                    })]
                })
            ]
        });
        
        this.oName = document.getElementById(idName);
        
        apf.sanitizeTextbox(this.oName);
        
        return panelBody;
    };

    this.destroy = function() {
        panelBody = this.editor = this.oName = null;
        delete panelBody;
        delete this.editor;
        delete this.oName;
    };
});




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/scayt.js)SIZE(2008)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.ContentEditable.plugin("scayt", function(){
    this.name        = "scayt";
    this.icon        = "scayt";
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARBUTTON;
    this.hook        = "ontoolbar";
    this.keyBinding  = "ctrl+h";
    this.state       = apf.OFF;

    this.execute = function(editor) {
        // @todo: implement this plugin

        // cmd=get_opt
        // customerid=1:rvyy72-5NS5o3-yXVS13-hNbyY1-GNda0-KjkQH1-jWrIR3-03eg64-J9VJ93-LXmzy4-FeHKe2-VO5TF3
        // sessionid=
        // ---------------------
        // cmd=scayt_spelltext
        // customerid=1:rvyy72-5NS5o3-yXVS13-hNbyY1-GNda0-KjkQH1-jWrIR3-03eg64-J9VJ93-LXmzy4-FeHKe2-VO5TF3
        // sessionid=1
        // text={urlencoded, html-tag-free text}
        // slang=en
        // intlang=en
        // sug_len=14
        apf.oHttp.get(function() {

        }, {});

        editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});
    };

    this.queryState = function(editor) {
        return this.state;
    };
});




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/search.js)SIZE(10527)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.ContentEditable.searchPlugin = function(sName) {
    this.name        = sName;
    this.icon        = sName;
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARPANEL;
    this.hook        = "ontoolbar";
    this.keyBinding  = this.name == "search" ? "ctrl+f" : "ctrl+shift+f";
    this.state       = apf.OFF;

    var panelBody;

    this.init = function(editor, btn) {
        this.buttonNode.className = this.buttonNode.className + " dropdown_small";
        var oArrow = this.buttonNode.insertBefore(document.createElement("span"),
            this.buttonNode.getElementsByTagName("div")[0]);
        oArrow.className = "selectarrow";
    };

    this.execute = function(editor) {
        if (!panelBody) {
            this.editor = editor;
            apf.popup.setContent(this.$uniqueId, this.createPanelBody());
        }

        editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});

        this.editor.$showPopup(this, this.$uniqueId, this.buttonNode, 218,
            this.name == "search" ? 71 : 95);
        // prefill search box with selected text
        this.oSearch.value = this.editor.$selection.getContent();
        var _self = this;
        $setTimeout(function() {
            _self.oSearch.focus();
        });
        //return button id, icon and action:

        return {
            id: this.name,
            action: null
        };
    };

    this.queryState = function(editor) {
        return this.state;
    };

    this.submit = function(e) {
        //e = new apf.AbstractEvent(e || window.event);
        var val = this.oSearch.value, bMatchCase = this.oCase.checked, flag = 0;
        if (!val)
            return;

        if (apf.isIE)
            this.editor.$selection.set();
        //this.editor.$execCommand("SelectAll");
        this.editor.$selection.collapse(false);
        this.editor.$visualFocus();

        if (bMatchCase) //IE specific flagging
            flag = flag | 4;

        var found = false;

        if (apf.isIE) {
            var sel   = this.editor.$selection;
            var range = sel.getRange();
            if (!(found = range.findText(val, 1, flag))) {
                // simulate 'wrapAround' search...
                this.editor.$activeDocument.execCommand("SelectAll");
                sel.collapse(true);
                range = sel.getRange();
                //no chaining of calls here, seems to b0rk selection in IE
                found = range.findText(val, 1, flag);
            }
            if (found) {
                range.scrollIntoView();
                range.select();
            }
            //this.storeSelection();
            sel.cache();
        }
        else {
            if (this.editor.oWin.find(val, bMatchCase, false, true, false, false, false))
                found = true;
        }
        if (this.oReplBtn)
            this.oReplBtn[!found ? "disable" : "enable"]();

        if (!found) {
            if (this.oReplBtn)
                this.oReplBtn.disable();
            alert("No occurences found for '" + val + "'");
        }
        else if (this.oReplBtn)
            this.oReplBtn.enable();

        if (e.stop)
            e.stop();
        else
            e.cancelBubble = true;

        if (!apf.isIE) {
            // IE cannot show the selection anywhere else then where the cursor
            // is, so no show for them users...
            var _self = this;
            $setTimeout(function() {
                _self.oSearch.focus();
            });
        }

        return false;
    };

    this.onDoReplClick = function(e) {
        this.replace();
    };

    this.onReplAllClick = function(e) {
        var val = this.oSearch.value, bMatchCase = this.oCase.checked, flag = 0,
            ed  = this.editor;
        if (!val)
            return;

        // Move caret to beginning of text
        this.editor.$execCommand("SelectAll");
        this.editor.$selection.collapse(true);
        this.editor.$visualFocus();

        var range = this.editor.$selection.getRange(), found = 0;

        if (bMatchCase) //IE specific flagging
            flag = flag | 4;

        if (apf.isIE) {
            while (range.findText(val, 1, flag)) {
                range.scrollIntoView();
                range.select();
                this.replace();
                found++;
            }
            this.editor.$selection.cache();
            //this.storeSelection();
        }
        else {
            while (this.editor.oWin.find(val, bMatchCase, false, false, false, false, false)) {
                this.replace();
                found++;
            }
        }

        if (found > 0)
            alert(found + " occurences found and replaced with '" + this.oReplace.value + "'");
        else
            alert("No occurences found for '" + val + "'");
    };

    this.replace = function() {
        var sRepl = this.oReplace.value;
        // Needs to be duplicated due to selection bug in IE
        if (apf.isIE) {
            //this.editor.$selection.set(); //Change by RLD
            this.editor.$selection.getRange().duplicate().pasteHTML(sRepl);
        }
        else
            this.editor.$activeDocument.execCommand("InsertHTML", false, sRepl);
    };

    this.createPanelBody = function() {
        panelBody = document.body.appendChild(document.createElement("div"));
        panelBody.className = "editor_popup";
        panelBody.style.display = "none";
        var idSearch     = "editor_" + this.$uniqueId + "_input",
            idReplace    = "editor_" + this.$uniqueId + "_replace",
            idCase       = "editor_" + this.$uniqueId + "_case",
            idBtns       = "editor_" + this.$uniqueId + "_btns";
        panelBody.innerHTML =
           '<div class="editor_panelrow editor_panelrowinput">\
                <label for="' + idSearch + '">Find what</label>\
                <textarea type="text" id="' + idSearch + '" class="editor_input" name="' + idSearch + '" value="">\
                </textarea>\
            </div>' +
            (this.name == "replace" ?
           '<div class="editor_panelrow editor_panelrowinput">\
                <label for="' + idReplace + '">Replace with</label>\
                <input type="text" id="' + idReplace + '" class="editor_input" name="' + idReplace + '" value="" />\
            </div>' : '') +
           '<div class="editor_panelrow editor_panelrowinput">\
                <label for="' + idCase + '">Match case</label>\
                <input type="checkbox" id="' + idCase + '" name="' + idCase + '" class="editor_checkbox" value="" />\
            </div>\
            <div id="' + idBtns + '" class="editor_panelrow editor_panelrowbtns"></div>';
        this.oSearch = document.getElementById(idSearch);
        this.oCase   = document.getElementById(idCase);
        
        new apf.toolbar({
            htmlNode: document.getElementById(idBtns),
            skinset: apf.getInheritedAttribute(this.editor.parentNode, "skinset"),
            childNodes: [
                new apf.bar({
                    childNodes: this.name == "search"
                        ? [new apf.button({
                               caption: this.editor.$translate("findnext"),
                               onclick: "apf.lookup(" + this.$uniqueId + ").submit(event)"
                           })]
                        : [
                              new apf.button({
                                  caption: this.editor.$translate("findnext"),
                                  onclick: "apf.lookup(" + this.$uniqueId + ").submit(event)"
                              }),
                              (this.oReplBtn = new apf.button({
                                  caption: this.editor.$translate("doreplace"),
                                  onclick: "apf.lookup(" + this.$uniqueId + ").onDoReplClick(event)"
                              })),
                              (this.oReplAllBtn = new apf.button({
                                  caption: this.editor.$translate("replaceall"),
                                  onclick: "apf.lookup(" + this.$uniqueId + ").onReplAllClick(event)"
                              }))
                          ]
                })
            ]
        });

        if (this.name == "replace") {
            this.oReplace = document.getElementById(idReplace);
            this.oReplBtn.disable();
        }

        
        if (apf.hasFocusBug) {
            var fSel = function(e) {
                e = e || window.event;
                e.cancelBubble = true;
            };
            apf.sanitizeTextbox(this.oSearch);
            this.oSearch.onselectstart = fSel;
            if (this.oReplace) {
                apf.sanitizeTextbox(this.oReplace);
                this.oReplace.onselectstart = fSel;
            }
            // checkboxes also need the focus fix:
            apf.sanitizeTextbox(this.oCase);
        }
        

        return panelBody;
    };

    this.destroy = function() {
        panelBody = this.oSearch = this.oCase = null;
        delete panelBody;
        delete this.oSearch;
        delete this.oCase;
        if (this.oReplace) {
            this.oReplace = this.oReplBtn = this.oReplAllBtn = null;
            delete this.oReplace;
            delete this.oReplBtn;
            delete this.oReplAllBtn;
        }
    };
};

apf.ContentEditable.plugin("search",  apf.ContentEditable.searchPlugin);
apf.ContentEditable.plugin("replace", apf.ContentEditable.searchPlugin);




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/emotions.js)SIZE(4278)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.ContentEditable.plugin("emotions", function() {
    this.name        = "emotions";
    this.icon        = "emotions";
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARPANEL;
    this.hook        = "ontoolbar";
    this.buttonNode  = null;
    this.state       = apf.OFF;
    this.colspan     = 4;
    this.emotions    = [];

    var panelBody;

    this.init = function(editor, btn) {
        this.buttonNode.className = this.buttonNode.className + " dropdown_small";
        var oArrow = this.buttonNode.insertBefore(document.createElement("span"),
            this.buttonNode.getElementsByTagName("div")[0]);
        oArrow.className = "selectarrow";
    };

    this.execute = function(editor) {
        if (!panelBody) {
            this.editor       = editor;
            this.emotionsPath = editor.$getPluginOption("emotions", "path");

            // parse smiley images, or 'emotions'
            var i, node, oNode = editor.$getPluginOption("emotions");
            for (i = 0; i < oNode.childNodes.length; i++) {
                node = oNode.childNodes[i];
                if (node.nodeType == 3 || node.nodeType == 4)
                    this.emotions = node.nodeValue.splitSafe(",");
            }

            apf.popup.setContent(this.$uniqueId, this.createPanelBody());
        }

        editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});

        this.editor.$showPopup(this, this.$uniqueId, this.buttonNode, 123, 110);
        //return button id, icon and action:
        return {
            id: this.name,
            action: null
        };
    };

    this.queryState = function() {
        return this.state;
    };

    this.submit = function(e) {
        e = new apf.AbstractEvent(e || window.event);
        this.editor.$visualFocus();
        var icon = e.target.getAttribute("rel");
        // @todo still iffy...
        if (!icon || icon == null)
            icon = e.target.parentNode.getAttribute("rel");
        if (!icon) return;
        apf.popup.forceHide();
        this.editor.$insertHtml('<img src="' + this.emotionsPath
            + "/smiley-" + icon + ".gif" + '" alt="" border="0" />', true);
        //this.restoreSelection();
    };

    this.createPanelBody = function() {
        panelBody = document.body.appendChild(document.createElement("div"));
        panelBody.className = "editor_popup";
        panelBody.style.display = "none";
        var aHtml    = [];
        var emotions = this.emotions;
        var path     = this.emotionsPath;
        var rowLen   = this.colspan - 1;
        for (var i = 0; i < emotions.length; i++) {
            if (i % this.colspan == 0)
                aHtml.push('<div class="editor_panelrow">');
            aHtml.push('<a class="editor_panelcell editor_largestcell" rel="',
                emotions[i], '" href="javascript:;" onmousedown="apf.lookup(',
                this.$uniqueId, ').submit(event);">\
                <img border="0" src="', path, "/smiley-", emotions[i], '.gif" />\
                </a>');
            if (i % this.colspan == rowLen)
                aHtml.push("</div>");
        }
        panelBody.innerHTML = aHtml.join("");

        return panelBody;
    };

    this.destroy = function() {
        panelBody = null;
        delete panelBody;
    };
});




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/directions.js)SIZE(1614)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.ContentEditable.directionPlugin = function(sName) {
    this.name        = sName;
    this.icon        = sName;
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARBUTTON;
    this.hook        = "ontoolbar";
    this.state       = apf.OFF;

    this.execute = function(editor) {
        // @todo: implement this baby
        editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});
    };

    this.queryState = function(editor) {
        return this.state;
    };
};

apf.ContentEditable.plugin("ltr", apf.ContentEditable.directionPlugin);
apf.ContentEditable.plugin("rtl", apf.ContentEditable.directionPlugin);




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/image.js)SIZE(5047)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.ContentEditable.plugin("image", function(){
    this.name        = "image";
    this.icon        = "image";
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARPANEL;
    this.hook        = "ontoolbar";
    this.keyBinding  = "ctrl+alt+i";
    this.state       = apf.OFF;

    var panelBody;

    this.init = function(editor) {
        this.buttonNode.className = this.buttonNode.className + " dropdown_small";
        var oArrow = this.buttonNode.insertBefore(document.createElement("span"),
            this.buttonNode.getElementsByTagName("div")[0]);
        oArrow.className = "selectarrow";
    };

    this.execute = function(editor) {
        if (!panelBody) {
            this.editor = editor;
            apf.popup.setContent(this.$uniqueId, this.createPanelBody());
        }
        
        editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});

        // @todo: auto-fill input with currently selected image url
        this.editor.$showPopup(this, this.$uniqueId, this.buttonNode, 218, 47);
        var _self = this;
        $setTimeout(function() {
            _self.oUrl.focus();
        });
        //return button id, icon and action:
        return {
            id: this.name,
            action: null
        };
    };

    this.queryState = function(editor) {
        return this.state;
    };

    this.submit = function(e) {
        var sUrl = this.oUrl.value;
        if (sUrl) {
            apf.popup.forceHide();
            var oUrl = new apf.url(sUrl);
            if (!oUrl.protocol || !oUrl.host || !oUrl.file) 
                alert("Please enter a valid URL");
            else
                this.editor.$insertHtml('<img src="' + sUrl + '" border="0" />', true);
        }
    };

    this.createPanelBody = function() {
        panelBody = document.body.appendChild(document.createElement("div"));
        panelBody.className = "editor_popup";
        panelBody.style.display = "none";
        var idUrl  = "editor_" + this.$uniqueId + "_input";
        var idBtns = "editor_" + this.$uniqueId + "_btns";
        panelBody.innerHTML =
           '<div class="editor_panelrow editor_panelrowinput">\
                <label for="' + idUrl + '">Image URL</label>\
                <input type="text" id="' + idUrl + '" class="editor_input" name="' + idUrl + '" value="" />\
            </div>\
            <div id="' + idBtns + '" class="editor_panelrow editor_panelrowbtns"></div>';
        this.oUrl = document.getElementById(idUrl);
        this.appendAmlNode(
            '<a:toolbar xmlns:a="' + apf.ns.aml + '"><a:bar>\
             <a:button caption="Insert"\
               onclick="apf.lookup(' + this.$uniqueId + ').submit(event)" />\
             </a:bar></a:toolbar>',
          document.getElementById(idBtns));

        
        if (apf.hasFocusBug) {
            apf.sanitizeTextbox(this.oUrl);
            this.oUrl.onselectstart = function(e) {
                e = e || window.event;
                e.cancelBubble = true;
            };
        }
        

        return panelBody;
    };

    this.destroy = function() {
        panelBody = this.oUrl = null;
        delete panelBody;
        delete this.oUrl;
    };
});

apf.ContentEditable.plugin("imagespecial", function() {
    this.name        = "imagespecial";
    this.icon        = "image";
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARBUTTON;
    this.hook        = "ontoolbar";
    this.keyBinding  = "ctrl+alt+j";
    this.state       = apf.OFF;

    var winHandle;

    this.execute = function(editor) {
        if (!winHandle) {
            // get window handle from editor AML attribute
            var s = (editor.getAttribute("imagewindow") || "").trim();
            if (s)
                winHandle = self[s];
        }

        if (winHandle && winHandle.show)
            winHandle.show();

        editor.dispatchEvent("pluginexecute", {name: this.name, plugin: this});
    };

    this.queryState = function(editor) {
        return this.state;
    };
});




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/visualaid.js)SIZE(1743)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.ContentEditable.plugin("visualaid", function(){
    this.name        = "visualaid";
    this.icon        = "visualaid";
    this.type        = apf.TOOLBARITEM;
    this.subType     = apf.TOOLBARBUTTON;
    this.hook        = "ontoolbar";
    this.keyBinding  = "ctrl+shift+v";
    this.state       = apf.OFF;

    this.execute = function(editor) {
        var state = this.queryState(editor);
        editor.$activeDocument.body.className = (state == apf.ON) ? "" : "visualAid";
        editor.$notifyButton(this.name);

        apf.dispatchEvent("pluginexecute", {name: this.name, plugin: this});
    };

    this.queryState = function(editor) {
        this.state = apf[editor.$activeDocument.body.className == "visualAid" ? "ON" : "OFF"];
        return this.state;
    };
});




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/childvalue.js)SIZE(2912)TIME(1264550463)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__CHILDVALUE__ = 1 << 27;


apf.ChildValue = function(){
    if (!this.$childProperty)
        this.$childProperty = "value";
    this.$regbase       = this.$regbase | apf.__CHILDVALUE__;
    
    var f;
    this.addEventListener("DOMCharacterDataModified", f = function(e){
        if (e.currentTarget == this)
            return;
        
        //Get value from xml (could also serialize children, but that is slower
        var m = this.serialize().match(/^[\s\S]*?>([\s\S]*)<[\s\S]*?$/),
            v = m && m[1] || "";

        
        if (v.indexOf("{") > -1 || v.indexOf("[") > -1) {
            this.$setDynamicProperty(this.$childProperty, v);
        }
        else
        
            this.setProperty(this.$childProperty, v);
    });
    
    this.addEventListener("DOMNodeInserted", f);
    this.addEventListener("DOMNodeRemoved", f);
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (!this.getElementsByTagNameNS(this.namespaceURI, "*").length 
          && (this.childNodes.length > 1 || this.firstChild 
          && (this.firstChild.nodeType == 1 
          || this.firstChild.nodeType != 7 
          && this.firstChild.nodeValue.trim().length))) {
            //Get value from xml (could also serialize children, but that is slower
            var m = (this.$aml && this.$aml.xml || this.serialize()).match(/^[\s\S]*?>([\s\S]*)<[\s\S]*?$/),
                v = m && m[1] || "";

            
            if (v.indexOf("{") > -1 || v.indexOf("[") > -1)
                this.$setDynamicProperty(this.$childProperty, v);
            else
            
                this.setProperty(this.$childProperty, v);
        }
        else if (typeof this[this.$childProperty] == "undefined")
            this.$propHandlers[this.$childProperty].call(this, "");
    });
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/dataaction.js)SIZE(26242)TIME(1264464062)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__DATAACTION__ = 1 << 25;


/**
 * Baseclass adding data action features to this element. 
 */
apf.DataAction = function(){
    this.$regbase = this.$regbase | apf.__DATAACTION__;

    /**** Public Methods ****/

    /**
     * Gets the ActionTracker this element communicates with.
     *
     * @return {ActionTracker}
     * @see  element.smartbinding
     */
    this.getActionTracker = function(ignoreMe){
        if (!apf.AmlNode)
            return apf.window.$at;

        var pNode = this, tracker = ignoreMe ? null : this.$at;
        if (!tracker && this.dataParent)
            tracker = this.dataParent.parent.$at; //@todo apf3.0 change this to be recursive??

        while (!tracker) {
            if (!pNode.parentNode) {
                var model;
                return (model = this.getModel && this.getModel(true)) && model.$at || apf.window.$at;
            }

            tracker = (pNode = pNode.parentNode).$at;
        }
        return tracker;
    };
 
    
    this.$lock = {};
    

    this.$actionsLog = {};
    this.$actions    = false;

    /**
     * @term locking {@link http://en.wikipedia.org/wiki/Lock_(computer_science) A lock} 
     * is a mechanism for enforcing limits on access to a resource in a 
     * multi-user environment. Locks are one way of enforcing concurrency 
     * control policies. Ajax.org Platform (apf) has support for locking in 
     * combination with {@link term.action action rules}. There are two 
     * types of locks; pessimistic and optimistic locks. Descriptions below is
     * from {@link http://en.wikipedia.org/wiki/Lock_(computer_science) wikipedia}. 
     *
     * Optimistic:
     * This allows multiple concurrent users access to the database whilst the 
     * system keeps a copy of the initial-read made by each user. When a user 
     * wants to update a record, the application determines whether another user 
     * has changed the record since it was last read. The application does this 
     * by comparing the initial-read held in memory to the database record to 
     * verify any changes made to the record. Any discrepancies between the 
     * initial-read and the database record violates concurrency rules and hence 
     * causes the system to disregard any update request. An error message is 
     * generated and the user is asked to start the update process again. 
     * It improves database performance by reducing the amount of locking 
     * required, thereby reducing the load on the database server. It works 
     * efficiently with tables that require limited updates since no users are 
     * locked out. However, some updates may fail. The downside is constant 
     * update failures due to high volumes of update requests from multiple 
     * concurrent users - it can be frustrating for users.
     *
     * For optimistic locking apf can run as if there would be no locking. 
     * Changed data is send to the server and is either successfully saved or
     * not. When the action isn't changed and the server returns an error code
     * the {@link element.actiontracker actiontracker} <strong>automatically 
     * reverts the change</strong>. 
     *
     * Pessimistic:
     * This is whereby a user who reads a record with the intention of updating 
     * it, places an exclusive lock on the record to prevent other users from 
     * manipulating it. This means no one else can manipulate that record until 
     * the user releases the lock. The downside is that users can be locked out 
     * for a long time thereby causing frustration. 
     * 
     * For pessimistic locking add the locking attribute to the {@link term.action action rules}
     * that need it. The following example shows a lock request for a rename
     * action on a file browser tree.
     * <code>
     *  <a:rename set="..." lock="{comm.lockFile([@path], unlock)}" />
     * </code>
     * The unlock variable is true when the lock needs to be released. This is
     * done when the action was cancelled after getting a lock. For instance
     * when the user presses escape while renaming.
     *
     * MultiUser:
     * In multi user environments it can be handy
     * to be signalled of changes by others within the application. For more 
     * information on this please look at {@link element.remote}.
     *
     * Remarks:
     * During offline works pessimistic locks will always fail. If the application
     * does not use {@link element.remote remote smart bindings} the developer
     * should reload the part of the content for which the lock failed. See
     * {@link baseclass.databinding.event.lockfailed}.
     *
     * Note: JFF understands the status codes specified in RFC4918 for the locking implementation
     *       {@link http://tools.ietf.org/html/rfc4918#section-9.10.6}
     */
     
    /**
     *  Start the specified action, does optional locking and can be offline aware
     *  - or for optimistic locking it will record the timestamp (a setting
     *    <a:appsettings locking="optimistic"/>)
     *  - During offline work, optimistic locks will be handled by taking the
     *    timestamp of going offline
     *  - This method is always optional! The server should not expect locking to exist.
     *
     * @event locksuccess   Fires when a lock request succeeds
     *   bubbles: yes
     *   object:
     *     {Number} state    the return code of the lock request
     * @event lockfailed    Fires when a lock request failes
     *   bubbles: yes
     *   object:
     *     {Number} state    the return code of the lock request
     * @event unlocksuccess Fires when an unlock request succeeds
     *   bubbles: yes
     *   object:
     *     {Number} state    the return code of the unlock request
     * @event unlockfailed  Fires when an unlock request fails
     *   bubbles: yes
     *   object:
     *     {Number} state    the return code of the unlock request
     */
    this.$startAction = function(name, xmlContext, fRollback){
        if (this.disabled || this.contenteditable && name != "edit")
            return false;

        var actionRule = this.$actions && this.$actions.getRule(name, xmlContext);
        if (!actionRule && apf.config.autoDisableActions && this.$actions) {
            
            if (!xmlContext) {
                apf.console.warn("Tried starting new action but no xml \
                    context was specified.");
            }
            else {
                apf.console.warn("Tried starting new action but no '" + name 
                    + "' action rule was found.");
            }
            
            
            return false;
        }

        var bHasOffline = typeof apf.offline != "undefined";
        
        if (bHasOffline && !apf.offline.canTransact())
            return false;
        

        if (this.dispatchEvent(name + "start", {
            xmlContext: xmlContext
        }) === false)
            return false;

        

        //Requesting a lock, whilst we still have one open
        if (this.$lock[name] && !this.$lock[name].stopped) {
            
            apf.console.warn("Starting new action whilst previous \
                action wasn't terminated:" + name);
            

            this.$stopAction(); //or should we call: fRollback.call(this, xmlContext);
        }

        //Check if we should attain a lock (when offline, we just pretend to get it)
        var lockInstruction = actionRule ? actionRule.lock : null;
        if ((bHasOffline && (!apf.offline.enabled || !apf.offline.onLine)) && lockInstruction) {
            var curLock = this.$lock[name] = {
                    start      : bHasOffline && !apf.offline.onLine
                                    ? apf.offline.offlineTime
                                    : new Date().getTime(),
                    stopped    : false,
                    xmlContext : xmlContext,
                    instr      : lockInstruction,
                    rollback   : fRollback
                },
                _self = this;

            //Execute pessimistic locking request
            apf.saveData(lockInstruction, {
              xmlNode  : xmlContext,
              unlock   : false,
              callback : function(data, state, extra){
                    if (state == apf.TIMEOUT && extra.retries < apf.maxHttpRetries)
                        return extra.tpModule.retry(extra.id);
    
                    if (state == apf.SUCCESS) {
                        _self.dispatchEvent("locksuccess", apf.extend({
                            state   : extra.http.status,
                            bubbles : true
                        }, extra));
    
                        curLock.retrieved = true; //@todo Record timeout here... think of method
    
                        //Action was apparently finished before the lock came in, cancelling lock
                        if (curLock.stopped)
                            _self.$stopAction(name, true, curLock);
    
                        //That's it we're ready to go...
                    }
                    else {
                        if (curLock.stopped) //If the action has terminated we just let it go
                            return; //Do we want to take away the event from the developer??
    
                        //Cancel the action, because we didnt get a lock
                        fRollback.call(_self, xmlContext);
                        
                        _self.dispatchEvent("lockfailed", apf.extend({
                            state   : extra.http.status,
                            bubbles : true
                        }, extra));
                    }
                }
              });
        }
        

        this.$actionsLog[name] = xmlContext;

        return true;
    };

    
    // @todo think about if this is only for rsb
    this.addEventListener("xmlupdate", function(e){
        if (apf.xmldb.disableRSB != 2)
            return;

        for (var name in this.$actionsLog) {
            if (apf.isChildOf(this.$actionsLog[name], e.xmlNode, true)) {
                //this.$stopAction(name, true);
                this.$actionsLog[name].rollback.call(this, this.$actionsLog[name].xmlContext);
            }
        }
    });
    

    this.$stopAction = function(name, isCancelled, curLock){
        delete this.$actionsLog[name];

        
        if (!curLock)
            curLock = this.$lock[name];

        if (curLock && !curLock.stopped) {
            curLock.stopped = true;

            //The resource needs to unlock when the action is cancelled
            if (isCancelled && curLock.retrieved) {
                //Execute unlocking request
                var _self = this;
                apf.saveData(curLock.instr, {
                  xmlNode    : curLock.xmlContext,
                  unlock     : true,
                  callback   : function(data, state, extra){
                        if (state == apf.TIMEOUT && extra.retries < apf.maxHttpRetries)
                            return extra.tpModule.retry(extra.id);

                        //Do we care if an unlock failed/succeeded?
                        _self.dispatchEvent(
                            (state == apf.SUCCESS
                                ? "unlocksuccess"
                                : "unlockfailed"),
                            apf.extend({
                                state   : extra.http.status,
                                bubbles : true
                            }, extra));
                    }
                  });
            }
        }

        return curLock;
        
    };

    /**
     * Executes an action using action rules set in the {@link element.actions actions element}.
     *
     * @param {String}      atAction      the name of the action to be performed by the ActionTracker.
     *   Possible values:
     *   setTextNode        sets the first text node of an xml element. {@link core.xmldb.method.setTextNode}
     *   setAttribute       sets the attribute of an xml element. {@link core.xmldb.method.setAttribute}
     *   removeAttribute    removes an attribute from an xml element. {@link core.xmldb.method.removeAttribute}
     *   setAttributes      sets multiple attribute on an xml element. Arguments are [xmlNode, Array]
     *   replaceNode        replaces an xml child with another one. {@link core.xmldb.method.replaceNode}
     *   addChildNode       adds a new xml node to a parent node. {@link core.xmldb.method.addChildNode}
     *   appendChild        appends an xml node to a parent node. {@link core.xmldb.method.appendChild}
     *   moveNode           moves an xml node from one parent to another. {@link core.xmldb.method.moveNode}
     *   removeNode         removes a node from it's parent. {@link core.xmldb.method.removeNode}
     *   removeNodeList     removes multiple nodes from their parent. {@link core.xmldb.method.removeNodeList}
     *   setValueByXpath    sets the nodeValue of an xml node whiche is selected
     *                      by an xpath statement. Arguments are [xmlNode, xpath, value]
     *   multicall          calls multiple of these actions. Arguments is an array
     *                      of argument arrays for these actions each with a func
     *                      property which is the name of the action.
     * @param {Array}       args          the arguments to the function specified
     *                                    in <code>atAction</code>.
     * @param {String}      action        the name of the action rule defined in
     *                                    actions for this element.
     * @param {XMLElement}  xmlNode       the context for the action rules.
     * @param {Boolean}     [noevent]     whether or not to call events.
     * @param {XMLElement}  [contextNode] the context node for action processing
     *                                    (such as RPC calls). Usually the same
     *                                    as <code>xmlNode</code>
     * @return {Boolean} specifies success or failure
     * @see  element.smartbinding
     */
    this.$executeAction = function(atAction, args, action, xmlNode, noevent, contextNode, multiple){
        if (this.disabled || this.contenteditable && action != "edit") 
            return; //hack

        
        apf.console.info("Executing action '" + action + "' for " + (this.name || "")
                         + " [" + (this.localName || "") + "]");
        

        
        if (typeof apf.offline != "undefined" && !apf.offline.canTransact())
            return false;
        

        //Get Rules from Array
        var rule = this.$actions && this.$actions.getRule(action, xmlNode);
        if (!rule && this.$actions && apf.config.autoDisableActions 
          && "action|change".indexOf(action) == -1) {
            apf.console.warn("Could not execute action '" + action + "'. \
              No valid action rule was found and auto-disable-actions is enabled");
            
            return false;
        }
        
        
        var curLock = this.$stopAction(action);
        
        
        var newMultiple;
        if (multiple) {
            newMultiple = [];
            for (var k = multiple.length - 1; k >= 0; k--) {
                newMultiple.unshift({
                    xmlActionNode : rule && rule[4],
                    amlNode       : this,
                    selNode       : multiple[k],
                    xmlNode       : multiple[k]
                })
            }
        }

        //@todo apf3.0 Shouldn't the contextNode be made by the match
        var ev = new apf.AmlEvent("before" + action.toLowerCase(), {
            action        : atAction,
            args          : args,
            xmlActionNode : rule,
            amlNode       : this,
            selNode       : contextNode,
            multiple      : newMultiple || false
            
            ,timestamp    : curLock
                              ? curLock.start
                              : new Date().getTime()
            
        });

        //Call Event and cancel if it returns false
        if (!noevent) {
            //Allow the action and arguments to be changed by the event
            if (this.dispatchEvent(ev.name, null, ev) === false)
                return false;
        }

        //Call ActionTracker and return ID of Action in Tracker
        var UndoObj = this.getActionTracker().execute(ev);
        ev.xmlNode = UndoObj.xmlNode;
        ev.undoObj = UndoObj;

        //Call After Event
        if (!noevent) {
            ev.name         = "after" + action.toLowerCase();
            ev.cancelBubble = false;
            delete ev.returnValue;
            this.dispatchEvent(ev.name, null, ev);
        }

        return UndoObj;
    };

    /**
     * Executes an action based on the set name and the new value
     * @param {String}      atName   the name of the action rule defined in actions for this element.
     * @param {String}      setName  the name of the binding rule defined in bindings for this element.
     * @param {XMLElement}  xmlNode  the xml element to which the rules are applied
     * @param {String}      value    the new value of the node
     */
    this.$executeSingleValue = function(atName, setName, xmlNode, value){
        var xpath, args, rule = this.$getBindRule(setName, xmlNode);
        
        //recompile bindrule to create nodes
        
        var compiled = rule.cvalue || rule.cmatch;
        
        
        //If not one xpath segment then error
        if (compiled.type != 3) {
            throw new Error("Cannot create from rule that isn't a single xpath"); //@todo make apf Error
        }
        

        var atAction,
            sel        = compiled.xpaths, //get first xpath
            shouldLoad = false;
        
        if (sel[0] == "#" || sel[1] == "#") {
            var m = (rule.cvalue3 || (rule.cvalue3 = apf.lm.compile(rule.value, {
                xpathmode: 5
            })))(xmlNode);
            
            var model = m.model && m.model.nodeFunc && m.model;
            if (model) {
                var node  = model.queryNode(m.xpath);
                xmlNode = model.data;
            }
            else {
                model = apf.xmldb.findModel(m.model);
                var node  = m.model.selectSingleNode(m.xpath);
                xmlNode = m.model;
            }

            sel[1] = m.xpath;
        }
        else {
            var model      = sel[0] && apf.nameserver.get("model", sel[0]) || this.$model,
                node       = model
                    ? model.queryNode(sel[1])
                    : (xmlNode || this.xmlRoot).selectSingleNode(sel[1]);
        }

        if (node) {
            if (apf.queryValue(node) == value) return; // Do nothing if value is unchanged

            atAction = (node.nodeType == 1 || node.nodeType == 3
                || node.nodeType == 4) ? "setTextNode" : "setAttribute";
            args = (node.nodeType == 1)
                ? [node, value]
                : (node.nodeType == 3 || node.nodeType == 4
                    ? [node.parentNode, value]
                    : [node.ownerElement || node.selectSingleNode(".."), node.nodeName, value]);
        }
        else {
            if (!this.$createModel)
                return false;

            atAction = "setValueByXpath";
            xpath    = sel[1];

            if (!xmlNode) {
                //Assuming this component is connnected to a model
                if (!model)
                    model = this.getModel();
                if (model) {
                    if (!model.data)
                        model.load("<data />");
    
                    xpath   = (model.getXpathByAmlNode(this) || ".")
                        + (xpath && xpath != "." ? "/" + xpath : "");
                    xmlNode = model.data;
                }
                else {
                    if (!this.dataParent)
                        return false;

                    xmlNode = this.dataParent.parent.selected || this.dataParent.parent.xmlRoot;
                    if (!xmlNode)
                        return false;
                    
                    xpath = (this.dataParent.xpath || ".")
                        + (xpath && xpath != "." ? "/" + xpath : "");
                    shouldLoad = true;
                }
            }

            args = [xmlNode, value, xpath];
        }

        //Use Action Tracker
        this.$executeAction(atAction, args, atName, xmlNode);
        
        if (shouldLoad)
            this.load(xmlNode.selectSingleNode(xpath));
    };
    
    /**
     * Changes the value of this element.
     * @action
     * @param  {String} [string] the new value of this element.
     * @todo apf3.0 maybe not for multiselect?? - why is clearError handling not
     *       in setProperty for value
     */
    this.change = function(value, force){
        
        if (this.errBox && this.errBox.visible && this.isValid && this.isValid())
            this.clearError();
        

        
        //Not databound
        if (!this.xmlRoot && !this.$createModel || !(this.$mainBind == "value" 
          && this.hasFeature(apf.__MULTISELECT__) 
            ? this.$attrBindings["value"] 
            : this.$hasBindRule(this.$mainBind))) {
        
            if (!force && value === this.value 
              || this.dispatchEvent("beforechange", {value : value}) === false)
                return false;

            //@todo in theory one could support actions
            //@todo disabled below, because it gives unexpected behaviour when 
            //form elements are used for layout and other UI alterations
            /*this.getActionTracker().execute({
                action        : "setProperty",
                args          : [this, "value", value, false, true],
                amlNode       : this
            });*/
            this.setProperty("value", value);

            return this.dispatchEvent("afterchange", {value : value});
        
        }
        
        var valueRule = this.$attrBindings["eachvalue"] && "eachvalue" 
            || this.$bindings["value"] && "value" 
            || this.$hasBindRule("caption") && "caption";
          
        if (value == (valueRule != "value" && (this.xmlRoot 
          && this.$applyBindRule("value", this.xmlRoot, null, true)) 
          || this.value))
            return false;

        this.$executeSingleValue("change", this.$mainBind, this.xmlRoot, value);
        
    };
    
    this.$booleanProperties["render-root"] = true;
    this.$supportedProperties.push("create-model", "actions");
    
    /**
     * @attribute {Boolean} create-model whether the model this element connects
     * to is extended when the data pointed to does not exist. Defaults to true.
     * Example:
     * In this example a model is extended when the user enters information in
     * the form elements. Because no model is specified for the form elements
     * the first available model is chosen. At the start it doesn't have any
     * data, this changes when for instance the name is filled in. A root node
     * is created and under that a 'name' element with a textnode containing
     * the entered text.
     * <code>
     *  <a:bar>
     *      <a:label>Name</a:label>
     *      <a:textbox value="[name]" required="true" />
     * 
     *      <a:label>Address</a:label>
     *      <a:textarea value="[address]" />
     * 
     *      <a:label>Country</a:label>
     *      <a:dropdown 
     *        value   = "[mdlForm::country]" 
     *        model   = "countries.xml" 
     *        each    = "[country]" 
     *        caption = "[@name]" />
     *      <a:button action="submit">Submit</a:button>
     *  </a:bar>
     * </code>
     */
    this.$propHandlers["create-model"] = function(value){
        this.$createModel = value;
    };
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (typeof this["create-model"] == "undefined" 
          && !this.$setInheritedAttribute("create-model")) {
            this.$createModel = true;
        }
    });
};

apf.config.$inheritProperties["create-model"] = 1;



/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/cache.js)SIZE(12399)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__CACHE__ = 1 << 2;



/**
 * All elements inheriting from this {@link term.baseclass baseclass} have caching features. It takes care of
 * storing, retrieving and updating rendered data (in html form)
 * to overcome the waiting time while rendering the contents every time the
 * data is loaded.
 *
 * @constructor
 * @baseclass
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.Cache = function(){
    /* ********************************************************************
                                        PROPERTIES
    *********************************************************************/
    this.cache               = {};
    this.subTreeCacheContext = null;

    this.caching  = true;
    this.$regbase = this.$regbase | apf.__CACHE__;

    /* ********************************************************************
                                        PUBLIC METHODS
    *********************************************************************/

    this.addEventListener("$load", function(e){
        if (!this.caching || e.forceNoCache)
            return;

        // retrieve the cacheId
        if (!this.cacheId) {
            this.cacheId = e.xmlNode.getAttribute(apf.xmldb.xmlIdTag) || 
                apf.xmldb.nodeConnect(apf.xmldb.getXmlDocId(e.xmlNode), e.xmlNode);//e.xmlNode
        }

        // Retrieve cached version of document if available
        var fromCache = getCache.call(this, this.cacheId, e.xmlNode);
        if (fromCache) {
            if (fromCache == -1)
                return false;

            var nodes = this.getTraverseNodes();

            //Information needs to be passed to the followers... even when cached...
            if (nodes.length && this.autoselect)
                this.select(nodes[0], null, null, null, true);
            else
                this.clearSelection(); //@todo apf3.0 was setProperty("selected", null

            if (!nodes.length) {
                // Remove message notifying user the control is without data
                this.$removeClearMessage();
                this.$setClearMessage(this["empty-message"], "empty");
            }
                
            
            //@todo move this to getCache??
            if (nodes.length != this.length)
                this.setProperty("length", nodes.length);
            

            return false;
        }
    });
    
    this.addEventListener("$clear", function(){
        if (!this.caching)
            return;
            
        /*
            Check if we borrowed an HTMLElement
            We should return it where it came from

            note: There is a potential that we can't find the exact location
            to put it back. We should then look at it's position in the xml.
            (but since I'm lazy it's not doing this right now)
            There might also be problems when removing the xmlroot
        */
        if (this.hasFeature(apf.__MULTISELECT__)
            && this.subTreeCacheContext && this.subTreeCacheContext.oHtml) {
            if (this.renderRoot) {
                this.subTreeCacheContext.parentNode.insertBefore(
                    this.subTreeCacheContext.oHtml, this.subTreeCacheContext.beforeNode);
            }
            else {
                while (this.$int.childNodes.length)
                    this.subTreeCacheContext.oHtml.appendChild(this.$int.childNodes[0]);
            }

            this.documentId = this.xmlRoot = this.cacheId = this.subTreeCacheContext = null;
        }
        else {
            /* If the current item was loaded whilst offline, we won't cache
             * anything
             */
            if (this.$loadedWhenOffline) {
                this.$loadedWhenOffline = false;
            }
            else {
                // Here we cache the current part
                var fragment = this.$getCurrentFragment();
                if (!fragment) return;//this.$setClearMessage(this["empty-message"]);

                fragment.documentId = this.documentId;
                fragment.xmlRoot    = this.xmlRoot;
                
                if (this.cacheId || this.xmlRoot)
                    setCache.call(this, this.cacheId ||
                        this.xmlRoot.getAttribute(apf.xmldb.xmlIdTag) || "doc"
                        + this.xmlRoot.getAttribute(apf.xmldb.xmlDocTag), fragment);
            }
        }
    });

    /**
     * Checks the cache for a cached item by ID. If the ID is found the
     * representation is loaded from cache and set active.
     *
     * @param  {String} id  the id of the cache element which is looked up.
     * @param  {Object} xmlNode
     * @return {Boolean}
     *   Possible values:
     *   true   the cache element is found and set active
     *   false  otherwise
     * @see    baseclass.databinding.method.load
     * @private
     */
    function getCache(id, xmlNode){
        /*
            Let's check if the requested source is actually
            a sub tree of an already rendered part
        */
        
        if (xmlNode && this.hasFeature(apf.__MULTISELECT__) && this.$isTreeArch) {
            var cacheItem,
                htmlId = xmlNode.getAttribute(apf.xmldb.xmlIdTag) + "|" + this.$uniqueId,
                node   = this.$pHtmlDoc.getElementById(htmlId);
            if (node) 
                cacheItem = getId ? false : this.$int; //@todo apf3.0 what's this GLOBAL var doing here?
            else {
                for (var prop in this.cache) {
                    if (this.cache[prop] && this.cache[prop].nodeType) {
                        node = this.cache[prop].getElementById(htmlId);
                        if (node) {
                            cacheItem = getId ? prop : this.cache[prop];
                            break;
                        }
                    }
                }
            }
            
            if (cacheItem && !this.cache[id]) {
                /*
                    Ok so it is, let's borrow it for a while
                    We can't clone it, because the updates will
                    get ambiguous, so we have to put it back later
                */
                
                var oHtml = this.$findHtmlNode(
                    xmlNode.getAttribute(apf.xmldb.xmlIdTag) + "|" + this.$uniqueId);
                /**
                 * @private
                 */
                this.subTreeCacheContext = {
                    oHtml      : oHtml,
                    parentNode : oHtml.parentNode,
                    beforeNode : oHtml.nextSibling,
                    cacheItem  : cacheItem
                };

                this.documentId = apf.xmldb.getXmlDocId(xmlNode);
                this.cacheId    = id;
                this.xmlRoot    = xmlNode;

                //Load html
                if (this.renderRoot)
                    this.$int.appendChild(oHtml);
                else {
                    while (oHtml.childNodes.length)
                        this.$int.appendChild(oHtml.childNodes[0]);
                }

                return true;
            }
        }
        

        //Checking Cache...
        if (!this.cache[id]) return false;

        //Get Fragment and clear Cache Item
        var fragment    = this.cache[id];

        this.documentId = fragment.documentId;
        this.cacheId    = id;
        this.xmlRoot    = fragment.xmlRoot;

        this.clearCacheItem(id);

        this.$setCurrentFragment(fragment);

        return true;
    }

    /**
     * Sets cache element and it's ID
     *
     * @param {String}           id        the id of the cache element to be stored.
     * @param {DocumentFragment} fragment  the data to be stored.
     * @private
     */
    function setCache(id, fragment){
        if (!this.caching) return;

        this.cache[id] = fragment;
    }

    /**
     * Finds HTML presentation node in cache by ID
     *
     * @param  {String} id  the id of the HTMLElement which is looked up.
     * @return {HTMLElement} the HTMLElement found. When no element is found, null is returned.
     */
    this.$findHtmlNode = function(id){
        var node = this.$pHtmlDoc.getElementById(id);
        if (node) return node;

        for (var prop in this.cache) {
            if (this.cache[prop] && this.cache[prop].nodeType) {
                node = this.cache[prop].getElementById(id);
                if (node) return node;
            }
        }

        return null;
    };

    /**
     * Removes an item from the cache.
     *
     * @param {String}  id       the id of the HTMLElement which is looked up.
     * @param {Boolean} [remove] whether to destroy the Fragment.
     * @see baseclass.databinding.method.clear
     * @private
     */
    this.clearCacheItem = function(id, remove){
        this.cache[id].documentId = 
        this.cache[id].cacheId    =
        this.cache[id].xmlRoot    = null;

        if (remove)
            apf.destroyHtmlNode(this.cache[id]);

        this.cache[id] = null;
    };

    /**
     * Removes all items from the cache
     *
     * @see baseclass.databinding.method.clearCacheItem
     * @private
     */
    this.clearAllCache = function(){
        for (var prop in this.cache) {
            if (this.cache[prop])
                this.clearCacheItem(prop, true);
        }
    };

    /**
     * Gets the cache item by it's id
     *
     * @param {String} id  the id of the HTMLElement which is looked up.
     * @see baseclass.databinding.method.clearCacheItem
     * @private
     */
    this.getCacheItem = function(id){
        return this.cache[id];
    };

    /**
     * Checks whether a cache item exists by the specified id
     *
     * @param {String} id  the id of the cache item to check.
     * @see baseclass.databinding.method.clearCacheItem
     * @private
     */
    this.$isCached = function(id){
        return this.cache[id] || this.cacheId == id ? true : false;
    };
    
    if (!this.$getCurrentFragment) {
        this.$getCurrentFragment = function(){
            var fragment = this.$int.ownerDocument.createDocumentFragment();
    
            while (this.$int.childNodes.length) {
                fragment.appendChild(this.$int.childNodes[0]);
            }
    
            return fragment;
        };
    
        this.$setCurrentFragment = function(fragment){
            this.$int.appendChild(fragment);
    
            if (!apf.window.hasFocus(this))
                this.blur();
        };
    }
    
    /**
     * @attribute {Boolean} caching whether caching is enabled for this element.
     */
    this.$booleanProperties["caching"] = true;
    this.$supportedProperties.push("caching");

    this.addEventListener("DOMNodeRemovedFromDocument", function(e){
        //Remove all cached Items
        this.clearAllCache();
    });
};

apf.GuiElement.propHandlers["caching"] = function(value) {
    if (!apf.isTrue(value)) return;
    
    if (!this.hasFeature(apf.__CACHE__))
        this.implement(apf.Cache);
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/docking.js)SIZE(14718)TIME(1259091143)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__DOCKING__ = 1 << 18;



/**
 * All elements inheriting from this {@link term.baseclass baseclass} have docking features.
 *
 * @constructor
 * @baseclass
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.5
 *
 * @see baseclass.alignment
 */
apf.Docking = function(){
    this.$regbase = this.$regbase | apf.__DOCKING__;
    
    /**
     * @private
     */
    this.startDocking = function(e){
        
        if (!this.aData) 
            return apf.console.warn("Docking start without alignment set on this element");
        

        apf.DockServer.start(this.aData, this, e);
    };
};

/**
 * @private
 */
apf.DockServer = {
    edge: 30,
    inited: false,
    
    init: function(){
        if (this.inited) 
            return;
        this.inited = true;
        
        if (!this.nextPositionMarker) {
            this.nextPositionMarker = document.body.appendChild(document.createElement("div"));
            this.nextPositionMarker.style.border   = "4px solid #555";
            this.nextPositionMarker.style.position = "absolute";
            this.nextPositionMarker.style.zIndex   = 10000;
            this.nextPositionMarker.style.filter   = "progid:DXImageTransform.Microsoft.Alpha(opacity=50);"
            this.nextPositionMarker.style.opacity  = 0.5;
            apf.setUniqueHtmlId(this.nextPositionMarker);
        }
    },
    
    start: function(oItem, amlNode, e){
        if (!this.inited) 
            apf.DockServer.init();
        
        this.dragdata = {
            item: oItem,
            amlNode: amlNode,
            x: e.offsetX || e.layerX,
            y: e.offsetY || e.layerY
        }
        
        apf.dragMode         = true;
        document.onmousemove = this.onmousemove;
        document.onmouseup   = this.onmouseup;

        
        apf.plane.show(this.nextPositionMarker);
        

        var pos  = apf.getAbsolutePosition(oItem.oHtml),
            diff = apf.getDiff(this.nextPositionMarker);

        this.nextPositionMarker.style.left    = pos[0] + "px";
        this.nextPositionMarker.style.top     = pos[1] + "px";
        this.nextPositionMarker.style.width   = (oItem.oHtml.offsetWidth  - diff[0]) + "px"
        this.nextPositionMarker.style.height  = (oItem.oHtml.offsetHeight - diff[1]) + "px";
        this.nextPositionMarker.style.display = "block";
        
        apf.layout.pause(oItem.oHtml.parentNode);
        
    },
    
    floatElement: function(e){
        this.dragdata.item.setPosition(e.clientX - this.dragdata.x,
            e.clientY - this.dragdata.y)
        
        if (this.dragdata.item.hidden != 3) {
            this.dragdata.item.setFloat();
            this.dragdata.amlNode.$purgeAlignment();
        }
        
        else 
            apf.layout.play(this.dragdata.item.oHtml.parentNode);
        
    },
    
    setPosition: function(e){
        var diff = apf.getDiff(this.nextPositionMarker);
        
        this.nextPositionMarker.style.left   = (e.clientX - this.dragdata.x) + "px";
        this.nextPositionMarker.style.top    = (e.clientY - this.dragdata.y) + "px";
        this.nextPositionMarker.style.width  = (this.dragdata.item.size[0] - diff[0]) + "px";
        this.nextPositionMarker.style.height = ((this.dragdata.item.state < 0
            ? this.dragdata.item.size[1]
            : this.dragdata.item.fheight) - diff[1]) + "px";
        
        document.body.style.cursor = "default";
        //apf.setStyleClass(document.body, "", ["same", "south", "east", "north", "west"]);
    },
    
    onmousemove: function(e){
        if (!e) 
            e = event;
        if (apf.isIE && e.button < 1) 
            return false;
        
        
        apf.plane.hide();
        

        apf.DockServer.nextPositionMarker.style.top = "10000px";
        //apf.DockServer.dragdata.amlNode.$ext.style.top = "10000px";
        
        var el = document.elementFromPoint(e.clientX
            + document.documentElement.scrollLeft,
            e.clientY + document.documentElement.scrollTop);

        
        apf.plane.show(apf.DockServer.nextPositionMarker);
        

        var o = el;
        while (o && !o.host && o.parentNode) 
            o = o.parentNode;
        var amlNode  = o && o.host ? o.host : false,
            htmlNode = amlNode.$ext;
        if (!amlNode.aData || !amlNode.dock) {
            document.body.style.cursor = "";
            apf.setStyleClass(document.body, "same",
                ["south", "east", "north", "west"]);
            return apf.DockServer.setPosition(e);
        }
        
        if (apf.DockServer.dragdata.item == amlNode.aData && amlNode.aData.hidden == 3) 
            return apf.DockServer.setPosition(e);
        
        var calcData = amlNode.aData.calcData, // @todo apf3.0 UNUSED VAR
            pos = apf.getAbsolutePosition(htmlNode),
            l   = e.clientX - pos[0],
            t   = e.clientY - pos[1],
        
            diff    = apf.getDiff(apf.DockServer.nextPositionMarker),
            verdiff = diff[1],
            hordiff = diff[0],
        
            vEdge = Math.min(apf.DockServer.edge, htmlNode.offsetHeight / 2),
            hEdge = Math.min(apf.DockServer.edge, htmlNode.offsetWidth  / 2),
        
            r = htmlNode.offsetWidth - l,
            b = htmlNode.offsetHeight - t,
            region,
        
            p = b / vEdge,
            q = l / hEdge,
            z = t / vEdge,
            w = r / hEdge;
        
        if (p < Math.min(q, w, z)) {
            if (b <= vEdge) 
                region = "south";
        }
        else if (w < Math.min(p, z, q)) {
            if (r <= hEdge) 
                region = "east";
        }
        else if (q < Math.min(p, z, w)) {
            if (l <= hEdge) 
                region = "west";
        }
        else if (z < Math.min(q, w, p)) {
            if (t <= vEdge) 
                region = "north";
        }
        
        if (apf.DockServer.dragdata.item == amlNode.aData) 
            region = "same";
        
        if (!region) 
            return apf.DockServer.setPosition(e);
        
        var nextPositionMarker = apf.DockServer.nextPositionMarker;
        if (region == "west") {
            nextPositionMarker.style.left   = pos[0] + "px";
            nextPositionMarker.style.top    = pos[1] + "px";
            nextPositionMarker.style.width  = ((htmlNode.offsetWidth / 2) - hordiff) + "px"
            nextPositionMarker.style.height = (htmlNode.offsetHeight - verdiff) + "px";
        }
        else if (region == "north") {
            nextPositionMarker.style.left   = pos[0] + "px";
            nextPositionMarker.style.top    = pos[1] + "px";
            nextPositionMarker.style.width  = (htmlNode.offsetWidth - hordiff) + "px"
            nextPositionMarker.style.height = (Math.ceil(htmlNode.offsetHeight / 2) - verdiff) + "px";
        }
        else if (region == "east") {
            nextPositionMarker.style.left   = (pos[0] + Math.ceil(htmlNode.offsetWidth / 2)) + "px";
            nextPositionMarker.style.top    = pos[1] + "px";
            nextPositionMarker.style.width  = ((htmlNode.offsetWidth / 2) - hordiff) + "px"
            nextPositionMarker.style.height = (htmlNode.offsetHeight - verdiff) + "px";
        }
        else if (region == "south") {
            nextPositionMarker.style.left   = pos[0] + "px";
            nextPositionMarker.style.top    = (pos[1] + Math.ceil(htmlNode.offsetHeight / 2)) + "px";
            nextPositionMarker.style.width  = (htmlNode.offsetWidth - hordiff) + "px"
            nextPositionMarker.style.height = (Math.ceil(htmlNode.offsetHeight / 2) - verdiff) + "px";
        }
        else if (region == "same") {
            nextPositionMarker.style.left   = pos[0] + "px";
            nextPositionMarker.style.top    = pos[1] + "px";
            nextPositionMarker.style.width  = (htmlNode.offsetWidth - hordiff) + "px"
            nextPositionMarker.style.height = (htmlNode.offsetHeight - verdiff) + "px";
        }
        
        document.body.style.cursor = "";
        apf.setStyleClass(document.body, region,
            ["same", "south", "east", "north", "west"]);
    },
    
    onmouseup: function(e){
        if (!e) 
            e = event;
        if (apf.isIE && e.button < 1) 
            return false;
        
        
        apf.plane.hide();
        

        apf.dragMode         = false;
        document.onmousemove = 
        document.onmouseup   = null;
        
        apf.DockServer.nextPositionMarker.style.display = "none";
        //apf.DockServer.dragdata.amlNode.$ext.style.top = "10000px";
        document.body.className = "";
        
        var el = document.elementFromPoint(e.clientX
               + document.documentElement.scrollLeft,
                 e.clientY + document.documentElement.scrollTop),
            o = el;
        while (o && !o.host && o.parentNode) 
            o = o.parentNode;
        var amlNode  = o && o.host ? o.host : false,
            htmlNode = amlNode.$ext,
            aData    = amlNode.aData;
        
        if (!amlNode.aData || !amlNode.dock
          || apf.DockServer.dragdata.item == amlNode.aData
          && amlNode.aData.hidden == 3) {
            //apf.layout.play(htmlNode.parentNode);
            return apf.DockServer.floatElement(e);
        }
        
        if (apf.DockServer.dragdata.item == amlNode.aData) 
            return apf.layout.play(htmlNode.parentNode);
        
        var pos = apf.getAbsolutePosition(htmlNode),
            l   = e.clientX - pos[0],
            t   = e.clientY - pos[1],
        
            region,
            vEdge = Math.min(apf.DockServer.edge, htmlNode.offsetHeight / 2),
            hEdge = Math.min(apf.DockServer.edge, htmlNode.offsetWidth  / 2),
        
            r = htmlNode.offsetWidth - l,
            b = htmlNode.offsetHeight - t,
        
            p = b / vEdge,
            q = l / hEdge,
            z = t / vEdge,
            w = r / hEdge;
        
        if (p < Math.min(q, w, z)) {
            if (b <= vEdge) 
                region = "b";
        }
        else if (w < Math.min(p, z, q)) {
            if (r <= hEdge) 
                region = "r";
        }
        else if (q < Math.min(p, z, w)) {
            if (l <= hEdge) 
                region = "l";
        }
        else if (z < Math.min(q, w, p)) {
            if (t <= vEdge) 
                region = "t";
        }
        
        if (!region) 
            return apf.DockServer.floatElement(e);
        
        var pHtmlNode = htmlNode.parentNode;
        
        l             = apf.layout.layouts[pHtmlNode.getAttribute("id")];
        
        if (!l) 
            return false;
        
        var root = l.root;//.copy();
        var current = aData;
        
        if (apf.DockServer.dragdata.item.hidden == 3) 
            apf.DockServer.dragdata.item.unfloat();
        
        var newItem = apf.DockServer.dragdata.item,
            pItem = newItem.parent;
        if (pItem.children.length == 2) {
            var fixItem     = pItem.children[(newItem.stackId == 0) ? 1 : 0];
            fixItem.parent  = pItem.parent;
            fixItem.stackId = pItem.stackId;
            fixItem.parent.children[fixItem.stackId] = fixItem;
            fixItem.weight  = pItem.weight;
            fixItem.fwidth  = pItem.fwidth;
            fixItem.fheight = pItem.fheight;
        }
        else {
            var nodes = pItem.children;
            for (var j = newItem.stackId; j < nodes.length; j++) {
                nodes[j] = nodes[j + 1];
                if (nodes[j]) 
                    nodes[j].stackId = j;
            }
            nodes.length--;
        }
        
        var type   = (region == "l" || region == "r") ? "hbox" : "vbox",
            parent = current.parent
            
            ,newBox = apf.layout.getData(type, l.layout);
            

        newBox.splitter   = current.splitter;
        newBox.edgeMargin = current.edgeMargin;
        
        newBox.id         = apf.layout.metadata.push(newBox) - 1;
        
        newBox.parent     = parent;
        parent.children[current.stackId] = newBox;
        newBox.stackId    = current.stackId;
        newBox.children   = (region == "b" || region == "r")
            ? [current, newItem]
            : [newItem, current];
        current.parent    = newItem.parent = newBox
        current.stackId   = (region == "b" || region == "r") ? 0 : 1;
        newItem.stackId   = (region == "b" || region == "r") ? 1 : 0;
        
        //if(type == "vbox") 
        newBox.fwidth = current.fwidth;
        //else if(type == "hbox") 
        newBox.fheight = current.fheight;
        
        newItem.weight = current.weight  = 1;//current.weight / 2;
        current.fwidth = current.fheight = null;
        
        var root = root.copy();
        l.layout.compile(root);
        l.layout.reset();
        
        apf.layout.activateRules(l.layout.parentNode);
        
    }
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/basebutton.js)SIZE(9750)TIME(1258118723)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Baseclass of an element that has one or two states and can be clicked on to
 * trigger an action. (i.e. {@link element.button} or {@link element.checkbox}).
 *
 * @constructor
 * @baseclass
 * @author      Abe Ginner
 * @version     %I%, %G%
 * @since       0.8
 *
 * @event click     Fires when the user presses a mousebutton while over this element and then let's the mousebutton go. 
 */
apf.BaseButton = function(){
    this.$init(true);
};

(function() {
    
    this.implement(apf.ChildValue);
    
    
    this.refKeyDown  =         // Number of keys pressed.
    this.refMouseDown = 0;     // Mouse button down?
    this.mouseOver    =        // Mouse hovering over the button?
    this.mouseLeft    = false; // Has the mouse left the control since pressing the button.

    /**** Properties and Attributes ****/

    /**
     * @attribute {string} background sets a multistate background. The arguments
     * are seperated by pipes '|' and are in the order of:
     * 'imagefilename|mapdirection|nrofstates|imagesize'
     * The mapdirection argument may have the value of 'vertical' or 'horizontal'.
     * The nrofstates argument specifies the number of states the iconfile contains:
     * 1 - normal
     * 2 - normal, hover
     * 3 - normal, hover, down
     * 4 - normal, hover, down, disabled
     * The imagesize argument specifies how high or wide each icon is inside the
     * map, depending of the mapdirection argument.
     *
     * Example:
     * A 3 state picture where each state is 16px high, vertically spaced
     * <code>
     * background="threestates.gif|vertical|3|16"
     * </code>
     */
    this.$propHandlers["background"] = function(value){
        var oNode = this.$getLayoutNode("main", "background", this.$ext);
        
        if (!oNode)
            return apf.console.warn("No background defined in the Button skin", "button");
        

        if (value) {
            var b = value.split("|");
            this.$background = b.concat(["vertical", 2, 16].slice(b.length - 1));

            oNode.style.backgroundImage  = "url(" + this.mediaPath + b[0] + ")";
            oNode.style.backgroundRepeat = "no-repeat";
        }
        else {
            oNode.style.backgroundImage  = "";
            oNode.style.backgroundRepeat = "";
            this.$background = null;
        }
    };

    /**** Keyboard Support ****/

    
    this.addEventListener("keydown", function(e){
        var key      = e.keyCode;
        //var ctrlKey  = e.ctrlKey;  << UNUSED
        //var shiftKey = e.shiftKey; << UNUSED

        switch (key) {
            case 13:
                if (this.localName != "checkbox")
                    this.$ext.onmouseup(e.htmlEvent, true);
                break;
            case 32:
                if (!e.htmlEvent.repeat) { // Only when first pressed, not on autorepeat.
                    this.refKeyDown++;
                    this.$updateState(e.htmlEvent);
                }
                return false;
        }
    }, true);

    this.addEventListener("keyup", function(e){
        var key = e.keyCode;

        switch (key) {
            case 32:
                this.refKeyDown--;

                if (this.refKeyDown < 0) {
                    this.refKeyDown = 0;
                    return false;
                }

                if (this.refKeyDown + this.refMouseDown == 0 && !this.disabled)
                    this.$ext.onmouseup(e, true);

                this.$updateState(e);
                return false;
        }
    }, true);
    

    /**** Private state handling methods ****/

    this.states = {
        "Out"   : 1,
        "Over"  : 2,
        "Down"  : 3
    };

    this.$updateState = function(e, strEvent) {
        if (this.disabled || e.reset) {
            this.refKeyDown   = 0;
            this.refMouseDown = 0;
            this.mouseOver    = false;
            return false;
        }

        if (this.refKeyDown > 0
          || (this.refMouseDown > 0 && this.mouseOver)
          || (this.isBoolean && this.value)) {
            this.$setState("Down", e, strEvent);
        }
        else if (this.mouseOver)
            this.$setState("Over", e, strEvent);
        else
            this.$setState("Out", e, strEvent);
    };

    this.$setupEvents = function() {
        var _self = this;

        this.$ext.onmousedown = function(e) {
            e = e || window.event;

            if (_self.$notfromext && (e.srcElement || e.target) == this)
                return;

            _self.refMouseDown = 1;
            _self.mouseLeft    = false;
            _self.$updateState(e, "mousedown");
        };
        
        this.$ext.onmouseup = function(e, force) {
            e = e || window.event;
            //if (e)  e.cancelBubble = true;

            if (!force && (!_self.mouseOver || !_self.refMouseDown))
                return;

            _self.refMouseDown = 0;
            _self.$updateState(e, "mouseup");

            // If this is coming from a mouse click, we shouldn't have left the button.
            if (_self.disabled || (e && e.type == "click" && _self.mouseLeft == true))
                return false;

            // If there are still buttons down, this is not a real click.
            if (_self.refMouseDown + _self.refKeyDown)
                return false;

            if (_self.$clickHandler && _self.$clickHandler())
                _self.$updateState (e || event, "click");
            else
                _self.dispatchEvent("click", {htmlEvent : e});

            return false;
        };

        this.$ext.onmousemove = function(e) {
            if (!_self.mouseOver) {
                e = e || window.event;

                if (_self.$notfromext && (e.srcElement || e.target) == this)
                    return;

                _self.mouseOver = true;
                _self.$updateState(e, "mouseover");
            }
        };

        this.$ext.onmouseout = function(e) {
            e = e || window.event;

            //Check if the mouse out is meant for us
            var tEl = e.explicitOriginalTarget || e.toElement;
            if (this == tEl || apf.isChildOf(this, tEl))
                return;

            _self.mouseOver    = false;
            _self.refMouseDown = 0;
            _self.mouseLeft    = true;
            _self.$updateState(e, "mouseout");
        };

        
        if (apf.isIphone)
            apf.iphone.linkEvents(this.$ext, true);
        

        if (apf.hasClickFastBug)
            this.$ext.ondblclick = this.$ext.onmouseup;
    };

    this.$doBgSwitch = function(nr){
        if (this.bgswitch && (this.$background[2] >= nr || nr == 4)) {
            if (nr == 4)
                nr = this.$background[2] + 1;

            var strBG = this.$background[1] == "vertical"
                ? "0 -" + (parseInt(this.$background[3]) * (nr - 1)) + "px"
                : "-"   + (parseInt(this.$background[3]) * (nr - 1)) + "px 0";

            this.$getLayoutNode("main", "background",
                this.$ext).style.backgroundPosition = strBG;
        }
    };

    /**** Focus Handling ****/

    this.$focus = function(){
        if (!this.$ext)
            return;

        this.$setStyleClass(this.$ext, this.$baseCSSname + "Focus");
    };

    this.$blur = function(oBtn){
        if (!this.$ext)
            return; //FIREFOX BUG!

        this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Focus"]);
        /*this.refKeyDown   = 0;
        this.refMouseDown = 0;
        this.mouseLeft    = true;*/

        
        /*if (this.submenu) {
            if (this.value) {
                this.$setState("Down", {}, "mousedown");
                this.$hideMenu();
            }
        }*/
        

        if (oBtn)
            this.$updateState(oBtn);//, "onblur"
    };

    /*** Clearing potential memory leaks ****/

    this.$destroy = function(skinChange){
        if (!skinChange && this.$ext) {
            this.$ext.onmousedown = this.$ext.onmouseup = this.$ext.onmouseover =
            this.$ext.onmouseout = this.$ext.onclick = this.$ext.ondblclick = null;
        }
    };

}).call(apf.BaseButton.prototype = new apf.StandardBinding());




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/basetab.js)SIZE(38906)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Baseclass of a paged element. 
 *
 * @constructor
 * @baseclass
 * @allowchild page
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 * 
 * @event beforeswitch  Fires before this element switches to another page.
 *   cancelable: Prevents the page to become active.
 *   object:
 *   {Mixed}    previous     the name or number of the current page.
 *   {Number}   previousId   the number of the current page.
 *   {apf.page} previousPage the current page.
 *   {Mixed}    next         the name or number of the page the will become active.
 *   {Number}   nextId       the number of the page the will become active.
 *   {apf.page} nextpage     the page the will become active.
 * @event afterswitch   Fires after this element has switched to another page.
 *   object:
 *   {Mixed}    previous     the name or number of the previous page.
 *   {Number}   previousId   the number of the previous page.
 *   {apf.page} previousPage the previous page.
 *   {Mixed}    next         the name or number of the current page.
 *   {Number}   nextId       the number of the the current page.
 *   {apf.page} nextpage     the the current page.   
 */
apf.BaseTab = function(){
    this.$init(true);
};

(function() {
    this.isPaged     = true;
    this.$focussable = apf.KEYBOARD;
    this.length      = 0;
    this.isLoading   = {};
    this.inited      =
    this.ready       = false;

    /**
     * Sets the current page of this element.
     * @param {mixed}    page     the name of numer of the page which is made active.
     * @param {Function} callback the function called after setting the page. Especially handy when using the src attribute.
     */
    this.set = function(page, callback, noEvent){
        if (noEvent || this.src && !this.$findPage(page, {})) {
            return this.$propHandlers["activepage"].call(
                this, page, null, null, callback, noEvent);
        }
        
        if (callback && this.activepage == page)
            return callback();

        this.$lastCallback = callback;
        this.setProperty("activepage", page);
    };

    /**** Properties and Attributes ****/

    this.$supportedProperties.push("activepage", "activepagenr", "length",
        "src", "loading");

    /**
     * @attribute {Number} activepagenr the child number of the active page.
     * Example:
     * This example uses property binding to maintain consistency between a
     * dropdown which is used as a menu, and a pages element
     * <code>
     *  <a:dropdown id="ddMenu" value="0">
     *      <a:item value="0">Home</a:item>
     *      <a:item value="1">General</a:item>
     *      <a:item value="2">Advanced</a:item>
     *  </a:dropdown>
     * 
     *  <a:pages activepagenr="{ddMenu.value}">
     *      <a:page>
     *          <h1>Home Page</h1>
     *      </a:page>
     *      <a:page>
     *          <h1>General Page</h1>
     *      </a:page>
     *      <a:page>
     *          <h1>Advanced Page</h1>
     *      </a:page>
     *  </a:pages>
     * </code>
     */
    this.$propHandlers["activepagenr"] =

    /**
     * @attribute {String} activepage the name of the active page.
     * Example:
     * <code>
     *  <a:tab activepage="general">
     *      <a:page id="home">
     *          ...
     *      </a:page>
     *      <a:page id="advanced">
     *          ...
     *      </a:page>
     *      <a:page id="general">
     *          ...
     *      </a:page>
     *  </a:tab>
     * </code>
     */
    this.$propHandlers["activepage"]   = function(next, prop, force, callback, noEvent){
        if (!this.inited || apf.isNot(next)) return;

        if (!callback) {
            callback = this.$lastCallback;
            delete this.$lastCallback;
        }

        var page, info = {};
        page = this.$findPage(next, info);

        if (!page) {
            if (this.src) {
                if (this.isLoading[next])
                    return;
                
                if (this.$findPage("loading", {}))
                    this.$propHandlers["activepage"].call(this, "loading");
                
                this.setProperty("loading", true);
                this.isLoading[next] = true;

                page = this.ownerDocument.createElementNS(apf.ns.apf, "page");
                page.setAttribute("id", next);
                this.appendChild(page);

                var _self = this;
                page.insertMarkup(this.src, {
                    page     : next,
                    //@todo apf3.0 change callback arguments in xinclude
                    callback : function(options){
                        if (!options.xmlNode) {
                            var oError = new Error(apf.formatErrorString(0, null,
                                "Loading new page", "Could not load new page: "
                                + _self.src));
                                
                            _self.setProperty("loading", false);
                            
                            if (this.dispatchEvent("error", apf.extend({
                                error   : oError,
                                bubbles : true
                            }, options)) === false)
                                return true;
                            
                            throw oError;
                        }
                        else {
                            //for success
                            _self.setProperty("activepage", next);
    
                            if (callback)
                                callback();
    
                            _self.setProperty("loading", false);
                        }
                    }
                });
                return;
            }
            
            
            apf.console.warn("Setting tab page which doesn't exist, \
                              referenced by name: '" + next + "'");
            

            return false;
        }

        if (page.parentNode != this) {
            
            apf.console.warn("Setting active page on page component which \
                              isn't a child of this tab component. Cancelling.");
            

            return false;
        }

        if (!page.visible || page.disabled) {
            
            apf.console.warn("Setting active page on page component which \
                              is not visible or disabled. Cancelling.");
            

            return false;
        }

        //If page is given as first argument, let's use its position
        if (next.tagName) {
            next = info.position;
            this.activepage = page.name || next;
        }

        //Call the onbeforeswitch event;
        if (!noEvent) {
            var oEvent = {
                previous     : this.activepage,
                previousId   : this.activepagenr,
                previousPage : this.$activepage,
                next         : next,
                nextId       : info.position,
                nextpage     : page
            };

            if (this.dispatchEvent("beforeswitch", oEvent) === false) {
                //Loader support
                if (this.hideLoader)
                    this.hideLoader();

                return false;
            }
        }

        //Maintain an activepagenr property (not reentrant)
        this.activepagenr = info.position;
        this.setProperty("activepagenr", info.position);

        //Deactivate the current page, if any,  and activate the new one
        if (this.$activepage)
            this.$activepage.$deactivate();

        page.$activate();

        this.$activepage = page;
        
        this.scrollIntoView(page);
        

        //Loader support
        if (this.hideLoader) {
            if (page.$rendered !== false) {
                this.hideLoader();
            }
            else {
                //Delayed rendering support
                page.addEventListener("afterrender", function(){
                    this.parentNode.hideLoader();
                 });
            }
        }

        if (!noEvent) {
            if (page.$rendered !== false)
                this.dispatchEvent("afterswitch", oEvent);
            else {
                //Delayed rendering support
                page.addEventListener("afterrender", function(){ 
                    this.parentNode.dispatchEvent("afterswitch", oEvent);
                });
             }
        }
        
        if (typeof callback == "function") 
            callback();

        return true;
    };

    /**** Public methods ****/

    /**
     * Retrieves an array of all the page elements of this element.
     */
    this.getPages = function(){
        var r = [], nodes = this.childNodes;
        for (var i = 0, l = nodes.length; i < l; i++) {
            if ("page|case".indexOf(nodes[i].localName) > -1)
                r.push(nodes[i]);
        }
        return r;
    };

    /**
     * Retrieves a page element by it's name or child number
     * @param {mixed} nameOrId the name or child number of the page element to retrieve.
     * @return {Page} the found page element.
     */
    this.getPage = function(nameOrId){
        if (apf.isNot(nameOrId))
            return this.$activepage;
        else
            return this.$findPage(nameOrId);
    };

    /**
     * Add a new page element
     * @param {String} [caption] the text displayed on the button of the page.
     * @param {String} [name]    the name of the page which is can be referenced by.
     * @return {page} the created page element.
     */
    this.add = function(caption, name, jml){
        var page = apf.document.createElement(jml || "page");
        if (name)
            page.setAttribute("id", name);
        if (caption)
            page.setAttribute("caption", caption);
        this.appendChild(page);
        
        
        this.scrollIntoView(page);
        
        return page;
    };

    /**
     * Removes a page element from this element.
     * @param {mixed} nameOrId the name or child number of the page element to remove.
     * @return {Page} the removed page element.
     */
    this.remove = function(nameOrId){
        var page = this.$findPage(nameOrId);
        if (!page)
            return false;
        
        page.removeNode();

        
        this.setScrollerState();
        
        return page;
    };

    
    
    var SCROLLANIM = {
            scrollOn  : false,
            steps     : 15,
            interval  : 10,
            size      : 0,
            left      : 0,
            control   : {
                stop  : false
            },
            stopHandle: function() {
                bAnimating = false;
            }
        },
        SCROLL_OFF     = 0x0001,
        SCROLL_HOVER   = 0x0002,
        SCROLL_DOWN    = 0x0004,
        SCROLL_DIS     = 0x0008,
        SCROLL_L_STATE = SCROLL_OFF,
        SCROLL_R_STATE = SCROLL_OFF,
        SCROLL_LEFT    = 0x0001,
        SCROLL_RIGHT   = 0x0002,
        SCROLL_BOTH    = 0x0004,
        bAnimating     = false,
        scrollTimer    = null,
        keepScrolling  = false,
        globalDir      = SCROLL_LEFT;

    function getButtonsWidth() {
        var cId = "cache_" + this.$buttons.childNodes.length;
        if (SCROLLANIM[cId])
            return SCROLLANIM[cId];

        var iWidth = 0;
        for (var i = 0, l = this.$buttons.childNodes.length; i < l; i++) {
            if (typeof this.$buttons.childNodes[i].offsetWidth != "undefined")
                iWidth += this.$buttons.childNodes[i].offsetWidth;
        }

        return SCROLLANIM[cId] = iWidth;
    }

    function setButtonState(dir, state) {
        var bBoth = dir & SCROLL_BOTH;
        if (bBoth)
            dir = SCROLL_LEFT;
        var oBtn = this[dir & SCROLL_LEFT ? "oLeftScroll" : "oRightScroll"];
        if (!(state & SCROLL_DIS)) {
            if (dir & SCROLL_LEFT)
                SCROLL_L_STATE = state;
            else
                SCROLL_R_STATE = state;
        }
        
        if (state & SCROLL_OFF)
            apf.setStyleClass(oBtn,  "", ["disabled", "hover", "down"]);
        else if (state & SCROLL_HOVER)
            apf.setStyleClass(oBtn,  "hover", ["disabled", "down"]);
        else if (state & SCROLL_DOWN)
            apf.setStyleClass(oBtn,  "down", ["disabled", "hover"]);
        else if (state & SCROLL_DIS)
            apf.setStyleClass(oBtn,  "disabled", ["hover", "down"]);

        if (bBoth)
            setButtonState(SCROLL_RIGHT, state);
    }

    /**
     * Set the state scroller buttons: enabled, disabled or completely hidden,
     * depending on the state of the tab buttons
     *
     * @param {Boolean} [bOn]   Indicates whether to turn the scroll buttons on or off
     * @param {Number}  [iBtns] Specifies the buttons to set the state of. Can be SCROLL_LEFT, SCROLL_RIGHT or SCROLL_BOTH
     * @type  {void}
     */
    this.setScrollerState = function(bOn, iBtns) {
        if (!this.ready || !this.$hasButtons || !this.oScroller) return;

        if (typeof bOn == "undefined") {
            var scrollerWidth = this.oScroller.offsetWidth
                || parseInt(apf.getStyle(this.oScroller, "width").replace(/(px|em|%)/, ""));
            bOn   = ((getButtonsWidth.call(this) + scrollerWidth) > this.$ext.offsetWidth);
            iBtns = SCROLL_BOTH;
        }

        if (iBtns & SCROLL_BOTH && bOn !== SCROLLANIM.scrollOn) {
            // in case of HIDING the scroller: check if the anim stuff has reverted
            SCROLLANIM.scrollOn = bOn;
            if (!bOn) {
                this.$buttons.style.left = SCROLLANIM.left + "px";
                this.oScroller.style.display = "none";
            }
            //else
            //    TODO: scroll active tab into view if it becomes hidden beneath scroller node(s)
        }
        else {
            this.oScroller.style.display = "";
        }

        this.oScroller.style.display = (iBtns & SCROLL_BOTH && !bOn)
            ? "none"
            : "";
        if (typeof iBtns == "undefined")
            iBtns = SCROLL_BOTH;
        if (!bOn) {
            if ((iBtns & SCROLL_LEFT) || (iBtns & SCROLL_BOTH))
                setButtonState.call(this, SCROLL_LEFT, SCROLL_DIS);
            if ((iBtns & SCROLL_RIGHT) || (iBtns & SCROLL_BOTH))
                setButtonState.call(this, SCROLL_RIGHT, SCROLL_DIS);
        }
    };

    /**
     * Corrects the state of the scroller buttons when the state of external
     * components change, like on a resize event of a window.
     *
     * @type {void}
     */
    this.correctScrollState = function() {
        if (!this.ready || !this.$hasButtons || !this.oScroller) return;
        this.setScrollerState();
    };

    /**
     * Retrieves the utmost left or right boundaries of the tab buttons strip that
     * can be scrolled to. The tabs cannot scroll any further than these boundaries
     *
     * @param {Number} dir        Determines which boundary side to look at; SCROLL_LEFT or SCROLL_RIGHT
     * @param {Boolan} [useCache] Used only when tabs are draggable. Not implemented.
     * @type  {Number}
     */
    function getAnimationBoundary(dir, useCache) {
        if (SCROLLANIM.size <= 0) {
            SCROLLANIM.left = this.$buttons.offsetLeft;
            SCROLLANIM.size = Math.round(this.firstChild.$button.offsetWidth);
        }
        if (dir & SCROLL_LEFT) {
            return SCROLLANIM.left;
        }
        else if (dir & SCROLL_RIGHT) {
            // TODO: support Drag n Drop of tabs...
            //if (typeof useCache == "undefined") useCache = false;
            //if (!tabcontrol.drag) tabcontrol.drag = {};
            //if (useCache && tabcontrol.drag.boundCache)
            //    return tabcontrol.drag.boundCache;
            var oNode = this.$buttons.childNodes[this.$buttons.childNodes.length - 1];

            return this.$ext.offsetWidth - (oNode.offsetLeft + oNode.offsetWidth
                + (this.oScroller.offsetWidth + 4));// used to be tabcontrol.drag.boundCache;
        }
    }

    /**
     * Event handler; executed when the user pressed one of the two scroll buttons
     * (left or right one). If the tab-buttons strip may/ can be scrolled, the
     * respective behavior is called.
     *
     * @param {Event}  e   Event object, usually a mousedown event from a scroller-button
     * @param {Number} dir Direction to scroll; SCROLL_LEFT or SCROLL_RIGHT
     * @type  {void}
     */
    this.scroll = function(e, dir) {
        if (!this.ready || !this.$hasButtons || !this.oScroller) return;
        if (!e)
            e = window.event;
        if (typeof e["type"] == "unknown") //scope expired (prolly GC'ed)
            e = {type: "click"};
        if (bAnimating && e.type != "dblclick") return;
        bAnimating = true;

        if (typeof dir == "undefined")
            dir = SCROLL_LEFT;

        //apf.tween.clearQueue(this.$buttons, true);
        var iCurrentLeft = this.$buttons.offsetLeft,
            size         = e["delta"] ? Math.round(e.delta * 36) : SCROLLANIM.size,
            //get maximum left offset for either direction
            iBoundary = getAnimationBoundary.call(this, dir),
            _self     = this;
        if (dir & SCROLL_LEFT) {
            setButtonState(SCROLL_LEFT,  SCROLL_DOWN);
            setButtonState(SCROLL_RIGHT, SCROLL_OFF);
            if (iCurrentLeft === iBoundary) {
                this.setScrollerState(false, SCROLL_LEFT);
                return apf.tween.single(this.$buttons, {
                    steps   : SCROLLANIM.steps,
                    interval: 20,
                    from    : iCurrentLeft,
                    to      : iCurrentLeft + 12,
                    type    : "left",
                    anim    : apf.tween.EASEOUT,
                    onstop  : SCROLLANIM.stopHandle,
                    onfinish: function(oNode) {
                        apf.tween.single(oNode, {
                            steps   : SCROLLANIM.steps,
                            interval: SCROLLANIM.interval,
                            from    : iCurrentLeft + 12,
                            to      : iCurrentLeft,
                            type    : "left",
                            anim    : apf.tween.EASEIN,
                            onstop  : SCROLLANIM.stopHandle,
                            onfinish: function() {
                                bAnimating = false;
                                if (e.name == "mousescroll")
                                    setButtonState(SCROLL_LEFT, SCROLL_OFF);
                            }
                        });
                    }
                });
            }
            //one scroll animation scrolls by a SCROLLANIM.size px.
            var iTargetLeft = iCurrentLeft + (e.type == "dblclick" ? size * 3 : size);
            if (iTargetLeft > iBoundary)
                iTargetLeft = iBoundary;

            if (iTargetLeft === iBoundary)
                this.setScrollerState(false, SCROLL_LEFT);
            this.setScrollerState(true, SCROLL_RIGHT);

            //start animated scroll to the left
            apf.tween.single(this.$buttons, {
                steps   : SCROLLANIM.steps,
                interval: SCROLLANIM.interval,
                control : SCROLLANIM.control,
                from    : iCurrentLeft,
                to      : iTargetLeft,
                type    : "left",
                anim    : apf.tween.NORMAL,
                onstop  : SCROLLANIM.stopHandle,
                onfinish: function() {
                    bAnimating = false;
                    if (e.name == "mousescroll")
                        setButtonState(SCROLL_LEFT, SCROLL_OFF);
                    if (keepScrolling)
                        _self.scroll(e, globalDir);
                }
            });
        }
        else if (dir & SCROLL_RIGHT) {
            this.setScrollerState(true);
            setButtonState(SCROLL_RIGHT, SCROLL_DOWN);
            setButtonState(SCROLL_LEFT,  SCROLL_OFF);
            if (iCurrentLeft === iBoundary) {
                this.setScrollerState(false, SCROLL_RIGHT);
                return apf.tween.single(this.$buttons, {
                    steps   : SCROLLANIM.steps,
                    interval: 20,
                    from    : iCurrentLeft,
                    to      : iCurrentLeft - 24,
                    type    : "left",
                    anim    : apf.tween.EASEOUT,
                    onstop  : SCROLLANIM.stopHandle,
                    onfinish: function(oNode, options) {
                        apf.tween.single(oNode, {
                            steps   : SCROLLANIM.steps,
                            interval: SCROLLANIM.interval,
                            from    : iCurrentLeft - 24,
                            to      : iCurrentLeft,
                            type    : "left",
                            anim    : apf.tween.EASEIN,
                            onstop  : SCROLLANIM.stopHandle,
                            onfinish: function() {
                                bAnimating = false;
                                if (e.name == "mousescroll")
                                    setButtonState(SCROLL_RIGHT, SCROLL_OFF);
                            }
                        });
                    }
                });
            }
            //one scroll animation scrolls by a SCROLLANIM.size px.
            var iTargetLeft = iCurrentLeft - (e.type == "dblclick" ? size * 3 : size);
            //make sure we don't scroll more to the right than the
            //maximum left:
            if (iTargetLeft < iBoundary)
                iTargetLeft = iBoundary;
            //start animated scroll to the right
            apf.tween.single(this.$buttons, {
                steps   : SCROLLANIM.steps,
                interval: SCROLLANIM.interval,
                control : SCROLLANIM.control,
                from    : iCurrentLeft,
                to      : iTargetLeft,
                type    : "left",
                anim    : apf.tween.NORMAL,
                onstop  : SCROLLANIM.stopHandle,
                onfinish: function() {
                    bAnimating = false;
                    if (e.name == "mousescroll")
                        setButtonState(SCROLL_RIGHT, SCROLL_OFF);
                    if (keepScrolling)
                        _self.scroll(e, globalDir);
                }
            });
        }
    };

    /**
     * If a tabpage is outside of the users' view, this function scrolls that
     * tabpage into view smoothly.
     *
     * @param {page} oPage The page to scroll into view
     * @type  {void}
     */
    this.scrollIntoView = function(oPage) {
        bAnimating = false;
        if (!this.ready || !this.$hasButtons || !this.oScroller || !oPage.$drawn)
            return;
        bAnimating = true;
        if (this.$buttons.offsetWidth < this.$ext.offsetWidth)
            return this.setScrollerState(false);

        var iTabLeft     = oPage.$button.offsetLeft,
            iTabWidth    = oPage.$button.offsetWidth,
            iCurrentLeft = this.$buttons.offsetLeft;

        if (SCROLLANIM.size <= 0) {
            SCROLLANIM.left = this.$buttons.offsetLeft;
            var p = this.firstChild;
            while (!p.$button)
                p = p.nextSibling;
            SCROLLANIM.size = Math.round(p.$button.offsetWidth);
        }
        this.$buttons.style.left = iCurrentLeft;

        var iRealWidth  = this.$ext.offsetWidth,
            iScrollCorr = this.oScroller.offsetWidth + 4,
            iTargetLeft = null,
            dir;

        if ((iTabLeft + iTabWidth) > ((iRealWidth - iScrollCorr) - iCurrentLeft)) { //scroll to the right
            iTargetLeft = (-(iTabLeft - SCROLLANIM.left)
                + (iRealWidth - iTabWidth - iScrollCorr));
            dir         = SCROLL_RIGHT;
        }
        else if ((iCurrentLeft + iTabLeft) < SCROLLANIM.left) { //sroll to the left
            iTargetLeft = SCROLLANIM.left - iTabLeft;
            dir         = SCROLL_LEFT;
        }

        if (iTargetLeft !== null) {
            this.setScrollerState(true);
            setButtonState(SCROLL_RIGHT, dir & SCROLL_RIGHT ? SCROLL_DOWN : SCROLL_OFF);
            setButtonState(SCROLL_LEFT,  dir & SCROLL_LEFT  ? SCROLL_DOWN : SCROLL_OFF);
            apf.tween.clearQueue(this.$buttons, true);

            apf.tween.single(this.$buttons, {
                steps   : SCROLLANIM.steps,
                interval: SCROLLANIM.interval,
                from    : iCurrentLeft,
                to      : iTargetLeft,
                type    : "left",
                anim    : apf.tween.NORMAL,
                onstop  : SCROLLANIM.stopHandle,
                onfinish: function() {
                    bAnimating = false;
                    setButtonState(SCROLL_RIGHT, SCROLL_OFF);
                    setButtonState(SCROLL_LEFT,  SCROLL_OFF);
                }
            });
        }
        else
            bAnimating = false;
    };

    

    /**** DOM Hooks ****/

    this.addEventListener("DOMNodeRemoved", function(e){
        var amlNode = e.currentTarget;
        if (e.$doOnlyAdmin || e.relatedNode != this 
          || amlNode.localName != "page")
            return;
        
        if (this.firstChild == amlNode && amlNode.nextSibling)
            amlNode.nextSibling.$first();
        if (this.lastChild == amlNode && amlNode.previousSibling)
            amlNode.previousSibling.$last();

        if (this.$activepage == amlNode) {
            if (amlNode.nextSibling || amlNode.previousSibling)
                this.set(amlNode.nextSibling || amlNode.previousSibling);
            else {
                
                this.setScrollerState();
                
                this.$activepage  =
                this.activepage   =
                this.activepagenr = null;
            }
        }
        
        else
            this.setScrollerState();
        
        
        
        this.setProperty("length", this.childNodes.length);
        
    });

    this.addEventListener("DOMNodeInserted",function(e){
        var amlNode = e.currentTarget;
        
        if (amlNode.localName != "page" || e.relatedNode != this)
            return;

        if (!e.$beforeNode) {
            var lastChild;
            if (lastChild = this.lastChild) {
                if (lastChild.nodeType != 1)
                    lastChild = lastChild.previousSibling;
                if (lastChild)
                    lastChild.$last(true);
            }
            amlNode.$last();
        }

        if (!this.firstChild || e.$beforeNode == this.firstChild) {
            if (this.firstChild)
                this.firstChild.$first(true);
            amlNode.$first();
        }

        if (this.$activepage) {
            var info = {};
            this.$findPage(this.$activepage, info);

            if (this.activepagenr != info.position) {
                if (parseInt(this.activepage) == this.activepage) {
                    this.activepage = info.position;
                    this.setProperty("activepage", info.position);
                }
                this.activepagenr = info.position;
                this.setProperty("activepagenr", info.position);
            }
        }
        else if (!this.$activepage)
            this.set(amlNode);
        
        
        this.setProperty("length", this.childNodes.length);
        
    });

    /**** Private state handling functions ****/

    this.$findPage = function(nameOrId, info){
        var node, nodes = this.childNodes;
        for (var t = 0, i = 0, l = nodes.length; i < l; i++) {
            node = nodes[i];
            if ("page|case".indexOf(node.localName) > -1 && (t++ == nameOrId
              || (nameOrId.localName && node || node.name) == nameOrId)) {
                if (info)
                    info.position = t - 1;
                return node;
            }
        }

        return null;
    };

    this.$enable = function(){
        var nodes = this.childNodes;
        for (var i = 0, l = nodes.length; i < l; i++) {
            if (nodes[i].enable)
                nodes[i].enable();
        }
    };

    this.$disable = function(){
        var nodes = this.childNodes;
        for (var i = 0, l = nodes.length; i < l; i++) {
            if (nodes[i].disable)
                nodes[i].disable();
        }
    };

    /**** Keyboard support ****/

    

    this.addEventListener("keydown", function(e){
        if (!this.$hasButtons)
            return;

        var page,
            key = e.keyCode;

        switch (key) {
            case 9:
                break;
            case 13:
                break;
            case 32:
                break;
            case 37: //LEFT
                page = this.getPage().previousSibling;
                while(page && (page.nodeType != 1
                  || "page|case".indexOf(page.localName) == -1 || !page.visible)) {
                    page = page.previousSibling;
                }

                if (page)
                    this.setProperty("activepage", page);
                break;
            case 39: //RIGHT
                page = this.getPage().nextSibling;
                while(page && (page.nodeType != 1 
                  || "page|case".indexOf(page.localName) == -1 || !page.visible)) {
                    page = page.nextSibling;
                }

                if (page)
                    this.setProperty("activepage", page);
                break;
            default:
                return;
        }
        //return false;
    }, true);

    

    /**** Init ****/

    this.$loadChildren = function(callback){
        var page  = false,
            _self = this,
            i, j, l, node, nodes;

        this.inited = true;

        if (this.$hasButtons) {
            this.$buttons = this.$getLayoutNode("main", "buttons", this.$ext);
            this.$buttons.setAttribute("id", this.$uniqueId + "_buttons");
        }

        this.oPages = this.$getLayoutNode("main", "pages", this.$ext);
        
        
        // add scroller node(s)
        this.oScroller = this.$getLayoutNode("main", "scroller", this.oPages);
        if (this.oScroller) {
            function startTimer(e, dir) {
                clearTimeout(scrollTimer);
                globalDir   = dir;
                scrollTimer = $setTimeout(function() {
                    keepScrolling = true;
                    _self.scroll(e, dir);
                }, 500);
            }
            function stopTimer() {
                clearTimeout(scrollTimer);
                keepScrolling = false;
            }

            this.oScroller.onmouseout = function(e) {
                SCROLLANIM.control.stop = true;
                setButtonState(SCROLL_BOTH, SCROLL_OFF);
            };

            
            /*apf.addEventListener("mousescroll", function(e) {
                var found = (e.target == _self.$buttons);
                while (!found && e.target != document.body) {
                    e.target = e.target.offsetParent;
                    found = (e.target == _self.$buttons);
                }
                if (!found) return;
                var dir = e.delta > 0 ? SCROLL_LEFT : SCROLL_RIGHT;
                e.delta = Math.abs(e.delta);
                _self.scroll(e, dir);
            });*/
            

            this.oLeftScroll  = apf.getNode(this.oScroller, [0]);
            this.oRightScroll = apf.getNode(this.oScroller, [1]);
            
            ["oLeftScroll", "oRightScroll"].forEach(function(sBtn) {
                var dir    = sBtn == "oLeftScroll" ? SCROLL_LEFT  : SCROLL_RIGHT,
                    revDir = sBtn == "oLeftScroll" ? SCROLL_RIGHT : SCROLL_LEFT;

                _self[sBtn].ondbclick   =
                _self[sBtn].onmousedown = function(e) {
                    SCROLLANIM.control.stop = false;
                    var state = dir & SCROLL_LEFT ? SCROLL_L_STATE : SCROLL_R_STATE;
                    if (this.className.indexOf("disabled") != -1
                      || state & SCROLL_DOWN) return;
                    e = e || event;
                    _self.scroll(e, dir);
                    startTimer(e, dir);
                    if (!apf.isSafariOld)
                        this.onmouseout();
                };
                _self[sBtn].onmouseover = function() {
                    SCROLLANIM.control.stop = false;
                    var state = dir & SCROLL_LEFT ? SCROLL_L_STATE : SCROLL_R_STATE;
                    if (this.className.indexOf("disabled") != -1
                      || state & SCROLL_DOWN) return;
                    setButtonState(dir, SCROLL_HOVER);
                    setButtonState(revDir, SCROLL_OFF);
                    globalDir = dir;
                };
                _self[sBtn].onmouseout = function() {
                    var state = dir & SCROLL_LEFT ? SCROLL_L_STATE : SCROLL_R_STATE;
                    if (this.className.indexOf("disabled") != -1
                      || state & SCROLL_DOWN) return;
                    setButtonState(dir, SCROLL_OFF);
                };
                _self[sBtn].onmouseup = function() {
                    if (this.className.indexOf("disabled") == -1) {
                        setButtonState(dir, SCROLL_OFF);
                    }
                    stopTimer();
                    SCROLLANIM.control.stop = true;
                };
            });
        }

        
        apf.layout.setRules(this.$ext, this.$uniqueId + "_tabscroller",
            "var o = apf.all[" + this.$uniqueId + "]; o && o.correctScrollState()");
        apf.layout.queue(this.$ext);
        
        

        //Skin changing support
        if (this.$int) {
            //apf.AmlParser.replaceNode(this.oPages, oPages);
            this.$int = this.oPages;
            page      = true;

            //@todo apf3.0 skin change?
            nodes = this.childNodes;
            for (i = 0; i < nodes.length; i++) {
                node = nodes[i];
                if(node.nodeType != 1)
                    continue;
                node.$draw(true);
                if(node.$skinchange)
                    node.$skinchange();
                node.$loadAml();
            }
        }
        else {
            this.$int = this.oPages;

            //Build children
            nodes = this.childNodes;
            for (j = 0, i = 0, l = nodes.length; i < l; i++) {
                if ("page|case".indexOf((node = nodes[i]).localName) > -1) {
                    //Set first page marker
                    if (j++ == 0)
                        node.$first();
                    if (j == l)
                        node.$last();
                }
            }
        }

        //Set active page
        if (node) {
            this.activepage = (typeof this.activepage != "undefined"
                ? this.activepage
                : this.activepagenr) || 0;
            page = this.getPage(this.activepage);
            if (page.render != "runtime" || page.$rendered)
                this.$propHandlers.activepage.call(this, this.activepage);
        }
        else {
            this.isPages = false;
        }

        
        this.setProperty("length", j);
        

        this.ready = true;
        
        window.setTimeout(function() {
            _self.setScrollerState();
        }, 0);
        


        if (!this.activepage && this.getAttribute("src")) {
            this.src = this.getAttribute("src");
            this.$propHandlers["activepage"].call(this);
        }
    };
    
    this.$destroy = function(bSkinChange) {
        if (bSkinChange || !this.oScroller)
            return;
        
        
        apf.layout.removeRule(this.$ext, this.$uniqueId + "_tabscroller");
        
        [this.oLeftScroll, this.oRightScroll].forEach(function(oBtn) {
            oBtn.onmousedown = oBtn.ondblclick = oBtn.onmouseover = 
            oBtn.onmouseout  = oBtn.onmouseup  = null;
        });
        
    };
}).call(apf.BaseTab.prototype = new apf.Presentation());




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable2.js)SIZE(19594)TIME(1265038748)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */
apf.__CONTENTEDITABLE__  = 1 << 24;



apf.ContentEditable2 = function() {
    this.$regbase = this.$regbase | apf.__CONTENTEDITABLE__;

    var _self = this;
    
    if (!apf.ContentEditable2.resize)
        apf.ContentEditable2.resize = new apf.Resize();
    
    this.$propHandlers["editable"] = function(value, prop){
        apf.ContentEditable2.resize.initElement(this);
        this.isEditable = true;
    }
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var x = this.$aml;
        var nodes = this.childNodes;
        for (var i = 0, l = nodes.length; i < l; i++) {
            if (typeof nodes[i].editable == "undefined") { //@todo inheritance?
                if (nodes[i].nodeFunc == apf.NODE_VISIBLE && nodes[i].localName != "page") {
                    nodes[i].setAttribute("editable", true);
                }
                else {
                    nodes[i].isEditable = true;
                    arguments.callee.apply(nodes[i], arguments);
                }
            }
        }
        
        if (!this.parentNode.isEditable) {
            //@todo Use new property events in apf3.0
            $setTimeout(function(){
                apf.ContentEditable2.resize.grab(_self);
            });
        }
    });
    
    this.addEventListener("DOMNodeRemovedFromDocument", function(e){
        
    });
};

//@todo Should move to execCommand
apf.ContentEditable2.setMode = function(mode, type){
	this.mode = mode;
	
	if (!this.pointer)
	    this.pointer = new apf.ElementDrawer();
	
	if (mode == "add") this.pointer.activate();
	else this.pointer.deactivate();
	
	this.addType = type;
}

apf.ContentEditable2.actions = {
    transaction : [],
    undostack : [],
    redostack : []
};

apf.ContentEditable2.execCommand = function(type, options, undo){
    if (!options) options = {};
    var sel = options.sel || this.resize.getSelected();//@todo should become a real selection object (see html5 spec)
    
    if (this.started && type != "commit" && type != "rollback" && !undo) {
        apf.ContentEditable2.actions.transaction.push([type, options]);
        return;
    }
    
    var i, item, items;
    switch (type) {
        case "add":
            if (undo) {
                apf.ContentEditable2.execCommand("remove", 
                    {sel: options.addedNode, maintenance: true});
            }
            else {
                var jmlNode    = apf.document.createElementNS(apf.ns.apf, this.addType),
                    htmlNode   = options.htmlNode,
                    parentNode = options.parentNode;
                if (!parentNode) {
                    parentNode = (this.resize.getSelected() || apf.document.documentElement);
                    if (parentNode.getPage) {
                        parentNode = parentNode.getPage();
                    }
                    else {
                        while (!parentNode.canHaveChildren)
                            parentNode = parentNode.parentNode;
                    }
                    options.parentNode = parentNode;
                }
                
                var pos = apf.getAbsolutePosition(parentNode.$int);
                jmlNode.setAttribute("left", htmlNode.offsetLeft - pos[0]);
                jmlNode.setAttribute("top", htmlNode.offsetTop - pos[1]);
                
                parentNode.appendChild(jmlNode);
                
                var minwidth  = jmlNode.minwidth
                        || parseInt(jmlNode.$getOption("main", "minwidth")) || 0,
                    minheight = jmlNode.minheight
                        || parseInt(jmlNode.$getOption("main", "minheight")) || 0,
                    maxwidth  = jmlNode.maxwidth
                        || parseInt(jmlNode.$getOption("main", "maxwidth")) || 10000,
                    maxheight = jmlNode.maxheight
                        || parseInt(jmlNode.$getOption("main", "maxheight")) || 10000;
                
                jmlNode.setAttribute("width", Math.min(maxwidth, Math.max(minwidth,
                    htmlNode.offsetWidth)));
                jmlNode.setAttribute("height", Math.min(maxheight,
                    Math.max(minheight, htmlNode.offsetHeight)));
                jmlNode.setAttribute("editable", true);

                
                apf.layout.processQueue();
                
                this.resize.grab(jmlNode);
                options.addedNode = jmlNode;
            }
            break;
        case "remove":
            if (undo) {
                options.removedNode[1].insertBefore(options.removedNode[0],
                    options.removedNode[2]);
                this.resize.grab(options.removedNode[0]);
            }
            else {
                var pNode = sel.parentNode;
                options.removedNode = [sel, pNode, sel.nextSibling];
                sel.removeNode();
                this.resize.grab(apf.document.activeElement && apf.document.activeElement.editable 
                    ? apf.document.activeElement
                    : (pNode.editable ? pNode : pNode.firstChild));
            }
            break;
        case "property":
            if (undo) {
                sel.setAttribute(options.name, options.prevValue);
            }
            else {
                options.prevValue = sel[options.name];
                sel.setAttribute(options.name, options.value);
            }
            break;
        case "undo":
            var undostack =  apf.ContentEditable2.actions.undostack;
            if (!undostack.length)
                return false;

            item = undostack.pop();
            apf.ContentEditable2.actions.redostack.push(item);
            item[1].maintenance = true;
            apf.ContentEditable2.execCommand(item[0], item[1], true);
            return true;
        case "redo":
            var redostack =  apf.ContentEditable2.actions.redostack;
            if (!redostack.length)
                return false;

            item = redostack.pop();
            apf.ContentEditable2.actions.undostack.push(item);
            item[1].maintenance = true;
            apf.ContentEditable2.execCommand(item[0], item[1]);
            return true;
        case "begin":
            this.started = true;
            return;
        case "commit":
            if (undo) {
                items = options;
                for (i = 0; i < items.length; i++)
                    apf.ContentEditable2.execCommand(items[i][0], items[i][1], true);
            }
            else {
                if (this.started) {
                    this.started = false;
                    items = apf.ContentEditable2.actions.transaction;
                    apf.ContentEditable2.actions.transaction = [];
                    apf.ContentEditable2.actions.undostack.push([type, items]);
                }
                else {
                    items = options;
                }

                for (i = 0; i < items.length; i++) {
                    items[i][1].maintenance = true;
                    if (!items[i][1].sel)
                        items[i][1].sel = sel;
                    apf.ContentEditable2.execCommand(items[i][0], items[i][1]);
                }
            }
            
            apf.layout.processQueue();
            
            this.resize.regrab();
            return;
        case "rollback":
            this.started = false;
            apf.ContentEditable2.actions.transaction = [];
            return;
    }
    
    if (!options || !options.maintenance)
        apf.ContentEditable2.actions.undostack.push([type, options]);
}

apf.Resize = function(){
    this.$init();

    this.$propHandlers = [];
    this.implement(apf.Interactive);
    
    this.draggable     = true;
    this.resizable     = true;
    this.dragOutline   = true;
    this.dragSelection = true;
    
    var _self = this,
        nodes = [],
        pos   = ["n", "ne", "e", "se", "s", "sw", "w", "nw"],
        div;
    while (nodes.length != 8) {
        div = document.body.appendChild(document.createElement("div"));
        div.className = "idegrabber";
        div.style.display = "none";
        div.onmousedown = mousedown;
        
        nodes.push(div);
        nodes[(div.type = pos.pop())] = div;
    }
    
    this.getSelected = function(){
        return selected;
    };
    
    this.initElement = function(el){
        el.$ext.onmousedown = function(e){
            _self.grab(el);
            _self.left = el.left;
            _self.top = el.top;
            _self.right = el.right;
            _self.bottom = el.bottom;
            (e || event).cancelBubble = true;
        }
        this.$propHandlers["draggable"].call({$ext: el.$ext}, true);
    };
    
    var selected, anchors,
        size   = 8,
        margin = 1;
    this.grab = function(oEl, options) {
        
        if (this.$ext) {
            apf.layout.removeRule(this.$ext, "contenteditable");
            apf.layout.activateRules(oEl);
        }
        
        if (!oEl) {
            this.hide();
            return;
        }
        
        if (oEl.nodeFunc) {
            selected = oEl;
            anchors = oEl.$anchors && oEl.$anchors.length 
                ? oEl.$anchors
                : [oEl.top, oEl.right, oEl.bottom, oEl.left];
            oEl = oEl.$ext;
            this.$ext = oEl;
        }
        
        this.regrab();
        
        //Show
        for (var i = 0; i < 8; i++) {
            nodes[i].style.display = "block";
        }

        if (anchors) {
            apf.setStyleClass(nodes.n, anchors[0] ? "idegrabber_selected" : "",
                ["idegrabber_selected"]);
            apf.setStyleClass(nodes.e, anchors[1] ? "idegrabber_selected" : "",
                ["idegrabber_selected"]);
            apf.setStyleClass(nodes.s, anchors[2] ? "idegrabber_selected" : "",
                ["idegrabber_selected"]);
            apf.setStyleClass(nodes.w, anchors[3] ? "idegrabber_selected" : "",
                ["idegrabber_selected"]);
        }

        //This should all be removed on ungrab
        
        apf.layout.setRules(oEl, "contenteditable", "apf.all[" + this.$uniqueId + "].regrab()", true);
        apf.layout.queue(oEl);
        
        _self.onresize = function(){
            apf.ContentEditable2.execCommand("commit");
        };

        _self.ondrag = function(e){
            apf.ContentEditable2.execCommand("commit");
        };
    };
    
    this.regrab = function(){
        //Position
        var oEl = this.$ext;
        var pos = apf.getAbsolutePosition(oEl);
        pos.push(oEl.offsetWidth, oEl.offsetHeight);

        //Middle ones (hor)
        nodes.s.style.left = 
        nodes.n.style.left = (pos[0] + (pos[2] - size)/2) + "px";
        
        //Middle ones (ver)
        nodes.e.style.top = 
        nodes.w.style.top = (pos[1] + (pos[3] - size)/2) + "px";
        
        //Top
        nodes.nw.style.top = 
        nodes.ne.style.top = 
        nodes.n.style.top  = (pos[1] - size - margin) + "px";
        
        //Left
        nodes.sw.style.left = 
        nodes.nw.style.left = 
        nodes.w.style.left  = (pos[0] - size - margin) + "px";
        
        //Right
        nodes.ne.style.left = 
        nodes.se.style.left = 
        nodes.e.style.left  = (pos[0] + pos[2] + margin) + "px";
        
        //Bottom
        nodes.se.style.top = 
        nodes.sw.style.top = 
        nodes.s.style.top  = (pos[1] + pos[3] + margin) + "px";
    };
    
    this.show = function(){
        for (var i = 0; i < 8; i++)
            nodes[i].style.display = "block";
    };
    
    this.hide = function(){
        for (var i = 0; i < 8; i++)
            nodes[i].style.display = "none";
    };
    
    this.setProperty = function(name, value){
        //return selected.setProperty.apply(selected, arguments);
        if (!apf.ContentEditable2.started)
            apf.ContentEditable2.execCommand("begin");

        apf.ContentEditable2.execCommand("property", {name:name, value:value});
        
        return value;
    };
    
    var map = {"e":"right", "w":"left", "n":"top", "s":"bottom"};
    function mousedown(e){
        if (!e) e = event;
        if (e.ctrlKey && this.type.length == 1) {
            apf.ContentEditable2.execCommand("begin");
            
            if (selected.$anchors && selected.$anchors.length) {
                var anchors = selected.$anchors;
                _self.setProperty("anchors", null);
                _self.setProperty("top", anchors[0]);
                _self.setProperty("right", anchors[1]);
                _self.setProperty("bottom", anchors[2]);
                _self.setProperty("left", anchors[3]);
            }
            
            apf.setStyleClass(this, !selected[map[this.type]] 
                ? "idegrabber_selected" : "", ["idegrabber_selected"]);

            var prop = map[this.type];
            if (selected[prop]) {
                if (prop == "right" && !this.left)
                    _self.setProperty("left", selected.$ext.offsetLeft);
                else if (prop == "bottom" && !this.top)
                    _self.setProperty("top", selected.$ext.offsetTop);

                _self.setProperty(prop, null);
            }
            else {
                var pHtmlNode = selected.$ext.offsetParent;
                if (pHtmlNode.tagName == "BODY")
                    pHtmlNode = document.documentElement;
                    
                switch(this.type) {
                    case "e":
                        _self.setProperty("right", pHtmlNode.offsetWidth
                            - selected.$ext.offsetLeft - selected.$ext.offsetWidth);
                        break;
                    case "w":
                        _self.setProperty("left", selected.$ext.offsetLeft);
                        break;
                    case "n":
                        _self.setProperty("top", selected.$ext.offsetTop);
                        break;
                    case "s":
                        _self.setProperty("bottom", pHtmlNode.offsetHeight
                            - selected.$ext.offsetTop - selected.$ext.offsetHeight);
                        break;
                }
            }

            _self.setProperty("width", !this.left || !this.right
                ? selected.$ext.offsetWidth
                : null);
            _self.setProperty("height", !this.top || !this.bottom
                ? selected.$ext.offsetHeight
                : null);
            
            apf.ContentEditable2.execCommand("commit");
        }
        else {
            _self.left      = selected.left;
            _self.top       = selected.top;
            _self.right     = selected.right;
            _self.bottom    = selected.bottom;
            _self.minwidth  = selected.minwidth
                || parseInt(selected.$getOption("main", "minwidth")) || 0;
            _self.minheight = selected.minheight
                || parseInt(selected.$getOption("main", "minheight")) || 0;
            _self.maxwidth  = selected.maxwidth
                || parseInt(selected.$getOption("main", "maxwidth")) || 10000;
            _self.maxheight = selected.maxheight
                || parseInt(selected.$getOption("main", "maxheight")) || 10000;
            
            _self.$resizeStart(e || event, {
                resizeType : this.type,
                nocursor   : true
            });
        }
    }
};
apf.Resize.prototype = new apf.Class();

/**
 * @private
 */
apf.ElementDrawer = function (){
    var p1    = document.body.appendChild(document.createElement("div")),
        p2    = document.body.appendChild(document.createElement("div")),
        q     = document.body.appendChild(document.createElement("div")),
        _self = this,
        startX, startY;
    p1.className = "pointer_left";
    p2.className = "pointer_right";
    q.className  = "new_element";

    this.activate = function(){
        document.onmousemove = function(e){
            if (!e) e = event;

            p1.style.width  = (Math.abs(e.clientX) || 1) + "px";
            p1.style.height = (Math.abs(e.clientY) || 1) + "px";

            p2.style.width  = (Math.abs(document.documentElement.offsetWidth
                - e.clientX - 5) || 1) + "px";
            p2.style.height = (Math.abs(document.documentElement.offsetHeight
                - e.clientY - 5) || 1) + "px";

            if (q.style.display == "block"){
                var wt = e.clientX - startX - 1,
                    ht = e.clientY - startY - 1,
                    min = Math.min(wt, ht);
                if (e.shiftKey)
                    wt = ht = min;

                q.style.width  = (wt < 0 ? -1 * (wt - 1) : (wt || 1)) + "px";
                q.style.height = (ht < 0 ? -1 * (ht - 1) : (ht || 1)) + "px";

                q.style.left  = wt < 0 ? "" : (startX) + "px";
                q.style.right = wt < 0 
                    ? (document.documentElement.offsetWidth - startX - 4) + "px"
                    : "";

                q.style.bottom = ht < 0 
                    ? (document.documentElement.offsetHeight - startY - 4) + "px"
                    : "";
                q.style.top    = ht < 0 ? "" : (startY) + "px";
            }
        }

        document.onmousedown = function(e){
            if (!e) e = event;
            //if ((e.srcElement || e.target) == document.body)
                //return false;

            q.style.display = "block";
            q.style.left    = (startX = event.clientX) + "px";
            q.style.top     = (startY = event.clientY) + "px";
            q.style.width   = (q.style.height = 1) + "px";
        };

        document.onmouseup = function(){
            if (q.offsetWidth > 10 && q.offsetHeight > 10) {
                apf.ContentEditable2.execCommand("add", {htmlNode: q});
                _self.deactivate();
            }

            q.style.display = "none";
            startX = false;
            startY = false;
        };

        p1.style.display =
        p2.style.display = "block";
        document.body.style.cursor =
        document.documentElement.style.cursor = "crosshair";
    };

    this.deactivate = function(){
        document.onmousemove = null;
        document.onmousedown = null;
        document.onmouseup = null;

        p1.style.display =
        p2.style.display = "none";
        document.body.style.cursor =
        document.documentElement.style.cursor = "";
    };
};

/**
 * @private
 */
apf.Selection = function(){};




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/xforms.js)SIZE(9309)TIME(1264896063)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__XFORMS__ = 1 << 17;




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/focussable.js)SIZE(3262)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__FOCUSSABLE__ = 1 << 26;


apf.Focussable = function(){
    this.$regbase = this.$regbase | apf.__FOCUSSABLE__;
    
    /**
     * Sets the position in the list that determines the sequence
     * of elements when using the tab key to move between them.
     * Call-chaining is supported.
     * @param {Number} tabindex the position in the list
     */
    this.setTabIndex = function(tabindex){
        apf.window.$removeFocus(this);
        apf.window.$addFocus(this, tabindex);
        return this;
    };

    /**
     * Gives this element the focus. This means that keyboard events
     * are send to this element.
     */
    this.focus = function(noset, e, nofix){
        if (!noset) {
            if (this.$isWindowContainer) {
                apf.window.$focusLast(this, e, true);
            }
            else {
                apf.window.$focus(this, e);

                
                if (!nofix && apf.hasFocusBug)
                    apf.window.$focusfix();
                
            }

            return this;
        }

        if (this.$focus)
            this.$focus(e);

        this.dispatchEvent("focus", apf.extend({
            srcElement : this,
            bubbles    : true
        }, e));
        return this;
    };

    /**
     * Removes the focus from this element.
     * Call-chaining is supported.
     */
    this.blur = function(noset, e){
        
        if (apf.popup.isShowing(this.$uniqueId))
            apf.popup.forceHide(); //This should be put in a more general position
        
        
        if (this.$blur)
            this.$blur(e);

        if (!noset)
            apf.window.$blur(this);

        this.dispatchEvent("blur", apf.extend({
            srcElement : this,
            bubbles    : !e || !e.cancelBubble
        }, e));
        return this;
    };

    /**
     * Determines whether this element has the focus
     * @returns {Boolean} indicating whether this element has the focus
     */
    this.hasFocus = function(){
        return apf.document.activeElement == this || this.$isWindowContainer
            && (apf.document.activeElement || {}).$focusParent == this;
    };
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/media.js)SIZE(18848)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__MEDIA__ = 1 << 20;



/**
 * All elements inheriting from this {@link term.baseclass baseclass} have media node features and dynamics.
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#media7
 *
 * @attribute {Boolean} seeking
 * @attribute {Boolean} autoplay
 * @attribute {Boolean} controls
 * @attribute {Boolean} ready
 * @attribute {Number}  bufferedBytes
 * @attribute {Number}  totalBytes
 *
 * @constructor
 * @baseclass
 * @author      Mike de Boer
 * @version     %I%, %G%
 * @since       1.0
 */
apf.Media = function(){
    this.$init(true);
};

(function() {
    this.$regbase = this.$regbase | apf.__MEDIA__;

    this.muted = false;

    this.$booleanProperties["paused"]     = true;
    this.$booleanProperties["muted"]      = true;
    this.$booleanProperties["seeking"]    = true;
    this.$booleanProperties["autoplay"]   = true;
    this.$booleanProperties["controls"]   = true;
    this.$booleanProperties["ready"]      = true;

    this.$supportedProperties.push("position", "networkState", "readyState",
        "progress", "buffered", "bufferedBytes", "totalBytes", "currentTime",
        "paused", "seeking", "volume", "type", "src", "autoplay", "controls");

    this.$mainBind  = "src";
    this.$sources   = [];
    this.$nomedia   = null;
    this.$amlTimer  = null;
    this.$loadTimer = null;
    this.$posTimer  = null;
    this.$volTimer  = null;

    /**
     * @attribute {Number} readyState 
     */
    this.$propHandlers["readyState"] = function(value){ //in seconds
        if (this.readyState !== value)
            this.readyState = value;
        if (value == apf.Media.HAVE_NOTHING) {
            
            apf.console.error("Unable to open medium with URL '" + this.src
                + "'. Please check if the URL you entered as src is pointing to \
                   a valid resource.");
            

            var oError = this.MediaError("Unable to open medium with URL '" + this.src
                + "'. Please check if the URL you entered as src is pointing to \
                   a valid resource.");
            if (this.dispatchEvent("havenothing", {
                error   : oError,
                bubbles : true
              }) === false)
                throw oError;
        }
        else if (value == apf.Media.HAVE_CURRENT_DATA)
            this.dispatchEvent("havecurrentdata");
        else if (value == apf.Media.HAVE_FUTURE_DATA)
            this.dispatchEvent("havefuturedata");
        else if (value == apf.Media.HAVE_ENOUGH_DATA) {
            this.dispatchEvent("haveenoughdata");
            this.setProperty("ready", true);
        }
    };

    /**
     * @attribute {Object} bufferedBytes
     *   Object:
     *    {Number} start
     *    {Number} end
     *    {Number} total
     */
    this.$propHandlers["bufferedBytes"] = function(value) {
        this.setProperty("progress", this.totalBytes
            ? value.end / this.totalBytes
            : 0);
    };

    /**
     * @attribute {Number} position
     */
    this.$propHandlers["position"] = function(value){
        clearTimeout(this.$posTimer);
        if (this.duration <= 0 || !this.seek) return;

        var _self = this;
        this.$posTimer = $setTimeout(function() {
            // first, check if the seek action doesn't go beyond the download
            // progress of the media element.
            if (value >= _self.progress)
                value = _self.progress - 0.05;

            var isPlaying = !_self.paused;
            if (isPlaying)
                _self.pause();

            if (value < 0)
                value = 0;
            else if (value > 1)
                value = 1;

            _self.seek(Math.round(value * _self.duration));

            _self.setProperty("paused", !isPlaying);
        });
    };

    /**
     * @attribute {Number} currentTime
     */
    this.$propHandlers["currentTime"] = function(value){ //in milliseconds
        if (value >= 0 && this.seek)
            this.seek(value);
    };

    /**
     * @attribute {Number} volume
     */
    this.$propHandlers["volume"] = function(value){
        if (!this.player) return;
        
        if (value < 0)
            throw this.MediaError("Attempt to set the volume to a negative value  '" + value + "'");
        

        if (value < 1 && value > 0)
            value = value * 100;

        if (this.setVolume)
            this.setVolume(value);
        if (value > 0 && this.muted)
            this.setProperty("muted", false);
    };

    this.oldVolume = null;

    /**
     * @attribute {Boolean} muted
     */
    this.$propHandlers["muted"] = function(value){
        if (!this.player || !this.setVolume) return;

        if (value) { //mute the player
            this.oldVolume = this.volume;
            this.setVolume(0);
        }
        else
            this.setVolume(this.oldVolume || 20);
    };

    /**
     * @attribute {Boolean} paused
     */
    this.$propHandlers["paused"] = function(value){
        if (!this.player) return;

        this.paused = apf.isTrue(value);
        if (this.paused)
            this.player.pause();
        else
            this.player.play();
    };

    /**
     * @attribute {String} type
     */
    this.$propHandlers["type"] = function(value){
        if (this.$loadTimer) return;

        var _self = this;
        this.$loadTimer = window.setTimeout(function() {
            reload.call(_self);
        });
    };

    /**
     * @attribute {String} src
     */
    this.$propHandlers["src"] = function(value){
        //@todo for mike: please check if this is the best behaviour for setting an empty value
        if (this.$loadTimer || !value) return;

        var oUrl = new apf.url(value);
        this.src = oUrl.uri;

        
        if (oUrl.protocol == "file")
            apf.console.warn("Media player: the medium with URL '" + this.src + "'\n"
                + "will be loaded through the 'file://' protocol.\nThis can "
                + "cause the medium to not load and/ or play.", "media");
        else if (!oUrl.isSameLocation())
            apf.console.warn("Media player: the medium with URL '" + this.src + "'\n"
                + "does not have the same origin as your web application.\nThis can "
                + "cause the medium to not load and/ or play.", "media");
        

        if (this.src != this.currentSrc && this.networkState !== apf.Media.LOADING) {
            var type = this.$guessType(this.src);
            if (type == this.type) {
                reset.call(this);
                this.loadMedia();
            }
            else {
                this.type = type;
                var _self = this;
                this.$loadTimer = window.setTimeout(function() {
                    reload.call(_self);
                });
            }
        }
    };

    /**
     * @attribute {Object} ID3
     */
    this.$propHandlers["ID3"] = function(value){
        if (!this.player) return;
        // usually this feature is only made available BY media as getters
        if (typeof this.player.setID3 == "function")
            this.player.setID3(value);
    };

    /**** DOM Hooks ****/

    this.addEventListener("AMLRemove", function(doOnlyAdmin){
        
        apf.console.log("Media: removing node...");
        
        reset.call(this);
    });

    this.addEventListener("AMLReparent", function(beforeNode, pNode, withinParent){
        if (!this.$amlLoaded)
            return;

        
        apf.console.log("Media: reparenting - " + beforeNode + ", " + pNode);
        

        this.$draw();
        reload.call(this, true);
    });

    function reset() {
        this.setProperty("networkState",  apf.Media.NETWORK_EMPTY);
        //this.setProperty("readyState",   apf.Media.HAVE_NOTHING);
        this.setProperty("ready",         false);
        //this.setProperty("buffered",      {start: 0, end: 0, length: 0});
        //this.setProperty("bufferedBytes", {start: 0, end: 0, length: 0});
        this.buffered      = {start: 0, end: 0, length: 0};
        this.bufferedBytes = {start: 0, end: 0, length: 0};
        this.totalBytes    = 0;
        this.setProperty("progress", 0);
        //this.setProperty("totalBytes",    0);

        this.setProperty("seeking",  false);
        this.setProperty("paused",   true);
        this.setProperty("position", 0);
        this.currentTime = this.duration = 0;
        this.played = this.seekable = null;
        this.ended  = false;

        this.start = this.end = this.loopStart = this.loopEnd =
            this.playCount = this.currentLoop = 0;
        this.controls = this.muted = false;
    }

    function reload(bNoReset) {
        
        apf.console.log("Media: reloading medium with mimetype '" + this.type + "'");
        

        window.clearTimeout(this.$loadTimer);
        this.$loadTimer = null;

        if (!bNoReset)
            reset.call(this);

        this.$destroy(true); //bRuntime = true

        this.playerType = this.$getPlayerType(this.type);

        // sanity checking
        if (!this.playerType || !this.$isSupported()) {
            this.$ext.innerHTML = this.notSupported;
            return;
        }

        this.$initPlayer();
    }

    /**
     * Returns an error state related to media
     *
     */
    this.MediaError = function(sMsg) {
        return new Error(apf.formatErrorString(0, this, "Media", sMsg));
    };

    // network state
    this.src = this.currentSrc = null;
    this.networkState       = apf.Media.NETWORK_EMPTY; //default state
    this.bufferingRate      = 0;
    this.bufferingThrottled = false;
    //TimeRanges container {start: Function(idx):Float, end: Function(idx):Float, length: n}
    this.buffered           = {start: 0, end: 0, length: 0};
    //ByteRanges container {start: Function(idx):Number, end: Function(idx):Number, length: n}
    this.bufferedBytes      = {start: 0, end: 0, length: 0};
    this.totalBytes         = 0;
    this.volume             = 100;

    this.loadMedia = function() {
        //must be overridden by the component
    };

    // ready state
    this.readyState = apf.Media.HAVE_NOTHING;
    this.seeking    = false;

    // playback state
    this.currentTime         = this.duration = 0;
    this.paused              = true;
    this.defaultPlaybackRate = this.playbackRate = 0;
    this.played              = null; // TimeRanges container
    this.seekable            = null; // TimeRanges container
    this.ended = this.autoplay = false;

    /**
     * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#dom-navigator-canplaytype
     */
    this.canPlayType = function(sType) {
        if (this.$getPlayerType) {
            var sPlayer = this.$getPlayerType(sType);
            if (!sPlayer || !this.$isSupported(sPlayer))
                return "no";
            if (sPlayer.indexOf("Wmp") != -1)
                return "maybe";
            return "probably"; //we're sooo confident ;)
        }

        return "no";
    };
    
    /**
     * Starts playing the media requested
     *
     */
    this.play = function() {
        this.setProperty("paused", false);
    };

    /**
     * Pauses playing the media requested
     *
     */
    this.pause = function() {
        this.setProperty("paused", true);
    };

    // looping
    this.start = this.end = this.loopStart = this.loopEnd =
    this.playCount = this.currentLoop = 0;

    // cue ranges
    this.addCueRange = function(sClassName, sId, iStart, iEnd, bPauseOnExit, fEnterCallback, fExitCallback) {
        //to be overridden by the component
    };

    this.removeCueRanges = function(sClassName) {
        //to be overridden by the component
    };

    /**
     * Return a counter as you commonly see in front panels of CD/ DVD players
     *
     * @link  http://php.net/strftime
     * @param {Number}  iMillis  Amount of milliseconds to transform in a counter
     * @param {String}  sFormat  Format of the counter is the form of PHP's strftime function:
     *                             %H - hour as a decimal number using a 24-hour clock (range 00 to 23)
     *                             %M - minute as a decimal number
     *                             %S - second as a decimal number
     *                             %Q - Millisecond as decimal (000-999)
     *                             %n - newline character
     *                             %t - tab character
     *                             %T - current time, equal to %H:%M:%S
     *                             %% - a literal `%' character
     * @param {Boolean} bReverse Show the counter in reverse notation (countdown)
     * @type  {String}
     */
    this.getCounter = function(iMillis, sFormat, bReverse) {
        // for String.pad, 'apf.PAD_LEFT' is implicit
        if (bReverse)
            iMillis = iMillis - this.duration;
        var iSeconds = Math.round(Math.abs(iMillis / 1000)),
            sHours   = String(Math.round(Math.abs(iSeconds / 60 / 60))).pad(2, "0"),
            sMinutes = String(Math.round(Math.abs(iSeconds / 60))).pad(2, "0"),
            sSeconds = String(iSeconds).pad(2, "0"),
            sMillis  = String(Math.round(Math.abs(iMillis % 1000))).pad(3, "0");
        return (bReverse ? "- " : "") + sFormat.replace(/\%T/g, "%H:%M:%S")
            .replace(/\%[a-zA-Z\%]/g, function(sMatch) {
                switch (sMatch) {
                case "%H":
                    return sHours;
                case "%M":
                    return sMinutes;
                case "%S":
                    return sSeconds;
                case "%Q":
                    return sMillis;
                case "%n":
                    return "\n";
                case "%t":
                    return "\t";
                case "%%":
                    return "%";
                }
            });
    };

    /**
     * Set the source for a media element by going through all the &lt;source&gt;
     * child elements of the &lt;audio&gt; or &lt;video&gt; node, searching for
     * a valid source media file that is playable by one of our plugins.
     * The 'src' and 'type' attributes respectively have precedence over any
     * &lt;source&gt; element.
     * It also parses the &lt;nomedia&gt; tag that specifies what text or HTML to
     * display when a medium is not supported and/ or playable.
     *
     * @param  {XmlDomElement} [aml] Parent Aml node of the player
     * @return {Boolean}             Tells the client that no supported/ playable source file was found
     */
    this.setSource = function() {
        if (!this.src) { // no direct src-attribute set
            var src, type, oSources = this.$sources;
            // iterate through all the <source> tags from left to right
            for (var i = 0, j = oSources.length; i < j; i++) {
                src  = oSources[i].src;
                if (!src) continue;
                type = oSources[i].type;
                if (!type) // auto-detect type, based on file extension
                    type = this.$guessType(src);
                if (this.canPlayType(type) != "no") {
                    // yay! we found a type that we can play for the client
                    this.src  = src;
                    this.type = type;
                    break; //escape!
                }
            }
        }
        else if (!this.type) {
            this.type = this.$guessType(this.src);
            if (this.canPlayType(this.type) == "no")
                return false;
        }

        return (this.src && this.type);
    };

    this.$addSource = function(amlNode) {
        clearTimeout(this.$amlTimer);

        if (amlNode.localName != "source"){
            
            throw new Error(apf.formatErrorString(0, this,
                "Parsing Media node",
                "Found element which is not a source element", this));
            
            return false;
        }

        this.$sources.pushUnique(amlNode);

        var _self = this;
        this.$amlTimer = $setTimeout(function() {
            clearTimeout(_self.$amlTimer);
            _self.dispatchEvent("AMLMediaReady");
        });
    };

    this.$removeSource = function(amlNode) {
        this.$sources.remove(amlNode);
    };

    this.addEventListener("DOMNodeInserted", function(e){
        var node = e.currentTarget;
        if (node.parentNode != this)
            return;

        this.$addSource(node);
    });

    this.addEventListener("DOMNodeRemoved", function(e){
        var node = e.currentTarget;
        // we support two levels deep:
        if (!(node.parentNode == this || node.parentNode.parentNode == this))
            return;

        this.$removeSource(node);
    });


}).call(apf.Media.prototype = new apf.StandardBinding());


apf.nomedia = function(struct, tagName) {
    this.$init(tagName || "nomedia", apf.NODE_HIDDEN, struct);
};

(function() {
    this.addEventListener("DOMNodeInsertedIntoDocument", function() {
        this.parentNode.notSupported =
            apf.getXmlString(this.$aml).replace(/<\/?a:nomedia[^>]*>/g, "");
    });
}).call(apf.nomedia.prototype = new apf.AmlElement());

apf.aml.setElement("nomedia", apf.nomedia);

// network state (.networkState)
apf.Media.NETWORK_EMPTY   = 0;
apf.Media.NETWORK_IDLE    = 1;
apf.Media.NETWORK_LOADING = 2;
apf.Media.NETWORK_LOADED  = 3;

// ready state (.readyState)
apf.Media.HAVE_NOTHING      = 0;
apf.Media.HAVE_METADATA     = 1;
apf.Media.HAVE_SOME_DATA    = 2; //wtf??
apf.Media.HAVE_CURRENT_DATA = 3;
apf.Media.HAVE_FUTURE_DATA  = 4;
apf.Media.HAVE_ENOUGH_DATA  = 5;




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/basesimple.js)SIZE(1767)TIME(1264690337)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Baseclass of a simple element. This are usually displaying elements 
 * (i.e. {@link element.label}, {@link element.picture})
 *
 * @constructor
 * @baseclass
 *
 * @inherits apf.StandardBinding
 * @inherits apf.DataAction
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 */
apf.BaseSimple = function(){
    this.$init(true);
};

(function() {
    
    this.implement(apf.DataAction);
    
    
    this.getValue = function(){
        return this.value;
    };

}).call(apf.BaseSimple.prototype = new apf.StandardBinding());





/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/a11y.js)SIZE(5144)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__ALIGNMENT__ = 1 << 29;



/**
 * All elements inheriting from this {@link term.baseclass baseclass} have
 * accessibility features.
 *
 * @constructor
 * @baseclass
 * @author      Mike de Boer (mike AT javeline DOT com)
 * @version     %I%, %G%
 * @since       3.0
 *
 * @default_private
 */
apf.A11y = function(){
    this.setRole = function(oNode, sRole) {
        if (!oNode)
            throw new Error();
        if (!apf.A11y.ROLES[sRole])
            throw new Error();

        oNode.setAttribute("role", sRole);
    };

    this.setWidgetAttr = function(oNode, sAttr, mValue) {
        var rel = apf.A11y.ATTR_WIDGETS[sAttr];

        if (!rel)
            throw new Error("attr does not exist");
        if ((typeof rel == "boolean" && typeof mValue != "boolean")
          || (typeof rel == "number" && typeof mValue != "number")
          || ((typeof rel == "string" || apf.isArray(rel)) && typeof mValue != "string"))
            throw new Error("invalid type");

        oNode.setAttribute("aria-" + sAttr, mValue);
    };

    this.updateLiveRegion = function(oNode, sAttr, mValue) {
        var rel = apf.A11y.ATTR_LIVEREGION[sAttr];

        if (!rel)
            throw new Error("attr does not exist");
        if ((typeof rel == "boolean" && typeof mValue != "boolean")
          || (apf.isArray(rel) && typeof mValue != "string"))
            throw new Error("invalid type");

        if (oNode) {
            oNode.setAttribute("aria-" + sAttr, mValue);
        }
        else {
            // create a hidden element, cache it and set the attributes on that
            // element.
        }
    };

    this.setDragDropAttr = function(oNode, sAttr, mValue) {
        var rel = apf.A11y.ATTR_LIVEREGION[sAttr];

        if (!rel)
            throw new Error("attr does not exist");
        if ((typeof rel == "boolean" && typeof mValue != "boolean")
          || (apf.isArray(rel) && typeof mValue != "string"))
            throw new Error("invalid type");

        oNode.setAttribute("aria-" + sAttr, mValue);
    };

    this.setRelationAttr = function() {
        var args  = Array.prototype.slice.call(arguments),
            oNode = args.shift(),
            sAttr = args.shift(),
            sVal  = args.join(" "); // space delimited list of values (for example IDs)

        if (!apf.A11y.ATTR_RELATIONS[sAttr])
            throw new Error();

        oNode.setAttribute("aria-" + sAttr, sVal);
    };
};

apf.A11y.ROLES = {
    "alert":1, "alertdialog":1, "application":1, "article":1, "banner":1, "button":1,
    "checkbox":1, "columnheader":1, "combobox":1, "complementary":1, "contentinfo":1,
    "definition":1, "dialog":1, "directory":1, "grid":1, "gridcell":1, "group:":1,
    "heading":1, "img":1, "link":1, "list":1, "listbox":1, "listitem":1, "log":1,
    "main":1, "marquee":1, "math":1, "menu":1, "menubar":1, "menuitem":1,
    "menuitemcheckbox":1, "menuitemradio":1, "navigation": 1, "note":1, "option":1,
    "presentation":1, "progressbar":1, "radio":1, "radiogroup":1, "region":1,
    "row":1, "rowheader":1, "search":1, "seperator":1, "slider":1, "slinbutton":1,
    "status":1, "tab":1, "tablist":1, "tabpanel":1, "textbox":1, "timer":1,
    "toolbar":1, "tooltip":1, "tree":1, "treegrid":1, "treeitem":1
};

apf.A11y.ATTR_WIDGETS = {
    "autocomplete":true, "checked":true, "disabled":true, "expanded":true,
    "haspopup":true, "hidden":true, "invalid":["grammar", "false", "spelling", 
    "true"], "level":1, "multiline":true, "multiselectable":true, "pressed":
    ["true", "false", "pressed"], "readonly":true, "required":true,
    "selected":true, "sort":["ascending", "descending", "none", "other"],
    "valuemax":1, "valuemin":1, "valuenow":1, "valuetext":"string"
};

apf.A11y.ATTR_LIVEREGION = {
    "atomic":true, "busy":true, "live":["off", "polite", "assertive"],
    "relevant":["additions", "removals", "text", "all", "additions text"]
};

apf.A11y.ATTR_DRAGDROP = {
    "dropeffect":["copy", "move", "reference", "execute", "popup", "none"],
    "grabbed":true
};

apf.A11y.ATTR_RELATIONS = {
    "activedescendant":{}, "controls":{}, "describedby":{}, "flowto":{},
    "label":"1", "labelledby":{}, "owns":{}, "posinset":1, "setsize":1
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/transaction.js)SIZE(23553)TIME(1264352083)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__TRANSACTION__ = 1 << 3;



/**
 * All elements inheriting from this {@link term.baseclass baseclass} have transaction support. A transaction is a 
 * set of changes to data which are treated as one change. When one of the 
 * changes in the set fails, all the changes will be cancelled. In the case of
 * a gui this is mostly relevant when a user decides to cancel after 
 * making several changes. A good example are the well known property windows 
 * with an ok, cancel and apply button. 
 *
 * When a user edits data, for instance user information, all the changes are
 * seen as one edit and put on the undo stack as a single action. Thus clicking
 * undo will undo the entire transaction, not just the last change done by that
 * user in the edit window. Transaction support both optimistic and pessimistic 
 * locking. For more information on the latter see the first example below.
 * Example:
 * This example shows a list with one item. When double clicked on the item
 * a window shows that allows the user to edit the properties of this item.
 * When the window is closed the changes are committed to the xml data. If the
 * user presses cancel the changes are discarded. By pressing the 'add new item'
 * button the same window appears which allows the user to add a new item. All
 * changes made by the user are also sent to the original data source via 
 * rpc calls. When the user starts editing an existing item a lock is requested.
 * This is not necesary for transaction support, but this example shows that it
 * is possible. When the lock fails the window will close. By hooking the
 * 'lockfail' event the user can be notified of the reason. For more information 
 * see {@link term.locking}.
 * <code>
 *  <a:list 
 *    id            = "lstItems" 
 *    onafterchoose = "winEdit.show()" 
 *    width         = "200">
 *      <a:each match="[item]">
 *          <a:caption match="[@name]" />
 *          <a:icon value="icoItem.png" />
 *      </a:each>
 *      <a:actions>
 *          <a:add set="http://localhost/save.php?xml=%[.]">
 *              <item name="New Item" />
 *          </a:add>
 *          <a:update 
 *            set  = "http://localhost/save.php?xml=%[.]" 
 *            lock = "http://localhost/lock.php?id=[@id]" />
 *      </a:actions>
 *      <a:model>
 *          <items>
 *              <item name="test" subject="subject" id="1">message</item>
 *          </items>
 *      </a:model>
 *  </a:list>
 *      
 *  <a:button onclick="winEdit.begin('add');">Add new item</a:button>
 *       
 *  <a:window 
 *    width       = "300"
 *    id          = "winEdit" 
 *    transaction = "true"
 *    model       = "{lstItems.selected}"
 *    title       = "Edit this message">
 *      <a:label>Name</a:label>
 *      <a:textbox 
 *        value      = "[@name]" 
 *        required   = "true" 
 *        invalidmsg = "Please enter your name" />
 *      <a:label>Subject</a:label>
 *      <a:textbox value="[@subject]" />
 *    
 *      <a:label>Message</a:label>
 *      <a:textarea value="[text()]" min-length="100" />
 *      
 *      <a:button action="ok" default="true">OK</a:button>
 *      <a:button action="cancel">Cancel</a:button>
 *      <a:button action="apply" disabled="{!winEdit.undolength}">Apply</a:button>
 *   </a:window>
 * </code>
 *
 * @constructor
 * @baseclass
 *
 * @event transactionconflict Fires when data in a transaction is being updated by an external process.
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8.9
 */
apf.Transaction = function(){
    this.$regbase = this.$regbase | apf.__TRANSACTION__;

    this.$addParent          =
    this.$transactionNode    =
    this.$transactionSubject =
    this.$originalNode       =
    this.$inTransaction      =
    this.$lastAction         = null;

    this.$supportedProperties.push("autoshow");
    
    /**
     * @attribute {Boolean} autoshow whether this element is shown when a transaction begins.
     */
    this.$booleanProperties["autoshow"] = true;

    /**
     * Commits a started transaction. This will trigger an update or add action.
     * forked copy of template data.
     *
     * @todo  check what's up with actiontracker usage... 
     * @bug  when a commit is cancelled using the onbeforecommit event, the 
     * state of the element becomes undefined.
     */
    this.commit = function(repeat){
        if (!this.$inTransaction)
            return false;

        if (!this.$validgroup && this.validgroup)
            this.$validgroup = self[this.validgroup];

        if (this.$validgroup && !this.$validgroup.isValid())
            return false;

        var returnValue = true;
        if (!this.$at.undolength) {
            if (repeat)
                return false;
            
            this.$at.purge();
            this.$inTransaction = false;
            
            this.load(this.$originalNode);
            this.$helperModel.reset();
            
            returnValue = false;
        }
        else {
            
            apf.console.info("Committing transaction on " + this.localName + "[" + this.name + "]");
            
            
            this.$at.reset();//purge();
            this.$inTransaction = false;
            
            //@todo recursive
            this.$transactionNode.removeAttribute(apf.xmldb.xmlListenTag)
            
            if (this.$lastAction == "add") {
                //Use ActionTracker :: this.xmlData.selectSingleNode("DataBinding/@select") ? o.xmlRoot : o.selected
                if (this.$transactionSubject.$executeAction("appendChild",
                  [this.$addParent, this.$transactionNode], "add", this.$transactionNode)
                  && this.$transactionSubject.hasFeature(apf.__MULTISELECT__)) {
                    this.$transactionSubject.select(this.$transactionNode);
                }
                
                this.$transactionSubject = null;
            }
            else {
                //Use ActionTracker
                //getTraverseParent(o.selected) || o.xmlRoot
                var at = this.$at;
                this.$at = this.dataParent 
                    ? this.dataParent.parent.getActionTracker()
                    : null;//self[this.getAttribute("actiontracker")];//this.dataParent.parent.getActionTracker();
                
                this.$transactionSubject.$executeAction("replaceNode", [this.$originalNode, this.$transactionNode],
                    "update", this.$transactionNode);
    
                this.$at = at;
        
                //this.load(this.$transactionNode);
            }
        }
        
        this.$transactionNode = null;
        this.$addParent       = null;
        this.$originalNode    = null;
        
        if (this.autoshow) {
            if (this.autoshow == -1)
                this.autoshow = true;
            else
                this.hide();
        }
        
        return returnValue;
    };
    
    /**
     * Rolls back the started transaction.
     */
    this.rollback = function(noLoad){
        if (!this.$inTransaction)
            return;
        
        
        apf.console.info("Rolling back transaction on " + this.localName + "[" + this.name + "]");
        
        
        if (this.$at) {
            if (this.rpcMode == "realtime")
                this.$at.undo(-1);

            this.$at.reset();
        }
        //this.xmldb.reset();
        
        this.$transactionNode = null; //prevent from restarting the transaction in load
        this.$addParent       = null;

        //Cleanup
        if (!noLoad)
            this.load(this.$originalNode);
        
        this.$helperModel.reset();
        
        this.$stopAction(this.$lastAction, true);
        
        this.$originalNode    = null;
        this.$inTransaction   = false;
        
        if (this.autoshow) {
            if (this.autoshow == -1)
                this.autoshow = true;
            else
                this.hide();
        }
    };

    /**
     * Starts a transaction for this element. This is either an add or update.
     * @param {String}     strAction the type of transaction to start
     *   Possible values:
     *   add    the transaction is started to add a new {@link term.datanode data node}.
     *   update the transaction is started to update an existing {@link term.datanode data node}.
     * @param {XMLElement} xmlNode 
     * @param {XMLElement} parentXmlNode 
     * @param {AMLElement} dataParent 
     */
    this.begin = function(strAction, xmlNode, parentXmlNode, dataParent){
        if (this.$inTransaction) {
            /*throw new Error(apf.formatErrorString(0, this, 
                "Starting Transaction", 
                "Cannot start a transaction without committing or rolling \
                 back previously started transaction.", this.oldRoot));*/
            
            
            apf.console.warn("Rolling back transaction, while starting a new one");
            
            
            if (this.autoshow)
                this.autoshow = -1;
            this.rollback();
        }

        
        apf.console.info("Beginning transaction on " + this.localName + "[" + this.name + "]");
        

        //Add should look at dataParent and take selection or xmlRoot
        //winMail.dataParent.parent.xmlRoot

        var _self = this;
        this.$lastAction = strAction;

        if (!this.$lastAction) {
            this.$lastAction = this.xmlRoot && "update" || "add";
                /*this.actionRules && (this.actionRules.add 
                ? "add"
                : (this.actionRules.update
                    ? "update" 
                    : null)) || this.xmlRoot && "update";*/
        }
        
        
        if (!this.$lastAction) {
            throw new Error(apf.formatErrorString(0, this, 
                "Starting Transaction", 
                "Could not determine whether to add or update."));
        }
        
        
        //Determines the actiontracker to integrate the grouped action into
        if (dataParent)
            this.$setDynamicProperty("model", "[" + dataParent.id + ".selected]"); //@todo what if it doesn't have an id

        if (xmlNode && this.$lastAction == "update") {
            this.xmlRoot = xmlNode;
            //this.$inTransaction = -1; //Prevent load from triggering a new transaction
            //this.load(xmlNode);
        }
        
        /*
         * @todo:
         *   create actiontracker based on data id, destroy actiontracker on cancel/commit - thus being able to implement editor feature natively
         *   Multiple transactions can exist at the same time in the same container, but on different data
         *   .cancel(xmlNode) .apply(xmlNode)
         *   .list(); // returns a list of all started transactions
         *   Add undo/redo methods to winMultiEdit
         *   Route undolength/redolength properties
         *   Setting replaceat="start" or replaceat="end"
         */
        if (!this.$at) {
            this.$at  = new apf.actiontracker();
            var propListen = function(e){
                _self.setProperty(e.prop, e.value);
            };
            this.$at.addEventListener("prop.undolength", propListen);
            this.setProperty("undolength", 0);
            this.$at.addEventListener("prop.redolength", propListen);
            this.setProperty("redolength", 0);
        }
        if (!this.$helperModel) {
            this.$helperModel = new apf.model();
            this.$helperModel["save-original"] = true;
            this.$helperModel.load("<data />");
        }

        this.$transactionNode = null;
        this.$addParent       = null;
        this.$originalNode    = this.xmlRoot;

        
        if (typeof apf.offline != "undefined" && !apf.offline.canTransact())
            return false;
        

        this.$inTransaction = true;
        function begin(){
            
            if (!this.$transactionNode) {
                throw new Error(apf.formatErrorString(0, this, 
                    "Starting transaction", 
                    "Missing transaction node. Cannot start transaction. \
                     This error is unrecoverable."));
            }
            

            this.$inTransaction = -1;
            this.$helperModel.data.appendChild(this.$transactionNode);//apf.xmldb.cleanNode());
            this.load(this.$helperModel.data.firstChild);
            this.$inTransaction = true;
            
            if (this.disabled)
                this.enable();
            
            if (this.autoshow) {
                if (this.autoshow == -1)
                    this.autoshow = true;
                else
                    this.show();
            }
        }
        
        //Determine data parent
        dataParent = this.dataParent && this.dataParent.parent;
        
        if (!dataParent || !dataParent.$actions 
          || !dataParent.$actions[this.$lastAction]) {
            dataParent = this;
        }
        
        //Add
        if (this.$lastAction == "add") {
            //Check for add rule on data parent
            var rule, actionRules = dataParent.$actions;
            if (actionRules) {
                if (xmlNode && xmlNode.nodeType)
                    rule = actionRules.getRule("add", xmlNode);
                else if (typeof xmlNode == "string") {
                    if (xmlNode.trim().charAt(0) == "<") {
                        xmlNode = apf.getXml(xmlNode);
                        rule = actionRules.getRule("add", xmlNode)
                    }
                    else {
                        var rules = actionRules.$rules["add"];
                        for (var i = 0, l = rules.length; i < l; i++) {
                            if (rules[i].getAttribute("type") == xmlNode) {
                                xmlNode = null;
                                rule = rules[i];
                                break;
                            }
                        }
                    }
                }
    
                if (!rule) 
                    rule = (dataParent.$actions["add"] || {})[0];
            }
            else
                rule = null;
            
            
            if (typeof apf.offline != "undefined" && !apf.offline.onLine
              && !rule.get)
                return false;
            
            
            //Run the add code (copy from multiselect) but don't add until commit
            var refNode  = this.$isTreeArch ? this.selected || this.xmlRoot : this.xmlRoot;
            var callback = function(addXmlNode, state, extra){
                if (state != apf.SUCCESS) {
                    var oError;
    
                    oError = new Error(apf.formatErrorString(1032, dataParent,
                        "Loading xml data",
                        "Could not add data for control " + dataParent.name
                        + "[" + dataParent.tagName + "] \nUrl: " + extra.url
                        + "\nInfo: " + extra.message + "\n\n" + xmlNode));
    
                    if (extra.tpModule.retryTimeout(extra, state, dataParent, oError) === true)
                        return true;
    
                    throw oError;
                }
                
                /*if (apf.supportNamespaces && node.namespaceURI == apf.ns.xhtml) {
                    node = apf.getXml(node.xml.replace(/xmlns\=\"[^"]*\"/g, ""));
                    //@todo import here for webkit?
                }*/

                if (typeof addXmlNode != "object")
                    addXmlNode = apf.getXmlDom(addXmlNode).documentElement;
                if (addXmlNode.getAttribute(apf.xmldb.xmlIdTag))
                    addXmlNode.setAttribute(apf.xmldb.xmlIdTag, "");
    
                if (!dataParent.$startAction("add", addXmlNode, _self.rollback))
                    return false;
    
                var actionNode = (dataParent.$actions && 
                  dataParent.$actions.getRule("add", dataParent.$isTreeArch
                    ? dataParent.selected
                    : dataParent.xmlRoot) || {})[2];
                
                if (parentXmlNode) {
                    _self.$addParent = parentXmlNode;
                }
                else if (actionNode && actionNode.getAttribute("parent")) {
                    _self.$addParent = dataParent.xmlRoot
                        .selectSingleNode(actionNode.getAttribute("parent"));
                }
                else {
                    _self.$addParent = dataParent.$isTreeArch
                        ? dataParent.selected || dataParent.xmlRoot
                        : dataParent.xmlRoot
                }
    
                if (!_self.$addParent)
                    _self.$addParent = dataParent.xmlRoot || dataParent.getModel(true).data;
    
                if (apf.isWebkit && _self.$addParent.ownerDocument != addXmlNode.ownerDocument)
                    addXmlNode = _self.$addParent.ownerDocument.importNode(addXmlNode, true); //Safari issue not auto importing nodes
    
                _self.$transactionNode    = addXmlNode;
                _self.$transactionSubject = dataParent;
                begin.call(_self);
            }

            if (xmlNode)
                return callback(xmlNode, apf.SUCCESS);
            else {
                if (rule && rule.get)
                    return apf.getData(rule.get, {xmlNode: refNode, callback: callback})
                else {
                    
                    throw new Error(apf.formatErrorString(0, this,
                        "Starting transaction", 
                        "Missing add rule for transaction"));
                    
                }
            }
        }
        
        //Update
        else {
            if (!dataParent.$startAction(this.$lastAction, this.xmlRoot, this.rollback))
                return false;

            this.$transactionSubject = dataParent;
            this.$transactionNode    = this.$originalNode.cloneNode(true);//xmldb.cleanNode(this.xmlRoot.cloneNode(true));
            //xmlNode.removeAttribute(xmldb.xmlIdTag);
            
            //@todo rename listening attributes
            begin.call(this);
        }
    };
    
    //Transaction nodes can always load data
    this.$canLoadData = function(){
        return true;
    }

    //Prevent model inheritance to the children
    this.addEventListener("prop.model", function(e){
        return false;
    });
    
    //Prevent clear dynamic
    this.clear = function(){
        this.documentId = this.xmlRoot = this.cacheId = null;
    }

    //No need to restart the transaction when the same node is loaded
    this.addEventListener("beforeload", function(e){
        var xmlNode = e.xmlNode;
        
        //@todo apf3.0 test if this can be enabled again
        //if (this.$originalNode == xmlNode)
            //return false;
        
        if (this.$inTransaction == -1)
            return;

        if (this.$inTransaction) {
            if (this.$transactionNode && xmlNode != this.$transactionNode) {
                if (this.autoshow)
                    this.autoshow = -1;
                
                this.rollback(true);
            }
            else return;
        }

        if (this.autoshow)
            this.autoshow = -1;
            
        if (this.begin("update", xmlNode) !== false)
            return false;
    });
     
    //hmm really?
    //@todo what to do here? check original cloned node???
    /*this.addEventListener("xmlupdate", function(e){
        if (this.$inTransaction) {
            this.dispatchEvent("transactionconflict", {
                action : e.action,
                xmlNode: e.xmlNode,
                UndoObj: e.UndoObj,
                bubbles : true
            });
        }
    });*/
    
    //@todo add when not update???
    /*this.watch("visible", function(id, oldval, newval){
        if (!this.xmlRoot || oldval == newval)
            return;
        
        if (newval) {
            if (!this.$inTransaction)
                this.begin();
        }
        else {
            if (this.$inTransaction) 
                this.rollback();
        }
    });*/
}

/**
 * @attribute {Boolean} transaction Whether this element provides transaction
 * support for all it's children.
 * @see baseclass.transaction
 */
apf.GuiElement.propHandlers["transaction"] = function(value){
    if (!(this.transaction = apf.isTrue(value)))
        return;

    /**
     * @inherits apf.StandardBinding
     * @inherits apf.DataAction
     * @inherits apf.Transaction
     */
    if (!this.hasFeature(apf.__DATABINDING__))
        this.implement(apf.StandardBinding);

    if (!this.hasFeature(apf.__DATAACTION__)) {
        this.implement(apf.DataAction);

        if (this.actions)
            this.$propHandlers["actions"].call(this, this.actions, "actions");
    }
     
    if (!this.hasFeature(apf.__TRANSACTION__)) {
        this.implement(apf.Transaction);
        
        if (!this.validgroup) {
            this.$validgroup = new apf.ValidationGroup();
            this.$validgroup.register(this);
        }
        
        if (!this.id)
            this.setProperty("id", this.localName + "_" + this.$uniqueId);
        
        var attr = this.attributes.getNamedItem("model");
        if (!attr)  //@todo find a way to not have to add a model
            this.attributes.push(attr = new apf.AmlAttr(this, "model", null));
        attr.inheritedValue = "{" + this.id + ".root}";
                
        if (typeof this.autoshow == "undefined" 
          && (this.localName == "modalwindow" || this.localName == "window"))
            this.autoshow = true;
    }
}



/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/baselist.js)SIZE(36126)TIME(1263859264)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */







/**
 * Baseclass of elements that allows the user to select one or more items
 * out of a list.
 *
 * @constructor
 * @baseclass
 *
 * @inherits apf.MultiSelect
 * @inherits apf.Cache
 * @inherits apf.DataAction
 * @inherits apf.XForms
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 * @default_private
 *
 * @binding caption  Determines the caption of a node.
 * @binding icon     Determines the icon of a node. This binding rule is used
 * to determine the icon displayed when using a list skin. The {baseclass.baselist.binding.image image binding}
 * is used to determine the image in the thumbnail skin.
 * @binding image    Determines the image of a node. This binding rule is used
 * to determine the image displayed when using a thumbnail skin. The {baseclass.baselist.binding.icon icon binding}
 * is used to determine the icon in the list skin.
 * Example:
 * In this example the image url is read from the thumbnail attribute of the data node.
 * <code>
 *  <a:thumbnail>
 *      <a:model>
 *          <data>
 *              <image caption="Thumb 1" thumbnail="thumb1.jpg" />
 *              <image caption="Thumb 2" thumbnail="thumb2.jpg" />
 *              <image caption="Thumb 3" />
 *          </data>
 *      </a:model>
 *      <a:bindings>
 *          <a:caption match="[@caption]" />
 *          <a:image match="[@thumbnail]" default="default_thumbnail.jpg" />
 *          <a:each match="[image]" />
 *      </a:bindings>
 *  </a:thumbnail>
 * </code>
 * @binding css      Determines a css class for a node.
 * Example:
 * In this example a node is bold when the folder contains unread messages:
 * <code>
 *  <a:list>
 *      <a:model>
 *          <data>
 *              <folder caption="Folder 1">
 *                  <message unread="true" />
 *              </folder>
 *              <folder caption="Folder 2" icon="email.png"></folder>
 *              <folder caption="Folder 3"></folder>
 *          </data>
 *      </a:model>
 *      <a:bindings>
 *          <a:caption match="[@caption]" />
 *          <a:css match="[message[@unread]]" value="highlighUnread" />
 *          <a:icon match="[@icon]" />
 *          <a:icon match="[folder]" value="Famfolder.gif" />
 *          <a:each match="[folder]" />
 *      </a:bindings>
 *  </a:list>
 * </code>
 * @binding tooltip  Determines the tooltip of a node.
 * @event notunique Fires when the more attribute is set and an item is added that has a caption that already exists in the list.
 *   object:
 *   {String} value the value that was entered.
 */
apf.BaseList = function(){
    this.$init(true);
    
    
    this.dynCssClasses = [];
    
    
    this.listNodes   = [];
};

(function() {
    this.implement(
        
        apf.Cache,
        
        
        apf.DataAction
        
        
    );

    /**** Properties and Attributes ****/

    this.$focussable = true; // This object can get the focus
    this.multiselect = true; // Initially Disable MultiSelect
    this.mode        = "normal";

    /**
     * @attribute {String} fill the set of items that should be loaded into this
     * element. A start and an end seperated by a -.
     * Example:
     * This example loads a list with items starting at 1980 and ending at 2050.
     * <code>
     *  <a:dropdown fill="1980-2050" />
     *  <a:dropdown fill="red,green,blue,white" />
     *  <a:dropdown fill="None,100-110,1000-1100" />
     *  <a:dropdown fill="01-10" />
     *  <a:dropdown fill="1-10" />
     * </code>
     */
    this.$propHandlers["fill"] = function(value){
        if (value)
            this.loadFillData(this.getAttribute("fill"));
        else
            this.clear();
    };
    
    //@todo unsetter
    this.$propHandlers["template"] = function(value){
        this.$template = typeof value == "object" 
          ? value 
          : apf.nameserver.get("template", value);

        if (!this.$template) {
            var f;
            apf.addEventListener("parsestop", f = function(){
                _self.$propHandlers["template"].call(_self, value);
                apf.removeEventListener("parsestop", f);
            });
            return;
        }
        
        //this.setProperty("skin", "templatelist");
        
        //@todo solve the model inheritance problem
        this.$deInitNode = function(xmlNode, htmlNode){
            var Lid = xmlNode.getAttribute(apf.xmldb.xmlIdTag) + "|" + this.$uniqueId;
            this.$template.destroyInstance(Lid);
            
            if (htmlNode)
                htmlNode.parentNode.removeChild(htmlNode);
        };

        this.$updateNode = function(xmlNode, htmlNode, noModifier){
            //Do nothing
        };

        this.$moveNode = function(xmlNode, htmlNode){
            //@todo
        };

        var docFrag = document.createDocumentFragment();

        this.$add = function(xmlNode, Lid, xmlParentNode, htmlParentNode, beforeNode){
            /*this.$getNewContext("item");
            var item = this.$getLayoutNode("item");
            item.setAttribute("id", Lid);
            var htmlNode = apf.insertHtmlNode(item, htmlParentNode || this.$int, beforeNode);*/
            var htmlNode = document.createElement("div");
            htmlNode.setAttribute("id", Lid);
            docFrag.appendChild(htmlNode);

            this.$template.getNewInstance(
                this.$getLayoutNode("item", "container", htmlNode), Lid, xmlNode, true);
            //docFrag.setProperty("model", xmlNode);
        };
        
        this.$fill = function(){
            //Do nothing (optimization later?)
            //apf.AmlParser.parseLastPass();
            //apf.isParsing = false;
            
            this.$int.appendChild(docFrag);
            
            apf.queue.empty();
        };
        
        //@todo changing template
        this.$checkLoadQueue();
    };

    /**** Keyboard support ****/

    

    //Handler for a plane list
    this.$keyHandler = function(e){
        var key      = e.keyCode,
            ctrlKey  = e.ctrlKey,
            shiftKey = e.shiftKey,
            selHtml  = this.$selected || this.$caret;

        if (e.returnValue == -1 || !selHtml || this.renaming) //@todo how about allowdeselect?
            return;

        var selXml = this.caret || this.selected,
            oExt   = this.$ext,
            // variables used in the switch statement below:
            node, margin, items, lines, hasScroll, hasScrollX, hasScrollY;

        switch (key) {
            case 13:
                if (this.$tempsel)
                    this.$selectTemp();

                if (this.ctrlselect == "enter")
                    this.select(this.caret, true);

                this.choose(this.selected);
                break;
            case 32:
                if (ctrlKey || this.mode != "normal" || !this.isSelected(this.caret))
                    this.select(this.caret, ctrlKey);
                break;
            case 109:
            case 46:
                //DELETE
                if (this.disableremove)
                    return;

                if (this.$tempsel)
                    this.$selectTemp();

                this.remove(this.mode != "normal" ? this.caret : null); //this.mode != "check"
                break;
            case 36:
                //HOME
                if (this.hasFeature(apf.__VIRTUALVIEWPORT__)) 
                    this.viewport.change(0, null, true, true);
                    
                this.select(this.getFirstTraverseNode(), false, shiftKey);
                this.$int.scrollTop = 0;
                break;
            case 35:
                //END
                if (this.hasFeature(apf.__VIRTUALVIEWPORT__)) 
                    this.viewport.change(this.viewport.length, null, true, true);
                
                this.select(this.getLastTraverseNode(), false, shiftKey);
                this.$int.scrollTop = this.$int.scrollHeight;
                break;
            case 107:
                //+
                if (this.more)
                    this.startMore();
                break;
            case 37:
                //LEFT
                if (!selXml && !this.$tempsel)
                    return;

                node   = this.$tempsel
                    ? apf.xmldb.getNode(this.$tempsel)
                    : selXml;
                margin = apf.getBox(apf.getStyle(selHtml, "margin"));
                items  = selHtml.offsetWidth
                    ? Math.floor((oExt.offsetWidth
                        - (hasScroll ? 15 : 0)) / (selHtml.offsetWidth
                        + margin[1] + margin[3]))
                    : 1;

                margin = apf.getBox(apf.getStyle(selHtml, "margin"));

                node   = this.getNextTraverseSelected(node, false);
                if (node)
                    this.$setTempSelected(node, ctrlKey, shiftKey, true);
                else
                    return;

                selHtml = apf.xmldb.findHtmlNode(node, this);
                if (selHtml.offsetTop < oExt.scrollTop) {
                    oExt.scrollTop = Array.prototype.indexOf.call(this.getTraverseNodes(), node) < items
                        ? 0
                        : selHtml.offsetTop - margin[0];
                }
                break;
            case 38:
                //UP
                if (!selXml && !this.$tempsel)
                    return;

                node = this.$tempsel
                    ? apf.xmldb.getNode(this.$tempsel)
                    : selXml;

                margin    = apf.getBox(apf.getStyle(selHtml, "margin"));
                hasScroll = oExt.scrollHeight > oExt.offsetHeight;
                items     = selHtml.offsetWidth
                    ? Math.floor((oExt.offsetWidth
                        - (hasScroll ? 15 : 0)) / (selHtml.offsetWidth
                        + margin[1] + margin[3]))
                    : 1;

                node      = this.getNextTraverseSelected(node, false, items);
                if (node)
                    this.$setTempSelected (node, ctrlKey, shiftKey, true);
                else
                    return;

                selHtml = apf.xmldb.findHtmlNode(node, this);
                if (selHtml.offsetTop < oExt.scrollTop) {
                    oExt.scrollTop = Array.prototype.indexOf.call(this.getTraverseNodes(), node) < items
                        ? 0
                        : selHtml.offsetTop - margin[0];
                }
                break;
            case 39:
                //RIGHT
                if (!selXml && !this.$tempsel)
                    return;

                node = this.$tempsel
                    ? apf.xmldb.getNode(this.$tempsel)
                    : selXml;
                margin = apf.getBox(apf.getStyle(selHtml, "margin"));
                node   = this.getNextTraverseSelected(node, true);
                if (node)
                    this.$setTempSelected (node, ctrlKey, shiftKey);
                else
                    return;

                selHtml = apf.xmldb.findHtmlNode(node, this);
                if (selHtml.offsetTop + selHtml.offsetHeight
                  > oExt.scrollTop + oExt.offsetHeight) {
                    oExt.scrollTop = selHtml.offsetTop
                        - oExt.offsetHeight + selHtml.offsetHeight
                        + margin[0];
                }
                break;
            case 40:
                //DOWN
                if (!selXml && !this.$tempsel)
                    return;

                node = this.$tempsel
                    ? apf.xmldb.getNode(this.$tempsel)
                    : selXml;

                margin    = apf.getBox(apf.getStyle(selHtml, "margin"));
                hasScroll = oExt.scrollHeight > oExt.offsetHeight;
                items     = selHtml.offsetWidth
                    ? Math.floor((oExt.offsetWidth
                        - (hasScroll ? 15 : 0)) / (selHtml.offsetWidth
                        + margin[1] + margin[3]))
                    : 1;

                node      = this.getNextTraverseSelected(node, true, items);
                if (node)
                    this.$setTempSelected (node, ctrlKey, shiftKey);
                else
                    return;

                selHtml = apf.xmldb.findHtmlNode(node, this);
                if (selHtml.offsetTop + selHtml.offsetHeight
                  > oExt.scrollTop + oExt.offsetHeight) { // - (hasScroll ? 10 : 0)
                    oExt.scrollTop = selHtml.offsetTop
                        - oExt.offsetHeight + selHtml.offsetHeight
                        + margin[0]; //+ (hasScroll ? 10 : 0)
                }
                break;
            case 33:
                //PGUP
                if (!selXml && !this.$tempsel)
                    return;

                node = this.$tempsel
                    ? apf.xmldb.getNode(this.$tempsel)
                    : selXml;

                margin     = apf.getBox(apf.getStyle(selHtml, "margin"));
                hasScrollY = oExt.scrollHeight > oExt.offsetHeight;
                hasScrollX = oExt.scrollWidth > oExt.offsetWidth;
                items      = Math.floor((oExt.offsetWidth
                    - (hasScrollY ? 15 : 0)) / (selHtml.offsetWidth
                    + margin[1] + margin[3]));
                lines      = Math.floor((oExt.offsetHeight
                    - (hasScrollX ? 15 : 0)) / (selHtml.offsetHeight
                    + margin[0] + margin[2]));

                node       = this.getNextTraverseSelected(node, false, items * lines);
                if (!node)
                    node = this.getFirstTraverseNode();
                if (node)
                    this.$setTempSelected (node, ctrlKey, shiftKey, true);
                else
                    return;

                selHtml = apf.xmldb.findHtmlNode(node, this);
                if (selHtml.offsetTop < oExt.scrollTop) {
                    oExt.scrollTop = Array.prototype.indexOf.call(this.getTraverseNodes(), node) < items
                        ? 0
                        : selHtml.offsetTop - margin[0];
                }
                break;
            case 34:
                //PGDN
                if (!selXml && !this.$tempsel)
                    return;

                node = this.$tempsel
                    ? apf.xmldb.getNode(this.$tempsel)
                    : selXml;

                margin     = apf.getBox(apf.getStyle(selHtml, "margin"));
                hasScrollY = oExt.scrollHeight > oExt.offsetHeight;
                hasScrollX = oExt.scrollWidth > oExt.offsetWidth;
                items      = Math.floor((oExt.offsetWidth - (hasScrollY ? 15 : 0))
                    / (selHtml.offsetWidth + margin[1] + margin[3]));
                lines      = Math.floor((oExt.offsetHeight - (hasScrollX ? 15 : 0))
                    / (selHtml.offsetHeight + margin[0] + margin[2]));

                node       = this.getNextTraverseSelected(selXml, true, items * lines);
                if (!node)
                    node = this.getLastTraverseNode();
                if (node)
                    this.$setTempSelected (node, ctrlKey, shiftKey);
                else
                    return;

                selHtml = apf.xmldb.findHtmlNode(node, this);
                if (selHtml.offsetTop + selHtml.offsetHeight
                  > oExt.scrollTop + oExt.offsetHeight) { // - (hasScrollY ? 10 : 0)
                    oExt.scrollTop = selHtml.offsetTop
                        - oExt.offsetHeight + selHtml.offsetHeight
                        + margin[0]; //+ 10 + (hasScrollY ? 10 : 0)
                }
                break;

            default:
                if (key == 65 && ctrlKey) {
                    this.selectAll();
                }
                else if (this.$hasBindRule("caption")) {
                    if (!this.xmlRoot || this.autorename) return;

                    //this should move to a onkeypress based function
                    if (!this.lookup || new Date().getTime()
                      - this.lookup.date.getTime() > 300) {
                        this.lookup = {
                            str  : "",
                            date : new Date()
                        };
                    }

                    this.lookup.str += String.fromCharCode(key);

                    var nodes = this.getTraverseNodes(); //@todo start at current indicator
                    for (var v, i = 0; i < nodes.length; i++) {
                        v = this.$applyBindRule("caption", nodes[i]);
                        if (v && v.substr(0, this.lookup.str.length)
                          .toUpperCase() == this.lookup.str) {

                            if (!this.isSelected(nodes[i])) {
                                if (this.mode == "check")
                                    this.setCaret(nodes[i]);
                                else
                                    this.select(nodes[i]);
                            }

                            if (selHtml) {
                                this.$int.scrollTop = selHtml.offsetTop
                                    - (this.$int.offsetHeight
                                    - selHtml.offsetHeight) / 2;
                            }
                            return;
                        }
                    }
                    return;
                }
                break;
        }

        this.lookup = null;
        return false;
    };

    

    /**** Private databinding functions ****/

    this.$deInitNode   = function(xmlNode, htmlNode){
        if (!htmlNode) return;

        //Remove htmlNodes from tree
        htmlNode.parentNode.removeChild(htmlNode);
    };

    this.$updateNode   = function(xmlNode, htmlNode, noModifier){
        //Update Identity (Look)
        var elIcon = this.$getLayoutNode("item", "icon", htmlNode);

        if (elIcon) {
            if (elIcon.nodeType == 1) {
                elIcon.style.backgroundImage = "url(" + 
                  apf.getAbsolutePath(this.iconPath,
                      this.$applyBindRule("icon", xmlNode)) + ")";
            }
            else {
                elIcon.nodeValue = apf.getAbsolutePath(this.iconPath,
                    this.$applyBindRule("icon", xmlNode));
            }
        }
        else {
            //.style.backgroundImage = "url(" + this.$applyBindRule("image", xmlNode) + ")";
            var elImage = this.$getLayoutNode("item", "image", htmlNode);
            if (elImage) {
                if (elImage.nodeType == 1) {
                    elImage.style.backgroundImage = "url(" + 
                        apf.getAbsolutePath(apf.hostPath,
                            this.$applyBindRule("image", xmlNode)) + ")";
                }
                else {
                    elImage.nodeValue = apf.getAbsolutePath(apf.hostPath, 
                        this.$applyBindRule("image", xmlNode));
                }
            }
        }

        //this.$getLayoutNode("item", "caption", htmlNode).nodeValue = this.$applyBindRule("Caption", xmlNode);
        var elCaption = this.$getLayoutNode("item", "caption", htmlNode);
        if (elCaption) {
            if (elCaption.nodeType == 1)
                elCaption.innerHTML = this.$applyBindRule("caption", xmlNode);
            else
                elCaption.nodeValue = this.$applyBindRule("caption", xmlNode);
        }

        htmlNode.title = this.$applyBindRule("title", xmlNode) || "";

        
        var cssClass = this.$applyBindRule("css", xmlNode);

        if (cssClass || this.dynCssClasses.length) {
            this.$setStyleClass(htmlNode, cssClass, this.dynCssClasses);
            if (cssClass && !this.dynCssClasses.contains(cssClass)) {
                this.dynCssClasses.push(cssClass);
            }
        }
        

        if (!noModifier && this.$updateModifier)
            this.$updateModifier(xmlNode, htmlNode);
    };

    this.$moveNode = function(xmlNode, htmlNode){
        if (!htmlNode) return;

        var oPHtmlNode = htmlNode.parentNode;
        var nNode      = this.getNextTraverse(xmlNode);
        var beforeNode = nNode
            ? apf.xmldb.findHtmlNode(nNode, this)
            : null;

        oPHtmlNode.insertBefore(htmlNode, beforeNode);
        //if(this.emptyMessage && !oPHtmlNode.childNodes.length) this.setEmpty(oPHtmlNode);
    };

    this.$add = function(xmlNode, Lid, xmlParentNode, htmlParentNode, beforeNode){
        //Build Row
        this.$getNewContext("item");
        var oItem      = this.$getLayoutNode("item"),
            elSelect   = this.$getLayoutNode("item", "select"),
            elIcon     = this.$getLayoutNode("item", "icon"),
            elImage    = this.$getLayoutNode("item", "image"),
            //elCheckbox = this.$getLayoutNode("item", "checkbox"), // NOT USED
            elCaption  = this.$getLayoutNode("item", "caption");

        oItem.setAttribute("id", Lid);

        elSelect.setAttribute("onmouseover",   "apf.setStyleClass(this, 'hover');");
        elSelect.setAttribute("onselectstart", "return false;");
        elSelect.setAttribute("style",         (elSelect.getAttribute("style") || "") + ";user-select:none;-moz-user-select:none;-webkit-user-select:none;");

        if (this.hasFeature(apf.__RENAME__) || this.hasFeature(apf.__DRAGDROP__)) {
            elSelect.setAttribute("ondblclick", "var o = apf.lookup(" + this.$uniqueId + "); " +
                
                "o.stopRename();" +
                
                " o.choose()");
            elSelect.setAttribute("onmouseout", "apf.setStyleClass(this, '', ['hover']);\
                this.hasPassedDown = false;");
            elSelect.setAttribute(this.itemSelectEvent || "onmousedown",
                'var o = apf.lookup(' + this.$uniqueId + ');\
                 var xmlNode = apf.xmldb.findXmlNode(this);\
                 var isSelected = o.isSelected(xmlNode);\
                 this.hasPassedDown = true;\
                 if (!o.renaming && o.hasFocus() && isSelected == 1) \
                    this.dorename = true;\
                 if (!o.hasFeature(apf.__DRAGDROP__) || o.mode != "normal" || !isSelected && !event.ctrlKey)\
                     o.select(this, event.ctrlKey, event.shiftKey)');
            elSelect.setAttribute("onmouseup", 'if (!this.hasPassedDown) return;\
                var o = apf.lookup(' + this.$uniqueId + ');' +
                
                'if (o.hasFeature(apf.__RENAME__) && this.dorename && o.mode == "normal")\
                    o.startDelayedRename(event);' +
                
                'this.dorename = false;\
                 var xmlNode = apf.xmldb.findXmlNode(this);\
                 var isSelected = o.isSelected(xmlNode);\
                 if (o.mode == "normal" && o.hasFeature(apf.__DRAGDROP__))\
                     o.select(this, event.ctrlKey, event.shiftKey)');
        } //@todo add DRAGDROP ifdefs
        else {
            elSelect.setAttribute("onmouseout",    "apf.setStyleClass(this, '', ['hover']);");
            elSelect.setAttribute("ondblclick", 'var o = apf.lookup('
                + this.$uniqueId + '); o.choose()');
            elSelect.setAttribute(this.itemSelectEvent
                || "onmousedown", 'var o = apf.lookup(' + this.$uniqueId
                + '); o.select(this, event.ctrlKey, event.shiftKey)');
        }

        //Setup Nodes Identity (Look)
        if (elIcon) {
            if (elIcon.nodeType == 1) {
                elIcon.setAttribute("style", "background-image:url("
                    + apf.getAbsolutePath(this.iconPath, this.$applyBindRule("icon", xmlNode))
                    + ")");
            }
            else {
                elIcon.nodeValue = apf.getAbsolutePath(this.iconPath,
                    this.$applyBindRule("icon", xmlNode));
            }
        }
        else if (elImage) {
            if (elImage.nodeType == 1)
                elImage.setAttribute("style", "background-image:url("
                    + apf.getAbsolutePath(apf.hostPath, this.$applyBindRule("image", xmlNode))
                    + ")");
            else {
                if (apf.isSafariOld) { //@todo this should be changed... blrgh..
                    var p   = elImage.ownerElement.parentNode,
                        img = p.appendChild(p.ownerDocument.createElement("img"));
                    img.setAttribute("src", 
                        apf.getAbsolutePath(apf.hostPath, this.$applyBindRule("image", xmlNode)));
                }
                else {
                    elImage.nodeValue = 
                        apf.getAbsolutePath(apf.hostPath, this.$applyBindRule("image", xmlNode));
                }
            }
        }

        if (elCaption) {
            apf.setNodeValue(elCaption,
                this.$applyBindRule("caption", xmlNode));
        }
        oItem.setAttribute("title", this.$applyBindRule("tooltip", xmlNode) || "");

        
        var cssClass = this.$applyBindRule("css", xmlNode);
        if (cssClass) {
            this.$setStyleClass(oItem, cssClass);
            if (cssClass)
                this.dynCssClasses.push(cssClass);
        }
        

        if (this.$addModifier)
            this.$addModifier(xmlNode, oItem);

        if (htmlParentNode)
            apf.insertHtmlNode(oItem, htmlParentNode, beforeNode);
        else
            this.listNodes.push(oItem);
    };

    this.$fill = function(){
        if (this.more && !this.moreItem) {
            this.$getNewContext("item");
            var Item      = this.$getLayoutNode("item"),
                elCaption = this.$getLayoutNode("item", "caption"),
                elSelect  = this.$getLayoutNode("item", "select");

            Item.setAttribute("class", "more");
            elSelect.setAttribute("onmousedown", 'var o = apf.lookup(' + this.$uniqueId
                + ');o.clearSelection();o.$setStyleClass(this, "more_down");');
            elSelect.setAttribute("onmouseout", 'apf.lookup(' + this.$uniqueId
                + ').$setStyleClass(this, "", ["more_down"]);');
            elSelect.setAttribute("onmouseup", 'apf.lookup(' + this.$uniqueId
                + ').startMore(this)');

            if (elCaption)
                apf.setNodeValue(elCaption,
                    this.more.match(/caption:(.*)(;|$)/i)[1]);
            this.listNodes.push(Item);
        }

        apf.insertHtmlNodes(this.listNodes, this.$int);
        this.listNodes.length = 0;

        if (this.more && !this.moreItem)
            this.moreItem = this.$int.lastChild;
    };

    /**
     * Adds a new item to the list and lets the users type in the new name.
     * This functionality is especially useful in the interface when
     * {@link element.list.attribute.mode} is set to check or radio. For instance in a form.
     * @see element.list.attribute.more
     */
    this.startMore = function(o){
        this.$setStyleClass(o, "", ["more_down"]);

        var xmlNode;
        if (!this.$actions["add"]) {
            if (this.each && !this.each.match(/[\/\[]/)) {
                xmlNode = "<" + this.each + (this.each.match(/^a:/) 
                    ? " xmlns:a='" + apf.ns.aml + "'" 
                    : "") + " custom='1' />";
            }
            else {
                
                throw new Error(apf.formatErrorString(0, this,
                    "Could not start more",
                    "No add action rule is defined for this component",
                    this.$aml));
                
                return false;
            }
        }

        this.add(xmlNode, null, null, function(addedNode){
            this.select(addedNode, null, null, null, null, true);
            this.$int.appendChild(this.moreItem);
    
            var undoLastAction = function(){
                this.getActionTracker().undo(this.autoselect ? 2 : 1);
    
                this.removeEventListener("stoprename", undoLastAction);
                this.removeEventListener("beforerename", removeSetRenameEvent);
                this.removeEventListener("afterrename",  afterRename);
            }
            var afterRename = function(){
                //this.select(addedNode);
                this.removeEventListener("afterrename",  afterRename);
            };
            var removeSetRenameEvent = function(e){
                this.removeEventListener("stoprename", undoLastAction);
                this.removeEventListener("beforerename", removeSetRenameEvent);
    
                //There is already a choice with the same value
                var xmlNode = this.findXmlNodeByValue(e.args[1]);
                if (xmlNode || !e.args[1]) {
                    if (e.args[1] && this.dispatchEvent("notunique", {
                        value : e.args[1]
                    }) === false) {
                        this.startRename();
                        
                        this.addEventListener("stoprename",   undoLastAction);
                        this.addEventListener("beforerename", removeSetRenameEvent);
                    }
                    else {
                        this.removeEventListener("afterrename", afterRename);
                        
                        this.getActionTracker().undo();//this.autoselect ? 2 : 1);
                        if (!this.isSelected(xmlNode))
                            this.select(xmlNode);
                    }
                    
                    return false;
                }
            };
    
            this.addEventListener("stoprename",   undoLastAction);
            this.addEventListener("beforerename", removeSetRenameEvent);
            this.addEventListener("afterrename",  afterRename);
    
            /*if (this.mode == "radio") {
                this.moreItem.style.display = "none";
                if (lastAddedMore)
                    this.removeEventListener("xmlupdate", lastAddedMore);
    
                lastAddedMore = function(){
                    this.moreItem.style.display = addedNode.parentNode
                        ? "none"
                        : "block";
                };
                this.addEventListener("xmlupdate", lastAddedMore);
            }*/
    
          
            
            this.startDelayedRename({}, 1);
            
        });
    };

    /**** Selection ****/

    this.$calcSelectRange = function(xmlStartNode, xmlEndNode){
        var r = [],
            nodes = this.hasFeature(apf.__VIRTUALVIEWPORT__)
                ? this.xmlRoot.selectNodes(this.each)
                : this.getTraverseNodes(),
            f, i;
        for (f = false, i = 0; i < nodes.length; i++) {
            if (nodes[i] == xmlStartNode)
                f = true;
            if (f)
                r.push(nodes[i]);
            if (nodes[i] == xmlEndNode)
                f = false;
        }

        if (!r.length || f) {
            r = [];
            for (f = false, i = nodes.length - 1; i >= 0; i--) {
                if (nodes[i] == xmlStartNode)
                    f = true;
                if (f)
                    r.push(nodes[i]);
                if (nodes[i] == xmlEndNode)
                    f = false;
            }
        }

        return r;
    };

    this.$selectDefault = function(XMLRoot){
        this.select(this.getTraverseNodes()[0], null, null, null, true);
    };

    /**
     * Generates a list of items based on a string.
     * @param {String} str the description of the items. Items are seperated by a comma (,). Ranges are specified by a start and end value seperated by a dash (-).
     * Example:
     * This example loads a list with items starting at 1980 and ending at 2050.
     * <code>
     *  lst.loadFillData("1980-2050");
     *  lst.loadFillData("red,green,blue,white");
     *  lst.loadFillData("None,100-110,1000-1100");
     *  lst.loadFillData("1-10"); // 1 2 3 4 etc
     *  lst.loadFillData("01-10"); //01, 02, 03, 04, etc
     * </code>
     */
    this.loadFillData = function(str){
        var len, start, end, parts = str.splitSafe(","), data = [];
        
        for (var p, part, i = 0; i < parts.length; i++) {
            if ((part = parts[i]).match(/^\d+-\d+$/)) {
                p     = part.split("-");
                start = parseInt(p[0]);
                end   = parseInt(p[1]);
                
                if (p[0].length == p[1].length) {
                    len = Math.max(p[0].length, p[1].length);
                    for (var j = start; j < end + 1; j++) {
                        data.push("<item>" + (j + "").pad(len, "0") + "</item>");
                    }
                }
                else {
                    for (var j = start; j < end + 1; j++) {
                        data.push("<item>" + j + "</item>");
                    }
                }
            }
            else {
                data.push("<item>" + part + "</item>");
            }
        }
        
        //@todo this is all an ugly hack (copied from item.js line 486)
        //this.$preventDataLoad = true;//@todo apf3.0 add remove for this
        
        this.$initingModel = true;
        
        this.each = "item";
        this.$setDynamicProperty("caption", "[label/text()|@caption|text()]");
        this.$setDynamicProperty("eachvalue", "[value/text()|@value|text()]");
        this.$canLoadDataAttr = false;

        this.load("<data>" + data.join("") + "</data>");
    };

}).call(apf.BaseList.prototype = new apf.MultiSelect());





/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/virtualviewport.js)SIZE(28672)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__VIRTUALVIEWPORT__ = 1 << 19;




/**
 * All elements inheriting from this {@link term.baseclass baseclass} can have a virtual viewport.
 *
 * @experimental This code has never been run. 
 * @constructor
 * @baseclass
 * @private
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com) & Mike de Boer
 * @version     %I%, %G%
 * @since       1.0
 */
apf.VirtualViewport = function(){
    this.$init(true);

    this.$regbase = this.$regbase | apf.__VIRTUALVIEWPORT__;

    this.virtualVTimer = null;
    this._xmlUpdate    = this.$xmlUpdate;
    
    apf.setStyleClass(this.$ext, "virtual");
    
    this.$deInitNode = function(xmlNode, htmlNode){
        /*  
            Not the htmlNode is deleted, but the viewport is rerendered from this node on. 
            If viewport is too high either the render starting point is adjusted and
            a complete rerender is requested, or the last empty elements are hidden
        */
        this.viewport.redraw();//very unoptimized
    };
    
    this.$moveNode = function(xmlNode, htmlNode){
        /*
            Do a remove when removed from current viewport
            Do an add when moved to current viewport
            Do a redraw from the first of either when both in viewport
        */
        this.viewport.redraw();//very unoptimized
    };
    
    this.emptyNode = apf.xmldb.getXml("<empty />");
    this.$addEmpty = this.$add;
    this.$add = function(xmlNode, Lid, xmlParentNode, htmlParentNode, beforeNode){
        //find new slot
        var htmlNode = this.$pHtmlDoc.getElementById(Lid);
        
        if(!htmlNode)
            return;
        
        //execute update
        this.$updateNode(xmlNode, htmlNode);//, noModifier);
    };

    this.$fill = function(){
        
    };
    
    this.addEventListener("$load", function(){
        if (!this.viewport.limit)
            this.viewport.limit = 1;
    });
    
    this.clear = function(nomsg, do_event){
        if (this.clearSelection)
            this.clearSelection(!do_event);

        this.documentId = this.xmlRoot = this.cacheId = null;

        if (!nomsg) {
            this.viewport.offset = 0;
            this.viewport.length = 0;
            this.viewport.resize(0);
            this.viewport.sb.update();
    
            this.$setClearMessage(this["empty-message"]);
        }
        else if(this.$removeClearMessage)
           this.$removeClearMessage();
        
        this.viewport.cache = null;
    };

    var _self = this;
    this.viewport = {
        offset : 0,
        limit  : 2,
        length : 0,
        sb     : new apf.scrollbar(),
        host   : this,
        cache  : null,
        
        inited : false,
        draw : function(){
            this.inited = true;
            var limit = this.limit; this.limit = 0;
            this.resize(limit, true);
        },
        
        redraw : function(){
            this.change(this.offset);
        },
        
        // set id's of xml to the viewport
        prepare : function(){
            if (!this.inited)
                this.draw();
            
            var nodes = _self.getTraverseNodes();
            if (!nodes)
                return;
            
            var docId  = apf.xmldb.getXmlDocId(_self.xmlRoot),
                hNodes = _self.$int.childNodes;
            for (var j = 0, i = 0, l = hNodes.length; i < l; i++) {
                if (hNodes[i].nodeType != 1) continue;
                
                hNodes[i].style.display = (j >= nodes.length) ? "none" : "block"; //Will ruin tables & lists
                
                apf.xmldb.nodeConnect(docId, nodes[j], hNodes[i], _self);
                j++;
            }
        },
        
        /**
         * @note This function only supports single dimension items (also no grid, like thumbnails)
         */
        resize : function(limit, updateScrollbar){
            this.cache = null;

            var i;
            //Viewport shrinks
            if (limit < this.limit) {
                var nodes = _self.$int.childNodes;
                for (i = nodes.length - 1; i >= 0; i--) {
                    if (nodes[i].nodeType != 1) continue;
                    _self.$int.removeChild(nodes[i]);
                    if (--this.limit == limit) break;
                }
            }
            //Viewport grows
            else if (limit > this.limit) {
                for (i = this.limit; i < limit; i++) {
                    _self.$addEmpty(_self.emptyNode, "", _self.xmlRoot, _self.$int);
                }
            }
            else
                return;
            
            this.limit = limit;
            
            if (updateScrollbar)
                this.sb.update(this.$int);
        },
        
        findNewLimit : function(scrollTop){
            var oHtml = _self.$int;
            
            if (!scrollTop)
                scrollTop = oHtml.scrollTop;

            if (!_self.xmlRoot || oHtml.lastChild && oHtml.lastChild.style.display == "none")
                return;

            //Grow
            if (!oHtml.lastChild || oHtml.lastChild.offsetTop + oHtml.lastChild.offsetHeight <= oHtml.offsetHeight + scrollTop) {
                var Lid, xmlNode, nodes, sel = _self.$getSelection();
                while (this.limit < this.length - 1 && (!oHtml.lastChild || oHtml.lastChild.offsetTop + oHtml.lastChild.offsetHeight <= oHtml.offsetHeight + scrollTop)) {
                    this.limit++;

                    nodes = _self.getTraverseNodes();
                    if (nodes.length < this.limit) {
                        this.limit = nodes.length;
                        break;
                    }

                    xmlNode = nodes[nodes.length - 1];
                    Lid = apf.xmldb.nodeConnect(_self.documentId, xmlNode, null, _self);
                    _self.$addEmpty(xmlNode, Lid, _self.xmlRoot, oHtml);
                    if (sel.indexOf(xmlNode) > -1)
                        _self.$select(oHtml.lastChild);
                    else
                        _self.$deselect(oHtml.lastChild);
                }
            }
            //Shrink
            else if (oHtml.lastChild && oHtml.lastChild.offsetTop > oHtml.offsetHeight + scrollTop) {
                var lastChild;
                while (this.limit > 2 && (lastChild = oHtml.lastChild).offsetTop > oHtml.offsetHeight + scrollTop) {
                    _self.$int.removeChild(lastChild);
                    this.limit--;
                }
            }
            
            if (!this.initialLimit)
                this.initialLimit = this.limit;
        },
        
        /**
         *  @todo   This method should be optimized by checking if there is
         *          overlap between the new offset and the old one
         */
        change : function(offset, limit, updateScrollbar, noScroll){
            var offsetN;
            
            if (offset < 0) 
                offset = 0;
            
            if (offset > this.length - this.limit - 1) 
                offsetN = Math.floor(this.length - this.limit - 1);
            else 
                offsetN = Math.floor(offset);
                
            if (!limit)
                limit = this.limit;
            
            //var offsetN = Math.floor(offset);

            this.cache   = null;
            var diff     = offsetN - this.offset,
                oldLimit = this.limit;
            if (diff * diff >= this.limit*this.limit) //there is no overlap
                diff = false;
            this.offset = offsetN;
            
            if (diff > 0) { //get last node before resize
                var lastNode = _self.$int.lastChild;
                if (lastNode.nodeType != 1)
                    lastNode = lastNode.previousSibling;
            }
            
            /*if (limit && this.limit != limit)
                this.resize(limit, updateScrollbar);
            else */
            if (updateScrollbar) {
                this.sb.$curValue = this.offset / (this.length - this.limit - 1);
                this.sb.updatePos();
            }

            //this.viewport.prepare();

            //Traverse through XMLTree
            //var nodes = this.$addNodes(this.xmlRoot, this.$int, null, this.renderRoot);
            var nodes = _self.getTraverseNodes();
            if (!nodes)
                return;
                
            if (nodes.length < this.limit) {
                if (offset > 0)
                    alert("shouldnt get here");
                else
                    this.resize(nodes.length);
            }

            var docId  = apf.xmldb.getXmlDocId(_self.xmlRoot),
                hNodes = _self.$int.childNodes,
                xmlNode, htmlNode, xmlPos, sel, len, j, i;

            //remove nodes from the beginning
            if (diff > 0) {
                xmlPos = oldLimit - diff;
                len    = hNodes.length,
                sel    = _self.$getSelection();
                for (j = 0, i = 0; j < diff && i < len; i++) {
                    htmlNode = _self.$int.firstChild;
                    if (htmlNode.nodeType == 1) {
                        j++;
                        xmlNode = nodes[xmlPos++];
                        if (xmlNode) {
                            apf.xmldb.nodeConnect(docId, xmlNode, htmlNode, _self);
                            _self.$updateNode(xmlNode, htmlNode);//, noModifier);
                            if (sel.indexOf(xmlNode) > -1)
                                _self.$select(htmlNode);
                            else
                                _self.$deselect(htmlNode);
                            htmlNode.style.display = "block";
                        }
                        else {
                            htmlNode.style.display = "none";
                        }
                    }
                    
                    _self.$int.appendChild(htmlNode);
                }
                
                //var lastNode = nodes[oldLimit - diff - 1]
            }
            //remove nodes from the end
            else if (diff < 0) {
                diff = diff * -1;
                xmlPos = 0; //should be adjusted for changing limit
                sel    = _self.$getSelection();
                for (j = 0, i = hNodes.length-1; j < diff && i >= 0; i++) {
                    htmlNode = _self.$int.lastChild;
                    if (htmlNode.nodeType == 1) {
                        j++;
                        xmlNode = nodes[xmlPos++];
                        apf.xmldb.nodeConnect(docId, xmlNode, htmlNode, _self);
                        _self.$updateNode(xmlNode, htmlNode);//, noModifier);
                        if (sel.indexOf(xmlNode) > -1)
                            _self.$select(htmlNode);
                        else
                            _self.$deselect(htmlNode);
                        htmlNode.style.display = "block";
                    }
                    
                    _self.$int.insertBefore(htmlNode, _self.$int.firstChild);
                }
            }
            //Recalc all nodes
            else if (diff === false){
                len = hNodes.length; 
                sel = _self.$getSelection();
                for (j = 0, i = 0; i < len; i++) {
                    htmlNode = hNodes[i];
                    if (htmlNode.nodeType == 1) {
                        xmlNode = nodes[j++];
                        apf.xmldb.nodeConnect(docId, xmlNode, htmlNode, _self);
                        _self.$updateNode(xmlNode, htmlNode);//, noModifier);
                        if (sel.indexOf(xmlNode) > -1)
                            _self.$select(htmlNode);
                        else
                            _self.$deselect(htmlNode);
                    }
                }
            }

            if (!noScroll) {
                if (offset >= this.length - this.initialLimit) {
                    diff = offset - (this.length - this.initialLimit) + 2;
                    _self.$int.scrollTop = (_self.$int.scrollHeight - _self.$int.offsetHeight) * (diff / 2);
                }
                else {
                    var scrollTop = (offset % 1) * _self.$int.firstChild.offsetHeight;//(diff/limit) * _self.$int.offsetHeight;
                    this.findNewLimit(scrollTop);
                    _self.$int.scrollTop = scrollTop;
                }
                
                if (updateScrollbar)
                    this.sb.update();
                
                return;
            }
        
            //Build HTML
            //_self.$fill(nodes);
            
            /*if (_self.$selected) {
                _self.$deselect(_self.$selected);
                _self.$selected = null;
            }
            
            if (_self.selected && _self.$isInViewport(_self.selected))
                _self.select(_self.selected);*/
        }
    };
    
    this.viewport.sb.parentNode = new apf.Class().$init();
    this.viewport.sb.parentNode.$int = this.$pHtmlNode;
    this.viewport.sb.dispatchEvent("DOMNodeInsertedIntoDocument");
    
    //this.$int.style.paddingLeft = this.viewport.sb.$ext.offsetWidth + "px";
    
    //this.viewport.sb.realtime = false;//!apf.isIE;
    this.viewport.sb.attach(this.$int, this.viewport, function(timed, pos){
        var vp = _self.viewport;
        
        if (vp.sb.realtime || !timed) {
            var l = vp.length - vp.initialLimit;
            if (l == 0)
                _self.$int.scrollTop = pos * (_self.$int.scrollHeight - _self.$int.offsetHeight);
            else 
                vp.change(l * pos, vp.limit, false);
        }
        else {
            clearTimeout(this.virtualVTimer);
            this.virtualVTimer = $setTimeout(function(){
                vp.change(Math.round((vp.length - vp.initialLimit) * pos), vp.limit, false);
            }, 300);
        }
    });
    
    /* @todo
     * - Fix bug in optimization
     * - Fix flickering with larger viewport
     * - Get templates to work
     * - Firefox has problems with the scrollbar
     * / Fix scrolling of items bigger than viewport (limit is too tight sometimes)
     * - Improve pgup/pgdown
     * - Fix multigrid lists (thumbnail)
     * - Fix FF html conversion (insertHtmlNodes)
     * - Optimize grow function to use fill
     */
    
    apf.layout.setRules(this.$int, "scrollbar", "\
        var s = apf.all[" + this.viewport.sb.$uniqueId + "];\
        s.update();\
    ", true);
    apf.layout.queue(this.$int);
    
    this.$isInViewport = function(xmlNode, struct){
        /*var marker = xmlNode.selectSingleNode("preceding-sibling::a_marker");
        var start = marker ? marker.getAttribute("end") : 0;
        
        if(!struct && this.viewport.offset + this.viewport.limit < start + 1)
            return false;
        
        var position = start;
        var nodes = (marker || xmlNode).selectNodes("following-sibling::"
              + this.each.split("|").join("following-sibling::"));
        
        for (var i = 0; i < nodes.length; i++) {
            ++position;
            if (nodes[i] == xmlNode)
                break;
        }
        
        if(struct) struct.position = position;
        
        if(this.viewport.offset > position 
          || this.viewport.offset + this.viewport.limit < position)
            return false;
        
        return true;*/
        var nodes = this.getTraverseNodes();
        for (var i = 0, l = nodes.length; i < l; i++){
            if (nodes[i] == xmlNode)
                return true;
        }
        
        return false;
    };
    
    this.scrollTo = function(xmlNode, last){
        var sPos = {};
        this.$isInViewport(xmlNode, sPos);
        this.viewport.change(sPos.position + (last ? this.viewport.limit - 1 : 0));
    };
    
    /**
     * @todo this one should be optimized
     */
    this.getFirstTraverseNode = function(xmlNode){
        return this.getTraverseNodes(xmlNode)[0];
    };
    
    /**
     * @private
     */
    this.$clearVirtualDataset = function(parentNode){
        var nodes = parentNode.childNodes;
        for (var i = nodes.length - 1; i >= 0; i--)
            parentNode.removeChild(nodes[i]);
    };

    /**
     * @private
     */
    this.$createVirtualDataset = function(xmlNode, length, docId) {
        var marker = xmlNode.selectSingleNode("a_marker") 
          || xmlNode.appendChild(xmlNode.ownerDocument.createElement("a_marker"));
        marker.setAttribute("start", "0");

        if (length) {
            marker.setAttribute("end",   length);
            marker.setAttribute("reserved", ++this.nodeCount[docId]);
            this.nodeCount[docId] += length;
        }
    };
    
    this.$xmlUpdate = function(){
        this.viewport.cache  = null;
        this.viewport.length = this.xmlRoot.selectNodes(this.each).length; //@todo fix this for virtual length
        this.viewport.sb.update(this.$int);
        this._xmlUpdate.apply(this, arguments);
    };
    
    this.$load = function(XMLRoot){
        //Add listener to XMLRoot Node
        apf.xmldb.addNodeListener(XMLRoot, this);

        //Reserve here a set of nodeConnect id's and add them to our initial marker
        //Init virtual dataset here
        
        if (!this.renderRoot && !this.getTraverseNodes(XMLRoot).length)
            return this.clear("loading");
        
        //Initialize virtual dataset if load rule exists
        if (this.$hasBindRule("load"))
            this.$createVirtualDataset(XMLRoot);
        
        //Prepare viewport
        this.viewport.cache  = null;
        this.viewport.length = this.xmlRoot.selectNodes(this.each).length + 1; //@todo fix this for virtual length
        this.viewport.prepare();
        
        //Traverse through XMLTree
        var nodes = this.$addNodes(XMLRoot, null, null, this.renderRoot);
        
        this.viewport.sb.update(this.$int);

        //Build HTML
        //this.$fill(nodes);

        //Select First Child
        if (this.selectable) {
            if (this.autoselect) {
                if (nodes.length)
                    this.$selectDefault(XMLRoot);
                
                else
                    this.setProperty("selected", null); //@todo review this
                
            }
            else {
                this.clearSelection(true);
                var xmlNode = this.getFirstTraverseNode(); //should this be moved to the clearSelection function?
                if (xmlNode)
                    this.setCaret(xmlNode);
                
                this.setProperty("selected", null); //@todo review this
                this.setProperty("chosen", null);
                
            }
        }

        if (this.$focussable)
            apf.window.hasFocus(this) ? this.$focus() : this.$blur();
    };
    
    this.$loadSubData = function(){}; //We use the same process for subloading, it shouldn't be done twice
    
    /**
     * @example <a:load get="call:getCategory(start, length, ascending)" total="@total" />
     */
    this.$loadPartialData = function(marker, start, length){
        //We should have a queing system here, disabled the check for now
        //if (this.$hasLoadStatus(xmlRootNode)) return;
        
        var loadNode, rule = this.$getBindRule("load", xmlRootNode);
        if (rule && (!rule[1] || rule[1](xmlRootNode))) {
            this.$setLoadStatus(xmlRootNode, "loading");
            
            var mdl = this.getModel(true);
            
            if (!mdl)
                throw new Error("Could not find model");
            
            if (!rule.getAttribute("total")) {
                throw new Error(apf.formatErrorString(this, "Loading data", "Error in load rule. Missing total xpath. Expecting <a:load total='xpath' />"))                
            }
            

            mdl.$insertFrom(rule.getAttribute("get"), {
                
                ascending  : this.$sort ? this.$sort.get().ascending : true,
                
                xmlNode     : loadNode,
                documentId  : this.documentId, //or should xmldb find this itself
                marker      : marker,
                start       : start,
                length      : length,
                insertPoint : this.xmlRoot, 
                amlNode     : this,
                callback    : function(xmlNode){
                    
                    _self.setProperty("root", _self.xmlRoot);
                    
                    
                    var length = parseInt(apf.queryValue(xmlNode, 
                        rule.getAttribute("total")));
                    
                    if (_self.viewport.length != length) {
                        _self.viewport.length = length;
                        
                        this.$createVirtualDataset(_self.xmlRoot, 
                            _self.viewport.length, _self.documentId);
                    }
                }
            });
        }
    };
    
    //Consider moving these functions to the xmldatabase selectByXpath(xpath, from, length);
    function fillList(len, list, from){
        for (var i = 0; i < len; i++) 
            list.push(_self.documentId + "|" + (from+i));
    }
    
    function buildList(markers, markerId, distance, xml) {
        var marker, nodes, start,
            vlen = this.viewport.limit,
            list = [];
        
        //Count from 0
        if (markerId == -1) {
            nodes    = xml.selectNodes(_self.each);
            start    = 0;
            marker   = markers[0];
        }
        else {
            //Count back from end of marker
            if (distance < 0) {
                fillList(Math.abs(distance), list, 
                    parseInt(marker.getAttribute("reserved")) + parseInt(marker.getAttribute("end"))
                    - parseInt(marker.getAttribute("start")) + distance);
                
                distance = 0;
                _self.$loadPartialData(marker);
                
                if (list.length == vlen)
                    return list;
            }
            
            nodes  = markers[markerId].selectNodes("following-sibling::"
              + this.each.split("|").join("following-sibling::"));
            start  = markers[markerId].getAttribute("end");
            marker = markers[++markerId];
        }
        
        do {
            //Add found nodes
            var loop = Math.min(marker.getAttribute("start") - start, vlen);//, nodes.length
            for (var i = distance; i < loop; i++)
                list.push(nodes[i]);
            
            if (list.length == vlen)
                break;
            
            //Add empty nodes
            var mlen = parseInt(marker.getAttribute("end")) - parseInt(marker.getAttribute("start"));
            fillList(Math.min(mlen, vlen - list.length), list, parseInt(marker.getAttribute("reserved")));
            
            //Add code here to trigger download of this missing info
            _self.$loadPartialData(marker);
            
            start    = parseInt(marker.getAttribute("end"));
            marker   = markers[++markerId];
            distance = 0;
        } 
        while (list.length < vlen && marker);
        
        _self.viewport.cache = list;
        return list;
    }
    
    /**
     * Retrieves a nodelist containing the {@link term.datanode data nodes} which are rendered by
     * this element (see each nodes, see {@link baseclass.multiselectbinding.binding.each}).
     *
     * @param {XMLElement} [xmlNode] the parent element on which the each query is applied.
     */
    this.getTraverseNodes = function(xmlNode){
        if (!this.xmlRoot)
            return;
        
        if (this.viewport.cache)
            return this.viewport.cache;

        var start = this.viewport.offset + 1,
            end   = start + this.viewport.limit;
        
        //caching statement here

        var markers = (xmlNode || this.xmlRoot).selectNodes("a_marker");

        //Special case for fully loaded virtual dataset
        if (!markers.length) {
            var list = (xmlNode || this.xmlRoot).selectNodes("("
                + this.each + ")[position() >= " + start
                + " and position() < " + (end) + "]");

            
            return this.$sort ? this.$sort.apply(list) : list;
            
        }

        for (var i = 0; i < markers.length; i++) {
            //Looking for marker that (partially) exceeds viewport's current position
            if (markers[i].getAttribute("end") < start) {
                //If this is the last marker, count from here
                if (i == markers.length - 1)
                    return buildList(markers, i, start - markers[i].getAttribute("end"), 
                      (xmlNode || this.xmlRoot));

                continue;
            }
            
            //There is overlap AND begin is IN marker
            if (markers[i].getAttribute("start") - end <= 0 
              && start >= markers[i].getAttribute("start"))
                return buildList(markers, i, start - markers[i].getAttribute("end"), 
                  (xmlNode || this.xmlRoot));

            //Marker is after viewport, there is no overlap
            else if (markers[i-1]) //Lets check the previous marker, if there is one
                return buildList(markers, i-1, start - markers[i-1].getAttribute("end"), 
                  (xmlNode || this.xmlRoot));
                
            //We have to count from the beginning
            else
                return buildList(markers, -1, start, (xmlNode || this.xmlRoot));
        }
    };
    
    var baseNTS = this.getNextTraverseSelected;
    this.getNextTraverseSelected = function(xmlNode, up, count){
        if (!xmlNode)
            xmlNode = this.selected;
        if (!count)
            count = 1;

        var node = baseNTS.call(this, xmlNode, up, count);
        if (node && node != xmlNode)
            return node;

        //@todo treeArch support
        var nodes = this.getTraverseNodes(), i = 0;
        while (nodes[i] && nodes[i] != xmlNode)
            i++;

        if (up)
            i = -1 * (nodes.length - i - 1);

        this.viewport.change(Math.max(0, this.viewport.offset + i
            + (up ? count : -1 * count)), null, true, true);
            
        nodes = this.getTraverseNodes();
        return nodes[up ? nodes.length - 1 : 0];
    };
    
    //@todo keyboard handlers for pgup/pgdown should measure items instead of assuming fixed height
    
    //Init
    this.caching = false; //for now, because the implications are unknown
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/basestatebuttons.js)SIZE(23401)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @constructor
 * @baseclass
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 */
apf.BaseStateButtons = function(){
    this.state   = "normal";
    this.edit    = false;
    this.animate = true;//!apf.hasSingleRszEvent; // experimental
    
    var actions  = {
        "min"   : ["minimized", "minimize", "restore"],
        "max"   : ["maximized", "maximize", "restore"],
        "edit"  : ["edit", "edit", "closeedit"],
        "close" : ["closed", "close", "show"]
    };
    this.$lastheight  = null;
    this.$lastpos     = null;
    this.$lastzindex  = null;

    this.$lastState = {"normal":true};    
    this.$booleanProperties["animate"] = true;
    this.$supportedProperties.push("buttons", "animate", "state");
    
    /**
     * Close the window. It can be reopened by using {@link baseclass.guielement.method.show}
     * Call-chaining is supported.
     * @todo show should unset closed
     */
    this.close = function(){
        this.setProperty("state", this.state.split("|")
            .pushUnique("closed").join("|"), false, true);
        return this;
    };

    /**
     * Minimize the window. The window will become the height of the title of
     * the window.
     * Call-chaining is supported.
     */
    this.minimize = function(){
        this.setProperty("state", this.state.split("|")
            .remove("maximized")
            .remove("normal")
            .pushUnique("minimized").join("|"), false, true);
        return this;
    };

    /**
     * Maximize the window. The window will become the width and height of the
     * browser window.
     * Call-chaining is supported.
     */
    this.maximize = function(){
        this.setProperty("state", this.state.split("|")
            .remove("minimized")
            .remove("normal")
            .pushUnique("maximized").join("|"), false, true);
        return this;
    };

    /**
     * Restore the size of the window. The window will become the width and
     * height it had before it was minimized or maximized.
     * Call-chaining is supported.
     */
    this.restore = function(){
        this.setProperty("state", this.state.split("|")
            .remove("minimized")
            .remove("maximized")
            .pushUnique("normal").join("|"), false, true);
        return this;
    };
    
     /**
     * Set the window into edit state. The configuration panel is shown.
     * Call-chaining is supported.
     */
    this.edit = function(value){
        this.setProperty("state", this.state.split("|")
            .pushUnique("edit").join("|"), false, true);
        return this;
    };

    /**
     * Removes the edit state of this window. The configuration panel is hidden.
     * Call-chaining is supported.
     */
    this.closeedit = function(value){
        this.setProperty("state", this.state.split("|")
            .remove("edit").join("|"), false, true);
        return this;
    };
    
    this.$toggle = function(type){
        var c = actions[type][0];
        this[actions[type][this.state.indexOf(c) > -1 ? 2 : 1]]();
    };
    
    this.$propHandlers["refparent"] = function(value){
        if (typeof value == "string")
            this.$refParent = self[value] && self[value].$ext || document.getElementById(value);
        else this.$refParent = value;
    }
    
    /**
     * @attribute {String} state the state of the window. The state can be a
     * combination of multiple states seperated by a pipe '|' character.
     *   Possible values:
     *   normal     The window has it's normal size and position. Default value.
     *   minimized  The window is minimized.
     *   maximized  The window is maximized.
     *   edit       The window is in the edit state.
     *   closed     The window is closed.
     */
    this.$propHandlers["state"] = function(value, noanim, comp, reenter){
        var _self = this;
        if (!this.$amlLoaded) { //@todo I still think this is weird and should not be needed
            apf.queue.add("state" + this.$uniqueId, function(){
                _self.$propHandlers["state"].call(_self, value, noanim);
            });
            return;
        }

        var i, pNode, position, l, t,
            o          = {},
            s          = value.split("|"),
            lastState  = this.$lastState,
            styleClass = [];

        for (i = 0; i < s.length; i++)
            o[s[i]] = true;
        o.value = value;

        if (!o.maximized && !o.minimized)
            o.normal = true;

        if (!reenter && this.dispatchEvent("beforestatechange", {
          from : lastState, 
          to   : o}) === false) {
            this.state = lastState.value;
            return false;
        }

        //Closed state
        if (o.closed == this.visible) {//change detected
            this.setProperty("visible", !o["closed"]);
            //@todo difference is, we're not clearing the other states, check the docking example
        }

        //Restore state
        if (o.normal != lastState.normal
          || !o.normal && (o.minimized != lastState.minimized
            || o.maximized != lastState.maximized)) {

            if (this.$lastheight) // this.aData && this.aData.hidden == 3 ??
                this.$ext.style.height = this.$lastheight;//(this.$lastheight - apf.getHeightDiff(this.$ext)) + "px";

            if (this.$lastpos) {
                if (this.animate && !noanim) {
                    //Pre remove paused event because of not having onresize
                    //if (apf.hasSingleRszEvent)
                        //delete apf.layout.onresize[apf.layout.getHtmlId(this.$pHtmlNode)];

                    var htmlNode = this.$ext;
                    position = apf.getStyle(htmlNode, "position");
                    if (position != "absolute") {
                        l = parseInt(apf.getStyle(htmlNode, "left")) || 0;
                        t = parseInt(apf.getStyle(htmlNode, "top")) || 0;
                    }
                    else {
                        l = htmlNode.offsetLeft;
                        t = htmlNode.offsetTop;
                    }

                    this.animstate = 1;
                    apf.tween.multi(htmlNode, {
                        steps    : 5,
                        interval : 10,
                        tweens   : [
                            {type: "left",   from: l,    to: this.$lastpos.px[0]},
                            {type: "top",    from: t,    to: this.$lastpos.px[1]},
                            {type: "width",  from: this.$ext.offsetWidth - hordiff,
                                to: this.$lastpos.px[2]},
                            {type: "height", from: this.$ext.offsetHeight - verdiff,
                                to: this.$lastpos.px[3]}
                        ],
                        oneach   : function(){
                            
                            if (apf.hasSingleRszEvent)
                                apf.layout.forceResize(_self.$int);
                            
                        },
                        onfinish : function(){
                            _self.$propHandlers["state"].call(_self, value, true,
                                null, true);
                        }
                    });

                    return;
                }

                this.$ext.style.left   = this.$lastpos.css[0];
                this.$ext.style.top    = this.$lastpos.css[1];
                this.$ext.style.width  = this.$lastpos.css[2];
                this.$ext.style.height = this.$lastpos.css[3];
                
                pNode = this.$lastpos.parentNode;
                pNode.style.width    = this.$lastpos.parent[0];
                pNode.style.height   = this.$lastpos.parent[1];
                pNode.style.overflow = this.$lastpos.parent[2];
            }

            
            if (this.aData && this.aData.restore)
                this.aData.restore();
            

            
            if (apf.layout)
                apf.layout.play(this.$pHtmlNode);
            
            if (this.$lastzindex) {
                this.$ext.style.zIndex = this.$lastzindex[0];
                if (this.oCover)
                    this.oCover.style.zIndex = this.$lastzindex[1];
            }

            this.$lastheight = this.$lastpos = this.$lastzindex = null;

            if (o.normal)
                styleClass.push("",
                    this.$baseCSSname + "Max",
                    this.$baseCSSname + "Min");
        }

        if (o.minimized != lastState.minimized) {
            if (o.minimized) {
                styleClass.unshift(
                    this.$baseCSSname + "Min",
                    this.$baseCSSname + "Max",
                    this.$baseCSSname + "Edit");

                
                if (this.aData && this.aData.minimize)
                    this.aData.minimize(this.collapsedHeight);
                

                if (!this.aData || !this.aData.minimize) {
                    this.$lastheight = apf.getStyle(this.$ext, "height");//this.$ext.offsetHeight;

                    this.$ext.style.height = Math.max(0, this.collapsedHeight
                        - apf.getHeightDiff(this.$ext)) + "px";
                }

                if (this.hasFocus())
                    apf.window.moveNext(null, this, true);
                //else if(apf.document.activeElement)
                    //apf.document.activeElement.$focus({mouse: true});
            }
            else {
                styleClass.push(this.$baseCSSname + "Min");

                $setTimeout(function(){
                    apf.window.$focusLast(_self);
                });
            }
        }

        if (o.maximized != lastState.maximized) {
            if (o.maximized) {
                styleClass.unshift(
                    this.$baseCSSname + "Max",
                    this.$baseCSSname + "Min",
                    this.$baseCSSname + "Edit");

                pNode = this.$refParent;
                if (!pNode)
                    pNode = (this.$ext.offsetParent == document.body
                      ? document.documentElement
                      : this.$ext.parentNode);

                _self.animstate = 0;
                var hasAnimated = false, htmlNode = this.$ext;
                
                var position = apf.getStyle(htmlNode, "position");
                if (position == "absolute") {
                    pNode.style.overflow = "hidden";
                    l = htmlNode.offsetLeft;
                    t = htmlNode.offsetTop;
                }
                else {
                    var pos = apf.getAbsolutePosition(htmlNode, pNode);
                    l = pos[0];//parseInt(apf.getStyle(htmlNode, "left")) || 0;
                    t = pos[1];//parseInt(apf.getStyle(htmlNode, "top")) || 0;
                }
                
                this.$lastpos = {
                    css    : [this.$ext.style.left, this.$ext.style.top,
                              this.$ext.style.width, this.$ext.style.height],
                    px     : [l, t, this.$ext.offsetWidth - hordiff, 
                              this.$ext.offsetHeight - verdiff],
                    parent : [pNode.style.width, pNode.style.height, 
                              pNode.style.overflow],
                    parentNode : pNode
                };

                var from = [htmlNode.offsetWidth, htmlNode.offsetHeight];
                function setMax(){
                    var w = !apf.isIE && pNode == document.documentElement
                            ? window.innerWidth
                            : pNode.offsetWidth,
                        h = !apf.isIE && pNode == document.documentElement
                            ? window.innerHeight
                            : pNode.offsetHeight;
                    
                    if (position != "absolute") {
                        var diff = apf.getDiff(pNode);
                        w -= diff[0] + (!_self.$refParent && apf.isIE8 ? 4 : 0);//@todo dirty hack!
                        h -= diff[0] + (!_self.$refParent && apf.isIE8 ? 4 : 0);//@todo dirty hack!
                    }
                    //@todo dirty hack!
                    else if (!_self.$refParent && apf.isIE8) {
                        w -= 4;
                        h -= 4;
                    }
                    
                    var box = _self.$refParent ? [0,0,0,0] : marginBox,
                        pos = pNode != htmlNode.offsetParent
                            ? apf.getAbsolutePosition(pNode, htmlNode.offsetParent)
                            : [0, 0],
                        pDiff = apf.getDiff(pNode);

                    pNode.style.width  = (pNode.offsetWidth - pDiff[0]) + "px";
                    pNode.style.height = (pNode.offsetHeight - pDiff[1]) + "px";
                    
                    if (_self.animate && !hasAnimated) {
                        _self.animstate = 1;
                        hasAnimated     = true;
                        apf.tween.multi(htmlNode, {
                            steps    : 5,
                            interval : 10,
                            tweens   : [
                                {type: "left",   from: l, to: pos[0] - box[3]},
                                {type: "top",    from: t, to: pos[1] - box[0]},
                                {type: "width",  from: from[0] - hordiff,
                                    to: (w - hordiff + box[1] + box[3])},
                                {type: "height", from: from[1] - verdiff,
                                    to: (h - verdiff + box[0] + box[2])}
                            ],
                            oneach   : function(){
                                
                                if (apf.hasSingleRszEvent)
                                    apf.layout.forceResize(_self.$int);
                                
                            },
                            onfinish : function(){
                                _self.animstate = 0;
                                
                                _self.dispatchEvent("afterstatechange", {
                                  from : lastState, 
                                  to   : o});
                            }
                        });
                    }
                    else if (!_self.animstate) {
                        htmlNode.style.left = (pos[0] - box[3]) + "px";
                        htmlNode.style.top  = (pos[1] - box[0]) + "px";

                        htmlNode.style.width  = (w
                            - hordiff + box[1] + box[3]) + "px";
                        htmlNode.style.height = (h
                            - verdiff + box[0] + box[2]) + "px";
                    }
                }
                
                if (apf.layout)
                    apf.layout.pause(this.$pHtmlNode, setMax);
                
                this.$lastzindex = [
                    this.$ext.style.zIndex || 1, 
                    this.oCover && this.oCover.style.zIndex || 1
                ];
                
                if (this.oCover)
                    this.oCover.style.zIndex = apf.WinServer.count + 1;
                this.$ext.style.zIndex = apf.WinServer.count + 2;
            }
            else {
                styleClass.push(this.$baseCSSname + "Max");
            }
        }

        if (o.edit != lastState.edit) {
            if (o.edit) {
                styleClass.unshift(
                    this.$baseCSSname + "Edit",
                    this.$baseCSSname + "Max",
                    this.$baseCSSname + "Min");

                if (this.btnedit)
                    oButtons.edit.innerHTML = "close"; //hack

                this.dispatchEvent('editstart');
            }
            else {
                if (this.dispatchEvent('editstop') === false)
                    return false;

                styleClass.push(this.$baseCSSname + "Edit");
                if (styleClass.length == 1)
                    styleClass.unshift("");

                if (this.btnedit)
                    oButtons.edit.innerHTML = "edit"; //hack
            }
        }

        if (styleClass.length || o.closed != lastState.closed) {
            if (styleClass.length)
                this.$setStyleClass(this.$ext, styleClass.shift(), styleClass);
                
            if (o.edit) { //@todo apf3.0
                this.dispatchEvent("prop.visible", {value:true});
                
                if (_self.oSettings)
                    apf.layout.forceResize(_self.oSettings);
                
            }

            if (!o.maximized || lastState.maximized && _self.animate) {
                _self.dispatchEvent("afterstatechange", {
                  from : lastState, 
                  to   : o});
            }
            
            this.$lastState = o;

            
            if (this.aData && !o.maximized) { //@todo is this the most optimal position?
                this.$purgeAlignment();
            }
            

            
            if (!this.animate && apf.hasSingleRszEvent && apf.layout)
                apf.layout.forceResize(_self.$int);
            
        }
    };

    var marginBox, hordiff, verdiff, oButtons = {}
    /**
     * @attribute {String} buttons the buttons that the window displays. This
     * can be multiple values seperated by a pipe '|' character.
     *   Possible values:
     *   min    The button that minimizes the window.
     *   max    The button that maximizes the window.
     *   close  The button that closes the window.
     *   edit   The button that puts the window into the edit state.
     */
    this.$propHandlers["buttons"] = function(value){
        
        if (apf.isIphone) return;
        
        if (!this.$hasLayoutNode("button"))
            return;

        var buttons   = value && (value = value.replace(/(\|)\||\|$/, "$1")).split("|") || [],
            nodes     = this.$buttons.childNodes,
            re        = value && new RegExp("(" + value + ")"),
            found     = {},
            idleNodes = [];

        //Check if we can 'remove' buttons
        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].nodeType != 1 || nodes[i].tagName != "DIV") //@todo temp hack
                continue;

            if (nodes[i].getAttribute("button") && (!value 
              || !nodes[i].className || !nodes[i].className.match(re))) {
                nodes[i].style.display = "none";
                this.$setStyleClass(nodes[i], "", ["min", "max", "close", "edit"]);
                idleNodes.push(nodes[i]);
            }
            else {
                found[RegExp.$1] = nodes[i];
            }
        }

        //Create new buttons if needed
        for (i = 0; i < buttons.length; i++) {
            if (!buttons[i])
                continue;
            
            if (found[buttons[i]]) {
                this.$buttons.insertBefore(found[buttons[i]], this.$buttons.firstChild);
                continue;
            }

            var btn = idleNodes.pop();
            if (!btn) {
                this.$getNewContext("button");
                btn = this.$getLayoutNode("button");
                btn.setAttribute("button", "button");
                setButtonEvents(btn);
                btn = apf.insertHtmlNode(btn, this.$buttons);
            }

            this.$setStyleClass(btn, buttons[i], ["min", "max", "close", "edit"]);
            btn.onclick = new Function("apf.lookup(" + this.$uniqueId + ").$toggle('"
                                       + buttons[i] + "')");
            btn.style.display = "block";
            oButtons[buttons[i]] = btn;
            this.$buttons.insertBefore(btn, this.$buttons.firstChild);
        }
        
        var diff = apf.getDiff(this.$ext);
        hordiff  = diff[0];
        verdiff  = diff[1];
        marginBox = apf.getBox(apf.getStyle(this.$ext, "borderWidth"));
    };
    
    function setButtonEvents(btn){
        btn.setAttribute("onmousedown",
            "apf.setStyleClass(this, 'down');\
             event.cancelBubble = true; \
             var o = apf.findHost(this).$ext;\
             if (o.onmousedown) o.onmousedown(event);\
             apf.window.$mousedown(event);");
        btn.setAttribute("onmouseup",
            "apf.setStyleClass(this, '', ['down'])");
        btn.setAttribute("onmouseover",
            "apf.setStyleClass(this, 'hover')");
        btn.setAttribute("onmouseout",
            "apf.setStyleClass(this, '', ['hover', 'down'])");
    }
    
    this.$initButtons = function(oExt){
        this.collapsedHeight = this.$getOption("Main", "collapsed-height");

        var oButtons = this.$getLayoutNode("main", "buttons", oExt);
        if (!oButtons || apf.isIphone || !this.getAttribute("buttons") 
          || !this.$hasLayoutNode("button"))
            return;

        var len = (this.getAttribute("buttons") || "").split("|").length;
        for (var btn, i = 0; i < len; i++) {
            this.$getNewContext("button");
            btn = oButtons.appendChild(this.$getLayoutNode("button"));
            btn.setAttribute("button", "button");
            setButtonEvents(btn);
        }
    };
    
    this.addEventListener("DOMNodeRemovedFromDocument", function(e){
        for (var name in oButtons) {
            oButtons[name].onclick = null;
        }
    });
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/teleport.js)SIZE(7149)TIME(1260316863)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element which specifies the ways the application can communicate to remote
 * data sources.
 * Example:
 * Example of the {@link teleport.cgi rpc module with the cgi protocol}.
 * <code>
 *  <a:rpc id="comm" protocol="cgi">
 *      <a:method
 *        name    = "searchProduct"
 *        url     = "http://example.com/search.php"
 *        receive = "processSearch">
 *          <a:variable name="search" />
 *          <a:variable name="page" />
 *          <a:variable name="textbanner" value="1" />
 *      </a:method>
 *      <a:method
 *        name = "loadProduct"
 *        url  = "http://example.com/show-product.php">
 *          <a:variable name="id" />
 *          <a:variable name="search_id" />
 *      </a:method>
 *  </a:rpc>
 *
 *  <a:script>
 *      //This function is called when the search returns
 *      function processSearch(data, state, extra){
 *          alert(data)
 *      }
 *
 *      //Execute a search for the product car
 *      comm.searchProduct('car', 10);
 *  </a:script>
 * </code>
 * Example:
 * Example of the {@link teleport.soap rpc module with the soap protocol}.
 * <code>
 *  <a:rpc id="comm" 
 *    protocol    = "soap" 
 *    url         = "http://example.com/show-product.php" 
 *    soap-prefix = "m" 
 *    soap-xmlns  = "http://example.com">
 *      <a:method 
 *        name    = "searchProduct" 
 *        receive = "processSearch">
 *          <a:variable name="search" />
 *          <a:variable name="page" />
 *          <a:variable name="textbanner" value="1" />
 *      </a:method>
 *      <a:method 
 *        name = "loadProduct">
 *          <a:variable name="id" />
 *          <a:variable name="search_id" />
 *      </a:method>
 *  </a:rpc>
 *
 *  <a:script>
 *      //This function is called when the search returns
 *      function processSearch(data, state, extra){
 *          alert(data)
 *      }
 *
 *      //Execute a search for the product car
 *      comm.searchProduct('car', 10);
 *  </a:script>
 * </code>
 * Example:
 * Writing to a file with a WebDAV connector
 * <code>
 *   <a:webdav id="myWebDAV"
 *    url   = "http://my-webdav-server.com/dav_files/" />
 *     
 *  <a:script>
 *      // write the text 'bar' to a file on the server called 'foo.txt'
 *      myWebDAV.write('http://my-webdav-server.com/dav_files/foo.txt', 'bar');
 *  </a:script>
 * </code>
 * Example:
 * XMPP connector with new message notification
 * <code>
 *  <a:xmpp id="myXMPP"
 *    url           = "http://my-jabber-server.com:5280/http-bind"
 *    model         = "mdlRoster"
 *    connection    = "bosh"
 *    onreceivechat = "messageReceived(arguments[0].from)" />
 *
 *  <a:script>
 *      // This function is called when a message has arrived
 *      function messageReceived(from){
 *          alert('Received message from ' + from);
 *      }
 *
 *      // Send a message to John
 *      myXMPP.sendMessage('john@my-jabber-server.com', 'A test message', '',
 *          apf.xmpp.MSG_CHAT);
 *  </a:script>
 * </code>
 *
 * @attribute {String}  url              the location of the server that is
 *                                       recipient of the rpc messages.
 * @attribute {String}  [route-server]   String specifying the url to the route script.
 *                                       Remarks:
 *                                       The route script will receive the route information in 3 extra headers:
 *                                           X-Route-Request     - Containing the destination url.<br />
 *                                           X-Proxy-Request     - Containing the destination url.<br />
 *                                           X-Compress-Response - Set to 'gzip'.<br />
 * @attribute {Boolean} [autoroute]      whether the call should be routed
 *                                       through a proxy when a permission
 *                                       error occurs due to the same domein policy.
 * @attribute {Number}  [timeout]        the number of milliseconds after
 *                                       which the call is considered timed out.
 *
 * 
 * @define teleport
 * @addnode global
 * @allowchild {teleport}
 *
 * @default_private
 */
apf.Teleport = function(){
    this.$init(true);
};

apf.__TELEPORT__ = 1 << 28;

(function() {
    this.$parsePrio = "002";
    
    this.$regbase = this.$regbase | apf.__TELEPORT__;

    this.$booleanProperties["autoroute"] = true;
    
    this.$supportedProperties.push("url", "timeout", "protocol", "route-server",
        "autoroute");

    this.$propHandlers["url"] = function(value) {
        var url = new apf.url(value);

        // do some extra startup/ syntax error checking
        if (!url.protocol) {
            throw new Error(apf.formatErrorString(0, this,
                "Communication (Teleport) initialization error",
                "Invalid server url provided."));
        }

        this.$domain   = url.host;
        this.$rootPath = url.path;
        this.$server   = value.replace(new RegExp(this.$rootPath + "$"), "");
    };

    this.$propHandlers["timeout"] = function(value) {
        this.timeout = parseInt(value) || 10000;
    };

    this.$propHandlers["protocol"] = function(value) {
        var proto = value.toLowerCase();
        if (!apf[proto]) {
            throw new Error(apf.formatErrorString(1025, null, "Teleport baseclass",
                "Could not find Ajax.org Teleport RPC Component '" + proto + "'", this));
        }
        this.implement(apf[proto]);
    };
    
    /**
     * Returns a string representation of this object.
     */
    this.toString = function(){
        return "[Ajax.org Teleport Component : " + (this.name || "")
            + " (" + this.type + ")]";
    };

    this.addEventListener("DOMNodeInsertedIntoDocument", function() {
        // Implement HTTP Module
        if (!apf.http) {
            throw new Error(apf.formatErrorString(1024, null, "Teleport baseclass", 
                "Could not find Ajax.org Teleport HTTP Component", this.$aml));
        }
        this.implement(apf.http);

        if (this.id)
            apf.$asyncObjects[this.id] = 1;
    });
}).call(apf.Teleport.prototype = new apf.AmlElement());



apf.Init.run("teleport");


/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/interactive.js)SIZE(23483)TIME(1264772818)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__INTERACTIVE__ = 1 << 21;



/**
 * All elements inheriting from this {@link term.baseclass baseclass} have interactive features, making an
 * element draggable and resizable.
 * Example:
 * <code>
 *  <a:textarea draggable="true" resizable="true" />
 * </code>
 * 
 * @attribute {Boolean} draggable whether an element is draggable. The user will
 * able to move the element around while holding the mouse button down on the 
 * element.
 * Example:
 * <code>
 *  <a:bar draggable="true" />
 * </code>
 * @attribute {Boolean} resizable whether an element is resizable. The user will able
 * to resize the element by grabbing one of the four edges of the element and 
 * pulling it in either direction. Grabbing the corners allows users to 
 * resize horizontally and vertically at the same time. The right bottom corner 
 * is special, because it offers an especially big grab area. The size of this
 * area can be configured in the skin of the element.
 * Example:
 * <code>
 *  <a:window resizable="true" />
 * </code>
 * @attribute {Number} minwidth  the minimum horizontal size the element can get when resizing.
 * @attribute {Number} minheight the minimum vertical size the element can get when resizing.
 * @attribute {Number} maxwidth  the maximum horizontal size the element can get when resizing.
 * @attribute {Number} maxheight the maximum vertical size the element can get when resizing.
 *
 * @event drag          Fires when the widget has been dragged.
 * @event resizestart   Fires before the widget is resized.
 *   cancelable: Prevents this resize action to start.
 *   object:
 *   {String} type the type of resize. This is a combination of the four directions, n, s, e, w.
 * @event resize        Fires when the widget has been resized.
 *
 * @constructor
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       1.0
 *
 * @see element.appsettings.attribute.outline
 * @see element.appsettings.attribute.resize-outline
 * @see element.appsettings.attribute.drag-outline
 */
apf.Interactive = function(){
    var nX, nY, rX, rY, startPos, lastCursor = null, l, t, lMax, tMax, lMin, 
        tMin, w, h, we, no, ea, so, rszborder, rszcorner, marginBox,
        verdiff, hordiff, _self = this, posAbs, oX, oY, overThreshold,
        dragOutline, resizeOutline, myPos;

    this.$regbase = this.$regbase | apf.__INTERACTIVE__;

    this.$propHandlers["draggable"] = function(value){
        if (apf.isFalse(value))
            this.draggable = value = false;
        else if (apf.isTrue(value))
            this.draggable = value = true;
        
        var o = this.oDrag || this.$ext;
        if (o.interactive & 1) 
            return;

        var mdown = o.onmousedown;
        o.onmousedown = function(){
            if (mdown && mdown.apply(this, arguments) === false)
                return;

            dragStart.apply(this, arguments);
        }
        o.interactive = (o.interactive||0)+1;
        
        //this.$ext.style.position = "absolute";
    };

    this.$propHandlers["resizable"] = function(value){
        if (apf.isFalse(value))
            this.resizable = value = false;
        else if (apf.isTrue(value))
            this.resizable = value = true;
        
        var o = this.oResize || this.$ext;
        if (o.interactive & 2) 
            return;
        
        var mdown = o.onmousedown;
        var mmove = o.onmousemove;

        o.onmousedown = function(){
            if (mdown && mdown.apply(this, arguments) === false)
                return;

            resizeStart.apply(this, arguments);
        };

        o.onmousemove = function(){
            if (mmove && mmove.apply(this, arguments) === false)
                return;

            resizeIndicate.apply(this, arguments);
        };
        
        o.interactive = (o.interactive||0)+2;
        
        //this.$ext.style.position = "absolute";
        
        rszborder = this.$getOption && parseInt(this.$getOption("Main", "resize-border")) || 3;
        rszcorner = this.$getOption && parseInt(this.$getOption("Main", "resize-corner")) || 12;
        marginBox = apf.getBox(apf.getStyle(this.$ext, apf.isIE ? "borderWidth" : "border-width"));
    };
    
    /*
    this.$propHandlers["minwidth"]  = 
    this.$propHandlers["maxwidth"]  = 
    this.$propHandlers["minheight"] = 
    this.$propHandlers["maxheight"] = function(value, prop){
        if (this.aData)
            this.aData[prop] = parseInt(value);
    }
    if (this.aData) {
        this.aData.minwidth = this.minwidth;
        this.aData.minheight = this.minheight;
    }*/
    
    function dragStart(e){
        if (!e) e = event;

        if (!_self.draggable || apf.dragMode)
            return;
        
        
        dragOutline = _self.dragOutline == true || apf.config.dragOutline;
        
        
        apf.dragMode  = true;
        overThreshold = false;
        
        
        apf.popup.forceHide();
        
        
        posAbs = "absolute|fixed".indexOf(apf.getStyle(_self.$ext, "position")) > -1;
        if (!posAbs) {
            _self.$ext.style.position = (posAbs = _self.dragSelection) 
                ? "absolute" : "relative";
        }

        //@todo not for docking
        
        if (posAbs && !_self.aData) {
            apf.plane.show(dragOutline
                ? oOutline
                : _self.$ext);//, true
        }
        

        var pos = posAbs 
            ? apf.getAbsolutePosition(_self.$ext, _self.$ext.offsetParent) 
            : [parseInt(apf.getStyle(_self.$ext, "left")) || 0, 
               parseInt(apf.getStyle(_self.$ext, "top")) || 0];
            
        nX = pos[0] - (oX = e.clientX);
        nY = pos[1] - (oY = e.clientY);
        
        //if (_self.hasFeature && _self.hasFeature(apf.__ANCHORING__))
            //_self.$disableAnchoring();

        
        if (posAbs && dragOutline) {
            oOutline.className     = "drag";
            
            var diffOutline = apf.getDiff(oOutline);
            _self.$ext.parentNode.appendChild(oOutline);
            oOutline.style.left    = pos[0] + "px";
            oOutline.style.top     = pos[1] + "px";
            oOutline.style.width   = (_self.$ext.offsetWidth - diffOutline[0]) + "px";
            oOutline.style.height  = (_self.$ext.offsetHeight - diffOutline[1]) + "px";
            
            if (_self.dragSelection)
                oOutline.style.display = "block";
        }
        
        
        document.onmousemove = dragMove;
        document.onmouseup   = function(){
            document.onmousemove = document.onmouseup = null;

            
            if (posAbs && !_self.aData)
                apf.plane.hide();
            
            
            var htmlNode = dragOutline
                ? oOutline
                : _self.$ext;

            if (overThreshold) {
                if (_self.setProperty) {
                    if (_self.right || _self.bottom) {
                        var pHtmlNode = _self.$ext.offsetParent;
                        if (pHtmlNode.tagName == "BODY")
                            pHtmlNode = document.documentElement;
                    }
                    
                    if (_self.right)
                        _self.setProperty("right", pHtmlNode.offsetWidth 
                            - htmlNode.offsetLeft - htmlNode.offsetWidth);
                    
                    if (_self.bottom)
                        _self.setProperty("bottom", pHtmlNode.offsetHeight 
                            - htmlNode.offsetTop - htmlNode.offsetHeight);
                    
                    if (l && (!_self.right || _self.left)) 
                        _self.setProperty("left", l);
                    if (t && (!_self.bottom || _self.top))
                        _self.setProperty("top", t);
                }
                else if (dragOutline) {
                    _self.$ext.style.left = l + "px";
                    _self.$ext.style.top  = t + "px";
                }
            }
            
            l = t = w = h = null;
            
            if (!posAbs)
                _self.$ext.style.position = "relative";
            
            if (_self.showdragging)
                apf.setStyleClass(_self.$ext, "", ["dragging"]);
            
            if (posAbs && dragOutline)
                oOutline.style.display = "none";
            
            apf.dragMode = false;

            if (_self.dispatchEvent)
                _self.dispatchEvent("drag", {
                    htmlNode : htmlNode
                });
        };
        
        if (apf.isIE)
            apf.window.$mousedown(e);

        return false;
    };
    
    function dragMove(e){
        if(!e) e = event;
        
        if (_self.dragSelection)
            overThreshold = true;
        
        if (!overThreshold && _self.showdragging)
            apf.setStyleClass(_self.$ext, "dragging");
        
        // usability rule: start dragging ONLY when mouse pointer has moved delta x pixels
        var dx = e.clientX - oX,
            dy = e.clientY - oY,
            distance; 

        if (!overThreshold 
          && (distance = dx*dx > dy*dy ? dx : dy) * distance < 2)
            return;

        //Drag outline support
        else if (!overThreshold && dragOutline 
          && oOutline.style.display != "block")
            oOutline.style.display = "block";

        var oHtml = dragOutline
            ? oOutline
            : _self.$ext;

        oHtml.style.left = (l = e.clientX + nX) + "px";
        oHtml.style.top  = (t = e.clientY + nY) + "px";

        overThreshold = true;
    };
    
    this.$resizeStart = resizeStart;
    function resizeStart(e, options){
        if (!e) e = event;

        if (!_self.resizable)
            return;

        
        resizeOutline = !(_self.resizeOutline == false || !apf.config.resizeOutline);
        
        
        if (!resizeOutline) {
            var diff = apf.getDiff(_self.$ext);
            hordiff  = diff[0];
            verdiff  = diff[1];
        }
        
        //@todo This is probably not gen purpose
        startPos = apf.getAbsolutePosition(_self.$ext);//, _self.$ext.offsetParent);
        startPos.push(_self.$ext.offsetWidth);
        startPos.push(_self.$ext.offsetHeight);
        myPos    = apf.getAbsolutePosition(_self.$ext, _self.$ext.offsetParent);
        
        var sLeft = 0,
            sTop  = 0,
            x     = (oX = e.clientX) - startPos[0] + sLeft + document.documentElement.scrollLeft,
            y     = (oY = e.clientY) - startPos[1] + sTop + document.documentElement.scrollTop,
            resizeType;

        if (options && options.resizeType) {
            posAbs = "absolute|fixed".indexOf(apf.getStyle(_self.$ext, "position")) > -1;
            resizeType = options.resizeType;
        }
        else {
            resizeType = getResizeType.call(_self.$ext, x, y);
        }
        rX = x;
        rY = y;

        if (!resizeType)
            return;

        if (_self.dispatchEvent && _self.dispatchEvent("resizestart", {
            type : resizeType
          }) === false)
            return;
        
        
        apf.popup.forceHide();
        

        //if (_self.hasFeature && _self.hasFeature(apf.__ANCHORING__))
            //_self.$disableAnchoring();
        
        if (_self.$ext.style.right) {
            _self.$ext.style.left = _self.$ext.offsetLeft + "px";
            _self.$ext.style.right = "";
        }
        if (_self.$ext.style.bottom) {
            _self.$ext.style.top = _self.$ext.offsetTop + "px";
            _self.$ext.style.bottom = "";
        }

        apf.dragMode  = true;
        overThreshold = false;

        we = resizeType.indexOf("w") > -1;
        no = resizeType.indexOf("n") > -1;
        ea = resizeType.indexOf("e") > -1;
        so = resizeType.indexOf("s") > -1;
        
        if (!_self.minwidth)  _self.minwidth  = 0;
        if (!_self.minheight) _self.minheight = 0;
        if (!_self.maxwidth)  _self.maxwidth  = 10000;
        if (!_self.maxheight) _self.maxheight = 10000;

        if (posAbs) {
            lMax = startPos[0] + startPos[2] - _self.minwidth;
            tMax = startPos[1] + startPos[3] - _self.minheight;
            lMin = startPos[0] + startPos[2] - _self.maxwidth;
            tMin = startPos[1] + startPos[3] - _self.maxheight;
        }

        
        if (posAbs) {
            apf.plane.show(resizeOutline
                ? oOutline
                : _self.$ext);//, true
        }
        
        
        
        if (resizeOutline) {
            oOutline.className     = "resize";
            var diffOutline = apf.getDiff(oOutline);
            hordiff = diffOutline[0];
            verdiff = diffOutline[1];
            
            //_self.$ext.parentNode.appendChild(oOutline);
            oOutline.style.left    = startPos[0] + "px";
            oOutline.style.top     = startPos[1] + "px";
            oOutline.style.width   = (_self.$ext.offsetWidth - hordiff) + "px";
            oOutline.style.height  = (_self.$ext.offsetHeight - verdiff) + "px";
            oOutline.style.display = "block";
        }
        
        
        if (!options || !options.nocursor) {
            if (lastCursor === null)
                lastCursor = document.body.style.cursor;//apf.getStyle(document.body, "cursor");
            document.body.style.cursor = resizeType + "-resize";
        }
        
        document.onmousemove = resizeMove;
        document.onmouseup   = function(e){
            document.onmousemove = document.onmouseup = null;
            
            
            if (posAbs)
                apf.plane.hide();
            
            
            if (resizeOutline) {
                var diff = apf.getDiff(_self.$ext);
                hordiff  = diff[0];
                verdiff  = diff[1];
            }

            doResize(e || event, true);
            
            if (_self.setProperty)
                updateProperties();
            
            l = t = w = h = null;

            document.body.style.cursor = lastCursor;
            lastCursor = null;
            
            if (resizeOutline)
                oOutline.style.display = "none";
            
            apf.dragMode = false;
            
            if (_self.dispatchEvent)
                _self.dispatchEvent("resize");
        };
        
        if (apf.isIE)
            apf.window.$mousedown(e);
        
        return false;
    }
    
    function updateProperties(){
        if (posAbs) {
            var htmlNode = _self.$ext;
            if (_self.right || _self.bottom) {
                var pHtmlNode = htmlNode.offsetParent;
                if (pHtmlNode.tagName == "BODY")
                    pHtmlNode = document.documentElement;
            }

            if (_self.right && _self.right != _self.setProperty("right", 
                  pHtmlNode.offsetWidth - htmlNode.offsetLeft 
                  - htmlNode.offsetWidth)) {
                htmlNode.style.left = "";
            }
            
            if (_self.bottom && _self.bottom != _self.setProperty("bottom", 
                  pHtmlNode.offsetHeight - htmlNode.offsetTop 
                  - htmlNode.offsetHeight)) {
                htmlNode.style.top = "";
            }
        
            if (l && (!_self.right || _self.left)) 
                _self.setProperty("left", l);
            if (t && (!_self.bottom || _self.top)) 
                _self.setProperty("top", t);
        }
        
        if (w && (!_self.left || !_self.right)) 
            _self.setProperty("width", w + hordiff) 
        if (h && (!_self.top || !_self.bottom)) 
            _self.setProperty("height", h + verdiff); 
    }
    
    var min = Math.min, max = Math.max, lastTime;
    function resizeMove(e){
        if(!e) e = event;
        
        //if (!e.button)
            //return this.onmouseup();
        
        // usability rule: start dragging ONLY when mouse pointer has moved delta x pixels
        /*var dx = e.clientX - oX,
            dy = e.clientY - oY,
            distance; 
        
        if (!overThreshold 
          && (distance = dx*dx > dy*dy ? dx : dy) * distance < 4)
            return;*/
        
        if (lastTime && new Date().getTime() 
          - lastTime < (resizeOutline ? 6 : apf.mouseEventBuffer))
            return;
        lastTime = new Date().getTime();
        
        doResize(e);
        
        //overThreshold = true;
    }
    
    function doResize(e, force){
        var oHtml = resizeOutline && !force
            ? oOutline
            : _self.$ext;

        var sLeft = document.documentElement.scrollLeft,
            sTop  = document.documentElement.scrollTop;
        
        if (we) {
            oHtml.style.left = (l = max(lMin, min(lMax, myPos[0] + e.clientX - oX + sLeft))) + "px";
            oHtml.style.width = (w = min(_self.maxwidth - hordiff, 
                max(hordiff, _self.minwidth, 
                    startPos[2] - (e.clientX - oX) + sLeft
                    ) - hordiff)) + "px"; //@todo
        }
        
        if (no) {
            oHtml.style.top = (t = max(tMin, min(tMax, myPos[1] + e.clientY - oY + sTop))) + "px";
            oHtml.style.height = (h = min(_self.maxheight - verdiff, 
                max(verdiff, _self.minheight, 
                    startPos[3] - (e.clientY - oY) + sTop
                    ) - verdiff)) + "px"; //@todo
        }

        if (ea)
            oHtml.style.width  = (w = min(_self.maxwidth - hordiff, 
                max(hordiff, _self.minwidth, 
                    e.clientX - startPos[0] + (startPos[2] - rX) + sLeft)
                    - hordiff)) + "px";

        if (so)
            oHtml.style.height = (h = min(_self.maxheight - verdiff, 
                max(verdiff, _self.minheight, 
                    e.clientY - startPos[1] + (startPos[3] - rY) + sTop)
                    - verdiff)) + "px";
        
        //@todo apf3.0 this is execution wise inefficient
        if (_self.parentNode.localName == "table") {
            updateProperties();
            apf.layout.processQueue();
        }
        
        
        if (apf.hasSingleRszEvent)
            apf.layout.forceResize(_self.$int);
        
    }
    
    function getResizeType(x, y){
        var cursor  = "", 
            tcursor = "";
        posAbs = "absolute|fixed".indexOf(apf.getStyle(_self.$ext, "position")) > -1;

        if (_self.resizable == true || _self.resizable == "vertical") {
            if (y < rszborder + marginBox[0])
                cursor = posAbs ? "n" : "";
            else if (y > this.offsetHeight - rszborder) //marginBox[0] - marginBox[2] - 
                cursor = "s";
            else if (y > this.offsetHeight - rszcorner) //marginBox[0] - marginBox[2] - 
                tcursor = "s";
        }
        
        if (_self.resizable == true || _self.resizable == "horizontal") {
            if (x < (cursor ? rszcorner : rszborder) + marginBox[0])
                cursor += tcursor + (posAbs ? "w" : "");
            else if (x > this.offsetWidth - (cursor || tcursor ? rszcorner : rszborder)) //marginBox[1] - marginBox[3] - 
                cursor += tcursor + "e";
        }
        
        return cursor;
    }
    
    var originalCursor;
    function resizeIndicate(e){
        if(!e) e = event;
        
        if (!_self.resizable || document.onmousemove)
            return;

        //@todo This is probably not gen purpose
        var pos   = apf.getAbsolutePosition(_self.$ext),//, _self.$ext.offsetParent
            sLeft = 0,
            sTop  = 0,
            x     = e.clientX - pos[0] + sLeft + document.documentElement.scrollLeft,
            y     = e.clientY - pos[1] + sTop + document.documentElement.scrollTop;
        
        if (!originalCursor)
            originalCursor = apf.getStyle(this, "cursor");
        
        var cursor = getResizeType.call(_self.$ext, x, y);
        this.style.cursor = cursor 
            ? cursor + "-resize" 
            : originalCursor || "default";
    };

    
    var oOutline;
    function initOutline(e){
        oOutline = this.$pHtmlDoc.getElementById("apf_outline");
        if (!oOutline) {
            oOutline = this.$pHtmlDoc.body.appendChild(this.$pHtmlDoc.createElement("div"));
            
            oOutline.refCount = 0;
            oOutline.setAttribute("id", "apf_outline");
            
            oOutline.style.position = "absolute";
            oOutline.style.display  = "none";
            oOutline.style.zIndex   = 2000000;
        }
        oOutline.refCount++
    }

    if (this.addEventListener && this.hasFeature(apf.__AMLNODE__)) {
        this.addEventListener("DOMNodeInsertedIntoDocument", initOutline);
    }
    else {
        this.$pHtmlDoc = document;
        initOutline.call(this);
    }
    
    
    /*this.addEventListener("DOMNodeRemovedFromDocument", function(e){
        oOutline.refCount--;
        
        if (!oOutline.refCount) {
            //destroy
        }
    });*/
};

apf.GuiElement.propHandlers["resizable"] = function(value){
    this.implement(apf.Interactive);
    this.$propHandlers["resizable"].apply(this, arguments);
}

apf.GuiElement.propHandlers["draggable"] = function(value){
    this.implement(apf.Interactive);
    this.$propHandlers["draggable"].apply(this, arguments);
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/delayedrender.js)SIZE(5028)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__DELAYEDRENDER__ = 1 << 11



/**
 * All elements inheriting from this {@link term.baseclass baseclass} have delayed
 * rendering features. Any element that is (partially) hidden at startup has the
 * possibility to delay rendering it's childNodes by setting render="runtime" on
 * the element. These elements include window, tab, pages, form and container.
 * For instance a Tab page in a container is initally hidden and does not
 * need to be rendered. When the tab button is pressed to activate the page
 * the page is rendered and then displayed. This can dramatically decrease
 * the startup time of the application.
 * Example:
 * In this example the button isn't rendered until the advanced tab becomes active.
 * <code>
 *  <a:tab>
 *      <a:page caption="General">
 *          ...
 *      </a:page>
 *      <a:page caption="Advanced" render="runtime">
 *          <a:button>OK</a:button>
 *      </a:page>
 *  </a:tab>
 * </code>
 *
 * @event beforerender  Fires before elements are rendered. Use this event to display a loader.
 *   cancelable: Prevents rendering of the childNodes
 * @event afterrender   Fires after elements are rendered. User this event to hide a loader.
 *
 * @attribute {String}  render           when the contents of this element is rendered.
 *   Possible values:
 *   init     elements are rendered during init of the application.
 *   runtime  elements are rendered when the user requests them.
 * @attribute {Boolean} use-render-delay whether there's a short delay between showing this element and rendering it's contents.
 *   Possible values:
 *   true   The elements are rendered immediately
 *   false  There is a delay between showing this element and the actual rendering,
 *          allowing the browsers' render engine to draw (for instance a loader).
 *
 * @constructor
 * @baseclass
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8.9
 */
apf.DelayedRender = function(){
    this.$regbase   = this.$regbase | apf.__DELAYEDRENDER__;
    this.$rendered  = false;
    
    /**
     * Renders the children of this element.
     *
     * @param {Boolean} [usedelay] whether a delay is added between calling 
     * this function and the actual rendering. This allows the browsers' 
     * render engine to draw (for instance a loader).
     */
    this.$render = function(usedelay){
        if (this.$rendered)
            return;

        if (this.dispatchEvent("beforerender") === false)
            return;

        if (this["render-delay"] || usedelay)
            $setTimeout("apf.lookup(" + this.$uniqueId + ").$renderparse()", 10);
        else
            this.$renderparse();
    };

    this.$renderparse = function(){
        if (this.$rendered)
            return;

        var domParser = this.ownerDocument.$domParser;
        domParser.parseFromXml(this.$aml, {
            amlNode       : this,
            doc           : this.ownerDocument,
            //nodelay       : true,
            delayedRender : true
        });
        domParser.$continueParsing(this);

        this.$rendered = true;

        this.dispatchEvent("afterrender");
    };
    
    var f;
    this.addEventListener("prop.visible", f = function(){
        if (arguments[0].value) {
            
            this.$render();
            
            
            this.removeEventListener("prop.visible", f);
        }
    });
};

apf.GuiElement.propHandlers["render"] = function(value) {
    if (!this.hasFeature(apf.__DELAYEDRENDER__) && value == "runtime") {
        this.implement(apf.DelayedRender);
    
        if (this.localName != "page") {
            this.visible = false;
            this.$ext.style.display = "none";
        }
        
        if (typeof this["render-delay"] == "undefined")
            this.$setInheritedAttribute("render-delay");
    }
};

apf.config.$inheritProperties["render-delay"] = 1;



/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/rename.js)SIZE(12871)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__RENAME__ = 1 << 10;



/**
 * All elements inheriting from this {@link term.baseclass baseclass} have the rename features. Rename is triggered by
 * pressing F2 on an item or by clicking once on an already selected item. This
 * will show an input element in place where the user can change the name of the
 * item to a new one. When the caption is changed the {@link term.datanode data node} is
 * changed accordingly.
 * Example:
 * This example shows a list containing products. Only products that have the
 * editable attribute set to 1 can be renamed by the user.
 * <code>
 *  <a:model id="mdlTest">
 *      <data>
 *          <product name="TV" />
 *          <product name="LCD" editable="1" />
 *      </data>
 *  </a:model>
 *  <a:list id="list" model="mdlTest" width="200">
 *      <a:each match="[product]">
 *          <a:caption match="[@name]" />
 *      </a:each>
 *      <a:actions>
 *          <a:rename
 *            match = "[product[@editable='1']]"
 *            set   = "rename.php" />
 *      </a:actions>
 *  </a:list>
 *       
 *  <a:button
 *    caption = "Rename"
 *    onclick = "list.startRename()" />
 * </code>
 *
 * @event stoprename Fires when a rename action is cancelled.
 *
 * @constructor
 * @baseclass
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.5
 */
apf.Rename = function(){
    this.$regbase      = this.$regbase|apf.__RENAME__;

    this.canrename     = true;
    this.renameSubject =
    this.renameTimer   =
    this.lastCursor    = null;
    
    /**
     * @attribute  {Boolean}  rename  whether the user can start renaming rendered nodes in this element.
     */
    this.$booleanProperties["canrename"]  = true;
    this.$booleanProperties["autorename"] = true;
    this.$supportedProperties.push("canrename", "autorename");

    
    this.$propHandlers["autorename"] = function(value){
        if (value) {
            this.reselectable = true;
            this.bufferselect = false;
            this.addEventListener("afterselect", $afterselect);
            this.addEventListener("keydown", $keydown);
        }
        else {
            this.removeEventListener("afterselect", $afterselect);
            this.removeEventListener("keydown", $keydown);
        }
    }
    
    function $afterselect(){
        var _self = this;
        $setTimeout(function(){
            if (_self.hasFocus())
                _self.startRename();
        }, 20);
    }
    
    function $keydown(e){
        if (!this.renaming && apf.isCharacter(e.keyCode))
            this.startRename();
    }
    
    this.$isContentEditable = function(e){
        if (this.renaming && this.autorename)
            return true;
    }
    

    /**
     * Changes the data presented as the caption of a specified {@link term.datanode data node}.
     * If none is specified the indicated node is used.
     *
     * @action
     * @param  {XMLElement} xmlNode the element to change the caption of.
     * @param  {String}     value   the value to set as the caption of the {@link term.datanode data node}.
     */
    this.rename = function(xmlNode, value){
        if (!xmlNode)
            xmlNode = this.caret || this.selected;

        if (!xmlNode) return;

        this.$executeSingleValue("rename", "caption", xmlNode, value);
    };

    /**
     * Starts the rename process with a delay, allowing for cancellation when
     * necesary. Cancellation is necesary for instance, when double click was
     * intended or a dragdrop operation.
     *
     */
    this.startDelayedRename = function(e, time){
        if (e && (e.button == 2 || e.ctrlKey || e.shiftKey))
            return;

        clearTimeout(this.renameTimer);
        this.renameTimer = $setTimeout('apf.lookup('
            + this.$uniqueId + ').startRename()', time || 400);
    };

    /**
     * Starts the rename process by displaying an input box at the position
     * of the item that can be renamed by the user.
     *
     */
    this.startRename = function(force, startEmpty){
        if (!force && (this.renaming || !this.canrename 
          || !this.$startAction("rename", this.caret 
          || this.selected, this.stopRename)))
            return false;

        if (!this.hasFocus())
            this.focus(null, null, true);

        clearTimeout(this.renameTimer);

        var elCaption = this.$getCaptionElement
            ? this.$getCaptionElement()
            : this.$caret || this.$selected;

        if (!elCaption) 
            return this.stopRename();
        
        this.renaming      = true;
        this.renameSubject = this.caret || this.selected;

        var wdt = elCaption.offsetWidth;
        this.lastCursor = elCaption.style.cursor;
        elCaption.style.cursor = "text";
        elCaption.parentNode.replaceChild(this.oTxt, elCaption);
        elCaption.host = this;

        if (apf.isTrue(this.$getOption("main", "scalerename"))) {
            var diff = apf.getWidthDiff(this.oTxt);
            this.oTxt.style.width = (wdt - diff - 3) + "px";
        }

        this.replacedNode = elCaption;
        var xmlNode       = this.$getCaptionXml
            ? this.$getCaptionXml(this.renameSubject)
            : this.$getDataNode("caption", this.renameSubject);

        this.oTxt[apf.hasContentEditable ? "innerHTML" : "value"] = startEmpty || !xmlNode
            ? ""
            : (xmlNode.nodeType >= 2 && xmlNode.nodeType <= 4
                ? unescape(decodeURI(xmlNode.nodeValue))
                : (apf.isOnlyChild(xmlNode.firstChild, [3,4])
                    ? apf.queryValue(xmlNode)
                    : this.$applyBindRule("caption", this.renameSubject))) || "";

        this.oTxt.unselectable = "Off";
        this.oTxt.host         = this;

        //this.oTxt.focus();
        try {
            this.oTxt.focus();
            this.oTxt.select();
        }
        catch(e) {}
    };

    /**
     * Stop renaming process and change the data according to the set value.
     * Cancel the renaming process without changing data.
     *
     */
    this.stopRename = function(contextXml, success){
        clearTimeout(this.renameTimer);

        if (!this.renaming || contextXml && contextXml != this.renameSubject
          || !this.replacedNode)
            return false;

        if (this.oTxt.parentNode && this.oTxt.parentNode.nodeType == 1) {
            if (apf.isIE8 || apf.isIE7Emulate)
                this.oTxt.blur();
            
            this.oTxt.parentNode.replaceChild(this.replacedNode, this.oTxt);
        }

        this.renaming = false;

        if (this.replacedNode) {
            this.replacedNode.style.cursor = this.lastCursor || "";
            this.replacedNode.host = null;
        }

        if (!success) {
            this.dispatchEvent("stoprename");
            this.$stopAction("rename");
        }
        else {
            if (this.replacedNode) {
                this.replacedNode.innerHTML = this.oTxt[apf.hasContentEditable
                    ? "innerText"
                    : "value"];
            }
             //this.$selected.innerHTML = this.oTxt.innerHTML;
            this.rename(this.renameSubject,
                this.oTxt[apf.hasContentEditable ? "innerText" : "value"]
                .replace(/<.*?nobr>/gi, ""));
        }

        if (!this.renaming) {
            this.renameSubject    = null;
            this.replacedNode     = null;
            this.oTxt.style.width = "";
        }
        
        return true;
    };

    
    this.addEventListener("keydown", function(e){
        var key = e.keyCode;

        if (this.renaming) {
            if (key == 27 || key == 13) {
                this.stopRename(null, key == 13 && !this.$autocomplete);
                e.cancelBubble = true;
                return false;
            }

            return;
        }

        //F2
        if (key == 113) {
            if (this.$tempsel)
                this.$selectTemp();

            if (this.caret != this.selected) {
                if (this.multiselect || this.isSelected(this.caret)) {
                    this.selected  = this.caret;
                    this.$selected = this.$caret;
                }
                else
                    this.select(this.caret, true);
            }

            this.startRename();

            return false;
        }
    }, true);
    

    this.addEventListener("DOMNodeRemovedFromDocument", function(e){
        this.oTxt.refCount--;

        if (!this.oTxt.refCount) {
            this.oTxt.host        =
            this.oTxt.onmouseover =
            this.oTxt.onmousedown =
            this.oTxt.select      =
            this.oTxt.onfocus     =
            this.oTxt.onblur      = null;
        }
    });
    
    this.$init(function(){
        if (!(this.oTxt = document.getElementById("txt_rename"))) {
            if (apf.hasContentEditable) {
                this.oTxt = document.createElement("DIV");
                this.oTxt.contentEditable = true;
                if (apf.isIE6)
                    this.oTxt.style.width = "1px";
                //this.oTxt.canHaveHTML = false;
            }
            else {
                this.oTxt              = document.createElement("input");
                this.oTxt.id           = "txt_rename";
                this.oTxt.autocomplete = false;
            }
        
            
            if (apf.hasFocusBug)
                apf.sanitizeTextbox(this.oTxt);
            
        
            this.oTxt.refCount         = 0;
            this.oTxt.id               = "txt_rename";
            this.oTxt.style.whiteSpace = "nowrap";
            this.oTxt.onselectstart    = function(e){
                (e || event).cancelBubble = true;
            };
            
            //this.oTxt.host = this;
            apf.sanitizeTextbox(this.oTxt);
            
        
            this.oTxt.onmouseover = this.oTxt.onmouseout = this.oTxt.oncontextmenu =
            this.oTxt.onmousedown = function(e){ (e || event).cancelBubble = true; };
        
            this.oTxt.onkeyup = function(){
                if (!this.host.$autocomplete)
                    return;
        
                this.host.$lookup(this[apf.hasContentEditable ? "innerHTML" : "value"]);
            }
        
            this.oTxt.select = function(){
                if (!apf.hasMsRangeObject)
                    return this.focus();
        
                var r = document.selection.createRange();
                //r.moveEnd("character", this.$ext.innerText.length);
                try {
                    r.moveToElementText(this);
        
                    if (apf.isFalse(this.host.$getOption("main", "selectrename"))
                      || typeof this.host.$renameStartCollapse != "undefined") //@todo please deprecate renameStartCollapse
                        r.collapse(this.host.$renameStartCollapse);
                } catch(e) {} //BUG!!!!
        
                r.select();
            };
        
            
            if (apf.hasFocusBug) {
                this.oTxt.onfocus = function(){
                    if (apf.window)
                        apf.window.$focusfix2();
                };
            }
            
        
            this.oTxt.onblur = function(){
                if (apf.isGecko)
                    return; //bug in firefox calling onblur too much
        
                
                if (apf.hasFocusBug)
                    apf.window.$blurfix();
                
        
                if (this.host.$autocomplete)
                    return;
        
                this.host.stopRename(null, true);
            };
        }
        
        this.oTxt.refCount++;
    });
}




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/dragdrop.js)SIZE(53115)TIME(1265038878)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__DRAGDROP__ = 1 << 5;



/**
 * All elements inheriting from this {@link term.baseclass baseclass} have drag&drop 
 * features. This baseclass operates on the bound data of this element. 
 * When a rendered item is dragged and dropped the bound data is moved or 
 * copied from one element to another, or to the same element but at a different 
 * position. This is possible because the rendered item has a 
 * {@link term.smartbinding bidirectional connection} to the data. Drag&drop can 
 * be turned on with a simple boolean, or by specifying detailed rules to set 
 * which data can be dragged and dropped and where.
 *
 * Example:
 * This is a simple example, enabling drag&drop for a list.
 * <code>
 *  <a:list
 *      drag     = "true"
 *      drop     = "true"
 *      dragcopy = "true" />
 * </code>
 *
 * Example:
 * This example shows a smartbinding that represents files and folders. It uses 
 * {@link term.datainstruction data instruction} to tell communicat to the webdav
 * server when an item is copied or moved.
 * <code>
 *  <a:smartbinding>
 *      <a:bindings>
 *          <a:caption select="@filename" />
 *          <a:each select="file|folder" />
 *
 *          <a:drag select = "person" copy="event.ctrlKey" />
 *          <a:drop
 *              select         = "file"
 *              target         = "folder"
 *              action         = "tree-append"
 *              copy = "event.ctrlKey" />
 *          <a:drop
 *              select         = "folder"
 *              target         = "folder"
 *              action         = "insert-before"
 *              copy = "event.ctrlKey" />
 *      </a:bindings>
 *      <a:actions>
 *          <a:move
 *              select = "self::folder"
 *              set    = "{myWebdav.move([@path], [../@path])}" />
 *          <a:copy
 *              select = "self::file"
 *              set    = "{myWebdav.copy([@path], [../@path])}" />
 *      </a:actions>
 *  </a:smartbinding>
 * </code>
 *
 * @event  dragdata  Fires before a drag&drop operation is started to determine the data that is dragged.
 *   object:
 *   {XMLElement} data the default data for the drag&drop operation
 * @event  dragstart Fires before a drag operation is started.
 *   cancelable: Prevents the drag operation to start.
 *   object:
 *   {XMLElement}  data      the data for the drag&drop operation
 *   {XMLElement}  selection the selection at the start of the drag operation
 *   {HTMLElement} indicator the html element that is shown while dragging the data
 *   {AMLElement}  host      the aml source element.
 * @event  dragover Fires when the users drags over this aml element.
 *   cancelable: Prevents the possibility to drop.
 *   object:
 *   {XMLElement}  data      the data for the drag&drop operation
 *   {XMLElement}  selection the selection at the start of the drag operation
 *   {HTMLElement} indicator the html element that is shown while dragging the data
 *   {AMLElement}  host      the aml source element.
 * @event  dragout  Fires when the user moves away from this aml element.
 *   object:
 *   {XMLElement}  data      the data for the drag&drop operation
 *   {XMLElement}  selection the selection at the start of the drag operation
 *   {HTMLElement} indicator the html element that is shown while dragging the data
 *   {AMLElement}  host      the aml source element.
 * @event  dragdrop  Fires when the user drops an item on this aml element.
 *   cancelable: Prevents the possibility to drop.
 *   object:
 *   {XMLElement}  data      the data for the drag&drop operation
 *   {XMLElement}  selection the selection at the start of the drag operation
 *   {HTMLElement} indicator the html element that is shown while dragging the data
 *   {AMLElement}  host      the aml source element.
 *   {Boolean}     candrop   whether the data can be inserted at the point hovered over by the user
 *
 * @see element.drag
 * @see element.drop
 * @see element.dragdrop
 *
 * @define dragdrop
 * @allowchild drop, drag
 * @define drag   Determines whether a {@link term.datanode data node} can 
 * be dragged from this element. 
 * Example:
 * This example shows a small mail application. The tree element displays a root
 * node, accounts and folders in a tree. The datagrid contains the mails. This
 * rule specifies which data nodes can be dropped where. Folders can be dropped 
 * in folders and accounts. Mails can be dropped in folders.
 * <code>
 *  <a:tree align="left" width="200">
 *      <a:each match="[root|account|folder|mail]">
 *          <a:caption match="[@name]" />
 *          <a:drag match  = "[folder]" />
 *          <a:drop match  = "[folder]" 
 *                  target = "[folder|account]"
 *                  action = "tree-append" />
 *          <a:drop match  = "[mail]" 
 *                  target = "[folder]"
 *                  action = "tree-append" />
 *      </a:each>
 *      <a:model>
 *          <data>
 *              <root name="Root">
 *                  <account name="Account 1">
 *                      <folder name="Folder 1"></folder>
 *                  </account>
 *              </root>
 *           </data>
 *      </a:model>
 *  </a:tree>
 *  <a:datagrid align="right">
 *      <a:each match="[mail]">
 *          <a:column 
 *            caption = "Name" 
 *            value   = "[@name]"
 *            width   = "100%" /> 
 *          <a:drag match="[mail]" />
 *      </a:each>
 *      <a:model>
 *          <data>
 *              <mail name="Mail 1"></mail>
 *          </data>
 *      </a:model>
 *  </a:datagrid>
 * </code>
 *
 * @attribute {String} match           an xpath statement querying the
 *                                     {@link term.datanode data node} that is
 *                                     dragged. If the query matches a node it
 *                                     is allowed to be dropped. The xpath is
 *                                     automatically prefixed by 'self::'.
 * @attribute {String} copy            a javascript expression that determines
 *                                     whether the dragged element is a copy or
 *                                     a move. Use event.ctrlKey to use the Ctrl
 *                                     key to determine whether the element is copied.
 *
 * @define drop   Determines whether a {@link term.datanode data node} can 
 * be dropped on a data node bound to this element. 
 * 
 * @attribute {String} match           an xpath statement querying the
 *                                     {@link term.datanode data node} that is
 *                                     dragged. If the query matches a node it
 *                                     is allowed to be dropped. The xpath is
 *                                     automatically prefixed by 'self::'.
 * @attribute {String} target          an xpath statement determining the new
 *                                     parent of the dropped {@link term.datanode data node}.
 *                                     The xpath is automatically prefixed by 'self::'.
 * @attribute {String} action          the action to perform when the
 *                                     {@link term.datanode data node} is inserted.
 *   Possible values:
 *   tree-append    Appends the {@link term.datanode data node} to the element it's dropped on.
 *   list-append    Appends the {@link term.datanode data node} to the root element of this element.
 *   insert-before  Inserts the {@link term.datanode data node} before the elements it's dropped on.
 * @attribute {String} copy            a javascript expression that determines
 *                                     whether the drop is a copy or a move.
 *                                     Use event.ctrlKey to use the Ctrl key to
 *                                     determine whether the element is copied.
 */
/**
 * @constructor
 * @baseclass
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.5
 */
apf.DragDrop = function(){
    this.$regbase = this.$regbase | apf.__DRAGDROP__;

    this.$dragInited = false;

    /* **********************
            Actions
    ***********************/

    /**
     * Copies a {@link term.datanode data node} to the bound data of this element.
     *
     * @action
     * @param  {XMLElement} xmlNode      the {@link term.datanode data node} which is copied.
     * @param  {XMLElement} pNode        the new parent element of the copied
     *                                   {@link term.datanode data node}. If none
     *                                   specified the root element of the data
     *                                   loaded in this element is used.
     * @param  {XMLElement} [beforeNode] the position where the {@link term.datanode data node}
     *                                   is inserted.
     */
    this.copy = function(nodeList, pNode, beforeNode, isMove){
        if (nodeList.nodeType)
            nodeList = [nodeList];
        
        var exec,
            changes = [],
            i       = 0,
            l       = nodeList.length;
        for (; i < l; i++) {
            changes.push({
                func : isMove ? "moveNode" : "appendChild",
                args : [pNode, isMove
                    ? nodeList[i]
                    : nodeList[i] = nodeList[i].cloneNode(true), beforeNode]
            });
        }
        
        if (this.$actions[(isMove ? "movegroup" : "copygroup")]) {
            exec = this.$executeAction("multicall", changes, 
                (isMove ? "movegroup" : "copygroup"), nodeList[0]);
        }
        else {
            exec = this.$executeAction("multicall", changes, 
                (isMove ? "move" : "copy"), nodeList[0], null, null, 
                nodeList.length > 1 ? nodeList : null);
        }

        if (exec !== false)
            return nodeList;

        return false;
    };

    /**
     * Moves a {@link term.datanode data node} to the bound data of this element.
     *
     * @action
     * @param  {XMLElement}  xmlNode      the {@link term.datanode data node} which is copied.
     * @param  {XMLElement}  pNode        the new parent element of the moved
     *                                    {@link term.datanode data node}. If none
     *                                    specified the root element of the data
     *                                    loaded in this element is used.
     * @param  {XMLElement}  [beforeNode] the position where the
     *                                    {@link term.datanode data node} is inserted.
     */
    this.move = function(nodeList, pNode, beforeNode){
        return this.copy(nodeList, pNode, beforeNode, true);
    };

    /**
     * Determines whether the user is allowed to drag the passed 
     * {@link term.datanode data node}. The decision is made based on the 
     * {@link element.drag drag} and {@link element.drag drag} 
     * rules. These elements determine when a data node can be dropped on 
     * another data node. For instance, imagine a mail application with a root
     * node, accounts and folders in a tree, and mails in a datagrid. The rules
     * would specify you can drag&drop folders within an account, and emails between
     * folders, but not on accounts or the root.
     *
     * @param  {XMLElement} dataNode the {@link term.datanode data node} subject to the test.
     * @return {Boolean} result of the test
     * @see baseclass.dragdrop.method.isDragAllowed
     */
    this.isDragAllowed = function(x, data){
        
        if (typeof apf.offline != "undefined" && !apf.offline.canTransact())
            return false;
        

        if (this.disabled || !x || !x.length || !x[0])
            return false;

        if (this.drag || this.dragcopy) {
            if (data)
                data.merge(x);
            return true;
        }

        /*var rules = this.$bindings["drag"]
          || this.$attrBindings && this.$attrBindings["drag"];
        if (!rules || !rules.length)
            return false;*/

        var d, 
            ruleList = [],
            j        = 0,
            l        = x.length;
        for (; j < l; j++) {
            d = this.$getDataNode("drag", x[j], null, ruleList);
            if (!d) return false; //It's all or nothing
            if (data)
                data.push(d);
        }

        return ruleList.length ? ruleList : false;
    };

    /**
     * Determines whether the user is allowed to dropped the passed 
     * {@link term.datanode data node}. The decision is made based on the 
     * {@link element.drag drag} and {@link element.drag drag} 
     * rules. These elements determine when a data node can be dropped on 
     * another data node. For instance, imagine a mail application with a root
     * node, accounts and folders in a tree, and mails in a datagrid. The rules
     * would specify you can drag&drop folders within an account, and emails between
     * folders, but not on accounts or the root.
     *
     * @param  {XMLElement} dataNode the {@link term.datanode data node} subject
     *                               to the test.
     * @param  {XMLElement} target   the {@link term.datanode data node} on which
     *                               the dragged data node is dropped.
     * @return {Boolean} result of the test
     * @see baseclass.dragdrop.method.isDragAllowed
     */
    this.isDropAllowed = function(x, target){
        
        if(typeof apf.offline != "undefined" && !apf.offline.canTransact())
            return false;
        

        if (this.disabled || !x || !x.length || !target) //!x[0] ???
            return false;

        var data, tgt, hasDropRule = this.$attrBindings && this.$attrBindings["drop"];
        if (this.drop && (!hasDropRule || hasDropRule.value == "true")) {
            this.$setDynamicProperty("drop", this.hasFeature(apf.__MULTISELECT__)
              ? "[" + this.each + "]"
              : "[node()]"); //@todo apf3.0 make sure each is without {}
            hasDropRule = true;
        }

        if (hasDropRule) {
            for (var j = 0, l = x.length; j < l; j++) {
                data = this.$getDataNode("drop", x[j]);
                if (!data)
                    break;
            }
            if (j == l && target && !apf.isChildOf(data, target, true))
                return [target, null];
        }

        var rules = this.$bindings["drop"];
        if (!rules || !rules.length)
            return false;

        //@todo this can be optimized when needed
        var rule, strTgt,
            i  = 0,
            rl = rules.length;
        for (; i < rl; i++) {
            rule = this.$bindings.getRuleIndex("drop", i);

            for (var j = 0, l = x.length; j < l; j++) {
                data = rule.cvalue ? rule.cvalue(x[j]) : rule.cmatch(x[j]);
                if (!data)
                    break;
            }
            if (j != l)
                continue;
            
            strTgt = rule.target;//node.getAttribute("target");
            if (!strTgt || strTgt == ".") {
                //op = node.getAttribute("action") 
                  //|| (this.$isTreeArch ? "tree-append" : "list-append");
                tgt = target;/*(op == "list-append" || target == this.xmlRoot
                  ? this.xmlRoot
                  : null);*/
            }
            else {
                tgt = (rule.ctarget || rule.compile("target"))(target);
            }
            
            if (tgt && !apf.isChildOf(data, tgt, true))
                return [tgt, rule];
        }

        return false;
    };

    this.$dragDrop = function(xmlReceiver, xmlNodeList, rule, defaction, isParent, srcRule, event){
        // @todo apf3.0 action not known here yet... should be moved down?
        if (action == "tree-append" && isParent) 
            return false;

        /*
            Possibilities:

            tree-append [default]: xmlNode.appendChild(movedNode);
            list-append          : xmlNode.parentNode.appendChild(movedNode);
            insert-before        : xmlNode.parentNode.insertBefore(movedNode, xmlNode);
        */
        var action = rule && rule.action;//node && node.getAttribute("action");

        if (action)
            action = (rule.caction || rule.compile("action"))(xmlNodeList[0]);
        else
            action = defaction;

        //copy convenience variables
        var context = {
              internal : apf.DragServer.dragdata.host == this,
              ctrlKey  : event.ctrlKey,
              keyCode  : event.keyCode
          },
          //@todo apf3.0 below should actually be compileNode with with_options
          ifcopy = rule && rule.copy;//.getAttribute("copy");

        if (ifcopy) {
            ifcopy = !apf.isFalse((rule.ccopy || rule.compile("copy"))(xmlNodeList[0], context));
        }
        else if (typeof this.dragcopy == "boolean" || typeof this.dropcopy == "boolean") { //@todo apf3.0 boolean here?
            if (this.dropcopy) {
                ifcopy = this.dropcopy;
            }
            else if (this.dragcopy) {
                ifcopy = event.ctrlKey;
            }
            else {
                //@todo read this from src
                var copyRule = this.$attrBindings && this.$attrBindings["dragcopy"];
                if (copyRule) {
                    ifcopy = !apf.isFalse((copyRule.cvalue2
                      || copyRule.compile("value", {
                        withopt : true
                      }))(xmlNodeList[0], context));
                }
            }
        }

        if (!ifcopy) { //Implemented one copy is all copy
            for (var i = 0, l = srcRule.length; i < l; i++) {
                ifcopy = typeof srcRule[i] == "object" && srcRule[i].copy
                    ? !apf.isFalse((srcRule[i].ccopy || srcRule[i].compile("copy"))(xmlNodeList[0], context))
                    : event.ctrlKey;
                if (ifcopy) break;
            }
        }

        var sNode,
            actRule     = ifcopy ? "copy" : "move",
            parentXpath = rule ? rule.getAttribute("parent") : null; //@todo apf3.0 Should be lm syntax
        switch (action) {
            case "list-append":
                xmlReceiver = (isParent 
                  ? xmlReceiver
                  : this.getTraverseParent(xmlReceiver));
                if (parentXpath) {
                    if (xmlReceiver.selectSingleNode(parentXpath))
                        xmlReceiver = xmlReceiver.selectSingleNode(parentXpath);
                    else {
                        xmlReceiver.appendChild(xmlReceiver.ownerDocument.createElement(parentXpath));
                        xmlReceiver = xmlReceiver.selectSingleNode(parentXpath);
                    }
                }
                sNode = this[actRule](xmlNodeList, xmlReceiver);
                break;
            case "insert-before":
                sNode = isParent
                    ? this[actRule](xmlNodeList, xmlReceiver)
                    : this[actRule](xmlNodeList, xmlReceiver.parentNode, xmlReceiver);
                break;
            case "tree-append":
                if (parentXpath) {
                    if (xmlReceiver.selectSingleNode(parentXpath))
                        xmlReceiver = xmlReceiver.selectSingleNode(parentXpath);
                    else {
                        xmlReceiver.appendChild(xmlReceiver.ownerDocument.createElement(parentXpath));
                        xmlReceiver = xmlReceiver.selectSingleNode(parentXpath);
                    }
                }
                sNode = this[actRule](xmlNodeList, xmlReceiver);
                break;
        }

        if (this.selectable && sNode) {
            this.selectList(sNode);//, null, null, null, true);
            this.setCaret(sNode[0]);
            this.focus();
        }

        return sNode;
    };

    /* **********************
            Init
    ***********************/

    /**
     * Loads the dragdrop rules from the dragdrop element
     *
     * @param  {Array}      rules     the rules array created using {@link core.apf.method.getrules}
     * @param  {XMLElement} [node] the reference to the dragdrop element
     * @see  SmartBinding
     * @private
     */
    this.enableDragDrop = function(){
        
        apf.console.info("Initializing Drag&Drop for " + this.localName
            + "[" + (this.name || '') + "]");
        

        //Set cursors
        //SHOULD come from skin
        this.icoAllowed = "";//this.xmlDragDrop.getAttribute("allowed");
        this.icoDenied  = "";//this.xmlDragDrop.getAttribute("denied");

        //Setup External Object
        this.$ext.dragdrop = false;

        var _self = this;

        this.$ext[apf.isIphone ? "ontouchstart" : "onmousedown"] = function(e){
            e = e || window.event;
            
            if (apf.isIphone) {
                if (e.touches.length == 1) return;
                var old_e = e;
                e = e.touches[0];
                var pos = apf.getAbsolutePosition(e.target, this);
                e.offsetX = pos[0];
                e.offsetY = pos[1];
            }
            

            var fEl,
                srcEl       = e.originalTarget || e.srcElement || e.target,
                multiselect = _self.hasFeature(apf.__MULTISELECT__);
            if (multiselect && srcEl == _self.$int)
                return;
            _self.dragging = 0;

            if (!apf.isIphone && _self.allowdeselect
              && (srcEl == this || srcEl.getAttribute(apf.xmldb.htmlIdTag)))
                return _self.clearSelection(); //@todo hacky - should detect what element has the select from the skin

            //MultiSelect must have carret behaviour AND deselect at clicking white
            if (_self.$findValueNode)
                fEl = _self.$findValueNode(srcEl);
            var el = (fEl
                ? apf.xmldb.getNode(fEl)
                : apf.xmldb.findXmlNode(srcEl));
            if (multiselect && (!_self.selected || !el || el == _self.xmlRoot))
                return;

            if (_self.isDragAllowed(multiselect ? _self.$getSelection() : el)) {
                
                if (apf.isIphone)
                    old_e.preventDefault();
                
                
                apf.DragServer.start(_self, srcEl, e);
            }

            //e.cancelBubble = true;
        };

        this.$ext[apf.isIphone ? "ontouchmove" : "onmousemove"] = function(e){
            if (this.host.dragging != 1) return;
        };

        
        if (apf.isIphone) {
            this.$ext.ontouchend = this.$ext.ontouchcancel = function(){
                this.host.dragging = 0;
            };
        }
        else 
        
        {
            this.$ext.onmouseup = function(){
                this.host.dragging = 0;
            };

            this.$ext.ondragcopy  =
            this.$ext.ondragstart = function(){ return false; };
        }

        if (document.elementFromPointAdd)
            document.elementFromPointAdd(this.$ext);

        if (this.$initDragDrop && !this.$dragInited) {
            this.$initDragDrop();
            this.$dragInited = 2;
        }
        else {
            this.$dragInited = true;
        }
    };
    
    function disableDragDrop(){
        this.$dragInited = false; //@todo solve oExt event conflicts
        
        
        if (apf.isIphone) {
            this.$ext.ontouchstart = this.$ext.ontouchmove
                = this.$ext.ontouchend = this.$ext.ontouchcancel = null;
        }
        else 
        
        {
            this.$ext.onmousedown = this.$ext.onmousemove
                = this.$ext.onmouseup = null;
        }

        if (document.elementFromPointRemove)
            document.elementFromPointRemove(this.$ext);
    }
    
    this.implement(
      
      this.hasFeature(apf.__MULTISELECT__)
        ? apf.MultiselectDragDrop : 
      
        apf.StandardDragDrop);
    
    //this.$booleanProperties["drag"]     = true;
    //this.$booleanProperties["dragcopy"] = true;
    this.$supportedProperties.push("drop", "drag", "dragcopy");

    /**
     * @attribute  {Boolean}  drag       whether the element allows dragging of it's items.
     * Example:
     * <code>
     *  <a:list drag="true">
     *      <a:item>item 1</a:item>
     *      <a:item>item 2</a:item>
     *      <a:item>item 3</a:item>
     *  </a:list>
     * </code>
     * @attribute  {Boolean}  dragcopy   whether dragged items are copied.
     * Example:
     * <code>
     *  <a:list 
     *    drag    = "true" 
     *    align   = "right" 
     *    height  = "300" 
     *    caption = "[@name]" 
     *    each    = "[mail]">
     *      <a:model>
     *          <data>
     *              <mail name="Mail 1"></mail>
     *              <mail name="Mail 2"></mail>
     *              <mail name="Mail 3"></mail>
     *          </data>
     *      </a:model>
     *  </a:list>
     * </code>
     * Example:
     * Items are only copied when the user holds the Ctrl key
     * <code>
     *  <a:list dragcopy="[ctrlKey]">
     *      <a:item>item 1</a:item>
     *      <a:item>item 2</a:item>
     *      <a:item>item 3</a:item>
     *  </a:list>
     * </code>
     * @attribute  {Boolean}  drop       whether the element allows items to be dropped.
     * Example:
     * <code>
     *  <a:list drop="true">
     *      <a:item>item 1</a:item>
     *      <a:item>item 2</a:item>
     *      <a:item>item 3</a:item>
     *  </a:list>
     * </code>
     * @attribute  {String}   dragdrop          the name of the dragdrop element for this element.
     * <code>
     *  <a:tree align="left" width="200" height="300">
     *      <a:each match="[root|account|folder|mail]">
     *          <a:caption match  = "[@name]" />
     *          <a:drag    match  = "[folder|mail]" />
     *          <a:drop    match  = "[folder]" 
     *                     target = "[folder|account]"
     *                     action = "tree-append" />
     *           <a:drop   match  = "[mail]" 
     *                     target = "[folder]"
     *                     action = "tree-append" />
     *      </a:each>
     *      <a:model>
     *          <data>
     *              <root name="Root">
     *                  <account name="Account 1">
     *                      <folder name="Folder 1">
     *                          <mail name="Mail drag drop"></mail>
     *                      </folder>
     *                  </account>
     *              </root>
     *          </data>
     *      </a:model>
     *  </a:tree>
     * 
     *  <a:list bindings="bndDragdrop" align="right">
     *      <a:model>
     *          <data>
     *              <mail name="Mail 1"></mail>
     *              <mail name="Mail 2"></mail>
     *              <mail name="Mail 3"></mail>
     *          </data>
     *      </a:model>
     *  </a:list>
     * 
     *  <a:bindings id="bndDragdrop">
     *      <a:caption match="[@name]" />
     *      <a:each match="[mail]" />
     *      <a:drag match = "[mail]" />
     *      <a:drop
     *        match = "[mail]"
     *        action = "list-append" />
     *   </a:bindings>
     * </code>
     */
    this.$propHandlers["dragcopy"] =
    this.$propHandlers["dropcopy"] =
    this.$propHandlers["drag"]     =
    this.$propHandlers["drop"]     = function(value, prop){
        this[prop] = apf.isTrue(value);

        if (this.$dragInited && prop == "drag" && value && this.$dragInited != 2) {
            this.$initDragDrop();
            this.$dragInited = 2;
            return;
        }

        if (prop == "dragcopy" || prop == "dropcopy")
            return;
        
        if (!value && !this.drag && !this.drop && !this.$bindings 
          && (this.$attrBindings && (!this.$attrBindings["drag"] || !this.$attrBindings["drop"])))
            disableDragDrop.call(this);
        else if (value && !this.$dragInited)
            this.enableDragDrop();
    };

    this.addEventListener("DOMNodeRemovedFromDocument", function(e){
        disableDragDrop.call(this);
        
        if (this.oDrag) {
            apf.destroyHtmlNode(this.oDrag);
            this.oDrag = null;
        }
    });
};

apf.GuiElement.propHandlers["dragcopy"] =
apf.GuiElement.propHandlers["dropcopy"] =
apf.GuiElement.propHandlers["drop"]     =
apf.GuiElement.propHandlers["drag"]     = function(value, prop) {
    if (!apf.isFalse(value)) {
        if (!this.hasFeature(apf.__DRAGDROP__)) {
            this.implement(apf.DragDrop);
            this.enableDragDrop();
        }
        
        this[prop] = apf.isTrue(value);
    }
};

/**
 * Central object for dragdrop handling.
 * @private
 */
apf.DragServer = {
    Init : function(){
        
        if (apf.isIphone) {
            this.ontouchmove = this.onmousemove;
            this.ontouchend = this.ontouchcancel = this.onmouseup;
        }
        

        apf.addEventListener("hotkey", function(e){
            if (apf.window.dragging && e.keyCode == 27) {
                if (document.body.lastHost && document.body.lastHost.dragOut)
                    document.body.lastHost.dragOut(apf.dragHost);

                return apf.DragServer.stopdrag();
            }
        });
    },

    start : function(amlNode, srcEl, e){
        if (document.elementFromPointReset)
            document.elementFromPointReset();
        
        amlNode.dragging = 1;

        var d = window.document;
        d = (!d.compatMode || d.compatMode == 'CSS1Compat') 
            ? d.html || d.documentElement
            : d.body

        var scrollX = (apf.isIE ? d.scrollLeft : window.pageXOffset),
            scrollY = (apf.isIE ? d.scrollTop  : window.pageYOffset),
            oParent = amlNode.$ext.offsetParent,
            pos
        while (oParent && oParent != d && oParent.tagName != "BODY") {
            scrollX -= oParent.scrollLeft;
            scrollY -= oParent.scrollTop;
            oParent = oParent.offsetParent;
        }

        //The coordinates need to be relative to the html element that 
        //represents the xml data node.
        var loopEl = srcEl, lastId;
        while (loopEl && loopEl.nodeType == 1 
          && !(lastId = loopEl.getAttribute(apf.xmldb.htmlIdTag))) {
            loopEl = loopEl.parentNode;
        }
        if (!lastId)
            return;
        pos = apf.getAbsolutePosition(loopEl);

        //Set coordinates object
        apf.DragServer.coordinates = {
            srcElement : srcEl,
            doc        : d,
            scrollX    : scrollX,
            scrollY    : scrollY,
            offsetX    : e.clientX - pos[0], 
            offsetY    : e.clientY - pos[1], 
            clientX    : e.pageX ? e.pageX - window.pageXOffset : e.clientX,
            clientY    : e.pageY ? e.pageY - window.pageYOffset : e.clientY
        };
        
        //Create Drag Data Object
        var selection = amlNode.hasFeature(apf.__MULTISELECT__) 
                ? amlNode.getSelection()
                : [amlNode.xmlRoot],
            data      = [],
            srcRules  = amlNode.isDragAllowed(selection, data);
        if (!srcRules) return;

        if (amlNode.hasEventListener("dragdata"))
            data = amlNode.dispatchEvent("dragdata", {data : data});
        
        /*for(var i = 0, l = data.length; i < l; i++) {
            data[i] = apf.getCleanCopy(data[i]);
        }*/

        this.dragdata = {
            rules       : srcRules,
            selection   : selection,
            data        : data,
            indicator   : amlNode.$showDragIndicator(selection, this.coordinates),
            host        : amlNode
        };

        //EVENT - cancelable: ondragstart
        if (amlNode.dispatchEvent("dragstart", this.dragdata) === false)
            return false;//(this.amlNode.$tempsel ? select(this.amlNode.$tempsel) : false);
        
        amlNode.dragging = 2;

        apf.dragMode         = true;
        document.onmousemove = this.onmousemove;
        document.onmouseup   = this.onmouseup;
    },

    stop : function(runEvent, success){
        if (this.last) this.dragout();

        //Reset Objects
        this.dragdata.host.dragging = 0;
        this.dragdata.host.$hideDragIndicator(success);

        /*if (runEvent && this.dragdata.host.$dragstop) 
            this.dragdata.host.$dragstop();*/

        apf.dragMode         = false;
        document.onmousemove = 
        document.onmouseup   = null;
        
        this.dragdata = null;
    },

    dragover : function(o, el, e){
        e = e || window.event;

        //@todo optimize by not checking the same node dragged over twice in a row
        var fEl;
        if (o.$findValueNode)
            fEl = o.$findValueNode(el);

        if (this.lastFel && this.lastFel == fEl 
          || !this.lastFel && this.last == o) //optimization
            return;

        //Check Permission
        var elSel = (fEl
                ? apf.xmldb.getNode(fEl)
                : apf.xmldb.findXmlNode(el)),
            candrop = o.isDropAllowed && o.xmlRoot
                ? o.isDropAllowed(this.dragdata.data, elSel || o.xmlRoot)
                : apf.isTrue(apf.getInheritedAttribute(o, "", function(p){
                      if (p.drop) {
                          o = p;
                          if (o == apf.DragServer.last)
                            return false;
                          return true;
                      }
                   }));

        if (this.last && this.last != o)
            this.dragout(this.last);
            
        if (!candrop)
            return;

        //EVENT - cancelable: ondragover
        if (o.dispatchEvent("dragover", this.dragdata) === false)
            candrop = false;

        //Set Cursor
        var srcEl = e.originalTarget || e.srcElement || e.target;
        /*srcEl.style.cursor = (candrop ? o.icoAllowed : o.icoDenied);
        if (srcEl.onmouseout != this.m_out) {
            srcEl.$onmouseout = srcEl.onmouseout;
            srcEl.onmouseout   = this.m_out;
        }
        o.$ext.style.cursor = (candrop ? o.icoAllowed : o.icoDenied);*/

        //REQUIRED INTERFACE: __dragover()
        if (o && o.$dragover)
            o.$dragover(el, this.dragdata, candrop);

        this.last = o;
        this.lastFel = fEl;
    },

    dragout : function(o){
        //if (this.last == o) 
            //return false;

        this.lastFel = null;

        //EVENT: ondragout
        if (o)
            o.dispatchEvent("dragout", this.dragdata);

        //REQUIRED INTERFACE: __dragout()
        if (this.last && this.last.$dragout)
            this.last.$dragout(null, this.dragdata);

        //Reset Cursor
        //o.$ext.style.cursor = "default";
        this.last = null;
    },

    dragdrop : function(o, el, srcO, e){
        //Check Permission
        var isParent, lastTop,
            elSel   = (o.$findValueNode
              ? apf.xmldb.getNode(o.$findValueNode(el))
              : apf.xmldb.findXmlNode(el)),
            candrop = (o.isDropAllowed && o.xmlRoot)
                ? o.isDropAllowed(this.dragdata.data, elSel || o.xmlRoot) : false;
         
        if (this.dragdata.indicator) {
            lastTop = this.dragdata.indicator.style.top;
            this.dragdata.indicator.style.top = "10000px";
        }
         
        if (!candrop) 
            candrop = apf.isTrue(apf.getInheritedAttribute(o, "", function(p){
              if (p.drop) {
                  o = p;
                  return true;
              }
            }));

        //EVENT - cancelable: ondragdrop
        if (candrop) {
            if (o.dispatchEvent("dragdrop", apf.extend({candrop : candrop, htmlEvent : e, top: lastTop},
              this.dragdata)) === false) {
                candrop = false;
            }
            else {
                if (!o.xmlRoot) {
                    var m = o.getModel 
                      ? o.getModel(true) 
                      : apf.nameserver.get("model", o.model)
                    if (m)
                        m.load(this.dragdata.data[0])
                    //else warn??
                    return true;
                }
                else {
                    var action = candrop[1]
                        && candrop[1].action
                        || (o.$isTreeArch ? "tree-append" : "list-append");
                    if (action == "list-append" && (!o.$isTreeArch && o == this.dragdata.host))
                        candrop = false;
                }
            }
        }
        
        if (this.dragdata.indicator)
            this.dragdata.indicator.style.top = lastTop;

        //Exit if not allowed
        if (!candrop) {
            this.dragout(o);
            return false;
        }

        if (o.$dragDrop) {
            //Move XML
            var rNode = o.$dragDrop(candrop[0], this.dragdata.data, candrop[1],
                action, isParent || candrop[0] == o.xmlRoot, this.dragdata.rules, e);
            this.dragdata.resultNode = rNode;
        }
        
        if (o.$dragdrop) {
            o.$dragdrop(el, apf.extend({
                htmlEvent : e,
                xmlNode   : rNode
            }, this.dragdata), candrop);
        }

        //Reset Cursor
        //o.$ext.style.cursor = "default";
        this.last    = null;
        this.lastFel = null;
        
        return true;
    },

    /* **********************
        Mouse Movements
    ***********************/

    onmousemove : function(e){
        if (!apf.DragServer.dragdata) return;
        e = e || window.event;
        
        if (apf.isIphone) {
            e.preventDefault();
            if (!e.touches)
                return apf.DragServer.stop(true);
            e = e.touches[0];
        }
        
        
        var dragdata = apf.DragServer.dragdata,
            c = {
                clientX: e.pageX ? e.pageX - window.pageXOffset : e.clientX,
                clientY: e.pageY ? e.pageY - window.pageYOffset : e.clientY
            };

        if (!dragdata.started
          && Math.abs(apf.DragServer.coordinates.clientX - c.clientX) < 6
          && Math.abs(apf.DragServer.coordinates.clientY - c.clientY) < 6)
            return;

        if (!dragdata.started) {
            if (dragdata.host.$dragstart)
                dragdata.host.$dragstart(null, dragdata);
            dragdata.started = true;
        }
        
        //dragdata.indicator.style.top = e.clientY+"px";
        //dragdata.indicator.style.left = e.clientX+"px";

        var storeIndicatorTopPos = dragdata.indicator.style.top;
        //console.log("INDICATOR BEFORE: "+dragdata.indicator.style.top+" "+dragdata.indicator.style.left);
        //get Element at x, y
        dragdata.indicator.style.display = "block";
        if (dragdata.indicator)
            dragdata.indicator.style.top = "10000px";

        apf.DragServer.dragdata.x = e.pageX ? e.pageX - (apf.isGecko
            ? window.pageXOffset
            : 0) : c.clientX;
        apf.DragServer.dragdata.y = e.pageY ? e.pageY - (apf.isGecko
            ? window.pageYOffset
            : 0) : c.clientY;
        var el = document.elementFromPoint(apf.DragServer.dragdata.x,
            apf.DragServer.dragdata.y);

        dragdata.indicator.style.top = storeIndicatorTopPos;
        //console.log("INDICATOR AFTER: "+dragdata.indicator.style.top+" "
        //+dragdata.indicator.style.left+" "+apf.DragServer.dragdata.x+" "+apf.DragServer.dragdata.y);
        //Set Indicator
        dragdata.host.$moveDragIndicator(c);

        //get element and call events
        var receiver = apf.findHost(el);

        //Run Events
        if (receiver)
            apf.DragServer.dragover(receiver, el, e);
        else if (apf.DragServer.last)
            apf.DragServer.dragout(apf.DragServer.last);


        apf.DragServer.lastTime = new Date().getTime();
    },

    onmouseup : function(e){
        e = e || window.event;
        
        if (apf.isIphone) {
            e.preventDefault();
            if (!e.changedTouches)
                return apf.DragServer.stop(true);
            e = e.changedTouches[0];
        }
        

        var c = {
            clientX: e.pageX ? e.pageX - window.pageXOffset : e.clientX,
            clientY: e.pageY ? e.pageY - window.pageYOffset : e.clientY
        };

        if (!apf.DragServer.dragdata.started
          && Math.abs(apf.DragServer.coordinates.clientX - c.clientX) < 6
          && Math.abs(apf.DragServer.coordinates.clientY - c.clientY) < 6) {
            apf.DragServer.stop(true)
            return;
        }

        //get Element at x, y
        var indicator            = apf.DragServer.dragdata.indicator,
            storeIndicatorTopPos = indicator.style.top;
        //apf.console.info("INDICATOR UP BEFORE: "+indicator.style.top+" "+indicator.style.left);
        if (indicator)
            indicator.style.top = "10000px";

        apf.DragServer.dragdata.x = e.pageX ? e.pageX - (apf.isGecko
            ? window.pageXOffset
            : 0) : c.clientX;
        apf.DragServer.dragdata.y = e.pageY ? e.pageY - (apf.isGecko
            ? window.pageYOffset
            : 0) : c.clientY;

        var el = document.elementFromPoint(apf.DragServer.dragdata.x,
            apf.DragServer.dragdata.y);

        indicator.style.top = storeIndicatorTopPos;
        //apf.console.info("INDICATOR UP AFTER: "+indicator.style.top+" "+indicator.style.left);

        //get element and call events
        var host = apf.findHost(el);

        //Run Events
        if (apf.DragServer.host && host != apf.DragServer.host)
            apf.DragServer.dragout(apf.DragServer.host);
        var success = apf.DragServer.dragdrop(host, el, apf.DragServer.dragdata.host, e);
        apf.DragServer.stop(true, success);
    }
};

/**
 * @private
 */
apf.MultiselectDragDrop = function() {
    /**** Drag & Drop ****/
    
    this.diffX        =
    this.diffY        = 0;
    this.multiple     = false;
    this.lastDragNode = null;
    this.lastel       = null;

    this.$showDragIndicator = function(sel, e){
        this.multiple = sel.length > 1;
        
        if (this.multiple) {
            this.diffX = e.scrollX;
            this.diffY = e.scrollY;
        }
        else {
            this.diffX = -1 * e.offsetX;
            this.diffY = -1 * e.offsetY;
        }
        
        var prefix = this.oDrag.className.split(" ")[0]
        this.$setStyleClass(this.oDrag, this.multiple
            ? prefix + "_multiple" : "", [prefix + "_multiple"]);

        if (this.multiple) {
            document.body.appendChild(this.oDrag);
            return this.oDrag;
        }
        else if (this.localName == "datagrid") {
            if (this.lastDragNode)
                apf.destroyHtmlNode(this.lastDragNode);

            sel = this.$selected || this.$caret;
            var oDrag = sel.cloneNode(true);
            oDrag.removeAttribute("onmousedown"); oDrag.onmousedown = null;
            oDrag.removeAttribute("onmouseup"); oDrag.onmouseup = null;
            oDrag.removeAttribute("onmouseout"); oDrag.onmouseout = null;
            oDrag.removeAttribute("ondblclick"); oDrag.ondblclick = null;
            document.body.appendChild(oDrag);
            
            oDrag.style.position = "absolute";
            oDrag.style.width    = sel.offsetWidth + "px";
            oDrag.style.display  = "none";
            oDrag.style.zIndex   = 10000000;
            oDrag.removeAttribute("id");
            this.$setStyleClass(oDrag, "draggrid");
            var nodes = sel.childNodes;
            var dragnodes = oDrag.childNodes;
            for (var i = nodes.length - 1; i >= 0; i--) {
                if (dragnodes[i].nodeType == 1)
                    dragnodes[i].style.width = apf.getStyle(nodes[i], "width");
            }
            //@todo apf3.0 remove all the event handlers of the children.
            return (this.lastDragNode = oDrag);
        }
        else {
            this.$updateNode(this.selected, this.oDrag);
        }
        
        return this.oDrag;
    };
    
    this.$hideDragIndicator = function(success){
        var oDrag = this.lastDragNode || this.oDrag, _self = this;
        if (!this.multiple && !success && oDrag.style.display == "block") {
            var pos = apf.getAbsolutePosition(this.$selected || this.$caret);
            apf.tween.multi(oDrag, {
                anim     : apf.tween.EASEIN,
                steps    : 15,
                interval : 10,
                tweens   : [
                    {type: "left", from: oDrag.offsetLeft, to: pos[0]},
                    {type: "top",  from: oDrag.offsetTop,  to: pos[1]}
                ],
                onfinish : function(){
                    if (_self.lastDragNode) {
                        apf.destroyHtmlNode(_self.lastDragNode);
                        _self.lastDragNode = null;
                    }
                    else {
                        _self.oDrag.style.display = "none";
                    }
                }
            });
        }
        else if (this.lastDragNode) {
            apf.destroyHtmlNode(this.lastDragNode);
            this.lastDragNode = null;
        }
        else {
            this.oDrag.style.display = "none";
        }
    };
    
    this.$moveDragIndicator = function(e){
        var oDrag = this.lastDragNode || this.oDrag;
        oDrag.style.left = (e.clientX + this.diffX) + "px";// - this.oDrag.startX
        oDrag.style.top  = (e.clientY + this.diffY + (this.multiple ? 15 : 0)) + "px";// - this.oDrag.startY
    };
    
    this.$initDragDrop = function(){
        if (!this.$hasLayoutNode("dragindicator")) 
            return;

        this.oDrag = apf.insertHtmlNode(
            this.$getLayoutNode("dragindicator"), document.body);

        this.oDrag.style.zIndex   = 1000000;
        this.oDrag.style.position = "absolute";
        this.oDrag.style.cursor   = "default";
        this.oDrag.style.display  = "none";
    };

    this.$findValueNode = function(el){
        if (!el) return null;

        while(el && el.nodeType == 1 
          && !el.getAttribute(apf.xmldb.htmlIdTag)) {
            if (this.$isTreeArch && el.previousSibling 
              && el.previousSibling.nodeType == 1) //@todo hack!! apf3.0 fix this.
                el = el.previousSibling;
            else
                el = el.parentNode;
        }

        return (el && el.nodeType == 1 && el.getAttribute(apf.xmldb.htmlIdTag)) 
            ? el 
            : null;
    };
    

    this.$dragout  = function(el, dragdata, extra){
        if (this.lastel)
            this.$setStyleClass(this.lastel, "", ["dragDenied", "dragInsert",
                "dragAppend", "selected", "indicate"]);
        
        var sel = this.$getSelection(true);
        for (var i = 0, l = sel.length; i < l; i++) 
            this.$setStyleClass(sel[i], "selected", ["dragDenied",
                "dragInsert", "dragAppend", "indicate"]);
        
        this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Drop"]);
        
        this.lastel = null;
    };
    
    if (!this.$dragdrop)
        this.$dragdrop = this.$dragout;

    this.$dragover = function(el, dragdata, extra){
        this.$setStyleClass(this.$ext, this.$baseCSSname + "Drop");
        
        var sel = this.$getSelection(true);
        for (var i = 0, l = sel.length; i < l; i++) 
            this.$setStyleClass(sel[i], "", ["dragDenied",
                "dragInsert", "dragAppend", "selected", "indicate"]);
        
        if (this.lastel)
            this.$setStyleClass(this.lastel, "", ["dragDenied",
                "dragInsert", "dragAppend", "selected", "indicate"]);

        var action = extra[1] && extra[1].action;
        this.lastel = this.$findValueNode(el);
        if (this.$isTreeArch && action == "list-append") {
            var htmlNode = apf.xmldb.findHtmlNode(this.getTraverseParent(apf.xmldb.getNode(this.lastel)), this);
            
            this.lastel = htmlNode
                ? this.$getLayoutNode("item", "container", htmlNode)
                : this.$int;
            
            this.$setStyleClass(this.lastel, "dragInsert");
        }
        else {
            this.$setStyleClass(this.lastel, extra
                ? (action == "insert-before" 
                    ? "dragInsert" 
                    : "dragAppend") 
                : "dragDenied");
        }
    };
    
};

/**
 * @private
 */
apf.StandardDragDrop = function() {
    this.$showDragIndicator = function(sel, e){
        var x = e.offsetX + 22,
            y = e.offsetY;
        
        this.oDrag.startX = x;
        this.oDrag.startY = y;
        
        
        document.body.appendChild(this.oDrag);
        //this.oDrag.getElementsByTagName("DIV")[0].innerHTML = this.selected.innerHTML;
        //this.oDrag.getElementsByTagName("IMG")[0].src = this.selected.parentNode.parentNode.childNodes[1].firstChild.src;
        var oInt = this.$getLayoutNode("main", "caption", this.oDrag);
        if (oInt.nodeType != 1) 
            oInt = oInt.parentNode;
        
        oInt.innerHTML = this.$applyBindRule("caption", this.xmlRoot) || "";
        
        return this.oDrag;
    };
    
    this.$hideDragIndicator = function(){
        this.oDrag.style.display = "none";
    };
    
    this.$moveDragIndicator = function(e){
        this.oDrag.style.left = (e.clientX - this.oDrag.startX
            + document.documentElement.scrollLeft) + "px";
        this.oDrag.style.top  = (e.clientY - this.oDrag.startY
            + document.documentElement.scrollTop) + "px";
    };
    
    //@todo falsely assuming only attributes are used for non multiselect widgets
    this.$initDragDrop = function(){
        if (!this.getAttribute("drag"))
            return;
        
        this.oDrag = document.body.appendChild(this.$ext.cloneNode(true));
        
        this.oDrag.style.zIndex     = 1000000;
        this.oDrag.style.position   = "absolute";
        this.oDrag.style.cursor     = "default";
        this.oDrag.style.filter     = "progid:DXImageTransform.Microsoft.Alpha(opacity=50)";
        this.oDrag.style.MozOpacity = 0.5;
        this.oDrag.style.opacity    = 0.5;
        this.oDrag.style.display    = "none";
    };
};

apf.DragServer.Init();




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/multicheck.js)SIZE(14281)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__MULTICHECK__ = 1 << 22;



/**
 * All elements inheriting from this {@link term.baseclass baseclass} have checkable items.
 *
 * @constructor
 * @baseclass
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       3.0
 *
 * @todo type detection, errors (see functions in multiselect)
 */
apf.MultiCheck = function(){
    this.$regbase    = this.$regbase | apf.__MULTICHECK__;

    /**** Properties ****/

    this.multicheck  = true;
    this.checklength = 0;
    this.checkedList = [];

    /**** Public Methods ****/
    
    /**
     * Checks a single, or set of.
     * The checking can be visually represented in this element.
     * The element can be checked, partialy checked or unchecked
     *
     * @param {mixed}   xmlNode      the identifier to determine the selection.
     * @return  {Boolean}  whether the selection could not be made
     *
     * @event  beforecheck  Fires before a check is made
     *
     * @event  aftercheck  Fires after a check is made
     *
     */
    this.check = function(xmlNode){ 
        if (this.disabled || this.checkedList.indexOf(xmlNode) > -1)
            return;
        
        if (this.dispatchEvent("beforecheck", {xmlNode : xmlNode}) === false)
            return false;
        
        if (!this.multicheck && this.checkedList.length)
            this.clearChecked(true);

        this.checkedList.push(xmlNode);
        
        
        if (this.$isTreeArch) {
            //Children
            var nodes = xmlNode.selectNodes(".//" 
                + this.each.split("|").join("|.//"));
        
            this.checkList(nodes, null, true, true);
            
            //Parents
            var all, pNode = this.getTraverseParent(xmlNode);
            while(pNode && pNode != this.xmlRoot) {
                nodes = this.getTraverseNodes(pNode);
                
                all = true;
                for (var i = 0; i < nodes.length; i++) {
                    if (this.checkedList.indexOf(nodes[i]) == -1) {
                        all = false;
                        break;
                    }
                }
                
                apf.setStyleClass(apf.xmldb.getHtmlNode(pNode, this), 
                    all ? "checked"
                        : "partial", ["partial", "checked"]);
                
                if (all) //logical assumption that parent cannot be selected at this point
                    this.checkedList.push(pNode);
                
                pNode = this.getTraverseParent(pNode);
            }
        }
        

        this.$setStyleClass(apf.xmldb.getHtmlNode(xmlNode, this),
            "checked", ["partial"]);
        
        this.dispatchEvent("aftercheck", {
            list        : this.checkedList,
            xmlNode     : xmlNode
        });
    };
    
    /**
     * Unchecks a single, or set of.
     *
     * @param {mixed}   xmlNode      the identifier to determine the selection.
     * @return  {Boolean}  whether the selection could be made
     *
     * @event  beforeuncheck  Fires before a uncheck is made
     *
     * @event  afteruncheck  Fires after a uncheck is made
     *
     */
    this.uncheck = function(xmlNode){
        if (this.disabled || this.checkedList.indexOf(xmlNode) == -1)
            return;
        
        
        if (this.$isTreeArch)
            return this.checkList([xmlNode], true, true);
        
        
        if (this.dispatchEvent("beforeuncheck", {
            xmlNode : xmlNode
        }) === false)
            return false;

        this.checkedList.remove(xmlNode);
        this.$setStyleClass(apf.xmldb.getHtmlNode(xmlNode, this), 
            "", ["checked", "partial"]);
        
        this.dispatchEvent("afteruncheck", {
            list        : this.checkedList,
            xmlNode     : xmlNode
        });
    };

    /**
     * Toggles between check and uncheck a single, or set of.
     *
     * @param {mixed}   xmlNode      the identifier to determine the selection.
     *
     */
    this.checkToggle = function(xmlNode){
        if (xmlNode.style) {
            var htmlNode = xmlNode,
                id       = htmlNode.getAttribute(apf.xmldb.htmlIdTag);
            while (!id && htmlNode.parentNode)
                id = (htmlNode = htmlNode.parentNode)
                    .getAttribute(apf.xmldb.htmlIdTag);
            xmlNode = apf.xmldb.getNode(htmlNode)
        }

        if (this.checkedList.indexOf(xmlNode) > -1)
            this.uncheck(xmlNode);
        else
            this.check(xmlNode);
    };
    
    /**
     * Checks a set of items
     *
     * @param {Array} xmlNodeList the {@link term.datanode data nodes} that will be selected.
     * @param {boolean} 
     * @param {boolean} 
     * @param {boolean} whether to not call any events
     * @event  beforecheck  Fires before a check is made
     *   object:
     *   {XMLElement} xmlNode   the {@link term.datanode data node} that will be deselected.
     * @event  aftercheck   Fires after a check is made
     *   object:
     *   {XMLElement} xmlNode   the {@link term.datanode data node} that is deselected.
     */
    this.checkList = function(xmlNodeList, uncheck, noClear, noEvent){
        //if (apf.isIE < 8)
        if (!xmlNodeList.indexOf)
            xmlNodeList = apf.getArrayFromNodelist(xmlNodeList);
            //@todo is this need for ie8 and/or other browsers
        
        if (this.disabled) return;
        
        if (!noEvent && this.dispatchEvent("beforecheck", {
            list : xmlNodeList
        }) === false)
            return false;
        
        if (!uncheck && !noClear) 
            this.clearChecked(true);
        
        if (!this.multicheck)
            xmlNodeList = [xmlNodeList[0]];

        var i;
        if (uncheck) {
            for (i = xmlNodeList.length - 1; i >= 0; i--) {
                this.checkedList.remove(xmlNodeList[i]);
                this.$setStyleClass(
                    apf.xmldb.getHtmlNode(xmlNodeList[i], this), "", ["checked"]);
            }
        }
        else {
            for (i = xmlNodeList.length - 1; i >= 0; i--) {
                this.checkedList.push(xmlNodeList[i]);
                this.$setStyleClass(
                    apf.xmldb.getHtmlNode(xmlNodeList[i], this), "checked");
            }
        }

        
        if (!noEvent && this.$isTreeArch) {
            var _self = this;
            function recur(xmlNode, forceChange) {
                var nodes = _self.getTraverseNodes(xmlNode);
                if (!nodes.length) {
                    if (forceChange) {
                        if (uncheck) {
                            _self.checkedList.remove(xmlNode);
                            _self.$setStyleClass(apf.xmldb.getHtmlNode(xmlNode, _self), 
                                "", ["checked"]);
                            return 0;
                        }
                        else {
                            if (_self.checkedList.indexOf(xmlNode) == -1) {
                                _self.checkedList.push(xmlNode);
                                _self.$setStyleClass(
                                    apf.xmldb.getHtmlNode(xmlNode, _self), "checked");
                            }
                            return 1;
                        }
                    }
                    return _self.checkedList.indexOf(xmlNode) > -1 ? 1 : 0;
                }

                var isInList = _self.checkedList.indexOf(xmlNode) != -1,
                    shouldBeChanged = forceChange
                        || xmlNodeList.indexOf(xmlNode) > -1 && (uncheck
                            ? !isInList
                            : isInList),
                    all      = true,
                    none     = true,
                    partial  = false,
                    isChecked;
                for (var i = nodes.length - 1; i >= 0; i--) {
                    isChecked = recur(nodes[i], shouldBeChanged);
                    if (isChecked) {
                        none = false;
                        if (!partial && isChecked == 2) {
                            partial = true;
                            //break;
                        }
                    }
                    else
                        all = false;
                    if (!all && !none) {
                        partial = true;
                        //break;
                    }
                }
                
                if (xmlNode == _self.xmlRoot)
                    return;
                
                if (all) {
                    if (!isInList) {
                        _self.checkedList.push(xmlNode);
                        apf.setStyleClass(apf.xmldb.getHtmlNode(xmlNode, _self), 
                            "checked", ["partial"]);
                    }
                }
                else{
                    if (isInList)
                        _self.checkedList.remove(xmlNode);

                    apf.setStyleClass(apf.xmldb.getHtmlNode(xmlNode, _self), 
                        partial ? "partial" : "", ["partial", "checked"]);
                }
                
                return all ? 1 : (none ? 0 : 2);
            }

            recur(this.xmlRoot)
        }
        
        
        if (!noEvent)
            this.dispatchEvent("aftercheck", {
                list        : xmlNodeList
            });
    };

    /**
     * Removes the selection of one or more checked nodes.
     *
     * @param {Boolean} [singleNode] whether to only deselect the indicated node
     * @param {Boolean} [noEvent]    whether to not call any events
     * @event  beforeuncheck  Fires before a uncheck is made
     *   object:
     *   {XMLElement} xmlNode   the {@link term.datanode data node} that will be deselected.
     * @event  afteruncheck   Fires after a uncheck is made
     *   object:
     *   {XMLElement} xmlNode   the {@link term.datanode data node} that is deselected.
     */
    this.clearChecked = function(noEvent){
        if (!noEvent && this.dispatchEvent("beforeuncheck", {
            xmlNode : this.checkedList
        }) === false)
            return false;
        
        for (var i = this.checkedList.length - 1; i >= 0; i--) {
            this.$setStyleClass(
                apf.xmldb.getHtmlNode(this.checkedList[i], this), "", ["checked"]);
        }
        
        this.checkedList.length = 0;
        
        if (!noEvent) {
            this.dispatchEvent("afteruncheck", {
                list : this.checkedList
            });
        }
    };
    
    /**
     * Determines whether a node is checked.
     *
     * @param  {XMLElement} xmlNode  The {@link term.datanode data node} to be checked.
     * @return  {Boolean} whether the element is selected.
     */
    this.isChecked = function(xmlNode){
        return this.checkedList.indexOf(xmlNode) > -1;
    };

    /**
     * Retrieves an array or a document fragment containing all the checked
     * {@link term.datanode data nodes} from this element.
     *
     * @param {Boolean} [xmldoc] whether the method should return a document fragment.
     * @return {mixed} the selection of this element.
     */
    this.getChecked = function(xmldoc){
        var i, r;
        if (xmldoc) {
            r = this.xmlRoot
                ? this.xmlRoot.ownerDocument.createDocumentFragment()
                : apf.getXmlDom().createDocumentFragment();
            for (i = 0; i < this.checkedList.length; i++)
                apf.xmldb.cleanNode(r.appendChild(
                    this.checkedList[i].cloneNode(true)));
        }
        else {
            for (r = [], i = 0; i < this.checkedList.length; i++)
                r.push(this.checkedList[i]);
        }

        return r;
    };
    
    /**
     * Checks all the {@link term.eachnode each nodes} of this element
     *
     */
    this.checkAll = function(){
        if (!this.multicheck || this.disabled || !this.xmlRoot)
            return;

        var nodes = this.$isTreeArch
            ? this.xmlRoot.selectNodes(".//" 
              + this.each.split("|").join("|.//"))
            : this.getTraverseNodes();
        
        this.checkList(nodes);
    };
    
    
    this.addEventListener("aftercheck", function(){
        //@todo inconsistent because setting this is in event callback
        if (this.checklength != this.checkedList.length)
            this.setProperty("checklength", this.checkedList.length);
    });
    
    this.addEventListener("afteruncheck", function(){
        //@todo inconsistent because setting this is in event callback
        if (this.checklength != this.checkedList.length)
            this.setProperty("checklength", this.checkedList.length);
    });
    
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/window-o3.js)SIZE(5401)TIME(1259708671)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/window.js)SIZE(49343)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Object representing the window of the aml application. The semantic is
 * similar to that of a window in the browser, except that this window is not
 * the same as the javascript global object. It handles the focussing within
 * the document and several other events such as exit and the keyboard events.
 *
 * @event blur              Fires when the browser window looses focus.
 * @event focus             Fires when the browser window receives focus.
 *
 * @constructor
 * @inherits apf.Class
 * @default_private
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 */
apf.window = function(){
    this.$uniqueId = apf.all.push(this);
    this.apf       = apf;

    /**
     * Returns a string representation of this object.
     */
    this.toString = function(){
        return "[APF Component : " + (this.name || "") + " (apf.window)]";
    };

    /**
     * Retrieves the primary {@link element.actiontracker action tracker} of the application.
     */
    this.getActionTracker = function(){
        return this.$at
    };

    /**
     * @private
     */
    this.loadCodeFile = function(url){
        //if(apf.isWebkit) return;
        if (self[url])
            apf.importClass(self[url], true, this.win);
        else
            apf.include(url);//, this.document);
    };

    
    /**
     * Flashes the task bar. This can be useful to signal the user that an
     * important event has occured. Only works in internet explorer under
     * certain conditions.
     */
    this.flash = function(){
        if (apf.window.hasFocus() || apf.isIphone)
            return;

        if (apf.isDeskrun) {
            jdwin.Flash();
        }
        else if (apf.isIE) {
            if (!this.popup)
                this.popup = window.createPopup();

            if (apf.window.stopFlash)
                return;

            state += "x"

            function doFlash(nopopup) {
                if (apf.window.hasFocus())
                    return;

                window.focus();

                function doPopup() {
                    if (apf.window.hasFocus())
                        return;

                    this.popup.hide();
                    this.popup.show(0, 0, 0, 0, document.body);
                    this.popup.document.write("<body><script>\
                        document.p = window.createPopup();\
                        document.p.show(0, 0, 0, 0, document.body);\
                        </script></body>");
                    this.popup.document.focus();

                    clearInterval(this.flashTimer);
                    this.flashTimer = setInterval(function(){
                        if (!apf.window.popup.isOpen
                          || !apf.window.popup.document.p.isOpen) {
                            clearInterval(apf.window.flashTimer);

                            if (!apf.window.hasFocus()) {
                                apf.window.popup.hide();
                                document.body.focus();
                                state = "d";
                                determineAction();
                            }
                            //when faster might have timing error
                        }
                    }, 10);
                }

                if (nopopup)
                    $setTimeout(function(){
                        doPopup.call(apf.window)
                    }, 10);
                else
                    doPopup.call(apf.window);
            }

            if ("TEXTAREA|INPUT|SELECT".indexOf(document.activeElement.tagName) > -1) {
                document.activeElement.blur();
                document.body.focus();
                apf.window.stopFlash = true;
                $setTimeout(function(){
                    doFlash.call(apf.window, true);
                    apf.window.stopFlash = false;
                }, 10);
            }
            else {
                doFlash.call(apf.window);
            }
        }
    };
    

    /**
     * Show the browser window.
     */
    this.show = function(){
        if (apf.isDeskrun)
            jdwin.Show();
    };

    /**
     * Hide the browser window.
     */
    this.hide = function(){
        if (apf.isDeskrun) {
            jdwin.Hide();
        }
        else {
            this.loaded = false;
            if (this.win)
                this.win.close();
        }
    };

    /**
     * Focus the browser window.
     */
    this.focus = function(){
        if (apf.isDeskrun)
            jdwin.SetFocus();
        else
            window.focus();
    };

    /**
     * Set the icon of the browser window.
     * @param {String} url the location of the .ico file.
     */
    this.setIcon = function(url){
        if (apf.isDeskrun)
            jdwin.icon = parseInt(url) == url ? parseInt(url) : url;
    };

    /**
     * Set the title of the browser window.
     * @param {String} value the new title of the window.
     */
    this.setTitle = function(value){
        this.title = value || "";

        if (apf.isDeskrun)
            jdwin.caption = value;
        else
            document.title = (value || "");
    };

    /**
     * @private
     */
    this.loadAml = function(x){
        if (x[apf.TAGNAME] == "deskrun")
            this.loadDeskRun(x);
        else {

        }
    };

    
    var jdwin   = apf.isDeskrun ? window.external : null,
        jdshell = apf.isDeskrun ? jdwin.shell     : null;

    /**
     * @private
     */
    this.loadDeskRun = function(q){
        jdwin.style = q.getAttribute("style")
            || "ismain|taskbar|btn-close|btn-max|btn-min|resizable";

        apf.config.drRegName = q.getAttribute("record");
        if (q.getAttribute("minwidth"))
            jdwin.setMin(q.getAttribute("minwidth"), q.getAttribute("minheight"));
        if (q.getAttribute("record")
          && jdshell.RegGet(apf.config.drRegName + "/window")) {
            var winpos = jdshell.RegGet(apf.config.drRegName + "/window");
            if (winpos) {
                winpos = winpos.split(",");
                window.external.width  = Math.max(q.getAttribute("minwidth"),
                    Math.min(parseInt(winpos[2]),
                    window.external.shell.GetSysValue("deskwidth")));
                window.external.height = Math.max(q.getAttribute("minheight"),
                    Math.min(parseInt(winpos[3]),
                    window.external.shell.GetSysValue("deskheight")));
                window.external.left   = Math.max(0, Math.min(parseInt(winpos[0]),
                    screen.width - window.external.width));
                window.external.top    = Math.max(0, Math.min(parseInt(winpos[1]),
                    screen.height - window.external.height));
            }
        }
        else {
            jdwin.left   = q.getAttribute("left")   || 200;
            jdwin.top    = q.getAttribute("top")    || 200;
            jdwin.width  = q.getAttribute("width")  || 800;
            jdwin.height = q.getAttribute("height") || 600;
        }

        jdwin.caption = q.getAttribute("caption") || "DeskRun";
        jdwin.icon    = q.getAttribute("icon") || 100;

        var ct = $xmlns(q, "context", apf.ns.aml);
        if (ct.length) {
            ct = ct[0];
            if (!apf.config.tray)
                apf.config.tray = window.external.CreateWidget("trayicon")
            var tray = apf.config.tray;

            tray.icon = q.getAttribute("tray") || 100;
            tray.tip  = q.getAttribute("tooltip") || "DeskRun";
            tray.PopupClear();
            tray.PopupItemAdd("Exit", 3);
            tray.PopupItemAdd("SEP", function(){});

            var nodes = ct.childNodes;
            for (var i = nodes.length - 1; i >= 0; i--) {
                if (nodes[i].nodeType != 1)
                    continue;

                if (nodes[i][apf.TAGNAME] == "divider") {
                    tray.PopupItemAdd("SEP", function(){});
                }
                else {
                    tray.PopupItemAdd(apf.queryValue(nodes[i], "."),
                        nodes[i].getAttribute("href")
                        ? new Function("window.open('" + nodes[i].getAttribute("href") + "')")
                        : new Function(nodes[i].getAttribute("onclick")));
                }
            }
        }

        jdwin.shell.debug = apf.debug ? 7 : 0;
        jdwin.Show();
        jdwin.SetFocus();
    };
    

    /**** Focus Internals ****/

    

    this.$tabList = [];

    this.$addFocus = function(amlNode, tabindex, isAdmin){
        if (!isAdmin) {
            amlNode.addEventListener("DOMNodeInserted", moveFocus);
            amlNode.addEventListener("DOMNodeRemoved", removeFocus);

            if (amlNode.$isWindowContainer > -2) {
                amlNode.addEventListener("focus", trackChildFocus);
                amlNode.addEventListener("blur", trackChildFocus);

                amlNode.$focusParent = amlNode;

                if (amlNode.$isWindowContainer > -1) {
                    if (!amlNode.$tabList)
                        amlNode.$tabList = [amlNode];
                    
                    this.$tabList.push(amlNode);
                    return;
                }
                else {
                    amlNode.$tabList = [amlNode];
                }
            }
        }

        var fParent = findFocusParent(amlNode),
            list    = fParent.$tabList;

        
        if (list[tabindex]) {
            apf.console.warn("Aml node already exist for tabindex " + tabindex
                             + ". Will insert " + amlNode.tagName + " ["
                             + (amlNode.name || "") + "] before existing one");
        }
        

        if (!amlNode.$isWindowContainer)
            amlNode.$focusParent = fParent;

        if (list[tabindex])
            list.insertIndex(amlNode, tabindex);
        else
            list.push(amlNode);
    };

    this.$removeFocus = function(amlNode){
        if (!amlNode.$focusParent)
            return;

        amlNode.$focusParent.$tabList.remove(amlNode);

        if (!amlNode.$isWindowContainer) {
            amlNode.removeEventListener("DOMNodeInserted", moveFocus);
            amlNode.removeEventListener("DOMNodeRemoved", removeFocus);
        }

        if (amlNode.$isWindowContainer > -2) {
            amlNode.removeEventListener("focus", trackChildFocus); 
            amlNode.removeEventListener("blur", trackChildFocus);
        }
    };

    var focusLoopDetect;
    this.$focus = function(amlNode, e, force){
        var aEl = this.document.activeElement;
        if (aEl == amlNode && !force)
            return; //or maybe when force do $focus

        
        var hadAlreadyFocus = aEl == amlNode;
        

        this.$settingFocus = amlNode;

        if (!e)
            e = {};

        if (aEl && aEl != amlNode && focusLoopDetect != aEl) {
            focusLoopDetect = aEl;
            e.toElement     = amlNode;
            e.fromElement   = aEl;

            aEl.blur(true, e);

            
            
            if (focusLoopDetect != aEl)
                return false;
        }

        (apf.activeElement = this.document.activeElement = amlNode).focus(true, e);

        this.$settingFocus = null;

        apf.dispatchEvent("movefocus", {
            toElement : amlNode
        });

        

        
        if (!hadAlreadyFocus)
            apf.console.info("Focus given to " + amlNode.localName +
                " [" + (amlNode.name || "") + "]");
        

        
        if (typeof apf.offline != "undefined" && apf.offline.state.enabled
          && apf.offline.state.realtime)
            apf.offline.state.set(this, "focus", amlNode.name || amlNode.$uniqueId);
        
    };

    this.$blur = function(amlNode){
        var aEl = this.document.activeElement;
        if (aEl != amlNode)
            return false;

        
        apf.console.info(aEl.localName + " ["
            + (aEl.name || "") + "] was blurred.");
        

        aEl.$focusParent.$lastFocussed = null;
        apf.activeElement = this.document.activeElement = null;

        apf.dispatchEvent("movefocus", {
            fromElement : amlNode
        });

        
    };
    
    var lastFocusParent;

    this.$focusDefault = function(amlNode, e){
        var fParent = findFocusParent(amlNode);
        this.$focusLast(fParent, e);
    };

    this.$focusRoot = function(e){
        var docEl = apf.document.documentElement;
        if (this.$focusLast(docEl, e) === false) {
            //docEl.$lastFocussed = null;
            //this.moveNext(null, apf.document.documentElement, true, e);
        }
    };

    this.$focusLast = function(amlNode, e, ignoreVisible){
        var lf = amlNode.$lastFocussed;

        if (lf && lf.parentNode && lf.$focussable === true
          && (ignoreVisible || lf.$ext.offsetHeight)) {
            this.$focus(lf, e, true);
        }
        else { //Let's find the object to focus first
            var next, node = amlNode, skip;
            while (node) {
                if (!skip && node.focussable !== false && node.$focussable === true && !node.$tabList
                  && (ignoreVisible || node.$ext.offsetHeight) && !node.disabled) {
                    this.$focus(node, e, true);
                    break;
                }
                
                //Walk sub tree
                if ((next = !skip && node.firstChild || !(skip = false) && node.nextSibling)) {
                    node = next;
                    if (node.$isWindowContainer > 0)
                        skip = true;
                }
                else if (node == amlNode) {
                    if (node.$isWindowContainer)
                        this.$focus(node, e, true);
                    return;
                }
                else {
                    do {
                        node = node.parentNode;
                    } while (node && !node.nextSibling && node != amlNode 
                      && !node.$isWindowContainer)
                    
                    if (node == amlNode)
                        return; //do nothing
                    
                    if (node) {
                        if (node.$isWindowContainer) {
                            this.$focus(node, e, true);
                            break;
                        }
                        
                        node = node.nextSibling;
                    }
                }
            }

            if (!node)
                this.$focus(apf.document.documentElement);//return false;//

            /*@todo get this back from SVN
            var node, list = amlNode.$tabList;
            for (var i = 0; i < list.length; i++) {
                node = list[i];
                if (node.focussable !== false && node.$focussable === true
                  && (ignoreVisible || node.$ext.offsetHeight)) {
                    this.$focus(node, e, true);
                    return;
                }
            }

            this.$focus(apf.document.documentElement);*/
        }
    };

    function trackChildFocus(e){
        if (e.name == "blur") {
            if (e.srcElement != this && this.$blur)
                this.$blur();
            return;
        }
        
        if (e.srcElement != this && this.$focus)
            this.$focus();
        
        if (e.srcElement == this || e.trackedChild) {
            e.trackedChild = true;
            return;
        }

        this.$lastFocussed = e.srcElement;

        if (this.localName.indexOf("window") > -1)
            e.trackedChild = true;
    }

    function findFocusParent(amlNode){
        var node = amlNode;
        do {
            node = node.parentNode;
        } while(node && !node.$isWindowContainer);
        //(!node.$focussable || node.focussable === false)

        return node || apf.document.documentElement;
    }

    //Dom handler
    //@todo make this look at the dom tree insertion point to determine tabindex
    function moveFocus(e){
        if (e && e.currentTarget != this)
            return;
        
        if (this.$isWindowContainer)
            apf.window.$tabList.pushUnique(this);
        else
            apf.window.$addFocus(this, this.tabindex, true)
    }

    //Dom handler
    function removeFocus(e){
        if (e && e.currentTarget != this)
            return;
        
        if (this.$isWindowContainer) {
            apf.window.$tabList.remove(this);
            return;
        }

        if (!this.$focusParent)
            return;

        this.$focusParent.$tabList.remove(this);
        //this.$focusParent = null; //@experimental to not execute this
    }

    /**** Focus API ****/

    /**
     * Determines whether a given aml element has the focus.
     * @param {AMLElement} the element to check
     * @returns {Boolean} whether the element has focus.
     */
    this.hasFocus = function(amlNode){
        return this.document.activeElement == amlNode;
    };

    /**
     * @private
     */
    this.moveNext = function(shiftKey, relObject, switchWindows, e){
        if (switchWindows && apf.document.activeElement) {
            var p = apf.document.activeElement.$focusParent;
            if (p.visible && p.modal)
                return false;
        }

        var dir, start, next,
            amlNode = relObject || apf.document.activeElement,
            fParent = amlNode
                ? (switchWindows && amlNode.$isWindowContainer > 0
                    ? apf.window
                    : amlNode.$focusParent)
                : apf.document.documentElement,
            list    = fParent.$tabList;

        if (amlNode && (switchWindows || amlNode != apf.document.documentElement)) {
            start   = (list || []).indexOf(amlNode);
            if (start == -1) {
                
                apf.console.warn("Moving focus from element which isn't in the list\
                                  of it's parent. This should never happen.");
                

                return;
            }
        }
        else {
            start = -1;
        }

        if (this.document.activeElement && this.document.activeElement == amlNode
          && list.length == 1 || list.length == 0)
            return false;

        dir  = (shiftKey ? -1 : 1);
        next = start;
        if (start < 0)
            start = 0;
        do {
            next += dir;

            if (next >= list.length)
                next = 0;
            else if (next < 0)
                next = list.length - 1;

            if (start == next && amlNode)
                return false; //No visible enabled element was found

            amlNode = list[next];
        }
        while (!amlNode
            || amlNode.disabled
            || amlNode == apf.document.activeElement
            || (switchWindows ? !amlNode.visible : amlNode.$ext && !amlNode.$ext.offsetHeight)
            || amlNode.focussable === false
            || switchWindows && !amlNode.$tabList.length);

        if (fParent == apf.window) {
            this.$focusLast(amlNode, {mouse:true}, switchWindows);
        }
        else {
            (e || (e = {})).shiftKey = shiftKey;
            this.$focus(amlNode, e);
        }

        
    };

    /**
     * @private
     */
    this.focusDefault = function(){
        
        if (typeof apf.offline != "undefined" && apf.offline.state.enabled) {
            var node, id = apf.offline.state.get(this, "focus");

            if (id == -1)
                return this.$focusRoot();

            if (id)
                node = self[id] || apf.lookup(id);

            if (node) {
                if (!node.$focussable) {
                    
                    apf.console.warn("Invalid offline state detected. The \
                                      application was probably changed in \
                                      between sessions. Resetting offline state\
                                      and rebooting.");
                    

                    apf.offline.clear();
                    apf.offline.reboot();
                }
                else {
                    this.$focus(node);
                    return;
                }
            }
        }
        

        if (this.moveNext() === false)
            this.moveNext(null, apf.document.documentElement, true)
    };

    

    /**** Set Window Events ****/

    apf.addListener(window, "beforeunload", function(){
        return apf.dispatchEvent("exit");
    });

    //@todo apf3.x why is this loaded twice
    apf.addListener(window, "unload", function(){
        if (!apf)
            return;
        
        apf.window.isExiting = true;
        apf.window.destroy();
    });

    

    var timer, state = "", last = "";
    this.$focusfix = function(){
        
        if (apf.isIphone) return;
        
        state += "a";
        clearTimeout(timer);
        $setTimeout("window.focus();");
        timer = $setTimeout(determineAction);
    };

    this.$focusfix2 = function(){
        
        if (apf.isIphone) return;
        
        state += "b";
        clearTimeout(timer);
        timer = $setTimeout(determineAction);
    };

    this.$blurfix = function(){
        
        if (apf.isIphone) return;
        
        state += "c";
        clearTimeout(timer);
        timer = $setTimeout(determineAction);
    };

    function determineAction(){
        clearTimeout(timer);

        //apf.console.info(state);
        if (state == "e" || state == "c"
          || state.charAt(0) == "x" && !state.match(/eb$/)
          || state == "ce" || state == "de") { //|| state == "ae"
            if (last != "blur") {
                last = "blur";
                apf.window.dispatchEvent("blur");
                //apf.console.warn("blur");
            }
        }
        else {
            if (last != "focus") {
                last = "focus";
                apf.window.dispatchEvent("focus");
                //apf.console.warn("focus");
            }
        }

        state = "";
        timer = null;
    }

    apf.addListener(window, "focus", this.$focusevent = function(){
        
        if (apf.isIphone)
            return apf.window.dispatchEvent("focus");
        
        if (apf.hasFocusBug) {
            state += "d";
            clearTimeout(timer);
            timer = $setTimeout(determineAction);
        }
        else {
            clearTimeout(iframeFixTimer)
            iframeFix.newState = "focus";
            //apf.console.warn("win-focus");
            iframeFixTimer = $setTimeout(iframeFix, 10);
        }
    });

    apf.addListener(window, "blur", this.$blurevent = function(){
        if (!apf) return;
        
        
        if (apf.isIphone)
            return apf.window.dispatchEvent("blur");
        
        if (apf.hasFocusBug) {
            state += "e";
            clearTimeout(timer);
            timer = $setTimeout(determineAction);
        }
        else {
            clearTimeout(iframeFixTimer)
            iframeFix.newState = "blur";
            //apf.console.warn("win-blur");
            iframeFixTimer = $setTimeout(iframeFix, 10);
        }
    });

    var iframeFixTimer;
    function iframeFix(){
        clearTimeout(iframeFixTimer);

        var newState = iframeFix.newState;
        if (last == newState)
            return;

        last = newState;

        apf.dispatchEvent(last);
        //apf.console.warn(last);
    }

    this.hasFocus = function(){
        return (last == "focus");
    };

    

    /**** Keyboard and Focus Handling ****/

    apf.addListener(document, "contextmenu", function(e){
        if (!e)
            e = event;

        
        var pos, ev,
            amlNode = apf.findHost(e.srcElement || e.target)
              || apf.document.activeElement
              || apf.document && apf.document.documentElement;

        if (amlNode && amlNode.localName == "menu") //The menu is already visible
            return false;


        //if (amlNode && amlNode.localName == "menu")
            //amlNode = amlNode.parentNode;

        if (apf.contextMenuKeyboard) {
            if (amlNode) {
                pos = amlNode.selected
                    ? apf.getAbsolutePosition(amlNode.$selected)
                    : apf.getAbsolutePosition(amlNode.$ext || amlNode.$pHtmlNode);
            }
            else {
                pos = [0, 0];
            }

            ev = {
                x         : pos[0] + 10 + document.documentElement.scrollLeft,
                y         : pos[1] + 10 + document.documentElement.scrollTop,
                htmlEvent : e
            }
        }
        else {
            if (e.htmlEvent) {
                ev = e;
            }
            else {
                ev = { //@todo probably have to deduct the border of the window
                    x         : e.clientX + document.documentElement.scrollLeft,
                    y         : e.clientY + document.documentElement.scrollTop,
                    htmlEvent : e
                }
            }
        }

        ev.bubbles = true; //@todo discuss this, are we ok with bubbling?

        apf.contextMenuKeyboard = null;

        if ((amlNode || apf).dispatchEvent("contextmenu", ev) === false
          || ev.returnValue === false) {
            if (e.preventDefault)
                e.preventDefault();
            return false;
        }
        

        if (apf.config.disableRightClick) {
            if (e.preventDefault)
                e.preventDefault();
            return false;
        }
    });

    var ta = {"INPUT":1, "TEXTAREA":1, "SELECT":1};
    apf.addListener(document, "mousedown", this.$mousedown = function(e){
        e = e || window.event;

        var p,
            amlNode   = apf.findHost(e.srcElement || e.target),
            cEditable = amlNode && amlNode.$editable
              
              || (amlNode && amlNode.hasFeature(apf.__CONTENTEDITABLE__))
              
            ;

        
        if (apf.popup.last && (!amlNode || apf.popup.last != amlNode.$uniqueId))
            apf.popup.forceHide();
        

        
        //Make sure the user cannot leave a modal window
        if ((!amlNode || !amlNode.$focussable || amlNode.focussable === false)
          && apf.config.allowBlur && amlNode.canHaveChildren != 2) {
            lastFocusParent = null;
            if (apf.document.activeElement)
                apf.document.activeElement.blur();
        }
        else if (amlNode) { //@todo check this for documentElement apf3.0
            if ((p = apf.document.activeElement
              && apf.document.activeElement.$focusParent || lastFocusParent)
              && p.visible && p.modal && amlNode.$focusParent != p) {
                apf.window.$focusLast(p, {mouse: true});
            }
            else if (!amlNode && apf.document.activeElement) {
                apf.window.$focusRoot();
            }
            else if (amlNode.$isWindowContainer == -1) {
                if (amlNode.$tabList.length)
                    apf.window.moveNext(null, amlNode.$tabList[0], null, {mouse: true});
                else
                    apf.window.$focus(amlNode);
            }
            else if (!amlNode.disabled && amlNode.focussable !== false) {
                if (amlNode.$focussable === apf.KEYBOARD_MOUSE) {
                    apf.window.$focus(amlNode, {mouse: true});
                }
                else if (amlNode.canHaveChildren == 2) {
                    if (!apf.config.allowBlur || !apf.document.activeElement 
                      || apf.document.activeElement.$focusParent != amlNode)
                        apf.window.$focusLast(amlNode, {mouse: true});
                }
                else {
                    apf.window.$focusDefault(amlNode, {mouse: true});
                }
            }
            else {
                apf.window.$focusDefault(amlNode, {mouse: true});
            }
    
            
            if (apf.hasFocusBug) {
                var isContentEditable = ta[(e.srcElement || e.target).tagName]
                    && !(e.srcElement || e.target).disabled
                    || (e.srcElement && e.srcElement.isContentEditable)
                    || amlNode.$isContentEditable
                    && amlNode.$isContentEditable(e) && !amlNode.disabled;
    
                if (!amlNode || !isContentEditable)
                    apf.window.$focusfix();
            }
            else if (!last) {
                apf.window.$focusevent();
            }
            
            
        }
        
        apf.dispatchEvent("mousedown", {
            htmlEvent : e,
            amlNode   : amlNode || apf.document.documentElement
        });

        //Non IE/ iPhone selection handling
        var canSelect = !(!apf.isIphone && !apf.isIE && (apf.document && !apf.config.allowSelect
          && (!apf.isParsingPartial || amlNode)
          
          || apf.dragMode
          
          ) && !ta[e.target.tagName]);

        if (canSelect) {
            amlNode = apf.findHost(e.target);
            
            if (amlNode){
                var isContentEditable = ta[(e.srcElement || e.target).tagName]
                    && !(e.srcElement || e.target).disabled
                    || (e.srcElement && e.srcElement.isContentEditable)
                    || amlNode.$isContentEditable
                    && amlNode.$isContentEditable(e) && !amlNode.disabled;
            
                //(!amlNode.canHaveChildren || !apf.isChildOf(amlNode.$int, e.srcElement))
                if (!isContentEditable && amlNode.nodeType != amlNode.NODE_PROCESSING_INSTRUCTION 
                  && !amlNode.$allowSelect 
                  && !amlNode.getElementsByTagNameNS(apf.ns.xhtml, "*").length)
                    canSelect = false;
            }
        }
       
        if (!canSelect && !cEditable) {
            if (e.preventDefault)
                e.preventDefault();
            return false;
        }
    });

    //IE selection handling
    apf.addListener(document, "selectstart", function(e){
        if (!e) e = event;

        var canSelect = !(apf.document && !apf.config.allowSelect
          
          || apf.dragMode
          
        );

        if (canSelect) {
            var amlNode = apf.findHost(e.srcElement);
            //(!amlNode.canHaveChildren || !apf.isChildOf(amlNode.$int, e.srcElement))
            if (amlNode && amlNode.nodeType != amlNode.NODE_PROCESSING_INSTRUCTION 
              && !amlNode.$allowSelect 
              && !amlNode.getElementsByTagNameNS(apf.ns.xhtml, "*").length)
                canSelect = false;
        }

        if (!canSelect) {
            e.returnValue = false;
            return false;
        }
    });

    // Keyboard forwarding to focussed object
    apf.addListener(document, "keyup", this.$keyup = function(e){
        if (!e) e = event;

        
        if (apf.document && apf.document.activeElement
          && !apf.document.activeElement.disableKeyboard
          && apf.document.activeElement.dispatchEvent("keyup", {
                keyCode  : e.keyCode,
                ctrlKey  : e.ctrlKey,
                shiftKey : e.shiftKey,
                altKey   : e.altkey,
                htmlEvent: e
            }) === false) {
            e.returnValue = false;
            return false;
        }
        

        apf.dispatchEvent("keyup", null, e);
    });

    
    function wheel(e) {
        if (!e)
            e = event;

        var delta = null;
        if (e.wheelDelta) {
            delta = e.wheelDelta / 120;
            if (apf.isOpera)
                delta *= -1;
        }
        else if (e.detail) {
            delta = -e.detail / 3;
        }

        if (delta !== null) {
            //Fix for scrolling too much
            if (apf.isIE) {
                var el = e.srcElement || e.target;
                while (el && el.scrollHeight <= el.offsetHeight)
                    el = el.parentNode;
                
                if (!el) return;
                
                if (el.nodeType == 9)
                    el = el.documentElement;
                
                if (el && el.tagName == "BODY" && "auto|scroll".indexOf(apf.getStyle(el, "overflowY")) == -1)
                    el = document.documentElement;

                if (el && "auto|scroll".indexOf(apf.getStyle(el, "overflowY")) > -1) {
                    var max, dist = 0.35 * el.offsetHeight * delta;
                    if (delta < 0) {
                        if (el && el.scrollTop >= (max = el.scrollHeight - el.offsetHeight + apf.getVerBorders(el)) + dist) {
                            el.scrollTop = max;
                            e.returnValue = false;
                        }
                    }
                    else {
                        if (el && el.scrollTop <= dist) {
                            el.scrollTop = 0;
                            e.returnValue = false;
                        }
                    }
                }
            }
            
            var ev  = {delta: delta, target: e.target || e.srcElement},
                res = apf.dispatchEvent("mousescroll", ev);
            if (res === false || ev.returnValue === false) {
                if (e.preventDefault)
                    e.preventDefault();

                e.returnValue = false;
            }
        }
    }

    if (document.addEventListener)
        document.addEventListener('DOMMouseScroll', wheel, false);

    window.onmousewheel   =
    document.onmousewheel = wheel; //@todo 2 keer events??
    

    //var browserNavKeys = {32:1,33:1,34:1,35:1,36:1,37:1,38:1,39:1,40:1}
    
    //@todo optimize this function
    apf.addListener(document, "keydown", this.$keydown = function(e){
        e = e || event;

        
        if (e.keyCode == 120 || e.ctrlKey && e.altKey && e.keyCode == 68) {
            if (!apf.debugwin.resPath)
                apf.debugwin.init();
            apf.debugwin.activate();
        }
        

        
        if (e.keyCode == 93)
            apf.contextMenuKeyboard = true;
        
        
        var amlNode           = apf.findHost(e.srcElement || e.target),
            isContentEditable = ta[(e.explicitOriginalTarget || e.srcElement || e.target).tagName]
              || (e.srcElement && e.srcElement.isContentEditable)
              
              || (amlNode && amlNode.hasFeature(apf.__CONTENTEDITABLE__))
              
            ;

        
        //@todo move this to appsettings and use with_hotkey
        var o,
            ctrlKey = apf.isMac ? e.metaKey : e.ctrlKey;
        if (!isContentEditable && apf.config.undokeys && ctrlKey) {
            //Ctrl-Z - Undo
            if (e.keyCode == 90) {
                o = apf.document.activeElement;
                while (o && !o.getActionTracker && !o.$at)
                    o = o.parentNode;
                if (!o) o = apf.window;
                (o.$at || o.getActionTracker()).undo();
            }
            //Ctrl-Y - Redo
            else if (e.keyCode == 89) {
                o = apf.document.activeElement;
                while (o && !o.getActionTracker && !o.$at)
                    o = o.parentNode;
                if (!o) o = apf.window;
                (o.$at || o.getActionTracker()).redo();
            }
        }
        

        var eInfo = {
            ctrlKey   : e.ctrlKey,
            metaKey   : e.metaKey,
            shiftKey  : e.shiftKey,
            altKey    : e.altKey,
            keyCode   : e.keyCode,
            htmlEvent : e,
            bubbles   : true
        };

        
        //Hotkey
        if (apf.dispatchEvent("hotkey", eInfo) === false || eInfo.returnValue === false) {
            e.returnValue  = false;
            e.cancelBubble = true;
            if (e.stopPropagation)
                e.stopPropagation();
            if (apf.canDisableKeyCodes) {
                try {
                    e.keyCode = 0;
                }
                catch(e) {}
            }
            if (e.preventDefault)
                e.preventDefault();
            return false;
        }
        

        
        var keys = []; //@todo put this in a lut
        if (e.altKey)
            keys.push("Alt");
        if (e.ctrlKey)
            keys.push("Ctrl");
        if (e.shiftKey)
            keys.push("Shift");
        if (e.metaKey)
            keys.push("Meta");

        if (apf.keyNames[e.keyCode])
            keys.push(apf.keyNames[e.keyCode]);

        if (keys.length) {
            if (e.keyCode > 46)
                keys.push(String.fromCharCode(e.keyCode));
            apf.setProperty("hotkey", keys.join("-"));
        }
        

        
        //Keyboard forwarding to focussed object
        if (apf.document.activeElement && !apf.document.activeElement.disableKeyboard
          && apf.document.activeElement.dispatchEvent("keydown", eInfo) === false) {
            e.returnValue  = false;
            e.cancelBubble = true;
            if (apf.canDisableKeyCodes) {
                try {
                    e.keyCode = 0;
                }
                catch(e) {}
            }
            if (e.preventDefault)
                e.preventDefault();
            return false;
        }
        
        //Focus handling
        else if ((!apf.config.disableTabbing || apf.document.activeElement) && e.keyCode == 9) {
            //Window focus handling
            if (e.ctrlKey && apf.document.activeElement) {
                var w = apf.document.activeElement.$focusParent;
                if (w.modal) {
                    if (e.preventDefault)
                        e.preventDefault();
                    return false;
                }

                apf.window.moveNext(e.shiftKey,
                    apf.document.activeElement.$focusParent, true);

                w = apf.document.activeElement.$focusParent;
                if (w && w.bringToFront)
                    w.bringToFront();
            }
            //Element focus handling
            else if(!apf.document.activeElement || apf.document.activeElement.tagName != "menu") {
                apf.window.moveNext(e.shiftKey);
            }

            if (e.preventDefault)
                e.preventDefault();
            return false;
        }
        

        //Disable backspace behaviour triggering the backbutton behaviour
        var altKey = apf.isMac ? e.metaKey : e.altKey;
        if (apf.config.disableBackspace
          && e.keyCode == 8// || (altKey && (e.keyCode == 37 || e.keyCode == 39)))
          && !isContentEditable) {
            if (apf.canDisableKeyCodes) {
                try {
                    e.keyCode = 0;
                }
                catch(e) {}
            }
            e.returnValue = false;
        }

        //Disable space behaviour of scrolling down the page
        /*if(Application.disableSpace && e.keyCode == 32 && e.srcElement.tagName.toLowerCase() != "input"){
            e.keyCode = 0;
            e.returnValue = false;
        }*/

        //Disable F5 refresh behaviour
        if (apf.config.disableF5 && (e.keyCode == 116 || e.keyCode == 117)) {
            if (apf.canDisableKeyCodes) {
                try {
                    e.keyCode = 0;
                }
                catch(e) {}
            }
            else {
                e.preventDefault();
                e.stopPropagation();
            }
            //return false;
        }
        
        
        /*if (browserNavKeys[e.keyCode] && apf.document.activeElement 
          && apf.config.autoDisableNavKeys)
            e.returnValue = false;*/

        if (e.keyCode == 27)
            e.returnValue = false;

        if (!apf.config.allowSelect
          && e.shiftKey && (e.keyCode > 32 && e.keyCode < 41)
          && !isContentEditable) {
            e.returnValue = false;
        }

        //apf.dispatchEvent("keydown", null, eInfo);

        if (e.returnValue === false && e.preventDefault)
            e.preventDefault();

        return e.returnValue;
        
    });
    
    apf.document = {};
    this.init = function(strAml){
        
        if (apf.actiontracker) {
            this.$at      = new apf.actiontracker();
            this.$at.name = "default";
            apf.nameserver.register("actiontracker", "default", this.$at);
        }
        

         
        apf.console.info("Start parsing main application");
        
        
        apf.Latometer.start();
        
        
        //Put this in callback in between the two phases
        
        /*XForms and lazy devs support
        if (!nodes.length && !apf.skins.skins["default"] && apf.autoLoadSkin) {
            apf.console.warn("No skin file found, attempting to autoload the \
                              default skin file: skins.xml");
            apf.loadAmlInclude(null, doSync, "skins.xml", true);
        }*/
        

        this.$domParser = new apf.DOMParser();
        this.document = apf.document = this.$domParser.parseFromString(strAml, 
          "text/xml", {
            
            timeout   : apf.config.initdelay,
            
            callback  : function(doc){
                //@todo apf3.0

                //Call the onload event (prevent recursion)
                if (apf.parsed != 2) {
                    //@todo apf3.0 onload is being called too often
                    var inital = apf.parsed;
                    apf.parsed = 2;
                    apf.dispatchEvent("parse", { //@todo apf3.0 document
                        initial : inital
                    });
                    apf.parsed = true;
                }
        
                if (!apf.loaded) {
                    
                    if (apf.isDeskrun)
                        apf.window.deskrun.Show();
                    
        
                    
                    //Set the default selected element
                    if (!apf.document.activeElement && !apf.config.allowBlur)
                        apf.window.focusDefault();
                    

                    apf.loaded = true;
                    $setTimeout(function() {
                        apf.dispatchEvent("load");
                    });
                }
        
                //END OF ENTIRE APPLICATION STARTUP
        
                
                apf.console.info("Initialization finished");
                
                
                
                apf.Latometer.end();
                apf.Latometer.addPoint("Total load time");
                apf.Latometer.start(true);
                
          }
        }); //async

        
        this.addEventListener("focus", function(e){
            if (!apf.document.activeElement && lastFocusParent && !apf.isIphone) {
                if (lastFocusParent.$isWindowContainer == -1) {
                    if (lastFocusParent.$tabList.length)
                        apf.window.moveNext(null, lastFocusParent.$tabList[0]);
                    else
                        apf.window.$focus(lastFocusParent);
                }
                else 
                    apf.window.$focusLast(lastFocusParent);
            }
        });
        this.addEventListener("blur", function(e){
            if (!apf.document.activeElement || apf.isIphone)
                return;
    
            apf.document.activeElement.blur(true, {srcElement: this});//, {cancelBubble: true}
            lastFocusParent = apf.document.activeElement.$focusParent;
            apf.activeElement = apf.document.activeElement = null;
        });
      
    };

    /**
     * @private
     */
    this.destroy = function(){
        this.$at = null;

        apf.unload(this);

        apf           =
        this.win      =
        this.window   =
        this.document = null;

        //@todo this is not needed... maybe use apf.removeListener
        window.onfocus        =
        window.onerror        =
        window.onunload       =
        window.onbeforeunload =
        window.onbeforeprint  =
        window.onafterprint   =
        window.onmousewheel   =
        window.onblur         = null;

        document.oncontextmenu =
        document.onmousedown   =
        document.onmousemove   =
        document.onmouseup     =
        document.onselectstart =
        document.onmousewheel  =
        document.onkeyup       =
        document.onkeydown     = null

        if (document.body) {
            document.body.onmousedown =
            document.body.onmousemove =
            document.body.onmouseup   = null;

            document.body.innerHTML = "";
        }
    };
};
apf.window.prototype = new apf.Class().$init();
apf.window = new apf.window();


/**
 * @private
 */
apf.sanitizeTextbox = function(oTxt){
    oTxt.onfocus = function(){
        if (apf.window)
            apf.window.$focusfix2();
    };

    oTxt.onblur = function(){
        if (apf.window)
            apf.window.$blurfix();
    };
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/browsers/gecko.js)SIZE(4959)TIME(1260921679)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Compatibility layer for Gecko based browsers.
 * @private
 */
apf.runGecko = function(){
    if (apf.runNonIe)
        apf.runNonIe();

    /* ***************************************************************************
     XSLT
     ****************************************************************************/
    
    
    //XMLDocument.selectNodes
    HTMLDocument.prototype.selectNodes = XMLDocument.prototype.selectNodes = function(sExpr, contextNode){
        try {
            var oResult = this.evaluate(sExpr, (contextNode || this),
                this.createNSResolver(this.documentElement),
                7, null);//XPathResult.ORDERED_NODE_SNAPSHOT_TYPE
        }
        catch(ex) {
            var msg = ex.message;
            if (ex.code == ex.INVALID_EXPRESSION_ERR)
                msg = msg.replace(/the expression/i, "'" + sExpr + "'");
            throw new Error(ex.lineNumber, "XPath error: " + msg);
        }
        
        var nodeList = new Array(oResult.snapshotLength);
        nodeList.expr = sExpr;
        for (var i = nodeList.length - 1; i >= 0; i--) 
            nodeList[i] = oResult.snapshotItem(i);
        return nodeList;
    };
    
    //Element.selectNodes
    Text.prototype.selectNodes =
    Element.prototype.selectNodes = function(sExpr){
       return this.ownerDocument.selectNodes(sExpr, this);
    };
    
    //XMLDocument.selectSingleNode
    HTMLDocument.prototype.selectSingleNode = XMLDocument.prototype.selectSingleNode = function(sExpr, contextNode){
        var nodeList = this.selectNodes(sExpr + "[1]", contextNode || null);
        return nodeList[0] || null;
    };
    
    //Element.selectSingleNode
    Text.prototype.selectSingleNode =
    Element.prototype.selectSingleNode = function(sExpr){
        return this.ownerDocument.selectSingleNode(sExpr, this);
    };
    
    
    
    var serializer = new XMLSerializer();
    apf.insertHtmlNodes = function(nodeList, htmlNode, beforeNode) {
        var o    = document.createElement("div"),
            frag = document.createDocumentFragment(),
            i    = nodeList.length - 1,
            l, node;
        for (; i >= 0; i--) {
            node = nodeList[i];
            frag.insertBefore(node, frag.firstChild);
        }

        o.innerHTML = apf.html_entity_decode(serializer.serializeToString(frag))
            .replace(/<([^>]+)\/>/g, "<$1></$1>");

        frag = document.createDocumentFragment();
        for (i = 0, l = o.childNodes.length; i < l; i++) {
            node = o.childNodes[0];
            frag.appendChild(node);
        }

        if (beforeNode)
            htmlNode.insertBefore(frag, beforeNode);
        htmlNode.appendChild(frag);
    };

    apf.insertHtmlNode = function(xmlNode, htmlNode, beforeNode, s) {
        var o = document.createElement("div");

        if (!s) {
            s = apf.html_entity_decode(xmlNode.serialize
                ? xmlNode.serialize(true)
                : ((xmlNode.nodeType == 3 || xmlNode.nodeType == 4 || xmlNode.nodeType == 2)
                    ? xmlNode.nodeValue
                    : serializer.serializeToString(xmlNode)));
        }

        o.innerHTML = s.replace(/<([^>]+)\/>/g, "<$1></$1>");

        if (beforeNode)
            htmlNode.insertBefore(o.firstChild, beforeNode);
        htmlNode.appendChild(o.firstChild);

        return beforeNode ? beforeNode.previousSibling : htmlNode.lastChild;
    };
    
    /* ******** Error Compatibility **********************************************
     Error Object like IE
     ****************************************************************************/
    function Error(nr, msg){
        
        if (!apf.debugwin.useDebugger) 
            apf.debugwin.errorHandler(msg, "", 0);
        
        
        this.message = msg;
        this.nr = nr;
    }
}




/*FILEHEAD(/var/lib/platform/source/trunk/core/browsers/gears.js)SIZE(1347)TIME(1260921679)*/


/**
 * @private
 */
apf.initGears = function(){
    // summary:
    //		factory method to get a Google Gears plugin instance to
    //		expose in the browser runtime environment, if present
    var factory, results;

    var gearsObj = apf.nameserver.get("google", "gears");
    if(gearsObj)
        return gearsObj; // already defined elsewhere

    if (typeof GearsFactory != "undefined") { // Firefox
        factory = new GearsFactory();
    }
    else {
        if(apf.isIE){
            // IE
            try {
                factory = new ActiveXObject("Gears.Factory");
            }
            catch(e) {
                // ok to squelch; there's no gears factory.  move on.
            }
        }
        else if(navigator.mimeTypes["application/x-googlegears"]) {
            // Safari?
            factory = document.createElement("object");
            factory.setAttribute("type", "application/x-googlegears");
            factory.setAttribute("width", 0);
            factory.setAttribute("height", 0);
            factory.style.display = "none";
            document.documentElement.appendChild(factory);
        }
    }

    // still nothing?
    if (!factory)
        return null;

    return apf.nameserver.register("google", "gears", factory);
};


/*FILEHEAD(/var/lib/platform/source/trunk/core/browsers/iphone.js)SIZE(11827)TIME(1265038748)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * @private
 */
apf.runIphone = function() {
    if (!apf.isIphone) return;

    $setTimeout(function() {
        
        apf.importCssString(
           'html, body {\
                margin: 0;\
                font-family: Helvetica;\
                background: #fff;\
                color: #000000;\
                overflow-x: hidden;\
                -webkit-user-select: none;\
                -webkit-text-size-adjust: none;\
                -webkit-touch-callout: none;\
            }\
            body > *:not(.toolbar) {\
                min-height: 372px;\
            }\
            body[orient="landscape"] > *:not(.toolbar) {\
                min-height: 268px;\
            }\
            body > *[selected="true"] {\
                display: block;\
            }', "screen");
        

        var head = document.getElementsByTagName("head")[0];
        if (apf.config.iphoneIcon) {
            var link = document.createElement("link");
            link.setAttribute("rel", "apple-touch-icon"
                + (apf.config.iphoneIconIsGlossy ? "" : "-precomposed"));
            link.setAttribute("href", "apf.config.iphoneIcon");
            head.appendChild(link);
        }

        function appendMeta(name, content) {
            var meta = document.createElement("meta");
            meta.setAttribute("name", name);
            meta.setAttribute("content", content);
            head.appendChild(meta);
        }

        if (apf.config.iphoneFixedViewport) {
            appendMeta("viewport",
                "width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;");
        }

        if (apf.config.iphoneFullScreen) {
            appendMeta("apple-mobile-web-app-capable", "yes");

            if (apf.config.iphoneStatusBar)
                appendMeta("apple-mobile-web-app-status-bar-style",
                    "apf.config.iphoneStatusBar");
        }
    });

    var hasOrientationEvent = false,
        currentWidth        = 0,
        portraitVal         = "portrait",
        landscapeVal        = "landscape",
        checkTimer          = null;

    apf.addDomLoadEvent(function() {
        $setTimeout(checkOrientAndLocation, 0);
        checkTimer = setInterval(checkOrientAndLocation, 300);
    });

    function orientChangeHandler() {
        switch(window.orientation) {
            case 0:
                setOrientation(portraitVal);
                break;
            case 90:
            case -90:
                setOrientation(landscapeVal);
                break;
        }
    }

    if (typeof window.onorientationchange == "object") {
        window.onorientationchange = orientChangeHandler;
        hasOrientationEvent = true;
        $setTimeout(orientChangeHandler, 0);
    }

    function checkOrientAndLocation() {
        if (!hasOrientationEvent) {
            if (window.innerWidth != currentWidth) {
                currentWidth = window.innerWidth;
                var orient   = currentWidth == 320 ? portraitVal : landscapeVal;
                setOrientation(orient);
            }
        }

        /*if (location.hash != currentHash) {
            var pageId = location.hash.substr(hashPrefix.length);
            iui.showPageById(pageId);
        }*/
    }

    function setOrientation(orient) {
        document.body.setAttribute("orient", orient);
        $setTimeout("scrollTo(0,1)", 100);
    }

    /* register event listeners:
     * - touchstart (skip)
     * - touchmove (skip)
     * - touchend (skip)
     * - touchcancel (skip)
     * - gesturestart
     * - gesturechange
     * - gestureend
     * - orientationchange
     */
    ["gesturestart", "gesturechange", "gestureend",
     "orientationchange"].forEach(function(type) {
        document["on" + type] = function(evt) {
            if (apf.dispatchEvent)
                apf.dispatchEvent(type, evt);
        };
    });

    apf.iphone = {
        titleNode : null,

        linkEvents: function(el, bClick) {
            return;
            el[bClick ? "onclick" : "ontouchstart"] = function(evt) {
                if (!evt.touches || evt.touches.length != 1) return;

                var e = evt.touches[0];
                if (typeof this.onmousedown == "function") {
                    this.onmousedown(e);
                    if (this != document)
                        return false;
                }
            };

            el.ontouchmove = function(evt) {
                if (!evt.touches || evt.touches.length != 1) return;

                var e = evt.touches[0];
                if (typeof this.onmousemove == "function") {
                    this.onmousemove(e);
                    if (this != document)
                        return false;
                }
            };

            var _touching = false;

            el.ontouchend = el.ontouchcancel = function(evt) {
                if (_touching) return;

                var e = evt.touches && evt.touches.length
                    ? evt.touches[0]
                    : evt.changedTouches[0];
                if (!e) return;

                _touching = true;
                $setTimeout(function() { _touching = false; });
                if (typeof this.onmouseup == "function") {
                    this.onmouseup(e);
                    if (this != document)
                        return false;
                }
            };

            return this;
        },
        nav: {
            sections     : null,
            active       : null,
            def          : "home",
            divideChar   : "/",
            levelTwoChar : "-",

            go: function(where, noanim) {
                var i, p, _self = apf.iphone.nav;
                _self.update();

                if (!(p = _self.sections[where.page])) return;

                scrollTo(0, 1);
                apf.dispatchEvent("pagechange", where);

                var sTitle = p.getAttribute("title");
                if (apf.iphone.titleNode && sTitle)
                    apf.iphone.titleNode.innerHTML = sTitle;

                if (noanim) {
                    for (i in _self.sections)
                        _self.sections[i].hide();
                    p.show();
                }
                else {
                    for (i in _self.sections) {
                        if (!_self.sections[i].visible || i == where.page)
                            continue;
                        var section = _self.sections[i];
                        section.setProperty("zindex", 0);
                        apf.tween.single(section.$ext, {
                            steps   : 5,
                            interval: 10,
                            from    : section.$ext.offsetLeft,
                            to      : (where.index < 0) ? 1000 : -1000,
                            type    : "left",
                            anim    : apf.tween.EASEOUT,
                            onfinish: function() {
                                section.setProperty("visible", false);
                            }
                        });
                    }

                    var pad   = 10,
                        el    = p.$ext,
                        iFrom = (where.index < 0)
                            ? -(el.offsetWidth) - pad
                            : window.innerWidth + el.offsetLeft + pad;
                    p.setProperty("visible", true);
                    p.setProperty("zindex",  apf.all.length + 1);
                    
                    apf.tween.single(el, {
                        steps   : 5,
                        interval: 10,
                        from    : iFrom,
                        to      : 0,
                        type    : "left",
                        anim    : apf.tween.EASEIN
                    });
                    
                }
            },

            update: function(force) {
                if (this.sections && !force) return;
                this.sections = {};
                for (var i in window) {
                    if (window[i] && window[i]["tagName"]
                      && window[i].tagName == "section")
                        this.sections[i] = window[i];
                }
            }
        }
    };

    $setTimeout(function() {
        apf.addEventListener("hashchange", apf.iphone.nav.go);
        if (location.href.match(/#(.*)$/))
    		apf.history.init(decodeURI(RegExp.$1));
        else if (apf._GET.page)
            apf.history.init(apf._GET.page);
        else
            apf.history.init();
    });

    // make sure that document event link to mouse events already. Since the
    // document object on top of the event bubble chain, it will probably also
    // be hooked by other JPF elements.
    //apf.iphone.linkEvents(document);
    document.ontouchstart = function(evt) {
        if (!evt.touches || evt.touches.length != 1) return;

        var e       = evt.touches[0],
            el      = e.target,
            amlNode = apf.findHost(e.target);
        if (!amlNode) return;

        while (typeof el["onmousedown"] != "function" && el != document.body)
            el = el.parentNode;
        if (typeof el.onmousedown == "function") {
            if (typeof el.onmouseover == "function")
                el.onmouseover(e);
            else if (typeof el.onmousemove == "function")
                el.onmousemove(e);
            el.onmousedown(e);
            return false;
        }
    };

    document.ontouchmove = function(evt) {
        if (!evt.touches || evt.touches.length != 1) return;

        var e       = evt.touches[0],
            el      = e.target,
            amlNode = apf.findHost(e.target);
        if (!amlNode) return;

        while (typeof el["onmousemove"] != "function" && el != document.body)
            el = el.parentNode;
        if (typeof el.onmousemove == "function") {
            el.onmousemove(e);
            return false;
        }
        else if (typeof document["onmousemove"] == "function") {
            return document.onmousemove(e);
        }
    };

    document.ontouchend = document.ontouchcancel = function(evt) {
        var e = evt.touches && evt.touches.length
            ? evt.touches[0]
            : evt.changedTouches[0];
        if (!e) return;
        var el      = e.target,
            amlNode = apf.findHost(e.target);
        if (!amlNode) return;

        while (typeof el["onmouseup"] != "function" && el != document.body)
            el = el.parentNode;
        if (typeof el.onmouseup == "function") {
            if (typeof el.onmouseout == "function")
                el.onmouseout(e);
            el.onmouseup(e, true);
            return false;
        }
        else if (typeof document["onmouseup"] == "function") {
            return document.onmouseup(e);
        }
    };
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/browsers/ie.js)SIZE(14219)TIME(1265032027)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Compatibility layer for Internet Explorer browsers.
 * @private
 */
apf.runIE = function(){
    /* ******** XML Compatibility ************************************************
     Extensions to the xmldb
     ****************************************************************************/
    var hasIE7Security = false,
        hasIESecurity  = false;
    
    if (self.XMLHttpRequest)
        try {
            new XMLHttpRequest()
        }
        catch (e) {
            hasIE7Security = true
        }
    try {
        new ActiveXObject("microsoft.XMLHTTP")
    }
    catch (e) {
        hasIESecurity = true
    }
    

    
     if (hasIESecurity)
        apf.importClass(runTpIframe, true, self);
     
    

    apf.getHttpReq = hasIESecurity
        ? function(){
            if (apf.availHTTP.length)
                return apf.availHTTP.pop();

            
            //if(apf.isDeskrun && !self.useNativeHttp)
            //    return jdshell.CreateComponent("XMLHTTP");
            

            return new XMLHttpRequest();
        }
        : function(){
            if (apf.availHTTP.length)
                return apf.availHTTP.pop();

            
            //if(apf.isDeskrun && !apf.useNativeHttp)
            //    return jdshell.CreateComponent("XMLHTTP");
            

            return new ActiveXObject("microsoft.XMLHTTP");
        };

    apf.getXmlDom = hasIESecurity
        ? function(message, noError){
            var xmlParser = getDOMParser(message, noError);
            return xmlParser;
        }
        : function(message, noError, preserveWhiteSpaces){
            var xmlParser = new ActiveXObject("microsoft.XMLDOM");
            xmlParser.setProperty("SelectionLanguage", "XPath");
            if (preserveWhiteSpaces)
                xmlParser.preserveWhiteSpace = true;

            if (message) {
                if (apf.cantParseXmlDefinition)
                    message = message.replace(/\] \]/g, "] ]")
                                     .replace(/^<\?[^>]*\?>/, "");//replace xml definition <?xml .* ?> for IE5.0

                xmlParser.loadXML(message);

                
                if (xmlParser.parseError != 0 && apf.xmldb && apf.isJson(message)) {
                    try {
                        xmlParser = apf.json2Xml(message, noError);
                    }
                   catch(e) {
                        throw new Error(apf.formatErrorString(1051, null,
                           "JSON to XML conversion error occurred."+e.message,
                           "\nSource Text : " + message.replace(/\t/gi, " ")));
                    }
                }
                else
                
                if (!noError)
                    this.xmlParseError(xmlParser);
            }

            return xmlParser;
        };

    apf.xmlParseError = function(xml){
        var xmlParseError = xml.parseError;
        if (xmlParseError != 0) {
            /*
             http://msdn.microsoft.com/library/en-us/xmlsdk30/htm/xmobjpmexmldomparseerror.asp?frame=true

             errorCode     Contains the error code of the last parse error. Read-only.
             filepos         Contains the absolute file position where the error occurred. Read-only.
             line             Specifies the line number that contains the error. Read-only.
             linepos         Contains the character position within the line where the error occurred. Read-only.
             reason         Explains the reason for the error. Read-only.
             srcText         Returns the full text of the line containing the error. Read-only.
             url             Contains the URL of the XML document containing the last error. Read-only.
             */
            throw new Error(apf.formatErrorString(1050, null,
                "XML Parse error on line " + xmlParseError.line,
                xmlParseError.reason + "Source Text:\n"
                    + xmlParseError.srcText.replace(/\t/gi, " ")
            ));
        }

        return xml;
    };
    
    /**
     * This method retrieves the current value of a property on a HTML element
     * @param {HTMLElement} el    the element to read the property from
     * @param {String}      prop  the property to read
     * @returns {String}
     */
    apf.getStyle = function(el, prop) {
        return el.currentStyle[prop];
    };
  
    apf.insertHtmlNodes = function(nodeList, htmlNode, beforeNode){
        for (var str = [], i = 0, l = nodeList.length; i < l; i++)
            str[i] = nodeList[i].xml;

        str = apf.html_entity_decode(str.join(""));
        
        if (apf.isIE < 7)
            str = str.replace(/style="background-image:([^"]*)"/g, 
              "find='$1' style='background-image:$1'");

        try {
            (beforeNode || htmlNode).insertAdjacentHTML(beforeNode
                ? "beforebegin"
                : "beforeend", str);
        }
        catch (e) {
            //IE table hack
            document.body.insertAdjacentHTML("beforeend", "<table><tr>"
                + str + "</tr></table>");

            var x = document.body.lastChild.firstChild.firstChild;
            for (i = x.childNodes.length - 1; i >= 0; i--)
                htmlNode.appendChild(x.childNodes[apf.hasDynamicItemList ? 0 : i]);
        }

        //Fix IE image loading bug
        if (apf.isIE < 7) {
            $setTimeout(function(){
                var nodes = htmlNode.getElementsByTagName("*");
                for (var s, i = 0, l = nodes.length; i < l; i++) {
                    if (s = nodes[i].getAttribute("find"))
                        nodes[i].style.backgroundImage = s.trim(); //@todo apf3.0 why is this needed?
                }
            });
        }
    }
    
    /* I have no idea what below code should do
    
    if (pNode.nodeType == 11) {
        id = xmlNode.getAttribute("id");
        if (!id)
            throw new Error(apf.formatErrorString(1049, null, "xmldb", "Inserting Cache Item in Document Fragment without an ID"));

        document.body.insertAdjacentHTML(beforeNode ? "beforebegin" : "beforeend", strHTML);
        pNode.appendChild(document.getElementById(id));
    }*/
    apf.insertHtmlNode = function(xmlNode, htmlNode, beforeNode, str){
        if (htmlNode.nodeType != 11 && !htmlNode.style)
            return htmlNode.appendChild(xmlNode);
        
        var pNode = beforeNode || htmlNode;
        
        if (!str)
            str = apf.html_entity_decode(xmlNode.serialize
                ? xmlNode.serialize(true)
                : xmlNode.xml || xmlNode.outerHTML || xmlNode.nodeValue);
        try {
            pNode.insertAdjacentHTML(beforeNode 
                ? "beforeBegin" 
                : "beforeEnd", str);
        }
        catch(e) {
            
            apf.console.warn("Warning found block element inside a " 
              + pNode.tagName 
              + " element. Rendering will give unexpected results");
            
            
            pNode.insertAdjacentHTML("afterEnd", str);
            return pNode.nextSibling;
        }

        return beforeNode ? beforeNode.previousSibling : htmlNode.lastChild;
    }
    
    apf.getHorBorders = function(oHtml){
        return Math.max(0,
              (parseInt(oHtml.currentStyle["borderLeftWidth"]) || 0)
            + (parseInt(oHtml.currentStyle["borderRightWidth"]) || 0))
    };

    apf.getVerBorders = function(oHtml){
        return Math.max(0,
              (parseInt(oHtml.currentStyle["borderTopWidth"]) || 0)
            + (parseInt(oHtml.currentStyle["borderBottomWidth"]) || 0))
    };

    apf.getWidthDiff = function(oHtml){
        return Math.max(0, (parseInt(oHtml.currentStyle["paddingLeft"]) || 0)
            + (parseInt(oHtml.currentStyle["paddingRight"]) || 0)
            + (parseInt(oHtml.currentStyle["borderLeftWidth"]) || 0)
            + (parseInt(oHtml.currentStyle["borderRightWidth"]) || 0))
    };

    apf.getHeightDiff = function(oHtml){
        return Math.max(0, (parseInt(oHtml.currentStyle["paddingTop"]) || 0)
            + (parseInt(oHtml.currentStyle["paddingBottom"]) || 0)
            + (parseInt(oHtml.currentStyle["borderTopWidth"]) || 0)
            + (parseInt(oHtml.currentStyle["borderBottomWidth"]) || 0))
    };

    apf.getDiff = function(oHtml){
        return [Math.max(0, (parseInt(oHtml.currentStyle["paddingLeft"]) || 0)
            + (parseInt(oHtml.currentStyle["paddingRight"]) || 0)
            + (parseInt(oHtml.currentStyle["borderLeftWidth"]) || 0)
            + (parseInt(oHtml.currentStyle["borderRightWidth"]) || 0)),
            Math.max(0, (parseInt(oHtml.currentStyle["paddingTop"]) || 0)
            + (parseInt(oHtml.currentStyle["paddingBottom"]) || 0)
            + (parseInt(oHtml.currentStyle["borderTopWidth"]) || 0)
            + (parseInt(oHtml.currentStyle["borderBottomWidth"]) || 0))]
    };
    
    apf.getMargin = function(oHtml) {
        return [Math.max(0, (parseInt(oHtml.currentStyle["marginLeft"]) || 0)
            + (parseInt(oHtml.currentStyle["marginRight"]) || 0)),
            Math.max(0, (parseInt(oHtml.currentStyle["marginTop"]) || 0)
            + (parseInt(oHtml.currentStyle["marginBottom"]) || 0))]
    };

    
    /**
     * @private
     */
    apf.popup2 = {
        cache: {},
        setContent: function(cacheId, content, style, width, height){
            if (!this.popup)
                this.init();

            this.cache[cacheId] = {
                content: content,
                style  : style,
                width  : width,
                height : height
            };
            if (content.parentNode)
                content.parentNode.removeChild(content);
            if (style)
                apf.importCssString(style, this.popup.document);

            return this.popup.document;
        },

        removeContent: function(cacheId){
            this.cache[cacheId] = null;
            delete this.cache[cacheId];
        },

        init: function(){
            this.popup = window.createPopup();

            this.popup.document.write('<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">\
                <html xmlns="http://www.w3.org/1999/xhtml" xmlns:a=' + apf.ns.aml + ' xmlns:xsl="http://www.w3.org/1999/XSL/Transform">\
                <head>\
                    <script>\
                    var apf = {\
                        all: [],\
                        lookup:function(uniqueId){\
                            return this.all[uniqueId] || {\
                                $setStyleClass:function(){}\
                            };\
                        }\
                    };\
                    function destroy(){\
                        apf.all=null;\
                    }\
                    </script>\
                    <style>\
                    HTML{border:0;overflow:hidden;margin:0}\
                    BODY{margin:0}\
                    </style>\
                </head>\
                <body onmouseover="if(!self.apf) return;if(this.c){apf.all = this.c.all;this.c.Popup.parentDoc=self;}"></body>\
                </html>');

            var c = apf;
            this.popup.document.body.onmousemove = function(){
                this.c = c
            }
        },

        show: function(cacheId, x, y, animate, ref, width, height, callback){
            if (!this.popup)
                this.init();
            var o = this.cache[cacheId];
            //if(this.last != cacheId)
            this.popup.document.body.innerHTML = o.content.outerHTML;

            if (animate) {
                var iVal, steps = 7, i = 0, popup = this.popup;
                iVal = setInterval(function(){
                    var value = ++i * ((height || o.height) / steps);
                    popup.show(x, y, width || o.width, value, ref);
                    popup.document.body.firstChild.style.marginTop
                        = (i - steps - 1) * ((height || o.height) / steps);
                    if (i > steps) {
                        clearInterval(iVal)
                        callback(popup.document.body.firstChild);
                    }
                }, 10);
            }
            else {
                this.popup.show(x, y, width || o.width, height || o.height, ref);
            }

            this.last = cacheId;
        },

        hide: function(){
            if (this.popup)
                this.popup.hide();
        },

        forceHide: function(){
            if (this.last)
                apf.lookup(this.last).dispatchEvent("popuphide");
        },

        destroy: function(){
            if (!this.popup)
                return;
            this.popup.document.body.c = null;
            this.popup.document.body.onmouseover = null;
        }
    };
    

    
    apf.importClass(apf.runXpath, true, self);
    
}




/*FILEHEAD(/var/lib/platform/source/trunk/core/browsers/non_ie.js)SIZE(25467)TIME(1265038748)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * @private
 */
apf.runNonIe = function (){
    

    DocumentFragment.prototype.getElementById = function(id){
        return this.childNodes.length ? this.childNodes[0].ownerDocument.getElementById(id) : null;
    };
    
    /**** XML Serialization ****/
    if (XMLDocument.prototype.__defineGetter__) {
        //XMLDocument.xml
        XMLDocument.prototype.__defineGetter__("xml", function(){
            return (new XMLSerializer()).serializeToString(this);
        });
        XMLDocument.prototype.__defineSetter__("xml", function(){
            throw new Error(apf.formatErrorString(1042, null, "XML serializer", "Invalid assignment on read-only property 'xml'."));
        });
        
        //Node.xml
        Node.prototype.__defineGetter__("xml", function(){
            if (this.nodeType == 3 || this.nodeType == 4 || this.nodeType == 2) 
                return this.nodeValue;
            return (new XMLSerializer()).serializeToString(this);
        });
        
        //Node.xml
        Element.prototype.__defineGetter__("xml", function(){
            return (new XMLSerializer()).serializeToString(this);
        });
    }
    
    /* ******** HTML Interfaces **************************************************
        insertAdjacentHTML(), insertAdjacentText() and insertAdjacentElement()
    ****************************************************************************/
    if (typeof HTMLElement!="undefined") {
        if (!HTMLElement.prototype.insertAdjacentElement) {
            Text.prototype.insertAdjacentElement =
            HTMLElement.prototype.insertAdjacentElement = function(where,parsedNode){
                switch (where.toLowerCase()) {
                    case "beforebegin":
                        this.parentNode.insertBefore(parsedNode,this);
                        break;
                    case "afterbegin":
                        this.insertBefore(parsedNode,this.firstChild);
                        break;
                    case "beforeend":
                        this.appendChild(parsedNode);
                        break;
                    case "afterend":
                        if (this.nextSibling)
                            this.parentNode.insertBefore(parsedNode,this.nextSibling);
                        else
                            this.parentNode.appendChild(parsedNode);
                        break;
                }
            };
        }

        if (!HTMLElement.prototype.insertAdjacentHTML) {
            Text.prototype.insertAdjacentHTML =
            HTMLElement.prototype.insertAdjacentHTML = function(where,htmlStr){
                var r = this.ownerDocument.createRange();
                r.setStartBefore(apf.isWebkit
                    ? document.body
                    : (self.document ? document.body : this));
                var parsedHTML = r.createContextualFragment(htmlStr);
                this.insertAdjacentElement(where, parsedHTML);
            };
        }

        if (!HTMLBodyElement.prototype.insertAdjacentHTML) //apf.isWebkit)
            HTMLBodyElement.prototype.insertAdjacentHTML = HTMLElement.prototype.insertAdjacentHTML;
    
        if (!HTMLElement.prototype.insertAdjacentText) {
            Text.prototype.insertAdjacentText =
            HTMLElement.prototype.insertAdjacentText = function(where,txtStr){
                var parsedText = document.createTextNode(txtStr);
                this.insertAdjacentElement(where,parsedText);
            };
        }
        
        //HTMLElement.removeNode
        HTMLElement.prototype.removeNode = function(){
            if (!this.parentNode) return;

            this.parentNode.removeChild(this);
        };
        
        //Currently only supported by Gecko
        if (HTMLElement.prototype.__defineSetter__) {
            //HTMLElement.innerText
            HTMLElement.prototype.__defineSetter__("innerText", function(sText){
                var s = "" + sText;
                this.innerHTML = s.replace(/\&/g, "&amp;")
                    .replace(/</g, "&lt;").replace(/>/g, "&gt;");
            });
        
            HTMLElement.prototype.__defineGetter__("innerText", function(){
                return this.innerHTML.replace(/<[^>]+>/g,"")
                    .replace(/\s\s+/g, " ").replace(/^\s*|\s*$/g, " ")
            });
            
            HTMLElement.prototype.__defineGetter__("outerHTML", function(){
                return (new XMLSerializer()).serializeToString(this);
            });
        }
    }
    
    /* ******** XML Compatibility ************************************************
        Giving the Mozilla XML Parser the same interface as IE's Parser
    ****************************************************************************/
    var ASYNCNOTSUPPORTED = false;
    
    //Test if Async is supported
    try {
        XMLDocument.prototype.async = true;
        ASYNCNOTSUPPORTED           = true;
    } catch(e) {/*trap*/} 
    
    Document.prototype.onreadystatechange = null;
    Document.prototype.parseError         = 0;
    
    Array.prototype.item = function(i){return this[i];};
    Array.prototype.expr = "";
    
    try{
        XMLDocument.prototype.readyState = 0;
    }catch(e){}
    
    XMLDocument.prototype.$clearDOM = function(){
        while (this.hasChildNodes())
            this.removeChild(this.firstChild);
    };
    
    XMLDocument.prototype.$copyDOM = function(oDoc){
        this.$clearDOM();
        
        if (oDoc.nodeType == 9 || oDoc.nodeType == 11) {
           var oNodes = oDoc.childNodes;
    
           for (var i = 0; i < oNodes.length; i++)
                this.appendChild(this.importNode(oNodes[i], true));
        }
        else if (oDoc.nodeType == 1)
            this.appendChild(this.importNode(oDoc, true));
    };
    
    //XMLDocument.loadXML();
    XMLDocument.prototype.loadXML = function(strXML){
        apf.xmldb.setReadyState(this, 1);
        var sOldXML = this.xml || this.serialize();
        var oDoc    = (new DOMParser()).parseFromString(strXML, "text/xml");
        apf.xmldb.setReadyState(this, 2);
        this.$copyDOM(oDoc);
        apf.xmldb.setReadyState(this, 3);
        apf.xmldb.loadHandler(this);
        return sOldXML;
    };
    
    Node.prototype.getElementById = function(id){};
    
    HTMLElement.prototype.replaceNode = 
    Element.prototype.replaceNode     = function(xmlNode){
        if (!this.parentNode) return;

        this.parentNode.insertBefore(xmlNode, this);
        this.parentNode.removeChild(this);
    };
    
    //XMLDocument.load
    XMLDocument.prototype.$load = XMLDocument.prototype.load;
    XMLDocument.prototype.load  = function(sURI){
        var oDoc = document.implementation.createDocument("", "", null);
        oDoc.$copyDOM(this);
        this.parseError = 0;
        apf.xmldb.setReadyState(this, 1);
    
        try {
            if (this.async == false && ASYNCNOTSUPPORTED) {
                var tmp = new XMLHttpRequest();
                tmp.open("GET", sURI, false);
                tmp.overrideMimeType("text/xml");
                tmp.send(null);
                apf.xmldb.setReadyState(this, 2);
                this.$copyDOM(tmp.responseXML);
                apf.xmldb.setReadyState(this, 3);
            } else
                this.$load(sURI);
        }
        catch (objException) {
            this.parseError = -1;
        }
        finally {
            apf.xmldb.loadHandler(this);
        }
    
        return oDoc;
    };
    
    
    
    
    
    //Element.transformNodeToObject
    Element.prototype.transformNodeToObject = function(xslDoc, oResult){
        var oDoc = document.implementation.createDocument("", "", null);
        oDoc.$copyDOM(this);
        oDoc.transformNodeToObject(xslDoc, oResult);
    };
    
    //Document.transformNodeToObject
    Document.prototype.transformNodeToObject = function(xslDoc, oResult){
        var xsltProcessor = null;
        try {
            xsltProcessor = new XSLTProcessor();
            
            if (xsltProcessor.reset) {
                // new nsIXSLTProcessor is available
                xslDoc = apf.getXmlDom(xslDoc.xml || xslDoc.serialize());
                xsltProcessor.importStylesheet(xslDoc);
                var newFragment = xsltProcessor.transformToFragment(this, oResult);
                oResult.$copyDOM(newFragment);
            }
            else {
                // only nsIXSLTProcessorObsolete is available
                xsltProcessor.transformDocument(this, xslDoc, oResult, null);
            }
        }
        catch(e) {
            if (xslDoc && oResult)
                throw new Error(apf.formatErrorString(1043, null, "XSLT Transformation", "Failed to transform document. \nInfo : " + e));
            else if (!xslDoc)
                throw new Error(apf.formatErrorString(1044, null, "XSLT Transformation", "No Stylesheet Document was provided. \nInfo : " + e));
            else if (!oResult)
                throw new Error(apf.formatErrorString(1045, null, "XSLT Transformation", "No Result Document was provided. \nInfo : " + e));
            else if (xsltProcessor == null)
                throw new Error(apf.formatErrorString(1046, null, "XSLT Transformation", "Could not instantiate an XSLTProcessor object. \nInfo : " + e));
            else
                throw e;
        }
    };
    
    //Element.transformNode
    Element.prototype.transformNode = function(xslDoc){
        return apf.getXmlDom(this.xml || this.serialize())
            .transformNode(xslDoc);
    };
    
    //Document.transformNode
    Document.prototype.transformNode = function(xslDoc){
        var xsltProcessor = new XSLTProcessor();
        xslDoc        = apf.getXmlDom(xslDoc.xml || xslDoc.serialize());
        xsltProcessor.importStylesheet(xslDoc);
        var newFragment   = xsltProcessor.transformToFragment(this,
            document.implementation.createDocument("", "", null));
    
        return newFragment.xml || newFragment.serialize()
        
        /*try{
            var serializer = new XMLSerializer();
            str = serializer.serializeToString(out);
        }
        catch(e){
            throw new Error("---- APF Error ----\nProcess : XSLT Transformation\nMessage : Failed to serialize result document. \nInfo : " + e);
        }
        
        return str;*/
    };
    
    
    
    /**
     * This method retrieves the current value of a property on a HTML element
     * @param {HTMLElement} el    the element to read the property from
     * @param {String}      prop  the property to read
     * @returns {String}
     */
    apf.getStyle = function(el, prop) {
        return window.getComputedStyle(el, '').getPropertyValue(prop);
    };
    
    //XMLDocument.setProperty
    HTMLDocument.prototype.setProperty = 
    XMLDocument.prototype.setProperty  = function(x,y){};
    
    /* ******** XML Compatibility ************************************************
        Extensions to the xmldb
    ****************************************************************************/
    apf.getHttpReq = function(){
        if (apf.availHTTP.length)
            return apf.availHTTP.pop();
        return new XMLHttpRequest();
    };

    apf.getXmlDom = function(message, noError){
        var xmlParser;
        if (message) {
            xmlParser = new DOMParser();
            xmlParser = xmlParser.parseFromString(message, "text/xml");

            
            if (xmlParser.documentElement.tagName == "parsererror" && apf.xmldb
              && apf.isJson(message)) {
                try {
                    xmlParser = apf.json2Xml(message, noError);
                }
                catch(e) {
                    throw new Error(apf.formatErrorString(1051, null,
                        "JSON to XML conversion error occurred.",
                        "\nSource Text : " + message.replace(/\t/gi, " ")));
                }
            }
            else
            
            if (!noError)
                this.xmlParseError(xmlParser);
        }
        else {
            xmlParser = document.implementation.createDocument("", "", null);
        }
        
        return xmlParser;
    };
    
    apf.xmlParseError = function(xml){
        if (xml.documentElement.tagName == "parsererror") {
            var str     = xml.documentElement.firstChild.nodeValue.split("\n"),
                linenr  = str[2].match(/\w+ (\d+)/)[1],
                message = str[0].replace(/\w+ \w+ \w+: (.*)/, "$1"),
            
                srcText = xml.documentElement.lastChild.firstChild.nodeValue.split("\n")[0];
            
            throw new Error(apf.formatErrorString(1050, null, 
                "XML Parse Error on line " +  linenr, message + 
                "\nSource Text : " + srcText.replace(/\t/gi, " ")));
        }
        
        return xml;
    };

    
    apf.xmldb.setReadyState = function(oDoc, iReadyState) {
        oDoc.readyState = iReadyState;
        if (oDoc.onreadystatechange != null && typeof oDoc.onreadystatechange == "function")
            oDoc.onreadystatechange();
    };
    
    apf.xmldb.loadHandler = function(oDoc){
        if (!oDoc.documentElement || oDoc.documentElement.tagName == "parsererror")
            oDoc.parseError = -1;
        
        apf.xmldb.setReadyState(oDoc, 4);
    };
    
    //
    //Fix XML Data-Island Support Problem with Form Tag
    apf.Init.add(function(){
        var i, nodes = document.getElementsByTagName("form");
        for (i = 0; i < nodes.length; i++)
            nodes[i].removeNode();
        nodes = document.getElementsByTagName("xml");
        for(i = 0; i < nodes.length; i++)
            nodes[i].removeNode();
        nodes = null;
    });
    
    /*window.onerror = function(message, filename, linenr){
        if(++ERROR_COUNT > MAXMSG) return;
        filename = filename ? filename.match(/\/([^\/]*)$/)[1] : "[Mozilla Library]";
        new Error("---- APF Error ----\nProcess : Javascript code in '" + filename +  "'\nLine : " + linenr + "\nMessage : " + message);
        return false;
    }*/
    
    if (document.body)
        document.body.focus = function(){};
    
    
    
    if (!document.elementFromPoint) {
        Document.prototype.elementFromPointRemove = function(el){
            if (!this.RegElements) return;

            this.RegElements.remove(el);
        };
        
        Document.prototype.elementFromPointAdd = function(el){
            if (!this.RegElements)
                this.RegElements = [];
            this.RegElements.push(el);
        };
        
        Document.prototype.elementFromPointReset = function(RegElements){
            //define globals
            FoundValue   = [];
            FoundNode    = null;
            LastFoundAbs = document.documentElement;
        };
        
        Document.prototype.elementFromPoint = function(x, y){
            // Optimization, Keeping last found node makes it ignore all lower levels 
            // when there is no possibility of changing positions and zIndexes
            /*if(self.FoundNode){
                var sx = getElementPosX(FoundNode); 
                var sy = getElementPosY(FoundNode);
                var ex = sx + FoundNode.offsetWidth; var ey = sy + FoundNode.offsetHeight;
            }
            if(!self.FoundNode || !(x > sx && x < ex && y > sy && y < ey))*/
                document.elementFromPointReset();
        
            // Optimization only looking at registered nodes
            if (this.RegElements) {
                var calc_z = -1,
                    i, calc, n, sx, sy, ex, ey, z
                for (calc_z = -1, calc, i = 0; i < this.RegElements.length; i++) {
                    n = this.RegElements[i];
                    if (getStyle(n, "display") == "none") continue;
        
                    sx = getElementPosX(n); 
                    sy = getElementPosY(n);
                    ex = sx + n.offsetWidth;
                    ey = sy + n.offsetHeight;
                    
                    if (x > sx && x < ex && y > sy && y < ey) {
                        z = getElementZindex(n);
                        if (z > calc_z) { //equal z-indexes not supported
                            calc   = [n, x, y, sx, sy];
                            calc_z = z;
                        }
                    }
                }
                
                if (calc) {
                    efpi(calc[0], calc[1], calc[2], 0, FoundValue, calc[3], calc[4]);
                    if (!FoundNode) {
                        FoundNode    = calc[0];
                        LastFoundAbs = calc[0];
                        FoundValue   = [calc_z];
                    }
                }
            }
            
            if (!this.RegElements || !this.RegElements.length)
                efpi(document.body, x, y, 0, [], getElementPosX(document.body),
                    getElementPosY(document.body));
                
            return FoundNode;
        };
        
        function getStyle(el, prop) {
            return document.defaultView.getComputedStyle(el,'').getPropertyValue(prop);
        }
        
        function efpi(from, x, y, CurIndex, CurValue, px, py){
            var StartValue = CurValue,
                StartIndex = CurIndex,
            //Loop through childNodes
                nodes      = from.childNodes,
                n, i, z, sx, sy, ex, ey, isAbs, isHidden, inSpace;
            for (n, i = 0; i < from.childNodes.length; i++) {
                n = from.childNodes[i];
                if (n.nodeType == 1 && getStyle(n, 'display') != 'none' && n.offsetParent) {
                    sx = px + n.offsetLeft - n.offsetParent.scrollLeft;//getElementPosX(n); 
                    sy = py + n.offsetTop - n.offsetParent.scrollTop;//getElementPosY(n);
                    ex = sx + n.offsetWidth;
                    ey = sy + n.offsetHeight;
                    
                    //if(Child is position absolute/relative and overflow == "hidden" && !inSpace) continue;
                    isAbs    = getStyle(n, "position");
                    isAbs        = (isAbs == "absolute") || (isAbs == "relative");
                    isHidden = getStyle(n, "overflow") == "hidden";
                    inSpace  = (x > sx && x < ex && y > sy && y < ey);

                    if (isAbs && isHidden && !inSpace) continue;
            
                    CurIndex = StartIndex;
                    CurValue = StartValue.copy();
            
                    //if (Child is position absolute/relative and has zIndex) or overflow == "hidden"
                    z = parseInt(getStyle(n, "z-index")) || 0;
                    if (isAbs && (z || z == 0) || isHidden) {
                        //if(!is position absolute/relative) zIndex = 0
                        if (!isAbs) z = 0;
                        
                        //if zIndex >= FoundValue[CurIndex] 
                        if (z >= (FoundValue[CurIndex] || 0)) {
                            //if zIndex > CurValue[CurIndex];
                            if (z > (CurValue[CurIndex] || 0)) {
                                //CurValue = StartValue.copy();
                                
                                //set CurValue[CurIndex] = zIndex
                                CurValue[CurIndex] = z;
                            }
                            
                            CurIndex++;
                            
                            //if(inSpace && CurIndex >= FoundValue.length)
                            if (inSpace && CurIndex >= FoundValue.length) {
                                //Set FoundNode is currentNode
                                FoundNode = n;
                                //Set FoundValue is CurValue
                                FoundValue = CurValue;//.copy();
                                
                                LastFoundAbs = n;
                            }
                        }
                        else
                            continue; //Ignore this treedepth
                    }
                    else if(inSpace && CurIndex >= FoundValue.length){
                        //else if CurValue[CurIndex] continue; //Ignore this treedepth
                        //else if(CurValue[CurIndex]) continue;
                        
                        //Set FoundNode is currentNode
                        FoundNode = n;
                        //Set FoundValue is CurValue
                        FoundValue = CurValue;//.copy();
                    }
                    
                    //loop through childnodes recursively
                    efpi(n, x, y, CurIndex, CurValue, isAbs ? sx : px, isAbs ? sy : py)
                }
            }
        }
        
        function getElementPosY(myObj){
            return myObj.offsetTop + parseInt(apf.getStyle(myObj, "border-top-width"))
                + (myObj.offsetParent ? getElementPosY(myObj.offsetParent) : 0);
        }
        
        function getElementPosX(myObj){
            return myObj.offsetLeft + parseInt(apf.getStyle(myObj, "border-left-width"))
                + (myObj.offsetParent ? getElementPosX(myObj.offsetParent) : 0);
        }
        
        function getElementZindex(myObj){
            //This is not quite sufficient and should be changed
            var z = 0, n, p = myObj;
            while (p && p.nodeType == 1) {
                z = Math.max(z, parseInt(getStyle(p, "z-index")) || -1);
                p = p.parentNode;
            }
            return z;
        }
    }
    
    

    apf.getHorBorders = function(oHtml){
        return Math.max(0, 
              (parseInt(apf.getStyle(oHtml, "border-left-width")) || 0)
            + (parseInt(apf.getStyle(oHtml, "border-right-width")) || 0));
    };
    
    apf.getVerBorders = function(oHtml){
        return Math.max(0, 
              (parseInt(apf.getStyle(oHtml, "border-top-width")) || 0)
            + (parseInt(apf.getStyle(oHtml, "border-bottom-width")) || 0));
    };

    apf.getWidthDiff = function(oHtml){
        return Math.max(0, (parseInt(apf.getStyle(oHtml, "padding-left")) || 0)
            + (parseInt(apf.getStyle(oHtml, "padding-right")) || 0)
            + (parseInt(apf.getStyle(oHtml, "border-left-width")) || 0)
            + (parseInt(apf.getStyle(oHtml, "border-right-width")) || 0));
    };
    
    apf.getHeightDiff = function(oHtml){
        return Math.max(0, (parseInt(apf.getStyle(oHtml, "padding-top")) || 0)
            + (parseInt(apf.getStyle(oHtml, "padding-bottom")) || 0)
            + (parseInt(apf.getStyle(oHtml, "border-top-width")) || 0)
            + (parseInt(apf.getStyle(oHtml, "border-bottom-width")) || 0));
    };
    
    apf.getDiff = function(oHtml){
        return [Math.max(0, parseInt(apf.getStyle(oHtml, "padding-left"))
            + parseInt(apf.getStyle(oHtml, "padding-right"))
            + parseInt(apf.getStyle(oHtml, "border-left-width"))
            + parseInt(apf.getStyle(oHtml, "border-right-width")) || 0),
            Math.max(0, parseInt(apf.getStyle(oHtml, "padding-top"))
            + parseInt(apf.getStyle(oHtml, "padding-bottom"))
            + parseInt(apf.getStyle(oHtml, "border-top-width"))
            + parseInt(apf.getStyle(oHtml, "border-bottom-width")) || 0)];
    };
    
    apf.getMargin = function(oHtml) {
        return [Math.max(0, (parseInt(apf.getStyle(oHtml, "margin-left")) || 0)
            + (parseInt(apf.getStyle(oHtml, "margin-right")) || 0)),
            Math.max(0, (parseInt(apf.getStyle(oHtml, "margin-top")) || 0)
            + (parseInt(apf.getStyle(oHtml, "margin-bottom")) || 0))]
    };
}



/*FILEHEAD(/var/lib/platform/source/trunk/core/browsers/opera.js)SIZE(5330)TIME(1262085721)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Compatibility layer for Opera browsers.
 * @private
 */
apf.runOpera = function (){
    if (apf.runNonIe)
        apf.runNonIe();
    
    /* ***************************************************************************
     XML Serialization
     ****************************************************************************/
    //XMLDocument.xml
    
    //Node.xml
    /*Node.prototype.serialize = function(){
     return (new XMLSerializer()).serializeToString(this);
     }
    //Node.xml
    
    Node.prototype.serialize        =
    XMLDocument.prototype.serialize =
    Element.prototype.serialize     = function(){
        return (new XMLSerializer()).serializeToString(this);
    };*/
    
    
    
    //XMLDocument.selectNodes
    Document.prototype.selectNodes     = 
    XMLDocument.prototype.selectNodes  =
    HTMLDocument.prototype.selectNodes = function(sExpr, contextNode){
        var oResult = this.evaluate(sExpr, (contextNode ? contextNode : this),
            this.createNSResolver(this.documentElement),
            XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
        var nodeList = new Array(oResult.snapshotLength);
        nodeList.expr = sExpr;
        for (var i = 0; i < nodeList.length; i++) 
            nodeList[i] = oResult.snapshotItem(i);
        return nodeList;
    };
    
    //Element.selectNodes
    Text.prototype.selectNodes =
    Element.prototype.selectNodes = function(sExpr){
        var doc = this.ownerDocument;
        if (!doc.selectSingleNode) {
            doc.selectSingleNode = HTMLDocument.prototype.selectSingleNode;
            doc.selectNodes = HTMLDocument.prototype.selectNodes;
        }
        
        if (doc.selectNodes) 
            return doc.selectNodes(sExpr, this);
        else {
            throw new Error(apf.formatErrorString(1047, null, "XPath Selection", 
                "Method selectNodes is only supported by XML Nodes"));
        }
    };
    
    //XMLDocument.selectSingleNode
    Document.prototype.selectSingleNode     =
    XMLDocument.prototype.selectSingleNode  =
    HTMLDocument.prototype.selectSingleNode = function(sExpr, contextNode){
        var nodeList = this.selectNodes(sExpr + "[1]", contextNode ? contextNode : null);
        return nodeList.length > 0 ? nodeList[0] : null;
    };
    
    //Element.selectSingleNode
    Text.prototype.selectSingleNode =
    Element.prototype.selectSingleNode = function(sExpr){
        var doc = this.ownerDocument;
        if (!doc.selectSingleNode) {
            doc.selectSingleNode = HTMLDocument.prototype.selectSingleNode;
            doc.selectNodes = HTMLDocument.prototype.selectNodes;
        }
        
        if (doc.selectSingleNode) {
            return doc.selectSingleNode(sExpr, this);
        }
        else {
            throw new Error(apf.formatErrorString(1048, null, "XPath Selection", 
                "Method selectSingleNode is only supported by XML Nodes. \nInfo : " + e));
        }
    };
    
    
    
    var serializer = new XMLSerializer();
    apf.insertHtmlNodes = function(nodeList, htmlNode, beforeNode) {
        var node,
            frag = document.createDocumentFragment(),
            i    = 0,
            l    = nodeList.length
        for (; i < l; i++) {
            if (!(node = nodeList[i])) continue;
            frag.appendChild(node);
        }
        (beforeNode || htmlNode).insertAdjacentHTML(beforeNode
            ? "beforebegin"
            : "beforeend", apf.html_entity_decode(serializer.serializeToString(frag)).replace(/<([^>]+)\/>/g, "<$1></$1>"));
    };

    apf.insertHtmlNode = function(xmlNode, htmlNode, beforeNode, s) {
        if (!s) {
            s = apf.html_entity_decode(xmlNode.serialize 
                ? xmlNode.serialize(true)
                : ((xmlNode.nodeType == 3 || xmlNode.nodeType == 4 || xmlNode.nodeType == 2)
                    ? xmlNode.nodeValue
                    : serializer.serializeToString(xmlNode)));
        }
        
        (beforeNode || htmlNode).insertAdjacentHTML(beforeNode
            ? "beforebegin"
            : "beforeend", s.replace(/<([^>]+)\/>/g, "<$1></$1>"));

        return beforeNode ? beforeNode.previousSibling : htmlNode.lastChild;
    };
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/browsers/webkit.js)SIZE(6483)TIME(1265032027)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Compatibility layer for Webkit based browsers.
 * @private
 */
apf.runWebkit = function(){
    
    if (!apf.isChrome) {
        var setTimeoutSafari = window.setTimeout;
        self.lookupSafariCall = [];
        $setTimeout = function(call, time){
            if (typeof call == "string") 
                return setTimeoutSafari(call, time);
            return setTimeoutSafari("self.lookupSafariCall["
                + (self.lookupSafariCall.push(call) - 1) + "]()", time);
        }
        
        if (apf.isSafariOld) {
            HTMLHtmlElement = document.createElement("html").constructor;
            Node            = HTMLElement = {};
            HTMLElement.prototype = HTMLHtmlElement.apf.__proto__.apf.__proto__;
            HTMLDocument    = Document = document.constructor;
            var x           = new DOMParser();
            XMLDocument     = x.constructor;
            Element         = x.parseFromString("<Single />", "text/xml").documentElement.constructor;
            x               = null;
        }
        if (!XMLDocument.prototype.__defineGetter__) {
            Document.prototype.serialize    = 
            Node.prototype.serialize        =
            XMLDocument.prototype.serialize = function(){
                return (new XMLSerializer()).serializeToString(this);
            };
        }
    }
    
    
    
    
    
    
    HTMLDocument.prototype.selectNodes = XMLDocument.prototype.selectNodes = function(sExpr, contextNode){
        if (sExpr.substr(0,2) == "//")
            sExpr = "." + sExpr;
        
        try {
            var oResult = this.evaluate(sExpr, (contextNode || this),
                this.createNSResolver(this.documentElement),
                7, null);//XPathResult.ORDERED_NODE_SNAPSHOT_TYPE
        }
        catch(ex) {
            try {
                var oResult = this.evaluate("child::" + sExpr, (contextNode || this),
                    this.createNSResolver(this.documentElement),
                    7, null);//XPathResult.ORDERED_NODE_SNAPSHOT_TYPE
            }
            catch(ex) {
                throw new Error("XPath error: " + ex.message + "\nLine: " + ex.lineNumber  + "\nExpression: '" + sExpr + "'");
            }
        }
        
        var nodeList = new Array(oResult.snapshotLength);
        nodeList.expr = sExpr;
        for (var i = nodeList.length - 1; i >= 0; i--) 
            nodeList[i] = oResult.snapshotItem(i);
        return nodeList;
    };
    
    //Element.selectNodes
    Text.prototype.selectNodes =
    Element.prototype.selectNodes = function(sExpr){
       return this.ownerDocument.selectNodes(sExpr, this);
    };
    
    //XMLDocument.selectSingleNode
    HTMLDocument.prototype.selectSingleNode = XMLDocument.prototype.selectSingleNode = function(sExpr, contextNode){
        var nodeList = this.selectNodes(sExpr, contextNode || null);
        return nodeList[0] || null;
    };
    
    //Element.selectSingleNode
    Text.prototype.selectSingleNode =
    Element.prototype.selectSingleNode = function(sExpr){
        return this.ownerDocument.selectSingleNode(sExpr, this);
    };
    
    
    
    var serializer = new XMLSerializer();
    apf.insertHtmlNodes = function(nodeList, htmlNode, beforeNode) {
        var node,
            frag = document.createDocumentFragment(),
            a = [], i = 0, l = nodeList.length;
        for (; i < l; i++) {
            if (!(node = nodeList[i])) continue;
            frag.appendChild(node);
        }

        (beforeNode || htmlNode).insertAdjacentHTML(beforeNode
            ? "beforebegin"
            : "beforeend", apf.html_entity_decode(serializer.serializeToString(frag))
                .replace(/<([^>]+)\/>/g, "<$1></$1>"));
    };

    apf.insertHtmlNode = function(xmlNode, htmlNode, beforeNode, s) {
        if (!s) {
            s = apf.html_entity_decode(xmlNode.serialize 
                ? xmlNode.serialize(true)
                : ((xmlNode.nodeType == 3 || xmlNode.nodeType == 4 || xmlNode.nodeType == 2)
                    ? xmlNode.nodeValue
                    : serializer.serializeToString(xmlNode)));
        }
        
        (beforeNode || htmlNode).insertAdjacentHTML(beforeNode
            ? "beforebegin"
            : "beforeend", s.replace(/<([^>]+)\/>/g, "<$1></$1>"));

        return beforeNode ? beforeNode.previousSibling : htmlNode.lastChild;
    };

    if (apf.runNonIe)
        apf.runNonIe();
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/browsers/o3.js)SIZE(8825)TIME(1265038748)*/




/*FILEHEAD(/var/lib/platform/source/trunk/core/crypto/bigint.js)SIZE(20439)TIME(1257329185)*/

/**
 * BigInt, a suite of routines for performing multiple-precision arithmetic in
 * JavaScript.
 *
 * Copyright 1998-2005 David Shapiro.
 *
 * You may use, re-use, abuse,
 * copy, and modify this code to your liking, but please keep this header.
 * Thanks!
 *
 * @author Dave Shapiro <dave AT ohdave DOT com>
 * @author Ian Bunning
 *
 * IMPORTANT THING: Be sure to set maxDigits according to your precision
 * needs. Use the setMaxDigits() function to do this. See comments below.
 *
 * Tweaked by Ian Bunning
 * Alterations:
 * Fix bug in function biFromHex(s) to allow
 * parsing of strings of length != 0 (mod 4)
 *
 * Changes made by Dave Shapiro as of 12/30/2004:
 *
 * The BigInt() constructor doesn't take a string anymore. If you want to
 * create a BigInt from a string, use biFromDecimal() for base-10
 * representations, biFromHex() for base-16 representations, or
 * biFromString() for base-2-to-36 representations.
 *
 * biFromArray() has been removed. Use biCopy() instead, passing a BigInt
 * instead of an array.
 *
 * The BigInt() constructor now only constructs a zeroed-out array.
 * Alternatively, if you pass <true>, it won't construct any array. See the
 * biCopy() method for an example of this.
 *
 * Be sure to set maxDigits depending on your precision needs. The default
 * zeroed-out array ZERO_ARRAY is constructed inside the setMaxDigits()
 * function. So use this function to set the variable. DON'T JUST SET THE
 * VALUE. USE THE FUNCTION.
 *
 * ZERO_ARRAY exists to hopefully speed up construction of BigInts(). By
 * precalculating the zero array, we can just use slice(0) to make copies of
 * it. Presumably this calls faster native code, as opposed to setting the
 * elements one at a time. I have not done any timing tests to verify this
 * claim.
 * Max number = 10^16 - 2 = 9999999999999998;
 *               2^53     = 9007199254740992;
 */



apf.crypto.BigInt = (function() {
    var biRadixBase = 2;
    var biRadixBits = 16;
    var bitsPerDigit = biRadixBits;
    var biRadix = 1 << 16; // = 2^16 = 65536
    var biHalfRadix = biRadix >>> 1;
    var biRadixSquared = biRadix * biRadix;
    var maxDigitVal = biRadix - 1;
    var maxInteger = 9999999999999998; 
    
    /*
     * maxDigits:
     * Change this to accommodate your largest number size. Use setMaxDigits()
     * to change it!
     *
     * In general, if you're working with numbers of size N bits, you'll need 2*N
     * bits of storage. Each digit holds 16 bits. So, a 1024-bit key will need
     *
     * 1024 * 2 / 16 = 128 digits of storage.
     */
    
    var maxDigits;
    var ZERO_ARRAY;
    var bigZero, bigOne;
    
    function setMaxDigits(value) {
        maxDigits = value;
        ZERO_ARRAY = new Array(maxDigits);
        for (var iza = 0; iza < ZERO_ARRAY.length; iza++) ZERO_ARRAY[iza] = 0;
        bigZero = new BigInt();
        bigOne = new BigInt();
        bigOne.digits[0] = 1;
    }
    
    setMaxDigits(20);
    
    // The maximum number of digits in base 10 you can convert to an
    // integer without JavaScript throwing up on you.
    var dpl10 = 15;
    // lr10 = 10 ^ dpl10
    var lr10 = biFromNumber(1000000000000000);
    
    function BigInt(flag) {
        if (typeof flag == "boolean" && flag == true) {
            this.digits = null;
        } else {
            this.digits = ZERO_ARRAY.slice(0);
        }
        this.isNeg = false;
    }
    
    function biFromDecimal(s) {
        var isNeg = s.charAt(0) == '-';
        var i = isNeg ? 1 : 0;
        var result;
        // Skip leading zeros.
        while (i < s.length && s.charAt(i) == '0') ++i;
        if (i == s.length) {
            result = new BigInt();
        } else {
            var digitCount = s.length - i;
            var fgl = digitCount % dpl10;
            if (fgl == 0) fgl = dpl10;
            result = biFromNumber(Number(s.substr(i, fgl)));
            i += fgl;
            while (i < s.length) {
                result = biAdd(biMultiply(result, lr10),
                               biFromNumber(Number(s.substr(i, dpl10))));
                i += dpl10;
            }
            result.isNeg = isNeg;
        }
        return result;
    }
    
    function biCopy(bi) {
        var result = new BigInt(true);
        result.digits = bi.digits.slice(0);
        result.isNeg = bi.isNeg;
        return result;
    }
    
    function biFromNumber(i) {
        var result = new BigInt();
        result.isNeg = i < 0;
        i = Math.abs(i);
        var j = 0;
        while (i > 0) {
            result.digits[j++] = i & maxDigitVal;
            i = Math.floor(i / biRadix);
        }
        return result;
    }
    
    function reverseStr(s) {
        var result = "";
        for (var i = s.length - 1; i > -1; --i) {
            result += s.charAt(i);
        }
        return result;
    }
    
    var hexatrigesimalToChar = new Array(
     '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
     'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
     'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
     'u', 'v', 'w', 'x', 'y', 'z'
    );
    
    function biToString(x, radix) {
        // 2 <= radix <= 36
        var b = new BigInt();
        b.digits[0] = radix;
        var digit,
            qr     = biDivideModulo(x, b),
            result = hexatrigesimalToChar[qr[1].digits[0]];
        while (biCompare(qr[0], bigZero) == 1) {
            qr = biDivideModulo(qr[0], b);
            digit = qr[1].digits[0];
            result += hexatrigesimalToChar[qr[1].digits[0]];
        }
        return (x.isNeg ? "-" : "") + reverseStr(result);
    }
    
    function biToDecimal(x) {
        var b = new BigInt();
        b.digits[0] = 10;
        var qr = biDivideModulo(x, b);
        var result = String(qr[1].digits[0]);
        while (biCompare(qr[0], bigZero) == 1) {
            qr = biDivideModulo(qr[0], b);
            result += String(qr[1].digits[0]);
        }
        return (x.isNeg ? "-" : "") + reverseStr(result);
    }
    
    var hexToChar = new Array('0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
      'a', 'b', 'c', 'd', 'e', 'f');
    
    function digitToHex(n) {
        var i, 
            mask   = 0xf,
            result = "";
        for (i = 0; i < 4; ++i) {
            result += hexToChar[n & mask];
            n >>>= 4;
        }
        return reverseStr(result);
    }
    
    function biToHex(x) {
        var result = "";
        var n = biHighIndex(x);
        for (var i = biHighIndex(x); i > -1; --i) {
            result += digitToHex(x.digits[i]);
        }
        return result;
    }
    
    function charToHex(c) {
        var ZERO = 48;
        var NINE = ZERO + 9;
        var littleA = 97;
        var littleZ = littleA + 25;
        var bigA = 65;
        var bigZ = 65 + 25;
        var result;
    
        if (c >= ZERO && c <= NINE) {
            result = c - ZERO;
        } else if (c >= bigA && c <= bigZ) {
            result = 10 + c - bigA;
        } else if (c >= littleA && c <= littleZ) {
            result = 10 + c - littleA;
        } else {
            result = 0;
        }
        return result;
    }
    
    function hexToDigit(s) {
        var result = 0;
        var sl = Math.min(s.length, 4);
        for (var i = 0; i < sl; ++i) {
            result <<= 4;
            result |= charToHex(s.charCodeAt(i))
        }
        return result;
    }
    
    function biFromHex(s) {
        var result = new BigInt();
        var sl = s.length;
        for (var i = sl, j = 0; i > 0; i -= 4, ++j) {
            result.digits[j] = hexToDigit(s.substr(Math.max(i - 4, 0), Math.min(i, 4)));
        }
        return result;
    }
    
    function biFromString(s, radix) {
        var isNeg = s.charAt(0) == '-';
        var istop = isNeg ? 1 : 0;
        var result = new BigInt();
        var place = new BigInt();
        place.digits[0] = 1; // radix^0
        for (var i = s.length - 1; i >= istop; i--) {
            var c = s.charCodeAt(i);
            var digit = charToHex(c);
            var biDigit = biMultiplyDigit(place, digit);
            result = biAdd(result, biDigit);
            place = biMultiplyDigit(place, radix);
        }
        result.isNeg = isNeg;
        return result;
    }
    
    function biDump(b) {
        return (b.isNeg ? "-" : "") + b.digits.join(" ");
    }
    
    function biAdd(x, y) {
        var result;
    
        if (x.isNeg != y.isNeg) {
            y.isNeg = !y.isNeg;
            result = biSubtract(x, y);
            y.isNeg = !y.isNeg;
        } else {
            result = new BigInt();
            var c = 0;
            var n;
            for (var i = 0; i < x.digits.length; ++i) {
                n = x.digits[i] + y.digits[i] + c;
                result.digits[i] = n % biRadix;
                c = Number(n >= biRadix);
            }
            result.isNeg = x.isNeg;
        }
        return result;
    }
    
    function biSubtract(x, y) {
        var result;
        if (x.isNeg != y.isNeg) {
            y.isNeg = !y.isNeg;
            result = biAdd(x, y);
            y.isNeg = !y.isNeg;
        } else {
            result = new BigInt();
            var n, c;
            c = 0;
            for (var i = 0; i < x.digits.length; ++i) {
                n = x.digits[i] - y.digits[i] + c;
                result.digits[i] = n % biRadix;
                // Stupid non-conforming modulus operation.
                if (result.digits[i] < 0) result.digits[i] += biRadix;
                c = 0 - Number(n < 0);
            }
            // Fix up the negative sign, if any.
            if (c == -1) {
                c = 0;
                for (var i = 0; i < x.digits.length; ++i) {
                    n = 0 - result.digits[i] + c;
                    result.digits[i] = n % biRadix;
                    // Stupid non-conforming modulus operation.
                    if (result.digits[i] < 0) result.digits[i] += biRadix;
                    c = 0 - Number(n < 0);
                }
                // Result is opposite sign of arguments.
                result.isNeg = !x.isNeg;
            } else {
                // Result is same sign.
                result.isNeg = x.isNeg;
            }
        }
        return result;
    }
    
    function biHighIndex(x) {
        var result = x.digits.length - 1;
        while (result > 0 && x.digits[result] == 0) --result;
        return result;
    }
    
    function biNumBits(x) {
        var n = biHighIndex(x);
        var d = x.digits[n];
        var m = (n + 1) * bitsPerDigit;
        var result;
        for (result = m; result > m - bitsPerDigit; --result) {
            if ((d & 0x8000) != 0) break;
            d <<= 1;
        }
        return result;
    }
    
    function biMultiply(x, y) {
        var result = new BigInt();
        var c;
        var n = biHighIndex(x);
        var t = biHighIndex(y);
        var u, uv, k, i, j;
    
        for (i = 0; i <= t; ++i) {
            c = 0;
            k = i;
            for (j = 0; j <= n; ++j, ++k) {
                uv = result.digits[k] + x.digits[j] * y.digits[i] + c;
                result.digits[k] = uv & maxDigitVal;
                c = uv >>> biRadixBits;
                //c = Math.floor(uv / biRadix);
            }
            result.digits[i + n + 1] = c;
        }
        // Someone give me a logical xor, please.
        result.isNeg = x.isNeg != y.isNeg;
        return result;
    }
    
    function biMultiplyDigit(x, y) {
        var n, c, uv,
            result = new BigInt();
        n = biHighIndex(x);
        c = 0;
        for (var j = 0; j <= n; ++j) {
            uv = result.digits[j] + x.digits[j] * y + c;
            result.digits[j] = uv & maxDigitVal;
            c = uv >>> biRadixBits;
            //c = Math.floor(uv / biRadix);
        }
        result.digits[1 + n] = c;
        return result;
    }
    
    function arrayCopy(src, srcStart, dest, destStart, n) {
        var m = Math.min(srcStart + n, src.length);
        for (var i = srcStart, j = destStart; i < m; ++i, ++j) {
            dest[j] = src[i];
        }
    }
    
    var highBitMasks = new Array(0x0000, 0x8000, 0xC000, 0xE000, 0xF000, 0xF800,
      0xFC00, 0xFE00, 0xFF00, 0xFF80, 0xFFC0, 0xFFE0,
      0xFFF0, 0xFFF8, 0xFFFC, 0xFFFE, 0xFFFF);
    
    function biShiftLeft(x, n) {
        var digitCount = Math.floor(n / bitsPerDigit);
        var result = new BigInt();
        arrayCopy(x.digits, 0, result.digits, digitCount,
          result.digits.length - digitCount);
        var bits = n % bitsPerDigit;
        var rightBits = bitsPerDigit - bits;
        for (var i = result.digits.length - 1, i1 = i - 1; i > 0; --i, --i1) {
            result.digits[i] = ((result.digits[i] << bits) & maxDigitVal) |
              ((result.digits[i1] & highBitMasks[bits]) >>>
              (rightBits));
        }
        result.digits[0] = ((result.digits[i] << bits) & maxDigitVal);
        result.isNeg = x.isNeg;
        return result;
    }
    
    var lowBitMasks = new Array(0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F,
      0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF,
      0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF);
    
    function biShiftRight(x, n) {
        var digitCount = Math.floor(n / bitsPerDigit);
        var result = new BigInt();
        arrayCopy(x.digits, digitCount, result.digits, 0,
          x.digits.length - digitCount);
        var bits = n % bitsPerDigit;
        var leftBits = bitsPerDigit - bits;
        for (var i = 0, i1 = i + 1; i < result.digits.length - 1; ++i, ++i1) {
            result.digits[i] = (result.digits[i] >>> bits) |
              ((result.digits[i1] & lowBitMasks[bits]) << leftBits);
        }
        result.digits[result.digits.length - 1] >>>= bits;
        result.isNeg = x.isNeg;
        return result;
    }
    
    function biMultiplyByRadixPower(x, n) {
        var result = new BigInt();
        arrayCopy(x.digits, 0, result.digits, n, result.digits.length - n);
        return result;
    }
    
    function biDivideByRadixPower(x, n) {
        var result = new BigInt();
        arrayCopy(x.digits, n, result.digits, 0, result.digits.length - n);
        return result;
    }
    
    function biModuloByRadixPower(x, n) {
        var result = new BigInt();
        arrayCopy(x.digits, 0, result.digits, 0, n);
        return result;
    }
    
    function biCompare(x, y) {
        if (x.isNeg != y.isNeg) {
            return 1 - 2 * Number(x.isNeg);
        }
        for (var i = x.digits.length - 1; i >= 0; --i) {
            if (x.digits[i] != y.digits[i]) {
                if (x.isNeg) {
                    return 1 - 2 * Number(x.digits[i] > y.digits[i]);
                } else {
                    return 1 - 2 * Number(x.digits[i] < y.digits[i]);
                }
            }
        }
        return 0;
    }
    
    function biDivideModulo(x, y) {
        var nb = biNumBits(x);
        var tb = biNumBits(y);
        var origYIsNeg = y.isNeg;
        var q, r;
        if (nb < tb) {
            // |x| < |y|
            if (x.isNeg) {
                q = biCopy(bigOne);
                q.isNeg = !y.isNeg;
                x.isNeg = false;
                y.isNeg = false;
                r = biSubtract(y, x);
                // Restore signs, 'cause they're references.
                x.isNeg = true;
                y.isNeg = origYIsNeg;
            } else {
                q = new BigInt();
                r = biCopy(x);
            }
            return new Array(q, r);
        }
    
        q = new BigInt();
        r = x;
    
        // Normalize Y.
        var t = Math.ceil(tb / bitsPerDigit) - 1;
        var lambda = 0;
        while (y.digits[t] < biHalfRadix) {
            y = biShiftLeft(y, 1);
            ++lambda;
            ++tb;
            t = Math.ceil(tb / bitsPerDigit) - 1;
        }
        // Shift r over to keep the quotient constant. We'll shift the
        // remainder back at the end.
        r = biShiftLeft(r, lambda);
        nb += lambda; // Update the bit count for x.
        var n = Math.ceil(nb / bitsPerDigit) - 1;
    
        var b = biMultiplyByRadixPower(y, n - t);
        while (biCompare(r, b) != -1) {
            ++q.digits[n - t];
            r = biSubtract(r, b);
        }
        for (var i = n; i > t; --i) {
        var ri = (i >= r.digits.length) ? 0 : r.digits[i];
        var ri1 = (i - 1 >= r.digits.length) ? 0 : r.digits[i - 1];
        var ri2 = (i - 2 >= r.digits.length) ? 0 : r.digits[i - 2];
        var yt = (t >= y.digits.length) ? 0 : y.digits[t];
        var yt1 = (t - 1 >= y.digits.length) ? 0 : y.digits[t - 1];
            if (ri == yt) {
                q.digits[i - t - 1] = maxDigitVal;
            } else {
                q.digits[i - t - 1] = Math.floor((ri * biRadix + ri1) / yt);
            }
    
            var c1 = q.digits[i - t - 1] * ((yt * biRadix) + yt1);
            var c2 = (ri * biRadixSquared) + ((ri1 * biRadix) + ri2);
            while (c1 > c2) {
                --q.digits[i - t - 1];
                c1 = q.digits[i - t - 1] * ((yt * biRadix) | yt1);
                c2 = (ri * biRadix * biRadix) + ((ri1 * biRadix) + ri2);
            }
    
            b = biMultiplyByRadixPower(y, i - t - 1);
            r = biSubtract(r, biMultiplyDigit(b, q.digits[i - t - 1]));
            if (r.isNeg) {
                r = biAdd(r, b);
                --q.digits[i - t - 1];
            }
        }
        r = biShiftRight(r, lambda);
        // Fiddle with the signs and stuff to make sure that 0 <= r < y.
        q.isNeg = x.isNeg != origYIsNeg;
        if (x.isNeg) {
            if (origYIsNeg) {
                q = biAdd(q, bigOne);
            } else {
                q = biSubtract(q, bigOne);
            }
            y = biShiftRight(y, lambda);
            r = biSubtract(y, r);
        }
        // Check for the unbelievably stupid degenerate case of r == -0.
        if (r.digits[0] == 0 && biHighIndex(r) == 0) r.isNeg = false;
    
        return new Array(q, r);
    }
    
    function biDivide(x, y) {
        return biDivideModulo(x, y)[0];
    }
    
    function biModulo(x, y) {
        return biDivideModulo(x, y)[1];
    }
    
    function biMultiplyMod(x, y, m) {
        return biModulo(biMultiply(x, y), m);
    }
    
    function biPow(x, y) {
        var result = bigOne;
        var a = x;
        while (true) {
            if ((y & 1) != 0) result = biMultiply(result, a);
            y >>= 1;
            if (y == 0) break;
            a = biMultiply(a, a);
        }
        return result;
    }
    
    function biPowMod(x, y, m) {
        var result = bigOne;
        var a = x;
        var k = y;
        while (true) {
            if ((k.digits[0] & 1) != 0) result = biMultiplyMod(result, a, m);
            k = biShiftRight(k, 1);
            if (k.digits[0] == 0 && biHighIndex(k) == 0) break;
            a = biMultiplyMod(a, a, m);
        }
        return result;
    }
    
    //publish public methods:
    return {
        construct: BigInt,
        setMaxDigits: setMaxDigits,
        fromDecimal: biFromDecimal,
        copy: biCopy,
        fromNumber: biFromNumber,
        toString: biToString,
        toDecimal: biToDecimal,
        toHex: biToHex,
        fromHex: biFromHex,
        fromString: biFromString,
        dump: biDump,
        add: biAdd,
        subtract: biSubtract,
        highIndex: biHighIndex,
        numBits: biNumBits,
        multiply: biMultiply,
        shiftLeft: biShiftLeft,
        shiftRight: biShiftRight,
        compare: biCompare,
        pow: biPow,
        powMod: biPowMod,
        divide: biDivide,
        divideByRadixPower: biDivideByRadixPower,
        moduloByRadixPower: biModuloByRadixPower
    };
})();




/*FILEHEAD(/var/lib/platform/source/trunk/core/crypto/sha1.js)SIZE(5258)TIME(1257329185)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



(function(global) {

function rotate_left(n,s) {
    var t4 = ( n<<s ) | (n>>>(32-s));
    return t4;
};

/*
function lsb_hex(val) { // Not in use; needed?
    var str="";
    var i;
    var vh;
    var vl;

    for( i=0; i<=6; i+=2 ) {
        vh = (val>>>(i*4+4))&0x0f;
        vl = (val>>>(i*4))&0x0f;
        str += vh.toString(16) + vl.toString(16);
    }
    return str;
};
*/

function cvt_hex(val) {
    var str="";
    var i;
    var v;

    for( i=7; i>=0; i-- ) {
        v = (val>>>(i*4))&0x0f;
        str += v.toString(16);
    }
    return str;
};

global.SHA1 = function(str) {
    // Calculate the sha1 hash of a string
    //
    // version: 905.3122
    // discuss at: http://phpjs.org/functions/sha1
    // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
    // + namespaced by: Michael White (http://getsprink.com)
    // +      input by: Brett Zamir (http://brett-zamir.me)
    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // -    depends on: utf8_encode
    // *     example 1: sha1('Kevin van Zonneveld');
    // *     returns 1: '54916d2e62f65b3afa6e192e6a601cdbe5cb5897'
    var blockstart, i, j, W = new Array(80),
        H0 = 0x67452301,
        H1 = 0xEFCDAB89,
        H2 = 0x98BADCFE,
        H3 = 0x10325476,
        H4 = 0xC3D2E1F0,
        A, B, C, D, E, temp;

    str = apf.crypto.UTF8.encode(str);
    var str_len = str.length,
        word_array = [];

    for(i = 0; i < str_len - 3; i += 4) {
        j = str.charCodeAt(i) << 24 | str.charCodeAt(i + 1) << 16 |
            str.charCodeAt(i + 2) << 8 | str.charCodeAt(i + 3);
        word_array.push(j);
    }

    switch (str_len % 4) {
        case 0:
            i = 0x080000000;
            break;
        case 1:
            i = str.charCodeAt(str_len - 1) << 24 | 0x0800000;
            break;
        case 2:
            i = str.charCodeAt(str_len - 2) << 24 | str.charCodeAt(str_len - 1)
                << 16 | 0x08000;
            break;
        case 3:
            i = str.charCodeAt(str_len - 3) << 24 | str.charCodeAt(str_len - 2)
                << 16 | str.charCodeAt(str_len - 1) << 8 | 0x80;
            break;
    }

    word_array.push( i );

    while((word_array.length % 16) != 14)
        word_array.push( 0 );

    word_array.push(str_len >>> 29);
    word_array.push((str_len << 3) & 0x0ffffffff);

    for (blockstart = 0; blockstart < word_array.length; blockstart += 16) {
        for (i = 0; i < 16; i++)
            W[i] = word_array[blockstart + i];
        for (i = 16; i <= 79; i++)
            W[i] = rotate_left(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

        A = H0;
        B = H1;
        C = H2;
        D = H3;
        E = H4;

        for (i = 0; i <= 19; i++) {
            temp = (rotate_left(A, 5) + ((B & C) | (~B & D)) + E + W[i]
                + 0x5A827999) & 0x0ffffffff;
            E = D;
            D = C;
            C = rotate_left(B, 30);
            B = A;
            A = temp;
        }

        for (i = 20; i <= 39; i++) {
            temp = (rotate_left(A, 5) + (B ^ C ^ D) + E + W[i] + 0x6ED9EBA1)
                & 0x0ffffffff;
            E = D;
            D = C;
            C = rotate_left(B, 30);
            B = A;
            A = temp;
        }

        for (i = 40; i <= 59; i++) {
            temp = (rotate_left(A, 5) + ((B & C) | (B & D) | (C & D)) + E + W[i]
                + 0x8F1BBCDC) & 0x0ffffffff;
            E = D;
            D = C;
            C = rotate_left(B, 30);
            B = A;
            A = temp;
        }

        for (i = 60; i <= 79; i++) {
            temp = (rotate_left(A, 5) + (B ^ C ^ D) + E + W[i] + 0xCA62C1D6)
                & 0x0ffffffff;
            E = D;
            D = C;
            C = rotate_left(B, 30);
            B = A;
            A = temp;
        }

        H0 = (H0 + A) & 0x0ffffffff;
        H1 = (H1 + B) & 0x0ffffffff;
        H2 = (H2 + C) & 0x0ffffffff;
        H3 = (H3 + D) & 0x0ffffffff;
        H4 = (H4 + E) & 0x0ffffffff;
    }

    temp = cvt_hex(H0) + cvt_hex(H1) + cvt_hex(H2) + cvt_hex(H3) + cvt_hex(H4);
    return temp.toLowerCase();
};

})(apf.crypto);




/*FILEHEAD(/var/lib/platform/source/trunk/core/crypto/base64.js)SIZE(6758)TIME(1257329185)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.crypto.Base64 = (function() {
    
    var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    
    // public method for encoding
    function encode(data) {
        var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc = "",
            tmp_arr = [];

        if (!data)
            return data;

        data = apf.crypto.UTF8.encode(data + "");

        do { // pack three octets into four hexets
            o1 = data.charCodeAt(i++);
            o2 = data.charCodeAt(i++);
            o3 = data.charCodeAt(i++);

            bits = o1 << 16 | o2 << 8 | o3;

            h1 = bits >> 18 & 0x3f;
            h2 = bits >> 12 & 0x3f;
            h3 = bits >> 6  & 0x3f;
            h4 = bits & 0x3f;

            // use hexets to index into b64, and append result to encoded string
            tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3)
                + b64.charAt(h4);
        }
        while (i < data.length);

        enc = tmp_arr.join("");

        switch (data.length % 3) {
            case 1:
                enc = enc.slice(0, -2) + '==';
                break;
            case 2:
                enc = enc.slice(0, -1) + '=';
                break;
        }

        return enc;
    }
    
    // public method for decoding
    function decode(data) {
        var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, tmp_arr = [];

        if (!data) {
            return data;
        }

        data += "";

        do {  // unpack four hexets into three octets using index points in b64
            h1 = b64.indexOf(data.charAt(i++));
            h2 = b64.indexOf(data.charAt(i++));
            h3 = b64.indexOf(data.charAt(i++));
            h4 = b64.indexOf(data.charAt(i++));

            bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

            o1 = bits>>16 & 0xff;
            o2 = bits>>8 & 0xff;
            o3 = bits & 0xff;

            if (h3 == 64)
                tmp_arr[ac++] = String.fromCharCode(o1);
            else if (h4 == 64)
                tmp_arr[ac++] = String.fromCharCode(o1, o2);
            else
                tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
        }
        while (i < data.length);

        return apf.crypto.UTF8.decode(tmp_arr.join(""));
    }
    
    return {
        decode: decode,
        encode: encode
    };
    
})();

apf.crypto.UTF8 = {
    // private method for UTF-8 encoding
    encode : function (string) {
        // Encodes an ISO-8859-1 string to UTF-8
        //
        // version: 905.1217
        // discuss at: http://phpjs.org/functions/utf8_encode
        // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // +   improved by: sowberry
        // +    tweaked by: Jack
        // +   bugfixed by: Onno Marsman
        // +   improved by: Yves Sucaet
        // +   bugfixed by: Onno Marsman
        // *     example 1: utf8_encode('Kevin van Zonneveld');
        // *     returns 1: 'Kevin van Zonneveld'
        string = (string + "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");

        var tmp_arr = [],
            start   = 0,
            end     = 0,
            c1, enc;

        for (var n = 0, l = string.length; n < l; n++) {
            c1 = string.charCodeAt(n);
            enc = null;

            if (c1 < 128) {
                end++;
            }
            else if ((c1 > 127) && (c1 < 2048)) {
                enc = String.fromCharCode((c1 >> 6) | 192)
                    + String.fromCharCode((c1 & 63) | 128);
            }
            else {
                enc = String.fromCharCode((c1 >> 12) | 224) 
                    + String.fromCharCode(((c1 >> 6) & 63) | 128)
                    + String.fromCharCode((c1 & 63) | 128);
            }
            if (enc !== null) {
                if (end > start)
                    tmp_arr.push(string.substring(start, end));
                tmp_arr.push(enc);
                start = end = n + 1;
            }
        }

        if (end > start)
            tmp_arr.push(string.substring(start, string.length));

        return tmp_arr.join("");
    },

    // private method for UTF-8 decoding
    decode : function (str_data) {
        // Converts a UTF-8 encoded string to ISO-8859-1
        //
        // version: 905.3122
        // discuss at: http://phpjs.org/functions/utf8_decode
        // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
        // +      input by: Aman Gupta
        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // +   improved by: Norman "zEh" Fuchs
        // +   bugfixed by: hitwork
        // +   bugfixed by: Onno Marsman
        // +      input by: Brett Zamir (http://brett-zamir.me)
        // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // *     example 1: utf8_decode('Kevin van Zonneveld');
        // *     returns 1: 'Kevin van Zonneveld'
        var tmp_arr = [], i = 0, ac = 0, c1 = 0, c2 = 0, c3 = 0;

        str_data += "";

        while (i < str_data.length) {
            c1 = str_data.charCodeAt(i);
            if (c1 < 128) {
                tmp_arr[ac++] = String.fromCharCode(c1);
                i++;
            }
            else if ((c1 > 191) && (c1 < 224)) {
                c2 = str_data.charCodeAt(i+1);
                tmp_arr[ac++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
                i += 2;
            }
            else {
                c2 = str_data.charCodeAt(i+1);
                c3 = str_data.charCodeAt(i+2);
                tmp_arr[ac++] = String.fromCharCode(((c1 & 15) << 12)
                    | ((c2 & 63) << 6) | (c3 & 63));
                i += 3;
            }
        }

        return tmp_arr.join('');
    }

};




/*FILEHEAD(/var/lib/platform/source/trunk/core/crypto/rsa.js)SIZE(5048)TIME(1257329185)*/

/**
 * RSA, a suite of routines for performing RSA public-key computations in
 * JavaScript.
 *
 * Requires BigInt.js and Barrett.js.
 *
 * Copyright 1998-2005 David Shapiro.
 *
 * You may use, re-use, abuse, copy, and modify this code to your liking, but
 * please keep this header.
 *
 * Thanks!
 * 
 * @author Dave Shapiro <dave AT ohdave DOT com>
 */



apf.crypto.RSA = (function() {
    function RSAKeyPair(encryptionExponent, decryptionExponent, modulus) {
        this.e = apf.crypto.BigInt.fromHex(encryptionExponent);
        this.d = apf.crypto.BigInt.fromHex(decryptionExponent);
        this.m = apf.crypto.BigInt.fromHex(modulus);
        /*
         * We can do two bytes per digit, so
         * chunkSize = 2 * (number of digits in modulus - 1).
         * Since biHighIndex returns the high index, not the number of digits, 1 has
         * already been subtracted.
         */
        ////////////////////////////////// TYF
        this.digitSize = 2 * apf.crypto.BigInt.highIndex(this.m) + 2;
        this.chunkSize = this.digitSize - 11; // maximum, anything lower is fine
        ////////////////////////////////// TYF
        this.radix = 16;
        this.barrett = new apf.crypto.Barrett(this.m);
    }
    
    function twoDigit(n) {
        return (n < 10 ? "0" : "") + String(n);
    }
    
    function encryptedString(key, s) {
        /*
         * Altered by Rob Saunders (rob@robsaunders.net). New routine pads the
         * string after it has been converted to an array. This fixes an
         * incompatibility with Flash MX's ActionScript.
         * Altered by Tang Yu Feng for interoperability with Microsoft's
         * RSACryptoServiceProvider implementation.
         */
        ////////////////////////////////// TYF
        if (key.chunkSize > key.digitSize - 11) {
            return "Error";
        }
        ////////////////////////////////// TYF
        var a = new Array();
        var sl = s.length;
        
        var i = 0;
        while (i < sl) {
            a[i] = s.charCodeAt(i);
            i++;
        }
        
        var al = a.length;
        var result = "";
        var j, k, block;
        for (i = 0; i < al; i += key.chunkSize) {
            block = new apf.crypto.BigInt.construct();
            j = 0;
            ////////////////////////////////// TYF
            /*
             * Add PKCS#1 v1.5 padding
             * 0x00 || 0x02 || PseudoRandomNonZeroBytes || 0x00 || Message
             * Variable a before padding must be of at most digitSize-11
             * That is for 3 marker bytes plus at least 8 random non-zero bytes
             */
            var x;
            var msgLength = (i+key.chunkSize)>al ? al%key.chunkSize : key.chunkSize;
            
            // Variable b with 0x00 || 0x02 at the highest index.
            var b = new Array();
            for (x = 0; x < msgLength; x++) {
                b[x] = a[i + msgLength - 1 - x];
            }
            b[msgLength] = 0; // marker
            var paddedSize = Math.max(8, key.digitSize - 3 - msgLength);
            for (x = 0; x < paddedSize; x++) {
                b[msgLength + 1 + x] = Math.floor(Math.random() * 254) + 1; // [1,255]
            }
            // It can be asserted that msgLength+paddedSize == key.digitSize-3
            b[key.digitSize - 2] = 2; // marker
            b[key.digitSize - 1] = 0; // marker
            
            for (k = 0; k < key.digitSize; ++j) 
            {
                block.digits[j] = b[k++];
                block.digits[j] += b[k++] << 8;
            }
            ////////////////////////////////// TYF
            
            var crypt = key.barrett.powMod(block, key.e);
            var text = key.radix == 16 ? apf.crypto.BigInt.toHex(crypt) : apf.crypto.BigInt.toString(crypt, key.radix);
            result += text + " ";
        }
        return result.substring(0, result.length - 1); // Remove last space.
    }
    
    function decryptedString(key, s) {
        var blocks = s.split(" ");
        var result = "";
        var i, j, block;
        for (i = 0; i < blocks.length; ++i) {
            var bi;
            if (key.radix == 16) {
                bi = apf.crypto.BigInt.fromHex(blocks[i]);
            } else {
                bi = apf.crypto.BigInt.fromString(blocks[i], key.radix);
            }
            block = key.barrett.powMod(bi, key.d);
            for (j = 0; j <= apf.crypto.BigInt.highIndex(block); ++j) {
                result += String.fromCharCode(block.digits[j] & 255,
                  block.digits[j] >> 8);
            }
        }
        // Remove trailing null, if any.
        if (result.charCodeAt(result.length - 1) == 0) {
            result = result.substring(0, result.length - 1);
        }
        return result;
    }
    
    //publish public functions:
    return {
        F4: "10001",
        E3: "3",
        getKeyPair: RSAKeyPair,
        twoDigit: twoDigit,
        encrypt: encryptedString,
        decrypt: decryptedString
    };
})();





/*FILEHEAD(/var/lib/platform/source/trunk/core/crypto/md5.js)SIZE(10878)TIME(1257329185)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.crypto.MD5 = {
    /*
     * Configurable variables. You may need to tweak these to be compatible with
     * the server-side, but the defaults work in most cases.
     */
    hexcase: 0,  /* hex output format. 0 - lowercase; 1 - uppercase        */
    b64pad : "", /* base-64 pad character. "=" for strict RFC compliance   */
    chrsz  : 8,  /* bits per input character. 8 - ASCII; 16 - Unicode      */

    /*
     * These are the functions you'll usually want to call
     * They take string arguments and return either hex or base-64 encoded strings
     */
    hex_md5: function(s) {
        return this.binl2hex(this.core_md5(this.str2binl(s), s.length * this.chrsz));
    },
    b64_md5: function(s) {
        return this.binl2b64(this.core_md5(this.str2binl(s), s.length * this.chrsz));
    },
    str_md5: function(s) {
        return this.binl2str(this.core_md5(this.str2binl(s), s.length * this.chrsz));
    },
    hex_hmac_md5: function(key, data) {
        return this.binl2hex(this.core_hmac_md5(key, data));
    },
    b64_hmac_md5: function(key, data) {
        return this.binl2b64(this.core_hmac_md5(key, data));
    },
    str_hmac_md5: function(key, data) {
        return this.binl2str(this.core_hmac_md5(key, data));
    },
    /**
     * Calculate the MD5 of an array of little-endian words, and a bit length
     */
    core_md5: function(x, len) {
      /* append padding */
      x[len >> 5] |= 0x80 << ((len) % 32);
      x[(((len + 64) >>> 9) << 4) + 14] = len;

      var a =  1732584193, b = -271733879, c = -1732584194, d =  271733878;

      for(var i = 0; i < x.length; i += 16) {
        var olda = a, oldb = b, oldc = c, oldd = d;

        a = this.md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
        d = this.md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
        c = this.md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
        b = this.md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
        a = this.md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
        d = this.md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
        c = this.md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
        b = this.md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
        a = this.md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
        d = this.md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
        c = this.md5_ff(c, d, a, b, x[i+10], 17, -42063);
        b = this.md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
        a = this.md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
        d = this.md5_ff(d, a, b, c, x[i+13], 12, -40341101);
        c = this.md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
        b = this.md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

        a = this.md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
        d = this.md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
        c = this.md5_gg(c, d, a, b, x[i+11], 14,  643717713);
        b = this.md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
        a = this.md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
        d = this.md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
        c = this.md5_gg(c, d, a, b, x[i+15], 14, -660478335);
        b = this.md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
        a = this.md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
        d = this.md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
        c = this.md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
        b = this.md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
        a = this.md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
        d = this.md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
        c = this.md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
        b = this.md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

        a = this.md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
        d = this.md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
        c = this.md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
        b = this.md5_hh(b, c, d, a, x[i+14], 23, -35309556);
        a = this.md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
        d = this.md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
        c = this.md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
        b = this.md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
        a = this.md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
        d = this.md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
        c = this.md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
        b = this.md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
        a = this.md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
        d = this.md5_hh(d, a, b, c, x[i+12], 11, -421815835);
        c = this.md5_hh(c, d, a, b, x[i+15], 16,  530742520);
        b = this.md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

        a = this.md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
        d = this.md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
        c = this.md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
        b = this.md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
        a = this.md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
        d = this.md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
        c = this.md5_ii(c, d, a, b, x[i+10], 15, -1051523);
        b = this.md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
        a = this.md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
        d = this.md5_ii(d, a, b, c, x[i+15], 10, -30611744);
        c = this.md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
        b = this.md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
        a = this.md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
        d = this.md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
        c = this.md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
        b = this.md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

        a = this.safe_add(a, olda);
        b = this.safe_add(b, oldb);
        c = this.safe_add(c, oldc);
        d = this.safe_add(d, oldd);
      }
      return [a, b, c, d];
    },
    /*
     * These functions implement the four basic operations the algorithm uses.
     */
    md5_cmn: function(q, a, b, x, s, t) {
        return this.safe_add(this.bit_rol(this.safe_add(this.safe_add(a, q),
            this.safe_add(x, t)), s),b);
    },
    md5_ff: function(a, b, c, d, x, s, t) {
        return this.md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
    },
    md5_gg: function(a, b, c, d, x, s, t) {
        return this.md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
    },
    md5_hh: function(a, b, c, d, x, s, t) {
        return this.md5_cmn(b ^ c ^ d, a, b, x, s, t);
    },
    md5_ii: function(a, b, c, d, x, s, t) {
        return this.md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
    },
    /**
     * Calculate the HMAC-MD5, of a key and some data
     */
    core_hmac_md5: function(key, data) {
        var bkey = this.str2binl(key),
            ipad = Array(16),
            opad = Array(16);
        if (bkey.length > 16)
            bkey = this.core_md5(bkey, key.length * this.chrsz);

        for (var i = 0; i < 16; i++) {
            ipad[i] = bkey[i] ^ 0x36363636;
            opad[i] = bkey[i] ^ 0x5C5C5C5C;
        }

        return this.core_md5(opad.concat(
            this.core_md5(ipad.concat(this.str2binl(data)), 512 + data.length * this.chrsz)
        ), 512 + 128);
    },
    /**
     * Add integers, wrapping at 2^32. This uses 16-bit operations internally
     * to work around bugs in some JS interpreters.
     */
    safe_add: function(x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF),
            msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF);
    },
    /**
     * Bitwise rotate a 32-bit number to the left.
     */
    bit_rol: function(num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt));
    },
    /**
     * Convert a string to an array of little-endian words
     * If chrsz is ASCII, characters >255 have their hi-byte silently ignored.
     */
    str2binl: function(str) {
        var bin  = [], i,
            mask = (1 << this.chrsz) - 1;
        for (i = 0; i < str.length * this.chrsz; i += this.chrsz)
            bin[i >> 5] |= (str.charCodeAt(i / this.chrsz) & mask) << (i%32);
        return bin;
    },
    /**
     * Convert an array of little-endian words to a string
     */
    binl2str: function(bin) {
        var str = [], i,
            mask = (1 << this.chrsz) - 1;
        for (i = 0; i < bin.length * 32; i += this.chrsz)
            str.push(String.fromCharCode((bin[i>>5] >>> (i % 32)) & mask));
        return str.join("");
    },
    /**
     * Convert an array of little-endian words to a hex string.
     */
    binl2hex: function(binarray) {
        var hex_tab = this.hexcase ? "0123456789ABCDEF" : "0123456789abcdef",
            str = [], i;
        for (i = 0; i < binarray.length * 4; i++) {
            str.push(hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +
                     hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF));
        }
        return str.join("");
    },
    /**
     * Convert an array of little-endian words to a base-64 string
     */
    binl2b64: function(binarray) {
        var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            str = [], i;
        for(i = 0; i < binarray.length * 4; i += 3) {
            var triplet = (((binarray[i   >> 2] >> 8 * ( i   %4)) & 0xFF) << 16)
                    | (((binarray[i+1 >> 2] >> 8 * ((i+1)%4)) & 0xFF) << 8 )
                    |  ((binarray[i+2 >> 2] >> 8 * ((i+2)%4)) & 0xFF);
            for (var j = 0; j < 4; j++) {
                if (i * 8 + j * 6 > binarray.length * 32)
                    str.push(this.b64pad);
                else
                    str.push(tab.charAt((triplet >> 6*(3-j)) & 0x3F));
            }
        }
        return str.join("");
    }
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/crypto/md4.js)SIZE(9799)TIME(1257329185)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.crypto.MD4 = {
    /*
     * Configurable variables. You may need to tweak these to be compatible with
     * the server-side, but the defaults work in most cases.
     */
    hexcase: 0,  /* hex output format. 0 - lowercase; 1 - uppercase        */
    b64pad : "", /* base-64 pad character. "=" for strict RFC compliance   */
    chrsz  : 8,  /* bits per input character. 8 - ASCII; 16 - Unicode      */

    /*
     * These are the functions you'll usually want to call
     */
    hex_md4: function(s){
        return this.binl2hex(this.core_md4(this.str2binl(s), s.length * this.chrsz));
    },
    
    b64_md4: function(s){
        return this.binl2b64(this.core_md4(this.str2binl(s), s.length * this.chrsz));
    },
    
    str_md4: function(s){
        return this.binl2str(this.core_md4(this.str2binl(s), s.length * this.chrsz));
    },
    
    hex_hmac_md4: function(key, data){
        return this.binl2hex(this.core_hmac_md4(key, data));
    },
    
    b64_hmac_md4: function(key, data){
        return this.binl2b64(this.core_hmac_md4(key, data));
    },
    
    str_hmac_md4: function(key, data){
        return this.binl2str(this.core_hmac_md4(key, data));
    },
    
    /**
     * Perform a simple self-test to see if the VM is working
     */
    md4_vm_test: function(){
        return this.hex_md4("abc") == "a448017aaf21d8525fc10ae87aa6729d";
    },
    
    /**
     * Calculate the MD4 of an array of little-endian words, and a bit length
     */
    core_md4: function(x, len){
        /* append padding */
        x[len >> 5] |= 0x80 << (len % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;
        
        var a = 1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d = 271733878;
        
        for (var i = 0; i < x.length; i += 16) {
            var olda = a;
            var oldb = b;
            var oldc = c;
            var oldd = d;
            
            a = this.md4_ff(a, b, c, d, x[i + 0], 3);
            d = this.md4_ff(d, a, b, c, x[i + 1], 7);
            c = this.md4_ff(c, d, a, b, x[i + 2], 11);
            b = this.md4_ff(b, c, d, a, x[i + 3], 19);
            a = this.md4_ff(a, b, c, d, x[i + 4], 3);
            d = this.md4_ff(d, a, b, c, x[i + 5], 7);
            c = this.md4_ff(c, d, a, b, x[i + 6], 11);
            b = this.md4_ff(b, c, d, a, x[i + 7], 19);
            a = this.md4_ff(a, b, c, d, x[i + 8], 3);
            d = this.md4_ff(d, a, b, c, x[i + 9], 7);
            c = this.md4_ff(c, d, a, b, x[i + 10], 11);
            b = this.md4_ff(b, c, d, a, x[i + 11], 19);
            a = this.md4_ff(a, b, c, d, x[i + 12], 3);
            d = this.md4_ff(d, a, b, c, x[i + 13], 7);
            c = this.md4_ff(c, d, a, b, x[i + 14], 11);
            b = this.md4_ff(b, c, d, a, x[i + 15], 19);
            
            a = this.md4_gg(a, b, c, d, x[i + 0], 3);
            d = this.md4_gg(d, a, b, c, x[i + 4], 5);
            c = this.md4_gg(c, d, a, b, x[i + 8], 9);
            b = this.md4_gg(b, c, d, a, x[i + 12], 13);
            a = this.md4_gg(a, b, c, d, x[i + 1], 3);
            d = this.md4_gg(d, a, b, c, x[i + 5], 5);
            c = this.md4_gg(c, d, a, b, x[i + 9], 9);
            b = this.md4_gg(b, c, d, a, x[i + 13], 13);
            a = this.md4_gg(a, b, c, d, x[i + 2], 3);
            d = this.md4_gg(d, a, b, c, x[i + 6], 5);
            c = this.md4_gg(c, d, a, b, x[i + 10], 9);
            b = this.md4_gg(b, c, d, a, x[i + 14], 13);
            a = this.md4_gg(a, b, c, d, x[i + 3], 3);
            d = this.md4_gg(d, a, b, c, x[i + 7], 5);
            c = this.md4_gg(c, d, a, b, x[i + 11], 9);
            b = this.md4_gg(b, c, d, a, x[i + 15], 13);
            
            a = this.md4_hh(a, b, c, d, x[i + 0], 3);
            d = this.md4_hh(d, a, b, c, x[i + 8], 9);
            c = this.md4_hh(c, d, a, b, x[i + 4], 11);
            b = this.md4_hh(b, c, d, a, x[i + 12], 15);
            a = this.md4_hh(a, b, c, d, x[i + 2], 3);
            d = this.md4_hh(d, a, b, c, x[i + 10], 9);
            c = this.md4_hh(c, d, a, b, x[i + 6], 11);
            b = this.md4_hh(b, c, d, a, x[i + 14], 15);
            a = this.md4_hh(a, b, c, d, x[i + 1], 3);
            d = this.md4_hh(d, a, b, c, x[i + 9], 9);
            c = this.md4_hh(c, d, a, b, x[i + 5], 11);
            b = this.md4_hh(b, c, d, a, x[i + 13], 15);
            a = this.md4_hh(a, b, c, d, x[i + 3], 3);
            d = this.md4_hh(d, a, b, c, x[i + 11], 9);
            c = this.md4_hh(c, d, a, b, x[i + 7], 11);
            b = this.md4_hh(b, c, d, a, x[i + 15], 15);
            
            a = this.safe_add(a, olda);
            b = this.safe_add(b, oldb);
            c = this.safe_add(c, oldc);
            d = this.safe_add(d, oldd);
            
        }
        return Array(a, b, c, d);
        
    },
    
    /*
     * These functions implement the basic operation for each round of the
     * algorithm.
     */
    md4_cmn: function(q, a, b, x, s, t){
        return this.safe_add(rol(this.safe_add(this.safe_add(a, q), this.safe_add(x, t)), s), b);
    },
    
    md4_ff: function(a, b, c, d, x, s){
        return this.md4_cmn((b & c) | ((~ b) & d), a, 0, x, s, 0);
    },
    
    md4_gg: function(a, b, c, d, x, s){
        return this.md4_cmn((b & c) | (b & d) | (c & d), a, 0, x, s, 1518500249);
    },
    
    md4_hh: function(a, b, c, d, x, s){
        return this.md4_cmn(b ^ c ^ d, a, 0, x, s, 1859775393);
    },
    
    /**
     * Calculate the HMAC-MD4, of a key and some data
     */
    core_hmac_md4: function(key, data){
        var bkey = this.str2binl(key);
        if (bkey.length > 16) 
            bkey = this.core_md4(bkey, key.length * this.chrsz);
        
        var ipad = Array(16), opad = Array(16);
        for (var i = 0; i < 16; i++) {
            ipad[i] = bkey[i] ^ 0x36363636;
            opad[i] = bkey[i] ^ 0x5C5C5C5C;
        }
        
        var hash = this.core_md4(ipad.concat(this.str2binl(data)), 512 + data.length * this.chrsz);
        return this.core_md4(opad.concat(hash), 512 + 128);
    },
    
    /**
     * Add integers, wrapping at 2^32. This uses 16-bit operations internally
     * to work around bugs in some JS interpreters.
     */
    safe_add: function(x, y){
        var lsw = (x & 0xFFFF) + (y & 0xFFFF);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF);
    },
    
    /**
     * Bitwise rotate a 32-bit number to the left.
     */
    rol: function(num, cnt){
        return (num << cnt) | (num >>> (32 - cnt));
    },
    
    /**
     * Convert a string to an array of little-endian words
     * If chrsz is ASCII, characters >255 have their hi-byte silently ignored.
     */
    str2binl: function(str){
        var bin = Array();
        var mask = (1 << this.chrsz) - 1;
        for (var i = 0; i < str.length * this.chrsz; i += this.chrsz) 
            bin[i >> 5] |= (str.charCodeAt(i / this.chrsz) & mask) << (i % 32);
        return bin;
    },
    
    /**
     * Convert an array of little-endian words to a string
     */
    binl2str: function(bin){
        var str = "";
        var mask = (1 << this.chrsz) - 1;
        for (var i = 0; i < bin.length * 32; i += this.chrsz) 
            str += String.fromCharCode((bin[i >> 5] >>> (i % 32)) & mask);
        return str;
    },
    
    /**
     * Convert an array of little-endian words to a hex string.
     */
    binl2hex: function(binarray){
        var hex_tab = this.hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
        var str = "";
        for (var i = 0; i < binarray.length * 4; i++) {
            str += hex_tab.charAt((binarray[i >> 2] >> ((i % 4) * 8 + 4)) & 0xF) +
            hex_tab.charAt((binarray[i >> 2] >> ((i % 4) * 8)) & 0xF);
        }
        return str;
    },
    
    /**
     * Convert an array of little-endian words to a base-64 string
     */
    binl2b64: function(binarray){
        var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var str = "";
        for (var i = 0; i < binarray.length * 4; i += 3) {
            var triplet = (((binarray[i >> 2] >> 8 * (i % 4)) & 0xFF) << 16) |
            (((binarray[i + 1 >> 2] >> 8 * ((i + 1) % 4)) & 0xFF) << 8) |
            ((binarray[i + 2 >> 2] >> 8 * ((i + 2) % 4)) & 0xFF);
            for (var j = 0; j < 4; j++) {
                if (i * 8 + j * 6 > binarray.length * 32) 
                    str += this.b64pad;
                else 
                    str += tab.charAt((triplet >> 6 * (3 - j)) & 0x3F);
            }
        }
        return str;
    }
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/crypto/blowfish.js)SIZE(26046)TIME(1257329185)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*
 * Copyright (C) 2005 - Stephen Griffin, i-code.co.uk
 * Copyright (C) 2005 - Raphael Derosso Pereira - thyAPI adaptation
 *                      <raphaelpereira@users.sourceforge.net>
 */

(function(global) {

if (typeof apf.crypto == "undefined") apf.crypto = {};

function stringtoints(instring){
    var binary = [];
    var i, ch;
    
    for (i = 0; i < instring.length; i++) {
        ch = instring.charCodeAt(i);
        binary[i >> 2] |= ch << (3 - i % 4) * 8;
    }
    return binary;
}

function intstostring(intvalues){
    var outstring = new String();
    
    for (var i = 0; i < intvalues.length; i++) {
        outstring += String.fromCharCode(intvalues[i] >>> 24,
            (intvalues[i] >>> 16) & 0xff, (intvalues[i] >>> 8) & 0xff,
            intvalues[i] & 0xff);
    }
    return outstring;
}

function base64tobin(codestring){
    var temp, i = 0;
    var binary = [];
    
    while (i < codestring.length * 6) {
        temp = codestring.charCodeAt(i / 6);
        
        if (temp > 47 && temp < 58) 
            temp -= 48;
        if (temp > 62 && temp < 91) 
            temp -= 53;
        if (temp > 96 && temp < 123) 
            temp -= 59;
        
        switch (i & 0x1f) { //i%32
            case 0:
                binary[i >> 5] = temp;
                i += 6;
                break;
            case 28:
                binary[i >> 5] = (binary[i >> 5] << 4) | (temp >> 2);
                i += 4;
                binary[i >> 5] = temp & 0x03;
                i += 2;
                break;
            case 30:
                binary[i >> 5] = (binary[i >> 5] << 2) | (temp >> 4);
                i += 2;
                binary[i >> 5] = temp & 0x0f;
                i += 4;
                break;
            default:
                binary[i >> 5] = (binary[i >> 5] << 6) | temp;
                i += 6;
        }
    }
    return binary;
}

function base64encode(binary){
    var temp, x,
        bincount   = 0,
        codestring = "",
        chars      = "0123456789?@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    
    while (bincount < binary.length) {
        for (x = 0; x < 2; x++) {
            temp = binary[bincount] >>> 26;
            codestring += chars.charAt(temp);
            temp = (binary[bincount] >>> 20) & 0x3f;
            codestring += chars.charAt(temp);
            
            temp = (binary[bincount] >>> 14) & 0x3f;
            codestring += chars.charAt(temp);
            
            temp = (binary[bincount] >>> 8) & 0x3f;
            codestring += chars.charAt(temp);
            
            temp = (binary[bincount] >>> 2) & 0x3f;
            codestring += chars.charAt(temp);
            
            temp = (binary[bincount++] & 0x3) << 4;
            temp = temp | (binary[bincount] >>> 28);
            codestring += chars.charAt(temp);
            
            temp = (binary[bincount] >>> 22) & 0x3f;
            codestring += chars.charAt(temp);
            
            temp = (binary[bincount] >>> 16) & 0x3f;
            codestring += chars.charAt(temp);
            
            temp = (binary[bincount] >>> 10) & 0x3f;
            codestring += chars.charAt(temp);
            
            temp = (binary[bincount] >>> 4) & 0x3f;
            codestring += chars.charAt(temp);
            
            temp = (binary[bincount++] & 0xf) << 2;
            temp = temp | (binary[bincount] >>> 30);
            codestring += chars.charAt(temp);
            
            temp = (binary[bincount] >>> 24) & 0x3f;
            codestring += chars.charAt(temp);
            
            temp = (binary[bincount] >>> 18) & 0x3f;
            codestring += chars.charAt(temp);
            
            temp = (binary[bincount] >>> 12) & 0x3f;
            codestring += chars.charAt(temp);
            
            temp = (binary[bincount] >>> 6) & 0x3f;
            codestring += chars.charAt(temp);
            
            temp = binary[bincount++] & 0x3f;
            codestring += chars.charAt(temp);
        }
    }
    return codestring;
}

/**
 * Class: Blowfish
 *
 *	Blowfish cypher class.
 *
 *	Algorithm gently taken from i-code.co.uk. Thanks Stephen!
 *
 */
apf.crypto.Blowfish = function(){this.init.apply(this, arguments);};
apf.crypto.Blowfish.prototype = {
    init: function(m){
        this.P;
        this.S;
        this.previous_xHi = 0;
        this.previous_xLo = 0;
    },
    
    /**
     * Encodes the text passed with key
     *
     * @param {String} str The text to be encoded
     * @param {String} pass The key to be used to encode the text
     * @return Base64 encoded string
     * @type String
     */
    encode: function(str, pass){
        var ciphertext = new String(""),
            IV         = new Array(),
            x;
        
        for (x = 0; x < 4; x++) {
            if (typeof(this.customRand) == 'function') {
                IV[x] = this.customRand();
            } else {
                IV[x] = Math.floor(Math.random() * 0xFFFFFFFF);
            }
        }
        
        var key = this.passtokey(pass, IV[2], IV[3], IV[4]);
        IV[4] = key[14];//hashHi
        IV[5] = key[15];//hashLo
        this.initialise(key, IV);
        
        var binary = stringtoints(str);
        this.encipher_array(binary);
        
        return {
            code: base64encode(binary),
            init: base64encode(IV)
        };
    },
    
    /**
     * Decodes a base64 encoded string to the original one, if key is correct
     *
     * @param {String} code The cyphered code
     * @param {String} pass The key to be used
     * @param {Number} init The base64 initialization int
     */
    decode: function(code, pass, init){
        var initialints = base64tobin(init);
        var key = this.passtokey(pass, initialints[2], initialints[3]);
        
        if ((initialints[4] == key[14]) && (initialints[5] == key[15])) { //check password hash
            this.initialise(key, initialints);
            var bincode = base64tobin(code);
            this.decipher(bincode);
            return intstostring(bincode);
        }
        
        return null;
    },
    
    setConstants: function(){
        var s0 = [0xD1310BA6, 0x98DFB5AC, 0x2FFD72DB, 0xD01ADFB7, 0xB8E1AFED,
            0x6A267E96, 0xBA7C9045, 0xF12C7F99, 0x24A19947, 0xB3916CF7, 0x0801F2E2,
            0x858EFC16, 0x636920D8, 0x71574E69, 0xA458FEA3, 0xF4933D7E, 0x0D95748F,
            0x728EB658, 0x718BCD58, 0x82154AEE, 0x7B54A41D, 0xC25A59B5, 0x9C30D539,
            0x2AF26013, 0xC5D1B023, 0x286085F0, 0xCA417918, 0xB8DB38EF, 0x8E79DCB0,
            0x603A180E, 0x6C9E0E8B, 0xB01E8A3E, 0xD71577C1, 0xBD314B27, 0x78AF2FDA,
            0x55605C60, 0xE65525F3, 0xAA55AB94, 0x57489862, 0x63E81440, 0x55CA396A,
            0x2AAB10B6, 0xB4CC5C34, 0x1141E8CE, 0xA15486AF, 0x7C72E993, 0xB3EE1411,
            0x636FBC2A, 0x2BA9C55D, 0x741831F6, 0xCE5C3E16, 0x9B87931E, 0xAFD6BA33,
            0x6C24CF5C, 0x7A325381, 0x28958677, 0x3B8F4898, 0x6B4BB9AF, 0xC4BFE81B,
            0x66282193, 0x61D809CC, 0xFB21A991, 0x487CAC60, 0x5DEC8032, 0xEF845D5D,
            0xE98575B1, 0xDC262302, 0xEB651B88, 0x23893E81, 0xD396ACC5, 0x0F6D6FF3,
            0x83F44239, 0x2E0B4482, 0xA4842004, 0x69C8F04A, 0x9E1F9B5E, 0x21C66842,
            0xF6E96C9A, 0x670C9C61, 0xABD388F0, 0x6A51A0D2, 0xD8542F68, 0x960FA728,
            0xAB5133A3, 0x6EEF0B6C, 0x137A3BE4, 0xBA3BF050, 0x7EFB2A98, 0xA1F1651D,
            0x39AF0176, 0x66CA593E, 0x82430E88, 0x8CEE8619, 0x456F9FB4, 0x7D84A5C3,
            0x3B8B5EBE, 0xE06F75D8, 0x85C12073, 0x401A449F, 0x56C16AA6, 0x4ED3AA62,
            0x363F7706, 0x1BFEDF72, 0x429B023D, 0x37D0D724, 0xD00A1248, 0xDB0FEAD3,
            0x49F1C09B, 0x075372C9, 0x80991B7B, 0x25D479D8, 0xF6E8DEF7, 0xE3FE501A,
            0xB6794C3B, 0x976CE0BD, 0x04C006BA, 0xC1A94FB6, 0x409F60C4, 0x5E5C9EC2,
            0x196A2463, 0x68FB6FAF, 0x3E6C53B5, 0x1339B2EB, 0x3B52EC6F, 0x6DFC511F,
            0x9B30952C, 0xCC814544, 0xAF5EBD09, 0xBEE3D004, 0xDE334AFD, 0x660F2807,
            0x192E4BB3, 0xC0CBA857, 0x45C8740F, 0xD20B5F39, 0xB9D3FBDB, 0x5579C0BD,
            0x1A60320A, 0xD6A100C6, 0x402C7279, 0x679F25FE, 0xFB1FA3CC, 0x8EA5E9F8,
            0xDB3222F8, 0x3C7516DF, 0xFD616B15, 0x2F501EC8, 0xAD0552AB, 0x323DB5FA,
            0xFD238760, 0x53317B48, 0x3E00DF82, 0x9E5C57BB, 0xCA6F8CA0, 0x1A87562E,
            0xDF1769DB, 0xD542A8F6, 0x287EFFC3, 0xAC6732C6, 0x8C4F5573, 0x695B27B0,
            0xBBCA58C8, 0xE1FFA35D, 0xB8F011A0, 0x10FA3D98, 0xFD2183B8, 0x4AFCB56C,
            0x2DD1D35B, 0x9A53E479, 0xB6F84565, 0xD28E49BC, 0x4BFB9790, 0xE1DDF2DA,
            0xA4CB7E33, 0x62FB1341, 0xCEE4C6E8, 0xEF20CADA, 0x36774C01, 0xD07E9EFE,
            0x2BF11FB4, 0x95DBDA4D, 0xAE909198, 0xEAAD8E71, 0x6B93D5A0, 0xD08ED1D0,
            0xAFC725E0, 0x8E3C5B2F, 0x8E7594B7, 0x8FF6E2FB, 0xF2122B64, 0x8888B812,
            0x900DF01C, 0x4FAD5EA0, 0x688FC31C, 0xD1CFF191, 0xB3A8C1AD, 0x2F2F2218,
            0xBE0E1777, 0xEA752DFE, 0x8B021FA1, 0xE5A0CC0F, 0xB56F74E8, 0x18ACF3D6,
            0xCE89E299, 0xB4A84FE0, 0xFD13E0B7, 0x7CC43B81, 0xD2ADA8D9, 0x165FA266,
            0x80957705, 0x93CC7314, 0x211A1477, 0xE6AD2065, 0x77B5FA86, 0xC75442F5, 
            0xFB9D35CF, 0xEBCDAF0C, 0x7B3E89A0, 0xD6411BD3, 0xAE1E7E49, 0x00250E2D, 
            0x2071B35E, 0x226800BB, 0x57B8E0AF, 0x2464369B, 0xF009B91E, 0x5563911D, 
            0x59DFA6AA, 0x78C14389, 0xD95A537F, 0x207D5BA2, 0x02E5B9C5, 0x83260376, 
            0x6295CFA9, 0x11C81968, 0x4E734A41, 0xB3472DCA, 0x7B14A94A, 0x1B510052, 
            0x9A532915, 0xD60F573F, 0xBC9BC6E4, 0x2B60A476, 0x81E67400, 0x08BA6FB5, 
            0x571BE91F, 0xF296EC6B, 0x2A0DD915, 0xB6636521, 0xE7B9F9B6, 0xFF34052E, 
            0xC5855664, 0x53B02D5D, 0xA99F8FA1, 0x08BA4799, 0x6E85076A];
        
        var s1 = [0x4B7A70E9, 0xB5B32944, 0xDB75092E, 0xC4192623, 0xAD6EA6B0, 0x49A7DF7D, 
            0x9CEE60B8, 0x8FEDB266, 0xECAA8C71, 0x699A17FF, 0x5664526C, 0xC2B19EE1,
            0x193602A5, 0x75094C29, 0xA0591340, 0xE4183A3E, 0x3F54989A, 0x5B429D65, 
            0x6B8FE4D6, 0x99F73FD6, 0xA1D29C07, 0xEFE830F5, 0x4D2D38E6, 0xF0255DC1, 
            0x4CDD2086, 0x8470EB26, 0x6382E9C6, 0x021ECC5E, 0x09686B3F, 0x3EBAEFC9, 
            0x3C971814, 0x6B6A70A1, 0x687F3584, 0x52A0E286, 0xB79C5305, 0xAA500737, 
            0x3E07841C, 0x7FDEAE5C, 0x8E7D44EC, 0x5716F2B8, 0xB03ADA37, 0xF0500C0D, 
            0xF01C1F04, 0x0200B3FF, 0xAE0CF51A, 0x3CB574B2, 0x25837A58, 0xDC0921BD, 
            0xD19113F9, 0x7CA92FF6, 0x94324773, 0x22F54701, 0x3AE5E581, 0x37C2DADC, 
            0xC8B57634, 0x9AF3DDA7, 0xA9446146, 0x0FD0030E, 0xECC8C73E, 0xA4751E41, 
            0xE238CD99, 0x3BEA0E2F, 0x3280BBA1, 0x183EB331, 0x4E548B38, 0x4F6DB908, 
            0x6F420D03, 0xF60A04BF, 0x2CB81290, 0x24977C79, 0x5679B072, 0xBCAF89AF, 
            0xDE9A771F, 0xD9930810, 0xB38BAE12, 0xDCCF3F2E, 0x5512721F, 0x2E6B7124, 
            0x501ADDE6, 0x9F84CD87, 0x7A584718, 0x7408DA17, 0xBC9F9ABC, 0xE94B7D8C, 
            0xEC7AEC3A, 0xDB851DFA, 0x63094366, 0xC464C3D2, 0xEF1C1847, 0x3215D908, 
            0xDD433B37, 0x24C2BA16, 0x12A14D43, 0x2A65C451, 0x50940002, 0x133AE4DD, 
            0x71DFF89E, 0x10314E55, 0x81AC77D6, 0x5F11199B, 0x043556F1, 0xD7A3C76B, 
            0x3C11183B, 0x5924A509, 0xF28FE6ED, 0x97F1FBFA, 0x9EBABF2C, 0x1E153C6E, 
            0x86E34570, 0xEAE96FB1, 0x860E5E0A, 0x5A3E2AB3, 0x771FE71C, 0x4E3D06FA, 
            0x2965DCB9, 0x99E71D0F, 0x803E89D6, 0x5266C825, 0x2E4CC978, 0x9C10B36A, 
            0xC6150EBA, 0x94E2EA78, 0xA5FC3C53, 0x1E0A2DF4, 0xF2F74EA7, 0x361D2B3D, 
            0x1939260F, 0x19C27960, 0x5223A708, 0xF71312B6, 0xEBADFE6E, 0xEAC31F66, 
            0xE3BC4595, 0xA67BC883, 0xB17F37D1, 0x018CFF28, 0xC332DDEF, 0xBE6C5AA5, 
            0x65582185, 0x68AB9802, 0xEECEA50F, 0xDB2F953B, 0x2AEF7DAD, 0x5B6E2F84, 
            0x1521B628, 0x29076170, 0xECDD4775, 0x619F1510, 0x13CCA830, 0xEB61BD96, 
            0x0334FE1E, 0xAA0363CF, 0xB5735C90, 0x4C70A239, 0xD59E9E0B, 0xCBAADE14, 
            0xEECC86BC, 0x60622CA7, 0x9CAB5CAB, 0xB2F3846E, 0x648B1EAF, 0x19BDF0CA, 
            0xA02369B9, 0x655ABB50, 0x40685A32, 0x3C2AB4B3, 0x319EE9D5, 0xC021B8F7, 
            0x9B540B19, 0x875FA099, 0x95F7997E, 0x623D7DA8, 0xF837889A, 0x97E32D77, 
            0x11ED935F, 0x16681281, 0x0E358829, 0xC7E61FD6, 0x96DEDFA1, 0x7858BA99, 
            0x57F584A5, 0x1B227263, 0x9B83C3FF, 0x1AC24696, 0xCDB30AEB, 0x532E3054, 
            0x8FD948E4, 0x6DBC3128, 0x58EBF2EF, 0x34C6FFEA, 0xFE28ED61, 0xEE7C3C73, 
            0x5D4A14D9, 0xE864B7E3, 0x42105D14, 0x203E13E0, 0x45EEE2B6, 0xA3AAABEA, 
            0xDB6C4F15, 0xFACB4FD0, 0xC742F442, 0xEF6ABBB5, 0x654F3B1D, 0x41CD2105, 
            0xD81E799E, 0x86854DC7, 0xE44B476A, 0x3D816250, 0xCF62A1F2, 0x5B8D2646, 
            0xFC8883A0, 0xC1C7B6A3, 0x7F1524C3, 0x69CB7492, 0x47848A0B, 0x5692B285, 
            0x095BBF00, 0xAD19489D, 0x1462B174, 0x23820E00, 0x58428D2A, 0x0C55F5EA, 
            0x1DADF43E, 0x233F7061, 0x3372F092, 0x8D937E41, 0xD65FECF1, 0x6C223BDB, 
            0x7CDE3759, 0xCBEE7460, 0x4085F2A7, 0xCE77326E, 0xA6078084, 0x19F8509E, 
            0xE8EFD855, 0x61D99735, 0xA969A7AA, 0xC50C06C2, 0x5A04ABFC, 0x800BCADC, 
            0x9E447A2E, 0xC3453484, 0xFDD56705, 0x0E1E9EC9, 0xDB73DBD3, 0x105588CD, 
            0x675FDA79, 0xE3674340, 0xC5C43465, 0x713E38D8, 0x3D28F89E, 0xF16DFF20, 
            0x153E21E7, 0x8FB03D4A, 0xE6E39F2B, 0xDB83ADF7];
        
        var s2 = [0xE93D5A68, 0x948140F7, 0xF64C261C, 0x94692934, 0x411520F7, 0x7602D4F7,
            0xBCF46B2E, 0xD4A20068, 0xD4082471, 0x3320F46A, 0x43B7D4B7, 0x500061AF, 
            0x1E39F62E, 0x97244546, 0x14214F74, 0xBF8B8840, 0x4D95FC1D, 0x96B591AF, 
            0x70F4DDD3, 0x66A02F45, 0xBFBC09EC, 0x03BD9785, 0x7FAC6DD0, 0x31CB8504, 
            0x96EB27B3, 0x55FD3941, 0xDA2547E6, 0xABCA0A9A, 0x28507825, 0x530429F4, 
            0x0A2C86DA, 0xE9B66DFB, 0x68DC1462, 0xD7486900, 0x680EC0A4, 0x27A18DEE, 
            0x4F3FFEA2, 0xE887AD8C, 0xB58CE006, 0x7AF4D6B6, 0xAACE1E7C, 0xD3375FEC, 
            0xCE78A399, 0x406B2A42, 0x20FE9E35, 0xD9F385B9, 0xEE39D7AB, 0x3B124E8B, 
            0x1DC9FAF7, 0x4B6D1856, 0x26A36631, 0xEAE397B2, 0x3A6EFA74, 0xDD5B4332, 
            0x6841E7F7, 0xCA7820FB, 0xFB0AF54E, 0xD8FEB397, 0x454056AC, 0xBA489527, 
            0x55533A3A, 0x20838D87, 0xFE6BA9B7, 0xD096954B, 0x55A867BC, 0xA1159A58, 
            0xCCA92963, 0x99E1DB33, 0xA62A4A56, 0x3F3125F9, 0x5EF47E1C, 0x9029317C, 
            0xFDF8E802, 0x04272F70, 0x80BB155C, 0x05282CE3, 0x95C11548, 0xE4C66D22, 
            0x48C1133F, 0xC70F86DC, 0x07F9C9EE, 0x41041F0F, 0x404779A4, 0x5D886E17, 
            0x325F51EB, 0xD59BC0D1, 0xF2BCC18F, 0x41113564, 0x257B7834, 0x602A9C60, 
            0xDFF8E8A3, 0x1F636C1B, 0x0E12B4C2, 0x02E1329E, 0xAF664FD1, 0xCAD18115, 
            0x6B2395E0, 0x333E92E1, 0x3B240B62, 0xEEBEB922, 0x85B2A20E, 0xE6BA0D99, 
            0xDE720C8C, 0x2DA2F728, 0xD0127845, 0x95B794FD, 0x647D0862, 0xE7CCF5F0, 
            0x5449A36F, 0x877D48FA, 0xC39DFD27, 0xF33E8D1E, 0x0A476341, 0x992EFF74, 
            0x3A6F6EAB, 0xF4F8FD37, 0xA812DC60, 0xA1EBDDF8, 0x991BE14C, 0xDB6E6B0D, 
            0xC67B5510, 0x6D672C37, 0x2765D43B, 0xDCD0E804, 0xF1290DC7, 0xCC00FFA3, 
            0xB5390F92, 0x690FED0B, 0x667B9FFB, 0xCEDB7D9C, 0xA091CF0B, 0xD9155EA3, 
            0xBB132F88, 0x515BAD24, 0x7B9479BF, 0x763BD6EB, 0x37392EB3, 0xCC115979, 
            0x8026E297, 0xF42E312D, 0x6842ADA7, 0xC66A2B3B, 0x12754CCC, 0x782EF11C, 
            0x6A124237, 0xB79251E7, 0x06A1BBE6, 0x4BFB6350, 0x1A6B1018, 0x11CAEDFA, 
            0x3D25BDD8, 0xE2E1C3C9, 0x44421659, 0x0A121386, 0xD90CEC6E, 0xD5ABEA2A, 
            0x64AF674E, 0xDA86A85F, 0xBEBFE988, 0x64E4C3FE, 0x9DBC8057, 0xF0F7C086, 
            0x60787BF8, 0x6003604D, 0xD1FD8346, 0xF6381FB0, 0x7745AE04, 0xD736FCCC, 
            0x83426B33, 0xF01EAB71, 0xB0804187, 0x3C005E5F, 0x77A057BE, 0xBDE8AE24, 
            0x55464299, 0xBF582E61, 0x4E58F48F, 0xF2DDFDA2, 0xF474EF38, 0x8789BDC2, 
            0x5366F9C3, 0xC8B38E74, 0xB475F255, 0x46FCD9B9, 0x7AEB2661, 0x8B1DDF84, 
            0x846A0E79, 0x915F95E2, 0x466E598E, 0x20B45770, 0x8CD55591, 0xC902DE4C, 
            0xB90BACE1, 0xBB8205D0, 0x11A86248, 0x7574A99E, 0xB77F19B6, 0xE0A9DC09, 
            0x662D09A1, 0xC4324633, 0xE85A1F02, 0x09F0BE8C, 0x4A99A025, 0x1D6EFE10, 
            0x1AB93D1D, 0x0BA5A4DF, 0xA186F20F, 0x2868F169, 0xDCB7DA83, 0x573906FE, 
            0xA1E2CE9B, 0x4FCD7F52, 0x50115E01, 0xA70683FA, 0xA002B5C4, 0x0DE6D027, 
            0x9AF88C27, 0x773F8641, 0xC3604C06, 0x61A806B5, 0xF0177A28, 0xC0F586E0, 
            0x006058AA, 0x30DC7D62, 0x11E69ED7, 0x2338EA63, 0x53C2DD94, 0xC2C21634, 
            0xBBCBEE56, 0x90BCB6DE, 0xEBFC7DA1, 0xCE591D76, 0x6F05E409, 0x4B7C0188, 
            0x39720A3D, 0x7C927C24, 0x86E3725F, 0x724D9DB9, 0x1AC15BB4, 0xD39EB8FC, 
            0xED545578, 0x08FCA5B5, 0xD83D7CD3, 0x4DAD0FC4, 0x1E50EF5E, 0xB161E6F8, 
            0xA28514D9, 0x6C51133C, 0x6FD5C7E7, 0x56E14EC4, 0x362ABFCE, 0xDDC6C837, 
            0xD79A3234, 0x92638212, 0x670EFA8E, 0x406000E0];
        
        var s3 = [0x3A39CE37, 0xD3FAF5CF, 0xABC27737, 0x5AC52D1B, 0x5CB0679E, 0x4FA33742, 
            0xD3822740, 0x99BC9BBE, 0xD5118E9D, 0xBF0F7315, 0xD62D1C7E, 0xC700C47B, 
            0xB78C1B6B, 0x21A19045, 0xB26EB1BE, 0x6A366EB4, 0x5748AB2F, 0xBC946E79, 
            0xC6A376D2, 0x6549C2C8, 0x530FF8EE, 0x468DDE7D, 0xD5730A1D, 0x4CD04DC6, 
            0x2939BBDB, 0xA9BA4650, 0xAC9526E8, 0xBE5EE304, 0xA1FAD5F0, 0x6A2D519A, 
            0x63EF8CE2, 0x9A86EE22, 0xC089C2B8, 0x43242EF6, 0xA51E03AA, 0x9CF2D0A4, 
            0x83C061BA, 0x9BE96A4D, 0x8FE51550, 0xBA645BD6, 0x2826A2F9, 0xA73A3AE1, 
            0x4BA99586, 0xEF5562E9, 0xC72FEFD3, 0xF752F7DA, 0x3F046F69, 0x77FA0A59, 
            0x80E4A915, 0x87B08601, 0x9B09E6AD, 0x3B3EE593, 0xE990FD5A, 0x9E34D797, 
            0x2CF0B7D9, 0x022B8B51, 0x96D5AC3A, 0x017DA67D, 0xD1CF3ED6, 0x7C7D2D28, 
            0x1F9F25CF, 0xADF2B89B, 0x5AD6B472, 0x5A88F54C, 0xE029AC71, 0xE019A5E6, 
            0x47B0ACFD, 0xED93FA9B, 0xE8D3C48D, 0x283B57CC, 0xF8D56629, 0x79132E28, 
            0x785F0191, 0xED756055, 0xF7960E44, 0xE3D35E8C, 0x15056DD4, 0x88F46DBA, 
            0x03A16125, 0x0564F0BD, 0xC3EB9E15, 0x3C9057A2, 0x97271AEC, 0xA93A072A, 
            0x1B3F6D9B, 0x1E6321F5, 0xF59C66FB, 0x26DCF319, 0x7533D928, 0xB155FDF5, 
            0x03563482, 0x8ABA3CBB, 0x28517711, 0xC20AD9F8, 0xABCC5167, 0xCCAD925F, 
            0x4DE81751, 0x3830DC8E, 0x379D5862, 0x9320F991, 0xEA7A90C2, 0xFB3E7BCE, 
            0x5121CE64, 0x774FBE32, 0xA8B6E37E, 0xC3293D46, 0x48DE5369, 0x6413E680, 
            0xA2AE0810, 0xDD6DB224, 0x69852DFD, 0x09072166, 0xB39A460A, 0x6445C0DD, 
            0x586CDECF, 0x1C20C8AE, 0x5BBEF7DD, 0x1B588D40, 0xCCD2017F, 0x6BB4E3BB, 
            0xDDA26A7E, 0x3A59FF45, 0x3E350A44, 0xBCB4CDD5, 0x72EACEA8, 0xFA6484BB, 
            0x8D6612AE, 0xBF3C6F47, 0xD29BE463, 0x542F5D9E, 0xAEC2771B, 0xF64E6370, 
            0x740E0D8D, 0xE75B1357, 0xF8721671, 0xAF537D5D, 0x4040CB08, 0x4EB4E2CC, 
            0x34D2466A, 0x0115AF84, 0xE1B00428, 0x95983A1D, 0x06B89FB4, 0xCE6EA048, 
            0x6F3F3B82, 0x3520AB82, 0x011A1D4B, 0x277227F8, 0x611560B1, 0xE7933FDC, 
            0xBB3A792B, 0x344525BD, 0xA08839E1, 0x51CE794B, 0x2F32C9B7, 0xA01FBAC9, 
            0xE01CC87E, 0xBCC7D1F6, 0xCF0111C3, 0xA1E8AAC7, 0x1A908749, 0xD44FBD9A, 
            0xD0DADECB, 0xD50ADA38, 0x0339C32A, 0xC6913667, 0x8DF9317C, 0xE0B12B4F, 
            0xF79E59B7, 0x43F5BB3A, 0xF2D519FF, 0x27D9459C, 0xBF97222C, 0x15E6FC2A, 
            0x0F91FC71, 0x9B941525, 0xFAE59361, 0xCEB69CEB, 0xC2A86459, 0x12BAA8D1, 
            0xB6C1075E, 0xE3056A0C, 0x10D25065, 0xCB03A442, 0xE0EC6E0E, 0x1698DB3B, 
            0x4C98A0BE, 0x3278E964, 0x9F1F9532, 0xE0D392DF, 0xD3A0342B, 0x8971F21E, 
            0x1B0A7441, 0x4BA3348C, 0xC5BE7120, 0xC37632D8, 0xDF359F8D, 0x9B992F2E, 
            0xE60B6F47, 0x0FE3F11D, 0xE54CDA54, 0x1EDAD891, 0xCE6279CF, 0xCD3E7E6F, 
            0x1618B166, 0xFD2C1D05, 0x848FD2C5, 0xF6FB2299, 0xF523F357, 0xA6327623, 
            0x93A83531, 0x56CCCD02, 0xACF08162, 0x5A75EBB5, 0x6E163697, 0x88D273CC, 
            0xDE966292, 0x81B949D0, 0x4C50901B, 0x71C65614, 0xE6C6C7BD, 0x327A140A, 
            0x45E1D006, 0xC3F27B9A, 0xC9AA53FD, 0x62A80F00, 0xBB25BFE2, 0x35BDD2F6, 
            0x71126905, 0xB2040222, 0xB6CBCF7C, 0xCD769C2B, 0x53113EC0, 0x1640E3D3, 
            0x38ABBD60, 0x2547ADF0, 0xBA38209C, 0xF746CE76, 0x77AFA1C5, 0x20756060, 
            0x85CBFE4E, 0x8AE88DD8, 0x7AAAF9B0, 0x4CF9AA7E, 0x1948C25C, 0x02FB8A8C, 
            0x01C36AE4, 0xD6EBE1F9, 0x90D4F869, 0xA65CDEA0, 0x3F09252D, 0xC208E69F, 
            0xB74E6132, 0xCE77E25B, 0x578FDFE3, 0x3AC372E6];
        
        this.S = [s0, s1, s2, s3];
        
        this.P = [0x243F6A88, 0x85A308D3, 0x13198A2E, 0x03707344, 0xA4093822, 0x299F31D0, 
            0x082EFA98, 0xEC4E6C89, 0x452821E6, 0x38D01377, 0xBE5466CF, 0x34E90C6C, 
            0xC0AC29B7, 0xC97C50DD, 0x3F84D5B5, 0xB5470917, 0x9216D5D9, 0x8979FB1B];
    },
    
    encipher: function(x){
        var xHi = x[0];
        var xLo = x[1];
        var Round = 0;
        
        xHi ^= this.P[0];
        
        while (Round < 16) {
            xLo ^= (((this.S[0][xHi >>> 24] + this.S[1][(xHi >>> 16) & 0x0ff])
                ^ this.S[2][(xHi >>> 8) & 0x0ff]) + this.S[3][xHi & 0x0ff]) ^ this.P[++Round];
            xHi ^= (((this.S[0][xLo >>> 24] + this.S[1][(xLo >>> 16) & 0x0ff])
                ^ this.S[2][(xLo >>> 8) & 0x0ff]) + this.S[3][xLo & 0x0ff]) ^ this.P[++Round];
        }
        
        xLo ^= this.P[16 + 1];
        
        x[0] = xLo;
        x[1] = xHi;
    },
    
    encipher_array: function(x){
        var i, count, xHi, xLo, Round, temp;
        
        for (i = 0; (i < x.length) || (x.length % 6); i += 2) {
            xHi = x[i];
            xLo = x[i + 1];
            
            xHi ^= this.previous_xHi;
            xLo ^= this.previous_xLo;
            
            xHi ^= this.P[0];
            
            Round = 0;
            
            while (Round < 16) {
                xLo ^= (((this.S[0][xHi >>> 24] + this.S[1][(xHi >>> 16) & 0x0ff])
                    ^ this.S[2][(xHi >>> 8) & 0x0ff]) + this.S[3][xHi & 0x0ff]) ^ this.P[++Round];
                xHi ^= (((this.S[0][xLo >>> 24] + this.S[1][(xLo >>> 16) & 0x0ff])
                    ^ this.S[2][(xLo >>> 8) & 0x0ff]) + this.S[3][xLo & 0x0ff]) ^ this.P[++Round];
            }
            
            xLo ^= this.P[17];
            
            this.previous_xHi = xLo;
            this.previous_xLo = xHi;
            
            x[i + 1] = xHi;
            x[i] = xLo;
        }
    },
    
    decipher: function(x){
        var i, xHi, xLo, Round, temp;
        
        for (i = 0; i < x.length; i += 2) {
            xHi = x[i];
            xLo = x[i + 1];
            
            xHi ^= this.P[17];
            
            Round = 16;
            
            while (Round > 0) {
                xLo ^= (((this.S[0][xHi >>> 24] + this.S[1][(xHi >>> 16) & 0xff])
                    ^ this.S[2][(xHi >>> 8) & 0xff]) + this.S[3][xHi & 0xff]) ^ this.P[Round--];
                xHi ^= (((this.S[0][xLo >>> 24] + this.S[1][(xLo >>> 16) & 0xff])
                    ^ this.S[2][(xLo >>> 8) & 0xff]) + this.S[3][xLo & 0xff]) ^ this.P[Round--];
            }
            
            xLo ^= this.P[0];
            
            temp = x[i];
            x[i] = xLo ^ this.previous_xHi;
            this.previous_xHi = temp;
            
            temp = x[i + 1];
            x[i + 1] = xHi ^ this.previous_xLo;
            this.previous_xLo = temp;
        }
    },
    
    initialise: function(key, IV){
        var i, j, k, data;
        var block = new Array(2);
        
        this.previous_xHi = IV[0];
        this.previous_xLo = IV[1];
        
        this.setConstants();
        
        for (j = 0, i = 0; i < 16 + 2; ++i) {
            this.P[i] = this.P[i] ^ key[j];
            j = (j + 1) % 14;
        }
        
        for (i = 0; i < 16 + 2; i += 2) {
            this.encipher(block);
            
            this.P[i] = block[0];
            this.P[i + 1] = block[1];
        }
        
        for (i = 0; i < 4; ++i) {
            for (j = 0; j < 256; j += 2) {
                this.encipher(block);
                this.S[i][j] = block[0];
                this.S[i][j + 1] = block[1];
            }
        }
    },
    
    passtokey: function(pass, HiIV, LoIV){
        var binarypassword = stringtoints(pass);
        var block          = new Array(2);
        var key            = new Array(16);
        var i = 0, j;
        
        block[0] = HiIV;
        block[1] = LoIV;
        
        do {
            this.initialise(key, block, 16);
            
            for (j = 0; j < 16;) {
                block[0] ^= binarypassword[i];
                
                this.encipher(block);
                
                key[j++] ^= block[0];
                key[j++] ^= block[1];
            }
        } while (++i < binarypassword.length)
        
        return key;
    }
};

})(this);




/*FILEHEAD(/var/lib/platform/source/trunk/core/crypto/barrett.js)SIZE(2650)TIME(1257329185)*/

/**
 * Crypt.Barrett, a class for performing Barrett modular reduction computations in
 * JavaScript.
 *
 * Requires BigInt.js.
 *
 * Copyright 2004-2005 David Shapiro.
 *
 * You may use, re-use, abuse, copy, and modify this code to your liking, but
 * please keep this header.
 *
 * Thanks!
 * 
 * @author Dave Shapiro <dave AT ohdave DOT com>
 */



/**
 * A class for performing Barrett modular reduction computations in JavaScript.
 *
 * @param {apf.crypto.BigInt} m
 */
apf.crypto.Barrett = function(){this.init.apply(this, arguments);};
apf.crypto.Barrett.prototype = {
    init: function(m) {
        this.modulus = apf.crypto.BigInt.copy(m);
        this.k = apf.crypto.BigInt.highIndex(this.modulus) + 1;
        var b2k = new apf.crypto.BigInt.construct();
        b2k.digits[2 * this.k] = 1; // b2k = b^(2k)
        this.mu = apf.crypto.BigInt.divide(b2k, this.modulus);
        this.bkplus1 = new apf.crypto.BigInt.construct();
        this.bkplus1.digits[this.k + 1] = 1; // bkplus1 = b^(k+1)
    },
    modulo: function(x) {
        var q1 = apf.crypto.BigInt.divideByRadixPower(x, this.k - 1);
        var q2 = apf.crypto.BigInt.multiply(q1, this.mu);
        var q3 = apf.crypto.BigInt.divideByRadixPower(q2, this.k + 1);
        var r1 = apf.crypto.BigInt.moduloByRadixPower(x, this.k + 1);
        var r2term = apf.crypto.BigInt.multiply(q3, this.modulus);
        var r2 = apf.crypto.BigInt.moduloByRadixPower(r2term, this.k + 1);
        var r = apf.crypto.BigInt.subtract(r1, r2);
        if (r.isNeg) {
            r = apf.crypto.BigInt.add(r, this.bkplus1);
        }
        var rgtem = apf.crypto.BigInt.compare(r, this.modulus) >= 0;
        while (rgtem) {
            r = apf.crypto.BigInt.subtract(r, this.modulus);
            rgtem = apf.crypto.BigInt.compare(r, this.modulus) >= 0;
        }
        return r;
    },
    multiplyMod: function(x, y) {
        /*
         * x = this.modulo(x);
         * y = this.modulo(y);
         */
        var xy = apf.crypto.BigInt.multiply(x, y);
        return this.modulo(xy);
    },
    powMod: function(x, y) {
        var result = new apf.crypto.BigInt.construct();
        result.digits[0] = 1;
        var a = x;
        var k = y;
        while (true) {
            if ((k.digits[0] & 1) != 0) result = this.multiplyMod(result, a);
            k = apf.crypto.BigInt.shiftRight(k, 1);
            if (k.digits[0] == 0 && apf.crypto.BigInt.highIndex(k) == 0) break;
            a = this.multiplyMod(a, a);
        }
        return result;
    }
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/parsers/js.js)SIZE(7977)TIME(1257329185)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Object returning an implementation of a JavaScript parser.
 *
 * @constructor
 * @parser
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.9
 */
apf.JSImplementation = function(){
    //------------------------------------------------------------------------------------
    
    var types = ['[', '{', '(', 'text', 'xpath', 'word', 'sep', 'ws', 'semi', 'sh', 'op', 'col', 'str', 'regex', 'comment'];
    var closes = [']', '}', ')'];
    var reParse = new RegExp();
    reParse.compile("([\\w_\\.]+)|([\\s]*,[\\s]*)|([\\s]*;[\\s]*)|(\\/\\*)|(\\*\\/)|(\\/\\/)|([\\r\\n])|((?:[\\s]*)[\\$\\@\\#\\%\\^\\&\\*\\?\\!](?:[\\s]*))|([\\s]*[\\+\\-\\<\\>\\|\\=]+[\\s]*)|(\\s*\\:\\s*)|(\\s+)|(\\\\[\\\\\\{\\}\\[\\]\\\"\\'\\/])|(\\[)|(\\])|([\\s]*\\([\\s]*)|([\\s]*\\)[\\s]*)|([\\s]*\\{[\\s]*)|([\\s]*\\}[\\s]*)|(\\')|(\\\")|(\\/)", "g");
    
    //------------------------------------------------------------------------------------
    
    this.dump_tree = function(n, s, w){
        for (var i = 0; i < n.length; i++) {
            var m = n[i], t = m[0];
            if (t < 3) {
                s.push(w + types[t]);
                this.dump_tree(m[1], s, '  ' + w);
                s.push(closes[t]);
                s.push('\n');
            }
            else {
                s.push(w + types[t] + ': ' + m[1] + '\n');
            }
        }
        return s;
    };
    
    this.parse = function(str, trim_startspace){
        var err    = []; // error list
        var tree   = []; // parse tree
        var stack  = []; // scopestack
        var node   = tree;
        var blevel = 0, tpos = 0;
        var istr   = 0, icc = 0;
        var lm     = 0;
        var count  = [0, 0, 0];
        
        //tokenize
        //return str;
        //str = str.replace(/\/\*[\s\S]*?\*\//gm,"");
        str.replace(reParse, function(m, word, sep, semi, c1, c2, c3, nl, sh,
          op, col, ws, bs1, bo, bc, po, pc, co, cc, q1, q2, re, pos){
            // stack helper functions
            function add_track(t){
                var txt = trim_startspace
                    ? str.substr(tpos, pos - tpos)
                        .replace(/[\r\n]\s*/, '').replace(/^\s*[\r\n]/, '')
                        .replace(/[\r\n\t]/g, '')
                    : str.substr(tpos, pos - tpos).replace(/[\r\n\t]/g, '');
                if (txt.length > 0) {
                    node[node.length] = [t, txt, tpos, pos];
                }
            }
            
            function add_node(t, data){
                node[node.length] = [t, data, pos];
            }
            
            function add_sub(t){
                count[t]++;
                var n = [];
                node[node.length] = [t, n, pos];
                stack[stack.length] = node;
                node = n;
            }
            
            function pop_sub(t){
                count[t]--;
                if (stack.length == 0) {
                    err[err.length] = ["extra " + closes[t], pos];
                }
                else {
                    node = stack.pop();
                    var ot = node[node.length - 1][0];
                    if (ot != t) {
                        err[err.length] = ["scope mismatch " + types[ot] + " with " + types[t], pos];
                    }
                }
            }
            
            if (!istr) {
                if (word) {
                    add_node(5, m);
                    if (m == 'macro') 
                        lm = 1;
                    else 
                        if (lm) 
                            macros[m] = 1, lm = 0;
                }
                if (sep) 
                    add_node(6, ',');
                if (ws) 
                    add_node(7, m);
                if (semi) 
                    add_node(8, m);
                if (sh) 
                    add_node(9, m);
                if (op) 
                    add_node(10, m);
                if (col) 
                    add_node(11, m);
                if (bo) {
                    add_sub(0);
                }
                if (bc) {
                    pop_sub(0);
                }
                if (co) 
                    add_sub(1);
                if (cc) 
                    pop_sub(1);
                if (po) 
                    add_sub(2);
                if (pc) 
                    pop_sub(2);
            }
            if (c3) {
                if (istr == 0) {
                    istr = 5;
                    tpos = pos + 2;
                }
            };
            if (nl) {
                if (istr == 5) {
                    istr = 0;
                    pos += 1;
                    add_track(14);
                }
            }
            if (q1) {
                if (istr == 0) {
                    istr = 1;
                    tpos = pos;
                } else 
                    if (istr == 1) {
                        istr = 0;
                        pos += 1;
                        add_track(12);
                    }
            }
            if (q2) {
                if (istr == 0) {
                    istr = 2;
                    tpos = pos;
                } else 
                    if (istr == 2) {
                        istr = 0;
                        pos += 1;
                        add_track(12);
                    }
            }
            if (c1) {
                if (istr == 0) {
                    istr = 4;
                    tpos = pos + 2;
                };
                            }
            if (c2) {
                if (istr == 4) {
                    istr = 0;
                    add_track(14);
                }
            }
            if (re) {
                if (istr == 0) {
                    // only allow regex mode if we have no previous siblings or we have a , before us
                    if (node.length == 0 || node[node.length - 1][0] == 6) {
                        istr = 3;
                        tpos = pos;
                    } else 
                        add_node(10, m);
                }
                else 
                    if (istr == 3) {
                        istr = 0;
                        pos += 1;
                        add_track(13);
                    }
            }
            return m;
        });
        //return parse tree
        if (stack.length > 0) 
            for (var i = stack.length - 1; i >= 0; i--) {
                var j = stack[i][stack[i].length - 1];
                err[err.length] = ["unclosed tag " + types[j[0]], j[2]];
            }
        return {
            'tree' : tree,
            'stack': stack,
            'err'  : err,
            'count': count
        };
    };
};
apf.JavascriptParser = new apf.JSImplementation();




/*FILEHEAD(/var/lib/platform/source/trunk/core/parsers/livemarkup.js)SIZE(109513)TIME(1264464062)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @term livemarkup
 * Live Markup is an extension to Javascript, and it allows APF to have
 * a simple consistent syntax for all attribute values and templates.
 * Live markup is used for templating, rpc, data binding,
 * property binding, formatting and even events.
 * Live Markup generates text-output via the default-output of statements,
 * and APF maintains knowledge of all properties and data used to create
 * this output allowing for a Live update when any of this information changes.
 * Nearly all attributes in APF are processed as a live markup " " string
 * Some attributes (like events) and <?lm ?> blocks are processed as code.
 * LiveMarkup features:
 * <ol>
 *  <li>inline xpaths</li>
 *  <li>E4X-like xml literals</li>
 *  <li>automatic statement/expression output and concat</li>
 *  <li>code and xpath expansion in-strings</li>
 *  <li>virtual-sync of async calls</li>
 * </ol>
 * Examples:
 * <code>
 *    var x = [folder/@name]; // value of xpath
 *    [folder/@name] = 'hello'; // set an attribute
 *    [folder/file] += <file/>; // add a new file node to folder/file list
 *    var y = <folder><file name={x}/></folder> // e4x-style xml
 *    x; //automatic output
 *    <xml/>; // automatic output
 *    if(a)func(); // automatic output of function returnvalue
 *    x = 15; // not outputted, assignments are never output.
 *    var z = "string with jsvars: {x} and xpath: [folder/@name]";
 *    alert(comm.someRpcCall(x)); // async call returns sync value
 * </code>
 * LiveMarkup syntax has one conflict with normal JS syntax; an array of 1 item vs xpath.
 * Arrays are recognised if there is atleast one , present: [1,2] and 1 item: [,1]
 *
 * Another important feature of LiveMarkup is that its infinitely nestable:
 * Outer construct: inner constructs
 * <ol>
 *  <li>string: xpath, code</li>
 *  <li>xpath: code, xpath(its a sub-xpath when NOT after [)\w] or IS inside "str" or 'str' )</li>
 *  <li>code: xpath, code, string, xml</li>
 *  <li>xml: xpath, code</li>
 * </ol>
 * Example of code in xpath in xml in code in string, for the sake of argument:
 * <code>
 * var x = "str{<xml id=[xp{y}]/>}"
 * </code>
 * since code has an auto-output, it is also possible to use scope { } delimiters holding a value
 * and used as an expression.
 * var x = {..code with auto output..}
 * The ^ character at the beginning of a statement can force 'no output' but is very rarely needed.
 *
 * It is important to realise that Live Markup is converted to normal Javascript
 * in a single compile pass, and does not constitute black-magic.
 * As rarely debugging might force you to look at generated code, its useful to know it exists.
 * For instance:
 * XML literals are turned into normal JS strings: <xml/> becomes "<xml/>"
 * in generated code. This is different from E4X where they are special type of object.
 * xpaths and operators are turned into functioncalls: [xpath] becomes _val(_n,"xpath")
 * and nesting becomes concatenation: "a{x}b" becomes ("str"+(x)+"str")
 *
 * Live markup xpath reference
 * Different xpath types:
 * [xpath] - value xpath (string)
 * %[xpath] - single node
 * *[xpath] - node set
 * #[xpath] - number of nodes selected by xpath
 * $[symbol] - language 'xpath', fetches value from language symbol library
 * [model::xpath] - xpath value on model with name 'model'
 * [{x}::xpath] - xpath value on xml node or model with js variable x
 * [{rpc.thing()}::xpath] - xpath value on an rpc call
 * [xpath] = 'value' - assign text-value to xpath (nodeValue = ..)
 * [xpath] = <xml/> - replace node with right hand xml
 * [xpath] = xmlNode - replace node with right hand node, removing xmlNode from its old position
 * [xpath] += 'value' - appends text-value to nodeValue
 * [xpath] += <xml/> - appends the <xml/> after the selected node
 * [xpath] += xmlNode - appends the node and removes from its old position
 *
 * Macro reference
 * localName(n) - returns the localName of the context node or supplied argument
 * tagName(n) - tagName of context node or supplied argument
 * nodeValue(n) - value of context nore or supplied argment similar to [.]
 * local(n){..code..} - a codeblock with a new context node n, n can be xml-string too
 * each(set){..code..) iterates over the set. usually used as: each(*[xpath]){}
 *
 */

/**
 * @constructor
 * @parser
 *
 * @author      Rik Arends
 * @version     %I%, %G%
 * @since       3.0
 */
apf.lm = new (function(){

    var statement_lut = { // all js statements to see its NOT an expression
            "var": 1, "for": 1, "while": 1, "do": 1, "if": 1, "else": 1,
            "switch": 1, "case": 1, "break": 1, "continue": 1, "default": 1,
            "function":2, "return": 1, "try": 1, "catch": 1, "throw":1,
            "debugger": 1, "alert": 1, "delete": 1, "export": 1, "import": 1,
            "label": 1, "foreach":1, "each": 1, "node": 1, "local": 1, "yield": 1,
            "let":1, "finally":1, "delete":1
        },
        type_lut = { // used for optimizing the parse regexp
            "\n": 1, "\r\n": 1, "==":2, "++":2, "--":2, '"': 5, "'": 5,
            "<!--": 6, "-->": 6, "/*": 6, "//": 6, "*/": 6, "{": 7, "}": 8,
            "[": 9, "]": 10, "(": 11, ")": 12, "<": 13, ">": 14, "+=":2,
            "-=":2, "/=":2, "*=":2
        },
        type_close = { // handy
            "{": "}", "[": "]", "(": ")", "{{":"}"
        },
        xpath_axes = { // used to detect xpath axes or model
            "ancestor": 1, "ancestor-or-self": 1, "attribute": 1, "child": 1,
            "descendant": 1, "descendant-or-self": 1, "following": 1,
            "following-sibling": 1, "namespace": 1, "parent": 1, "preceding": 1,
            "self": 1
        },
        misc_tok = { // misc token lookup
            ";":1, ",":2, "^":3, "=":4, "+=":4, "-=":4, "/=":4, "*=":4, "/":5, ":":6
        },
        xpath_lut_code = { // which autoxpath to use when doing macro({xpath})
            "~": "_val(_n,", "%": "_nod(_n,", "*": "_nods(_n,", "#": "_cnt(_n,", "$": "_lng("
        },
        xpath_lut_text = { // which autoxpath to use when doing xpath macros in textmode
            "~": "_val(_n,", "%": "_xml(_n,", "*": "_xmls(_n,", "#": "_cnt(_n,", "$": "_lng("
        },
        xpath_lut_attr = { // xpath lut for node attributes
            "~": "_val(_n,", "%": "_val(_n,", "*": "_val(_n,", "#": "_cnt(_n,", "$": "_lng("
        },
        xpath_lut_node,
        xpath_lut_node_normal = { // normal xpath lookup
            "~": "_val(_n,", "%": "_xml(_n,", "*": "_xmls(_n,", "#": "_cnt(_n,", "$": "_lng("
        },
        xpath_lut_node_langedit = { // language edit xpath lookup
            "~": "_val(_n,", "%": "_xml(_n,", "*": "_xmls(_n,", "#": "_cnt(_n,", "$": "_lnged("
        },
        pre_regexp = {
            "[":1, "(":1, ",":1, "=":1, "return":1, "throw":1
        },
        pre_xpath = {
            "else":1, "return":1, "delete":1
        },
        pre_plain = {
            "do":1, "else":1, "try":1
        },
        op_lut = { // obj.prop += operator lut
            "=" : "_asn(", "+=": "_add(", "-=": "_sub(", "/=": "_div(", "*=": "_mul("
        },
        new_block = {
            "+":1, "%":1, "-":1, "/":1, "=":1, "(":1, "?":1, "|":1, "^":1, "[":1,
            "&":1, "*":1, "!":1, ":":1, "<":1, ",":1
        },
        out_context_word = { // token preceeding a word signalling a new output
            "{":1, "} ":1, ")":1, ")   ":1, ";":1, "\n":1, "else":1
        },
        out_context_paren = { // token preceeding a paren signalling a new output
            "{":1, ";":1, "\n":1, "else":1
        }, // special markers: ') ' tail of xpath macro. ')  ' func def, tok=')    ' its not an if while etc.
        markup_in_code_lut = {
            "} ":1, ")   ":1,// the } used when it wasnt a code-expression
            "(":1, ")":1, ";":1, "&":1, "^":1, "|":1, ",":1, '"':1, "'":1, "=":1,
            "+=":2, "-=":2, "/=":2, "*=":2, "?":1, "{":1, "}":1, ">":1, "[":1,
            "]":1, "+":1, ":":1, "else":1, "return":1
        },
        block_autoappend = { // token preceeding block signalling auto append
            '"':1, "'":1, ">":1, "]":1, "}":1
        },
        unesc_lut = { // unescape in code and xpath mode
            "\\\"": "\"", "\\\'": "\'", "\\{": "{", "\\}": "}", "\\[": "[",
            "\\]": "]", "\\(":"(", "\\)":")", "\\\\":"\\"
        },
        call_exclusion = {
            "alert": 1, "confirm" :1, "setTimeout":1, "setInterval":1, "switch":1,
            "call":1, "return":1, "throw":1, "case":1, "catch":1
        },
        is_out_space = {
            " ":1, "\n":1
        },
        newline_notallowed = {
            "{":1, ";":1, "(":1, "\n":1
        },//@todo !verify and document! character escaping system
        unesc_str = { // unescape in string mode
            "\\{": "{", "\\}": "}", "\\[": "[", "\\]": "]", "\\(": "(", "\\)": ")"
        },
        unesc_txt = { // unescape in text mode
            "\\{" : "{", "\\}" : "}", "\\[" : "[", "\\]" : "]", "\\(" : "(",
            "\\)" : ")", "\\\\": "\\\\\\\\", "\\"  :"\\\\", "\\<" : "<", "\\>" : ">"
        },
        xml_code_operators = { // word to operand lookup table for easy use in xml
            "lte": "<=", "gte": ">=", "lt": "<", "gt": ">", "and": "&&", "or": "||",
            "andbin": "&", "orbin": "|", "LTE": "<=", "GTE": ">=", "LT": "<",
            "GT": ">", "AND": "&&", "OR": "||", "ANDBIN": "&", "ORBIN": "|"
        },
        xpath_macro = { // which autoxpath to use when doing macro({xpath})
            0 : "_val(_n,",
            1 : "_valcr(_n,_cr,",
            2 : "_nod(_n,",
            3 : "_nodcr(_n,_cr,",
            4 : "_nods(_n,",
            5 : "_xpt(_n,",
            6 : "_valst(_n,",
            7 : "_valed(_n,",
            "foreach"   : "_nods(_n,",
            "each"      : "_nods(_n,",
            "local"     : "_nod(_n,",
            "tagName"   : "_nod(_n,",
            "localName" : "_nod(_n,",
            "xml"       : "_xmlq(",
            "_call"     : "_val(_n,"
        },
        xpath_model = { // which autoxpath to use when doing macro({xpath})
            "_val(_n,"      : "_valm(",
            "_valcr(_n,_cr,": "_valcr(0,_cr,",
            "_nod(_n,"      : "_nodm(",
            "_nodcr(_n,_cr,": "_nodcr(0,_cr,",
            "_nods(_n,"     : "_nodsm(",
            "_xml(_n,"      : "_xml(0,",
            "_xmls(_n,"     : "_xmls(0,",
            "_cnt(_n,"      : "_cntm(",
            "_xpt(_n,"      : "_xptm(",
            "_valst(_n,"    : "_valm(",
            "_valed(_n,"    : "_valed(0,",
            "_lng("         : "_lng(",
            "_lnged("       : "_lnged(",
            "_nod_del(_n,"  : "_nod_del(0,",
            "_nods_del(_n," : "_nods_del(0,"
        },
        xpath_op = { // which autoxpath to use when doing macro({xpath})
            "=":{
                "_val(_n,"      : "_nod_asn(_n,",
                "_valm("        : "_nod_asn(0,",
                "_valcr(_n,_cr,": "_nod_asn(_n,",
                "_valcr(0,_cr," : "_nod_asn(0,",
                "_nod(_n,"      : "_nod_asn(_n,",
                "_nodm("        : "_nod_asn(0,",
                "_nodcr(_n,_cr,": "_nod_asn(_n,",
                "_nodcr(0,_cr," : "_nod_asn(0,",
                "_nods(_n,"     : "_nods_asn(_n,",
                "_nodsm("       : "_nods_asn(0,"
            },
            "+=":{ // which autoxpath to use when doing macro({xpath})
                "_val(_n,"      : "_nod_add(_n,",
                "_valm("        : "_nod_add(0,",
                "_valcr(_n,_cr,": "_nod_add(_n,",
                "_valcr(0,_cr," : "_nod_add(0,",
                "_nod(_n,"      : "_nod_add(_n,",
                "_nodm("        : "_nod_add(0,",
                "_nodcr(_n,_cr,": "_nod_add(_n,",
                "_nodcr(0,_cr," : "_nod_add(0,",
                "_nods(_n,"     : "_nods_add(_n,",
                "_nodsm("       : "_nods_add(0,"
            }
        },
        xpath_del = {
            "_cnt(_n,"      : "_nod_del(_n,",
            "_xpt(_n,"      : "_nod_del(_n,",
            "_val(_n,"      : "_nod_del(_n,",
            "_valcr(_n,"    : "_nod_del(_n,",
            "_nod(_n,"      : "_nod_del(_n,",
            "_nodcr(_n,_cr,": "_nod_del(_n,",
            "_nods(_n,"     : "_nods_del(_n,"
        },
        parserx = /(\r?[\n]|\/\*|\*\/|\/\/|\<\!\-\-|\-\-\>|[=+\/\*-]=|\+\+|\-\-|["'{(\[\])}\]\<\>]|$)|([ \t]+)|([a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF.$_][\w.$_]*)|(\d[x\d.]*)|(\\?[\w._?,:;!=+-\\\/^&|*"'[\]{}()%$#@~`<>]?)/g,
		selfrx = /(^|\|)(?!\@|text\(\)|\.\.|[\w\-\:]+?\:\:)/g, // inject self regexp
        macro_o = {},
        macro_c = {},
        macro_m = {},
        // config vars
        c_async_lut = apf.$asyncObjects || { // used to figure out if the thing before the. is an async obj
            "comm" :1,
            "rpc"  :1,
            "http" :1
        },
        c_xpathmode,    // guess 'node' as the type for {} o_xpathpairs, 1 = node, 2 = nodes
        c_elemxpath,    // which xpath macro to use inside a ns'ed element
        c_statexpath,   // which xpath to use for the stateful value
        c_injectself,   // add self:: in some o_xpathpairs
        // outputs
        o, ol,          // output and output len
        o_asyncs,       // number of async calls
        o_xpathpairs,   // all xpaths and their models in pairs
        o_props,        // the js properties found
        o_segs,     	// segments at groundlevel
        o_xpaths,    	// xpaths at groundlevel
        o_models,       // number of xpaths with models
        // temp and state vars
        s = [], sl,     // scopestack and scopestack len
        bt = [],        // backtrack lut
        bts = [],       // backtrack string stack
        parse_mode,     // the parse parse_mode
        scope,          // ol of a scope begni
        segment,        // the ol of a segment begin
        start_tok,      // the token a string or comment was started with
        str,str_len,           // length of the input string
        line_no,        // line number we are at
        nesting,        // nesting count
        // last state vars
        last_tok,       // last token
        last_type,      // last type
        last_dot,       // . pos when last token was a word
        last_model,     // last model found
        last_prop,      // last property found
        last_cmt_mode,	// the parse mode outside the comment
        last_cmt_tok,	// last token before comment
        last_cmt_type,	// last type before comment
        last_line,      // offset of last newline
        last_ns,        // last namespace found
        last_word; 	    // last word in code mode
    // macros used in code()
    macro_o["if"]       = "if(",
    macro_c["if"]       = ")",
    macro_o["while"] 	= "while(",
    macro_c["while"] 	= ")",
    macro_o["for"]      = "for(",
    macro_c["for"]      = ")",
    macro_o["switch"] 	= "switch(",
    macro_c["switch"] 	= ")",
    macro_o["catch"] 	= "catch(",
    macro_c["catch"] 	= ")",
    macro_c["function"] = ")  ";

    macro_o.foreach 	=
    macro_o.each        = "\nfor(var _t=_t||[],_t=(_t.push(_n,0,("
    macro_c.foreach 	=
    macro_c.each        = ")||[]),_t);(_n=_t[_t.length-1][_t[_t.length-2]++])||(_t.length-=2,_n=_t.pop(),0);)"
    macro_o.local       = "\nfor(var _t=_t||[],_t=(_t.push(_n,((_n=_local("
    macro_c.local       = ")),1)),_t);(_t[_t.length-1]--&&_n)||(_t.length--,_n=_t.pop(),0);)"
    macro_o.localName   = "_localName(_n",
    macro_c.localName 	= ")"
    macro_o.output  	= "_o.join(''",
    macro_c.output      = ")"
    macro_o.reset       = "(_o=[],l=0",
    macro_c.reset       = ")"

    macro_o.item        = "(_t[_t.length-1][_t[_t.length-2]-1]",
    macro_c.item        = ")",
    macro_o.first       = "(_t[_t.length-2]==1",
    macro_c.first       = ")",
    macro_o.last        = "(_t[_t.length-2]==_t[_t.length-1].length",
    macro_c.last        = ")",
    macro_o.total       = "(_t[_t.length-1].length",
    macro_c.total       = ")",
    macro_o.pos	        = "(_t[_t.length-2]-1",
    macro_c.pos	        = ")",

    macro_o.tagName     = "_tagName(_n",
    macro_c.tagName  	= ")"
    macro_o._nodeValue  = "_nodeValue(_n",
    macro_c._nodeValue  = ")"
    macro_c.async       = "])";
    macro_c.precall     = "])";
    macro_c._call       = ")";

    var call_args_lut = {
            _call     : ".call(_n",
            localName : macro_o.localName,
            tagName   : macro_o.tagName,
            nodeValue : macro_o.nodeValue
        },

        // centralized code fragments used in parser/generator
        cf_block_o     = "(function(){var _o=[],_l=0;",
        cf_block_c     = ";return _l==1?_o[0]:_o.join('');})()",
        cf_async_o     = "_async(_n,_c,_a,_w,_f,this,",
        cf_async_m     = "',_a[++_a.i]||[",
        cf_obj_output  = "_r=",
        cf_mode_output,
        cf_str_output  = "_o[_l++]=",
        cf_def_output  = "",
        cf_func_o      = "{var _o=[],_l=0,_n=this;",
        cf_func_c      = ";\nreturn _l==1?_o[0]:_o.join('');}",

        // compile chunks used in compile/match
        cc_async_o     = "(_a=_a||{}).i=0;try{",
        cc_async_c     = "}catch(_e){if(_e.x)return;throw(_e);}",
        //cc_async_o     = "(_a=_a||{}).i=0;",
        //cc_async_c     = "",
        cc_pc_o          = "(_a=_a||{}).i=0;try{_pc(_w);",
        cc_pc_c        = "}catch(_e){if(_e.x)return;throw(_e);}",
        cc_opt_o       = "with(_w){",
        cc_opt_c       = "}",
        cc_v_blk_o     = "var _o=[],_l=0;_o[_l++]=",
        cc_v_blk_ob    = "var _o=[],_l=0;",
        cc_v_blk_c     = ";\nreturn _ret(_l==1?_o[0]:_o.join(''));",
        cc_v_blk_cb    = ";\n_c(_ret(_l==1?_o[0]:_o.join('')),apf.SUCCESS,apf.$lmx);apf.$lmx=null;",
        cc_v_ret_o     = "return _ret(",
        cc_v_ret_c     = ");",
        cc_v_cb_o      = "_c(_ret(",
        cc_v_cb_c      = "),apf.SUCCESS,apf.$lmx);apf.$lmx=null;",

        cc_o_blk_o     = "var _r=",
        cc_o_blk_ob    = "var _r;",

        cc_o_blk_c     = ";\nreturn _r;",
        cc_o_blk_cb    = ";\n_c(_r,apf.SUCCESS,apf.$lmx);apf.$lmx=null;",
        cc_o_blk_ce    = ";\n_c(0,apf.SUCCESS,apf.$lmx);apf.$lmx=null;;",
        cc_o_ret_o     = "return ",
        cc_o_ret_c     = "",
        cc_o_cb_o      = "_c(",
        cc_o_cb_c      = ",apf.SUCCESS);",
        cc_f_async_o   = "var _f=function(_n,_c,_w,_a){",
        cc_f_opt_o     = "var _f=function(_n,_w){",
        cc_f_o         = "var _f=function(_n){",
        cc_fc_async_o  = "var _f=function(_n,_c,_w,_cr,_a){",
        cc_fc_opt_o    = "var _f=function(_n,_w,_cr,){",
        cc_fc_o        = "var _f=function(_n,_cr){",
        cc_fe_async_o  = "var _f=function(event,_c,_w,_a,_n){",
        cc_fe_opt_o    = "var _f=function(event,_w,_n){",
        cc_fe_o        = "var _f=function(event,_n){",
        cc_f_c         = "}",
        cc_f_match_o   = "var _f=function(_m){",

        cc_m_m_blk     = ";\nif(_n=_r){if(!_n.nodeType)_n=_m;",
        cc_m_m_value_o = ";\nif(_n=",
        cc_m_m_value_c = "){if(!_n.nodeType)_n=_m;",
        cc_m_v_string  = "\nreturn ",
        cc_m_v_o       = "\nreturn _ret(",
        cc_m_v_c       = ");",
        cc_m_n_string  = "\nreturn _n;",
        cc_m_n_o       = "\nreturn (_r = (",
		// decision point for compileMatch node-mode for the return type
        cc_m_n_c       = "))?(_r.nodeType?_r:_n):(_r===null?null:_n);",

        cc_m_o         = "var _r, _n = _m;",
        cc_m_brk       = ";\n_n = _m;",
        cc_m_v_ret     = "\nreturn _ret(_nodeValue(_n));" ,
        cc_m_n_ret     = "\nreturn _n;" ,
        cc_m_c         = "\n}";

    function switchToBlock(no_output){ // used to switch expression mode to block mode
        var u, v;
        if (o[scope-1] == "{{")
            u = scope-1; // scan for our root expression block to switch to block
        else
            for (v = sl - 2, u = 0; v >= 0 && o[u=(s[v] & 0xfffffff) - 1] != "{{"; v -=2 ){};
		
        if (!no_output && ol > u + 1)  // inject auto output unless no output or nothing to output in buffer
            o[u] = cf_block_o + cf_str_output
        else
            o[u] = cf_block_o;
        parse_mode = 1;
    }

    function parser(tok, rx_lut, rx_white, rx_word, rx_num, rx_misc, pos){
        var u, v, w,
            type = rx_lut ? type_lut[rx_lut] : (rx_white ? 0 : (rx_word ? 3 : (rx_num ? 4 : (tok ? 2 : 15))));
        switch (parse_mode) {
            case 0: // =====================  expression parse_mode =========================
            case 1: // ==========================  block parse_mode =========================
                switch (type) {
                    case 0: // -------- whitespace --------
                        if ((last_type == 3 && last_tok!='$') || last_type == 4)
                            o[ol++] = " ";
                        else if(xpath_lut_code[last_tok])
                            last_type = 0;// make last_type visible to xpathmode select
                        break;
                    case 1: // -------- newline --------
                        line_no++,
                        last_line = pos;
                        if (o[ol-1] != "\n" && !newline_notallowed[last_tok])
                            o[ol++] = "\n";
                        if (xpath_lut_code[last_tok])
                            last_type = 0;// make last_type visible to xpathmode select
                        break;
                    case 2: // -------- misc --------
                        if (v = misc_tok[tok]) {
                            switch (v) {
                                case 1: // ';'
                                    if (!s[sl-1]) {// close = macro
                                        o[ol++] = ")",
                                        sl     -= 2;
                                    }

                                    if (!parse_mode) { // dont do ; inject newline instead
                                        if (o[ol-1] != "\n" && last_tok != "{" && last_tok != ";")
                                            o[ol++] = "\n";
                                    }
                                    else if(!sl || s[sl - 1]) // dont inject ; if we are in nested assignment macros
                                        o[ol++] = ";";
                                    break;
                                case 2: // ','
                                    if (!s[sl - 1]) { // close = macro
                                        o[ol++] = ")",
                                        sl     -= 2;
                                    }
                                    o[ol++] = ",";
                                    break;
                                case 3: //'^' // dont output
                                    if (o[ol-1] == "\n" || o[ol - 1] == ";" || last_tok=="{"
                                      || last_tok == "} " || ol == scope) { // dont output-shortcut requirements
                                        if (!parse_mode)
                                            switchToBlock();
                                        o[ol++] = "  "; // two spaces make it modify the output-ifs outcome
                                    }
                                    else
                                        o[ol++] = "^";
                                    break;
                                case 4: //'= += -= assignment macro mode
									if(last_tok!='<' && last_tok!='>'){
										if (!parse_mode)
											switchToBlock(true);
										o[ol++] = tok;
										// lets scan in reverse to see if we have an output or a non-output
										for (v = ol; v >= scope && !statement_lut[o[v]] && !((o[v] == "  " 
											|| o[v] == (nesting ? cf_str_output : cf_mode_output)) && (o[v]="",1)); v--){};
										if (last_type == 3 && last_dot>0 && last_tok.charAt(0)!="."){ // prop = macro
											ol -= 2;
											while (is_out_space[o[ol]])
												ol--;
											w = last_tok;
											o[ol++] = op_lut[tok], o[ol++] = w.slice(0,last_dot), 
											o[ol++] = ",'", o[ol++] = w.slice(last_dot+1),
											o[ol++] = "',", s[sl++] = scope | (parse_mode << 28),
											s[sl++] = ""; // notabene, this stored item is checked everywhere
										}
										else if (o[v = ol - 2] == ") ") { // recognise tail of xpath macro
											if (!(u = xpath_op[tok]) || !(u = u[ o[w = s[sl] & 0xfffffff]]))
												throw {
													t: "Invalid xpath assign",
													p: pos
												};
											o[w] = u,o[v] = ",", o[v + 1] = "", o[v + 2] = "";
											s[sl++] = scope | (parse_mode << 28),
											s[sl++] = "" // this value is checked everywhere
										}
									}else{
										o[ol++] = tok;
									}break;
                                case 5: // '/' // regexp mode
                                    if (pre_regexp[last_tok]) {
                                        s[sl++] = scope | (parse_mode << 28);
                                        s[sl++] = o[ol++] = tok;
                                        scope   = segment = ol - 1;
                                        nesting++, parse_mode = 5, start_tok = tok;
                                    }
                                    else
                                        o[ol++] = "/";
                                    break;
                                case 6: // ':' // switch to {x:1} object mode
                                    if (sl > 2 && s[sl - 1] == "{{" && (ol < scope + 4 && last_type == 5)
                                      || (ol < scope + 3 && (last_type == 3 || last_type == 4))) {
                                        o[scope-1] = s[sl-1] = "{"
                                        parse_mode = (v = s[sl - 2]) >> 28;
                                        s[sl-2]    = v & 0xfffffff,
                                        nesting--;
                                    }
                                    else if(o[ol - 3] == "case" || (last_type == 5 && last_word == "case"))
                                        tok = ";"; //fixes auto output problem
                                    o[ol++] = ":";
                                    break;
                            }
                        }
                        else
                            o[ol++] = unesc_lut[tok] || tok;
                        break;
                    case 3: // -------- word --------
                    case 4: // ------- number -------
                        v = u = w = 0;// last_word used for case 'bla bla':
                        last_dot = (last_word = tok).lastIndexOf(".");
						if (tok.charAt(0) != '.' // .obj shouldnt trigger block
                          && ((v = (u = ((out_context_word[last_tok]  // check if we need to switch
                                || o[ol - 1] == "\n")  && !new_block[last_tok]))
                                && !s[sl - 1].indexOf("{") && ol > scope)
                                || (w = statement_lut[tok])) && !parse_mode){ // check statement
							if(w == 2 && s[sl - 1].indexOf("{")) w = 0; // (function() shouldnt trigger blockmode
							switchToBlock(w);  // pass in statement_lut[tok] as outputflag
						}
                        if (u && !s[sl - 1]) { // assign macro close
                            o[ol-1] == "\n" && (o[ol - 1] = ""), o[ol++] = ")",
                            o[ol++] = "\n", v = 1, sl -= 2;
                        }
                        if (v && parse_mode && !statement_lut[tok]) // inject output
                            o[ol++] = (nesting ? cf_str_output : cf_mode_output);

                        if (last_dot > 0 && tok.charAt(0) != ".") // store property
                            o_props[o[ol++] = last_prop = tok] = 1;
                        else // lookup and/or/etc
                            o[ol++] = xml_code_operators[tok] || tok;
                        break;
                    case 5: // -------- stringquotes --------
                        if ((v = (u = ((out_context_word[last_tok] || o[ol - 1]== "\n" )
                          && !new_block[last_tok])) && !s[sl - 1].indexOf("{")
                          && ol > scope) && !parse_mode) // check if we need to switch to block mode
                            switchToBlock();

                        if (u && !s[sl - 1]) { // close = macro
                            o[ol - 1] == "\n" && (o[ol - 1] = ""), o[ol++] = ")",
                            o[ol++] = "\n", v = 1, sl -= 2;
                        }
                        if (v) { // generate output
                            o[ol++] = (o[ol-2] != "\n" && block_autoappend[last_tok])
                                ? "+"
                                : (nesting ? cf_str_output : cf_mode_output);
                        }
                        else if (block_autoappend[last_tok])
                            o[ol++] = "+";

                        s[sl++] = scope | (parse_mode << 28), s[sl++] = o[ol++] = tok;
                        scope   = segment = ol - 1, nesting++, parse_mode = 5, start_tok = tok;
                        break;
                    case 6: // -------- comment --------
                        if (tok == "*/" || tok== "-->")
                            throw {
                                t: "Unmatched comment "+tok,
                                p: pos
                            };
                        last_cmt_mode = parse_mode, last_cmt_tok = last_tok,
                        last_cmt_type = last_type, parse_mode = 6, start_tok = tok;
                        break;
                    case 7: // -------- { --------
                        if (o[ol - 1] == ")  " || (o[ol - 2] == ")  " && ol--)) { // ')  ' is function def
                            if (s[sl - 1] != "(" && s[sl - 1] != "[") {
                                s[sl++] = scope | (parse_mode << 28),
                                s[sl++] = "{{", o[ol++] = cf_func_o,
                                scope = ol, parse_mode = 1, nesting++, o[ol++] = ""; // make the scope check pass
                            }
                            else {
                                s[sl++] = scope, s[sl++] = o[ol++] = tok, scope = ol;
                                parse_mode = 1;
                            }// for do else..etc below
                        }
                        else if ((macro_o[s[sl + 1]] && last_tok == ")   ") || pre_plain[last_tok]) {
                            s[sl++] = scope, s[sl++] = o[ol++] = tok, scope = ol;
                            o[ol++] = "";
                        }
                        else {
                            if ((v = (u = ((out_context_word[last_tok]||o[ol - 1] == "\n")
                              && !new_block[last_tok]))
                              && !s[sl - 1].indexOf("{") && ol > scope) && !parse_mode)
                                switchToBlock(); // block mode detection

                            if (u && !s[sl - 1]) { // close = macro
                                o[ol - 1] == "\n" && (o[ol - 1] = ""),
                                o[ol++] = ")", o[ol++] = "\n", v = 1, sl -= 2;
                            }
                            if (v) { // inject output, +''+ is when between two { } { } (supposedly)
                                o[ol++] = (o[ol - 2] != "\n" && block_autoappend[last_tok])
                                    ? "+''+"
                                    : (nesting ? cf_str_output : cf_mode_output);
                            }
                            else if (block_autoappend[last_tok]) // inject append
                                o[ol++] = (last_tok == "}") ? "+''+" : "+";

                            s[sl++] = scope | (parse_mode << 28), s[sl++] = o[ol++] = "{{";

                            if (!nesting && scope != ol) // count output segments on nesting 0
                                o_segs++;

                            nesting++, segment = scope = ol, parse_mode = 0;
                        }
                        break;
                    case 8: // -------- } --------
                        if (!s[sl - 1]) // close = macro
                            o[ol++] = ")", o[ol++] = "\n",sl -= 2;

                        if (type_close[v = s[--sl]] != (o[ol++] = tok))
                            throw {
                                t: "Cannot close " + v + " with " + tok,
                                p: pos
                            };

                        if (v == "{{") { // closing code block
                            if (scope == ol - 1) {
                                if( (s[sl - 1] >> 28) <= 1) // empty code in code
                                    o[scope-1] = "{", o[ol - 1] = "}";
                                else // empty code elsewhere
                                    o[scope - 1] = o[ol - 1] = "'";
                            }
                            else {
                                if (!parse_mode) { // expression wraps in ()
                                    o[scope - 1] = "(",
                                    o[ol - 1]    = ")";
                                }
                                else { // codeblock wraps in (function(){})()
                                    if (o[scope - 1] == cf_func_o) {
                                        if (scope == ol - 2)
                                            o[scope - 1] = "{", o[ol - 1] = "}";
                                        else
                                            o[ol - 1] = cf_func_c;
                                    }
                                    else
                                        o[ol - 1] = cf_block_c;
                                }
                            }
                            parse_mode = (v=s[--sl])>>28, scope = v&0x0fffffff;
                            segment = ol, nesting--;

                            if(!nesting) // count segs on nesting level 0
                                o_segs++;

                            if (parse_mode == 7) // attribute hack
                                o[ol++] = "+\"\\\"", parse_mode = 4;
                        } else scope = s[--sl]; // was object def or if(){}

                        break;
                    case 9: // -------- [ --------
                        if (((last_type == 3 && !pre_xpath[last_tok] && last_tok!='$') || last_tok == ")" || last_tok == "]") && o[ol - 1] != "\n") {
                            o[ol++] = "[", s[sl++] = scope | (parse_mode << 28), //was array index
                            s[sl++] = tok, segment = scope = ol;
                        }
                        else {
                            last_model = null;

                            if ((w = xpath_lut_code[last_tok])) {
                                ol--, last_tok = o[ol-1]; // xpath with *%$#
                                if (o[ol - 1] == "delete" || (o[ol - 2] == "delete" && ol--))
                                    w = xpath_del[w], ol--; // delete *[xpath]
                            }
                            else {
                                w = xpath_macro[s[sl - 1]] || xpath_macro[nesting ? 0 : c_xpathmode];
                                if (last_tok == "delete") // delete [xpath]
                                    w = xpath_del[w], ol -= 2;
                            }
                            if ((v = (u = ((out_context_word[last_tok] || o[ol - 1] == "\n")
                              && !new_block[last_tok])) && !s[sl - 1].indexOf("{")
                              && (ol > scope || s[sl - 1].length == 1)) && !parse_mode)
                                switchToBlock(); // check if we need to switch to block mode

                            if (u && !s[sl - 1]) { // close = macro
                                o[ol - 1] == "\n" && (o[ol - 1] = ""), o[ol++] = ")",
                                o[ol++] = "\n", v = 1, sl -= 2;
                            }

                            if (v) { // inject output
                                o[ol++] = (o[ol - 2] != "\n" && block_autoappend[last_tok])
                                    ? "+"
                                    : (nesting ? cf_str_output : cf_mode_output);
                            }
                            else if (block_autoappend[last_tok]) // inject append
                                o[ol++] = "+";

                            if(!nesting && ol!=scope)
                                o_segs++;
                            // store scope in bt for reparse of array
                            nesting++, s[sl++] = scope|(parse_mode<<28), s[sl++] = o[ol++] = w,
                            segment = scope = ol, bt[scope] = pos, parse_mode = 3;
                        }
                        break;
                    case 10: // -------- ] --------
                        if(!s[sl-1]) // close = macro
                            o[ol++]=")",sl -=2;

                        if ( type_close[v = s[--sl]] != (o[ol++] = tok))
                            throw {
                                t: "Cannot close " + v + " with " + tok,
                                p: pos
                            };

                        scope = s[--sl]&0xfffffff; // clean scope of possible parse_mode 1
                        break;
                    case 11: // -------- ( --------
                        if ( ((v = (u=((out_context_paren[last_tok]||o[ol-1]=="\n") &&
                            !new_block[last_tok])) && !s[sl-1].indexOf("{") &&
                            ol>scope)) && !parse_mode)
                            switchToBlock();

                        if (u && !s[sl-1]) // close = macro
                            o[ol-1]=="\n"&&(o[ol-1]=""),o[ol++]=")", o[ol++]="\n",v = 1,sl -=2;

                        if (v && parse_mode) // inject output
                            o[ol++] = (nesting?cf_str_output:cf_mode_output), last_type = 0;

                        if (w = macro_o[last_tok]) {
                            if (o[ol-1]==" ") ol--; // support func ()
                            o[ol-1] = w, s[sl++] = scope, s[sl++] = last_tok, scope = segment = ol;
                        }
                        else {
                            if (last_type == 3) { // word(
                                if (last_dot < 0) { // no dot
                                    v = 0;
                                    if (last_tok == "function" || o[ol - 3] == "function" || o[ol - 4] == "function") {
                                        s[sl++] = scope, s[sl++] = "function", //func def
                                        o[ol++] = "(", scope = segment = ol;
                                    }
                                    else { // its a call and not a new
                                        if (!call_exclusion[last_tok] && o[ol-3]!="new") {
                                            o[ol++] = ".call(_n", s[sl++] = scope,
                                            s[sl++] = "_call", scope = segment = ol;
                                        }
                                        else { // its an excluded call
                                            s[sl++] = scope, s[sl++] = o[ol++] = tok,
                                            scope = segment = ol;
                                        }
                                    }
                                }
                                else if (last_dot > 1 && c_async_lut[v = last_tok.substring(0,last_dot)]) {// its an async call
                                    if (o[--ol] == " ")
                                        ol--;
                                    o[ol++] = cf_async_o, o[ol++] = v, o[ol++] = ",'";
                                    o[ol++] = last_tok.slice(last_dot + 1);
                                    o[ol++] = cf_async_m, s[sl++] = scope, s[sl++] = "async",
                                    scope = segment = ol, o_asyncs++;
                                }
                                else { // its a obj.prop() type call
                                    s[sl++] = scope, s[sl++] = o[ol++] = tok,
                                    scope = segment = ol;
                                }
                            }
                            else { // function object call
                                s[sl++] = scope, s[sl++] = o[ol++] = tok,
                                scope = segment = ol;
                            } // dont store calls as props
                            if (last_tok == last_prop)
                                delete o_props[last_tok];
                        }
                        break;
                    case 12: // -------- ) --------
                        if (!s[sl - 1]) { // close = macro
                            o[ol-1] == "\n" && (o[ol-1] = ""), o[ol++] = ")",
                            o[ol++]="\n", v = 1, sl -= 2;
                        }

                        if (w = macro_c[v = s[--sl]]) { // closing a macro
                            if (v != "_call")
                                tok = ")   "; // make sure any [ ] doesnt get interpreted as array index
                            if ((u = call_args_lut[v]) && u != o[ol - 1])
                                o[scope - 1] = u + ",";// do , insertion for argless macros
                            o[ol++] = w; // write close-end of macro
                        }
                        else if (type_close[v] != (o[ol++] = tok)) {
                            throw {
                                t:"Cannot close " + v + " with " + tok,
                                p: pos
                            };
                        }
                        scope = s[--sl] & 0xfffffff; // scope should be unimpacted
                        break;
                    case 13: // -------- < --------
                        // check if < is markup or not
                        if (ol == scope || markup_in_code_lut[last_tok] || o[ol - 1] == "\n"){
                            if ((v = (u = ((out_context_word[last_tok] || o[ol - 1] == "\n")
                              && !new_block[last_tok])) && !s[sl - 1].indexOf("{")
                              && ol > scope) && !parse_mode)
                                switchToBlock(); // switch to block mode

                            if (u && !s[sl - 1]) { // close = macro
                                o[ol - 1] == "\n" && (o[ol - 1] = ""), o[ol++] = ")",
                                o[ol++] = "\n", v = 1, sl -= 2;
                            }
                            if (v) {
                                o[ol++] = (o[ol - 2] != "\n" && block_autoappend[last_tok])
                                    ? "+''+"
                                    : (nesting ? cf_str_output : cf_mode_output);
                            }
                            else if (block_autoappend[last_tok])
                                o[ol++] = "+";
                            // start markup mode with the markup-stack counting
                            last_ns = null, o[ol++] = '"', o[ol++] = "<", nesting++,
                            s[sl++] = scope | (parse_mode << 28), sl += 3,
                            s[sl - 2] = s[sl - 1] = 0;

                            segment = scope = ol - 1, parse_mode = 4;
                        }
                        else
                            o[ol++] = "<";
                        break;
                    case 14: // -------- < --------
                        o[ol++] = ">";
                        break;
                    case 15: // end
                        if (sl && !s[sl - 1]) { // close = macro
                            o[ol - 1] == "\n" && (o[ol - 1] = ""), o[ol++] = ")",
                            o[ol++] = "\n", v = 1, sl -= 2;
                        }
                        break;
                }
                break;
            case 2: // ==========================  text parse_mode ==========================
                switch (type) {
                    case 1: // -------- newline --------
                        line_no++, last_line = pos;
                        if (ol != scope && ol != segment) // only output when not first
                            o[ol++] = "\\n";
                        break;
                    case 2: // -------- misc --------
                        if (ol == segment) // segment connectors
                            o[ol] = (ol++ == scope) ? "\"" : "+\"";

                        o[ol++] = unesc_txt[tok] || tok;
                        break;
					case 3: // word
                        if (ol == segment)
                            o[ol] = (ol++ == scope) ? "\"" : "+\"";
						if(tok.charAt(tok.length-1)=='$'){
							o[ol++] = tok.slice(0,-1);
							o[ol++] = tok = '$';// fix word$[xpath] 
						}else o[ol++] = tok;
						break;
                    case 5: // -------- stringquotes --------
                        if (ol == segment)
                            o[ol] = (ol++ == scope) ? "\"" : "+\"";

                        o[ol++] = (tok == '"') ? "\\\"" : "'";
                        break;
                    case 7: // -------- { -------- code mode
                        if (ol == segment){
                            if (ol != scope )
                                o[ol++] =  "+";
                        }
                        else
                            o[ol++] = "\"+", nesting || o_segs++;
                        s[sl++] = scope | 0x20000000, s[sl++] = o[ol++] = "{{",
                        nesting++, segment = scope = ol, parse_mode = 0;
                        break;
                    case 9:  // -------- [ --------  xpath mode
                        last_model = null; // get xpath macro
                        if ((w = xpath_lut_text[last_tok]) && o[ol - 1] == last_tok) {
                            if (--ol - 1 == scope)
                                ol --; // remove first ""
                        }
                        else // only select c_xpathmode when nesting == 0
                            w = xpath_macro[(nesting || scope != ol) ? 0 : c_xpathmode];

                        if (ol != scope) {
                            o[ol] = (ol++ == segment) ? "+" : (nesting || o_segs++, "\"+");

                            if (!nesting)
                                o_segs++;
                        }

                        s[sl++] = scope | 0x20000000, s[sl++] = o[ol++] = w,
                        segment = scope = ol, nesting++, parse_mode = 3;
                        break;
                    case 15: // -------- end --------
                        if (sl)
                            throw {
                                t: "Unclosed " + s[sl-1] + " found at end in textmode",
                                p: pos
                            };
                        if (ol != scope && ol != segment)
                            o[ol++] = "\"", nesting || o_segs++;
                        break;
                    default: // -------- default --------
                        if (ol == segment)
                            o[ol] = (ol++ == scope) ? "\"" : "+\"";
                        o[ol++] = tok;
                }
                break;
            case 3: // ==========================  xpath parse_mode =========================
                switch(type){
                    case 0: // -------- whitespace --------
                        if (ol != scope){ // strip initial spaces\l
                            if (ol == segment)
                                o[ol++] = "+\"";
                            o[ol++] = tok;
                        }
                        break;
                    case 1: // -------- newline --------
                        line_no++, last_line = pos;
                        break;
                    case 2: // -------- misc --------
                        if (tok == ":" && last_tok == ":" && !xpath_axes[w = o[ol - 2]] 
                          && ((v = s[sl - 2]) >> 28) != 6) { // found model::xpath split
                            if (o[ol - 2] == '+"') // model is calculated
                                o[ol - 2] = o[ol - 1] = "", last_model = "#";
                            else {
                                o[ol - 1] = '"';
                                if (segment == scope) // model is normal name
                                    last_model = o.slice(segment + 1, ol - 1).join("");
                                else // model is calculated
                                    last_model = "#";
                            }
                            if (!(w = xpath_model[o[scope - 1]]))
                                throw {
                                    t: "Invalid model found for: "+o[scope-1],
                                    p: pos
                                };

                            o[scope - 1] = w, o[ol++] = ",", segment = scope = ol;
                        }
                        else {
                            if (tok == "," && (v = (s[sl - 2] >> 28)) <= 1) { // xpath is an array in code
                                ol = scope-1, u = str.slice(bt[scope] + 1, pos + 1);
                                // fix up stack to not be an xpath but an array
                                last_type = 9, parse_mode = v, o[ol++] = last_tok = "[";
                                s[sl - 2] = (s[sl - 2] & 0xfffffff) | (parse_mode << 28),
                                s[sl - 1] = last_tok, segment = scope = ol, nesting--;

                                if (!nesting)
                                    o_xpaths--;
                                if (u.length > 1) { // ignore [, optimized escaping
                                    bts.push(str); // push str so str always is the string in replace
                                    (str = u).replace(parserx, parser); // reparse it
                                    str = bts.pop(); // pop it again
                                }
                            }
                            else {
                                if (ol == segment)
                                    o[ol] = (ol++ == scope) ? "\"" : "+\"";
                                o[ol++] = unesc_lut[tok] || tok;
                            }
                        }
                        break;
					case 3: // word
						if (ol == segment)
                            o[ol] = (ol++ == scope) ? "\"" : "+\"";					
                        if(tok.charAt(tok.length-1)=='$'){
							o[ol++] = tok.slice(0,-1);
							o[ol++] = tok = '$';// fix word$[xpath] 
						}else o[ol++] = tok;
						break
                    case 5: // -------- stringquotes --------
                        if (ol == segment)
                            o[ol] = (ol++ == scope) ? "\"" : "+\"";
                        if (s[sl - 1] == "[") // strings only are used in [ ]
                            s[sl - 1] = tok;
                        else if(s[sl - 1] == tok) // close string
                            s[sl - 1] = "[";

                        if (tok == '"')
                            o[ol++] = "\\";
                        o[ol++] = tok;
                        break;
                    case 7: // -------- { --------
                        if (ol == segment) {
                            if (ol != scope)
                                o[ol++] = "+''+";
                        }
                        else
                            o[ol++] = "\"+";

                        s[sl++] = scope | 0x30000000, s[sl++] = o[ol++] = "{{",
                        nesting++, segment = scope = ol, parse_mode = 0;

                        if (last_model && s[sl - 3] != xpath_lut_text["$"]) {
                            o_xpathpairs.push(last_model, "#");
                            last_model = null, o_models++;
                        }
                        break;
                    case 9: // -------- [ --------
                        // lets see if we are an xpath
                        if (s[sl - 1] == "'" || s[sl - 1] == '"' || 
							((last_type != 3 || last_tok=='$') && last_tok != ")") ) {
                            if (last_model)
                                o_xpathpairs.push(last_model, "#"), o_models++;
                            last_model = null;

                            if ((w = xpath_lut_text[last_tok]) && o[ol - 1] == last_tok)
                                ol--;
                            else
                                w = xpath_macro[0];

                            if (ol == segment){
                                if (ol != scope)
                                    o[ol++] = "+";
                            }
                            else o[ol++] = "\"+";

                            s[sl++] = scope | 0x30000000, s[sl++] = o[ol++] = w, nesting++,
                            segment = scope = ol, parse_mode = 3;
                        }
                        else {
                            if (ol == segment)
                                o[ol] = (ol++ == scope) ? "\"" : "+\"";

                            s[sl++] = scope|0x60000000, s[sl++] = o[ol++] = "["; // keep track of [, abuse mode 6
                        }
                        break;
                    case 10: // -------- ] --------
                        sl--, parse_mode = (u = s[--sl]) >> 28, u = u & 0x0fffffff;

                        if (parse_mode == 6){ // was part of [] internally to xpath, see above
                            if (s[sl + 1] != "[")
                                throw {
                                    t:"In xpath, cannot close " + s[sl + 1] + " with " + tok,
                                    p: pos
                                };
                            if (ol == segment)
                                o[ol] = (ol++ == scope) ? "\"" : "+\"";

                            o[ol++] = "]";
                            parse_mode = 3;
                        }
                        else {
                            if (ol == scope ) {
                                if ((s[sl] >> 28) <= 1) // empty array in code
                                    o[scope - 1] = "[", o[ol++] = "]";
                                else // empty xpath elsewhere
                                    o[scope - 1] = o[ol++] = "\"" ;
                                segment = ol;
                            }
                            else {
                                //if( s[sl+1] != '[' )
                                //    throw {t:"Unclosed string in xpath"+s[sl+1], p: pos};
                                if (ol != segment)
                                    o[ol++] = "\"";
                                if (segment == scope){ // we might have an xpath name
                                    v = o.slice(segment + 1, ol - 1).join("");
                                    if (c_injectself && o[scope - 1] != "," // inject self
                                      && v != (u = v.replace(selfrx, "$1self::"))
                                      && s[sl + 1] != xpath_lut_text["$"]) {
                                        o[scope+1] = v = u;
                                        for (u = scope + 2; u < ol - 1; u++)
                                            o[u] = "";
                                    }
                                }
                                else {
                                    if ((u = o[scope - 1]) != ",") {
                                        v = "#";
                                        if (c_injectself)// inject dyn self if dyn xpath
                                            o[scope - 1] = u + "_injself(", o[ol++] = ")";
                                    } 
                                    else
                                        v = "";
                                }
                                if (s[sl + 1] != xpath_lut_text["$"] && v) {
                                    o_xpathpairs.push(last_model, v);  // only store if not _lng
                                    if (last_model)
                                        o_models++;
                                }
                                o[ol++] = ") ", segment = ol; // close xpath with ') ' marker
                                //logw("CLOSING XPATH"+o.join('#')+nesting);
                                if (parse_mode == 7) // attribute assign in xml mode
                                    o[ol++] = "+\"\\\"", parse_mode = 4;
                            }
                            // lets output an xpath if we werent a language symbol
                            nesting--, last_model = null;
                            if (!nesting)
                                o_segs++, o_xpaths++;
                        }
                        scope = u;
                        break;
                    case 11: // -------- ( --------
                        if (ol == segment)
                            o[ol] = (ol++ == scope) ? "\"" : "+\"";
                        s[sl++] = scope | 0x30000000, // keep track of () in xpath
                        s[sl++] = o[ol++] =  "(";//, last_model = null;
                        break;
                    case 12: // -------- ) --------
                        if (ol == segment)
                            o[ol] = (ol++ == scope) ? "\"" : "+\"";

                        if (type_close[v = s[--sl]] != (o[ol++] = tok))
                            throw {
                                t:"Cannot close " + v + " with " + tok,
                                p: pos
                            };

                        scope = s[--sl] & 0xfffffff;
                        break;
                    case 15: // -------- end --------
                        throw {
                            t: "Unexpected end whilst parsing xpath",
                            p: pos
                        };
                        break;
                    default: // -------- default --------
                        if (ol == segment)
                            o[ol] = (ol++ == scope) ? "\"" : "+\"";
                        o[ol++] = tok;
                        break;
                }
                break;
            case 4: // ===========================  xml parse_mode ==========================
                switch (type) {// stack: '<'sl+4,outside=0, '</'sl-4  '>'sl-2,outside=1 '/>'sl-4,outside=1
                    case 0: // -------- whitespace --------
                        if (ol == segment)
                            o[ol++] = "+\"";

                        o[ol++] = " ", last_type = 0;
                        break;
                    case 1: // -------- newline --------
                        if (ol == segment)
                            o[ol++] = "+\"";

                        line_no++, last_line = pos, o[ol++] = "\\n", last_type = 1;
                        break;
                    case 2: // -------- misc --------
                        if (ol == segment)
                            o[ol++] = "+\"";
                        if (tok == "/" && last_tok == "<") {
                            sl -= 4; // </ closing tag, drop stacklevel by 4
                            if (s[sl] || s[sl + 2])
                                throw {
                                    t: "Unexpected closing tag whilst parsing xml",
                                    p: pos
                                };
                        }
                        else if (tok == ":" && last_type == 3 && o[ol - 2] == "<")
                            last_ns = last_tok; // found a namespace item in a tag
                        o[ol++] = unesc_txt[tok] || tok;
                        break;
					case 3: // word
                        if (ol == segment)
                            o[ol++] = "+\"";		
                        if(tok.charAt(tok.length-1)=='$'){
							o[ol++] = tok.slice(0,-1);
							o[ol++] = tok = '$';// fix word$[xpath] 
						}else o[ol++] = tok;
						break						
                    case 5: // -------- stringquotes --------
                        if (ol == segment)
                            o[ol++] = "+\"";

                        if (tok == '"')
                            o[ol++] = "\\";
                        o[ol++] = tok;
                        break;
                    case 6: // -------- comment --------
                        if (tok == "//" && !s[sl - 1]) {
                            if (ol == segment)
                                o[ol++] = "+\"";  // < char ups stack by 4, outside= 0
                            o[ol++] = tok;
                        }
                        else {
                            if (tok == "*/")
                                throw {
                                    t: "Unmatched comment "+tok,
                                    p: pos
                                };
                            last_cmt_mode = parse_mode, last_cmt_tok = last_tok,
                            last_cmt_type = last_type, parse_mode = 6, start_tok = tok;
                        }
                        break;
                    case 13: // -------- < --------
                        last_ns = null;
                        if (ol == segment)
                            o[ol++] = "+\"";  // < char ups stack by 4, outside= 0
                        o[ol++] = tok, s[sl] = s[sl + 2] = 0, sl += 4, s[sl - 1]=0;
                        break;
                    case 14: // -------- > --------
                        if (ol == segment)
                            o[ol++] = "+\"";

                        o[ol++] = tok;
                        if (last_tok != "<") {
                            if (last_tok == "/") {
                                sl -= 4; // self close tag /> drops stack -4
                                if (s[sl + 2])
                                    throw {
                                        t: "Unexpected / whilst parsing xml",
                                        p: pos
                                    }
                                if (o[ol - 3] == "<") // remove empty </> from output
                                    ol -= 2, o[ol - 1] = "";
                            }
                            else
                                sl -= 2; // <tag> nets stackdepth of 2
                            if (s[sl]) { // end of xml mode
                                nesting--, o[ol++] = "\"", scope = s[sl], segment = ol,
                                parse_mode = scope >> 28, scope = scope & 0x0fffffff;
                            }
                            else
                                s[sl - 1] = 1; // we are outside a tag, flag it on the stack
                        }
                        else // remove empty <> from output
                            ol--, o[ol - 1] = "";
                        break;
                    case 9:  // -------- [ --------  xpath mode
                        last_model = null;

                        if (last_tok == "!" && o[ol - 2] == "<" && !s[sl - 1]) { // CDATA mode
                            o[ol++] = tok, s[sl++] = scope | (parse_mode << 28);
                            s[sl++] = "]]>", scope = segment = ol - 1;
                            nesting++, parse_mode = 5;
                        }
                        else {
                            if (s[sl - 1]) { // we are outside a tag
                                if((v = xpath_lut_node[last_tok]))
                                    ol --;
                                else
                                    v = xpath_macro[last_ns ? c_elemxpath : 0];
                                s[sl++] = scope | 0x40000000
                            }
                            else {
                                s[sl++] = scope | 0x40000000
                                if ((v = xpath_lut_attr[last_tok])) {
                                    ol--;
                                    if (o[ol - 1] == "=")
                                        last_tok = "=";
                                }
                                else
                                    v = xpath_macro[last_ns ? c_statexpath : 0];

                                if (last_tok == "=")//0x7 flags xpath-in-missing-quotes <a i=[xp]/>
                                    o[ol++] = "\\\"", s[sl - 1] = scope | 0x70000000;
                            }
                            o[ol] = (ol++ == segment) ? "+''+" : "\"+";
                            nesting++, s[sl++] = o[ol++] = v,
                            segment = scope = ol, parse_mode = 3;
                        }
                        break;
                    case 7: // -------- { -------- code mode
                        if (last_tok == "=") // 0x7 flags code-in-missing-quotes <a i={x}/>
                            o[ol++] = "\\\"", s[sl++] = scope | 0x70000000;
                        else
                            s[sl++] = scope | 0x40000000

                        o[ol] = (ol++ == segment) ? "+''+" : "\"+";
                        s[sl++] = o[ol++] = "{{", nesting++;
                        segment = scope = ol, parse_mode = 0;
                        break;
                    default:
                        if (ol == segment)
                            o[ol++] = "+\"";
                        o[ol++] = tok;
                        break;
                    case 15: // -------- end --------
                        throw {
                            t: "Unexpected end whilst parsing xml",
                            p: pos
                        };
                        break;
                }break
            case 5: // ==========================  string parse_mode ========================
                switch (type) {
                    case 1: // -------- newline --------
                        line_no++, last_line = pos;
                        if (ol == segment)
                            o[ol] = (ol++ == scope) ? "\"" : "+\"";
                        o[ol++] = "\\n";
                        break;
                    case 2: // -------- misc --------
                        if (tok == "/" && s[sl - 1] == "/") { // regexp closing character
                            o[ol++]    = "/", scope = s[sl -= 2], segment = ol,
                            parse_mode = scope >> 28,
                            scope      = scope & 0x0fffffff, nesting--;
                        }
                        else {
                            if (ol == segment)
                                o[ol] = (ol++ == scope) ? "\"" : "+\"";
                            o[ol++] = (s[sl - 1] != "/" && unesc_str[tok]) || tok;
                        }
                        break;
					case 3: // word
						if (ol == segment)
                            o[ol] = (ol++ == scope) ? "" : "+\"";		
                        if(tok.charAt(tok.length-1)=='$'){
							o[ol++] = tok.slice(0,-1);
							o[ol++] = tok = '$';// fix word$[xpath] 
						}else o[ol++] = tok;
						break							
                    case 5: // -------- stringquotes --------
                        if (s[sl - 1] == tok) { // closed by matching quote
                            if (scope != segment) // string is segmented, output )
                                o[ol] = (ol++ != segment) ? (tok + ")") : ")";
                            else
                                o[ol++] = tok; // else just close
                            scope = s[sl -= 2], segment = ol, parse_mode = scope >> 28;
                            scope = scope & 0x0fffffff, nesting--;
                        }
                        else {
                            if (ol == segment)
                                o[ol] = (ol++ == scope) ? "\"" : "+\"";
                            o[ol++] = tok == '"' ? "\\\"" : tok;
                        }
                        break;
                    case 6: // -------- default --------
                        if (s[sl - 1] == "/" && tok == "*/") { // caught faux comment in regexp /a*/, is close
                            o[ol++] = "*/", scope = s[sl -= 2], segment = ol,
                            parse_mode = scope >> 28, scope = scope & 0x0fffffff, nesting--;
                        }
                        else {
                            if (ol == segment)
                                o[ol] = (ol++ == scope) ? "" : "+\"";
                            o[ol++] = tok;
                        }
                        break;
                    case 7: // -------- { -------- code mode
                        if (s[sl - 1] != "'" && s[sl - 1] != "/") {
                            if (s[sl - 1] == '"')
                                o[scope] = '("';
                            if (ol == segment) {
                                if (ol != scope)
                                    o[ol++] = "+";
                            }
                            else
                                o[ol++] = "\"+";
                            s[sl++] = scope | 0x50000000, o[ol++] =  s[sl++] = "{{",
                            nesting++, segment = scope = ol, parse_mode = 0;
                        }
                        else
                            o[ol++] = tok;
                        break;
                    case 9:  // -------- [ --------  xpath mode
                        if (s[sl - 1] != "'" && s[sl - 1] != "/" // ignore in '' and CDATA[, else xpath
                          && (s[sl - 1] == '"' && (o[scope] = '("') || ol != scope + 2
                          || last_tok != "CDATA") ) {
                            last_model = null;
                            if ((w = xpath_lut_text[last_tok])  && o[ol - 1] == last_tok)
                                ol--;
                            else
                                w = xpath_macro[0]

                            if (ol != scope)
                                o[ol] = (ol++ == segment) ? "+" : "\"+";

                            s[sl++] = scope | 0x50000000, s[sl++] = o[ol++] = w,
                            segment = scope = ol, nesting++, parse_mode = 3;
                        }
                        else
                            o[ol++] = tok;
                        break;
                    case 14: // -------- > --------
                        if (ol == segment)
                            o[ol] = (ol++ == scope) ? "" : "+\"";
                        o[ol++] = tok;

                        if (s[sl - 1] == "]]>" && last_tok == "]" && o[ol - 3]=="]") { // check if CDATA close
                            scope = s[sl -= 2], parse_mode = scope >> 28;
                            scope = scope & 0x0fffffff, nesting--;
                            sl -= 4; // close the tag since we came from XML mode
                            if (s[sl]) // was last tag, jump up the stack one more.
                                nesting--, o[ol++] = "\"", scope = s[sl], segment = ol,
                                parse_mode = scope >> 28, scope = scope & 0x0fffffff;
                            else
                                s[sl - 1] = 1;
                        }
                        break;
                    case 15: // -------- end --------
                        throw {
                            t: "Unexpected end whilst parsing string",
                            p: pos
                        };
                        break;
                    default: // -------- default --------
                        if (ol == segment)
                            o[ol] = (ol++ == scope) ? "" : "+\"";
                        o[ol++] = tok;
                        break;
                }
                break;
            case 6: // =========================  comment parse_mode ========================
                switch (type) {
                    case 1: // -------- newline --------
                        line_no++, last_line = pos;
                        if (start_tok == "//")
                            parse_mode = last_cmt_mode,
                            tok = last_tok = last_cmt_tok,
                            type = last_type = last_cmt_type;
                        break;
                    case 6: // -------- comment --------
                        if ((start_tok == "/*" && tok == "*/") 
                          || (start_tok == "<!--" && tok == "-->")) {
                            parse_mode = last_cmt_mode,
                            tok = last_tok = last_cmt_tok,
                            type = last_type = last_cmt_type;
                        }
                        break;
                    case 15: // -------- end --------
                        throw {
                            t: "Unexpected end whilst parsing comment",
                            p: pos
                        };
                        break;
                }
                break;
        }
        if (type > 1)
            last_tok = tok, last_type = type;
    }

    this.lastCode = function(){
        if (typeof(o) == "object")
            return o.join("");
        return o;
    };

    function handleError(e, last_line, part){
        // TODO: make a proper JPF exception with this information:
        if (e.t) {
            throw new Error(apf.formatErrorString(0, null,
                "Parsing live markup source",
                "Error whilst parsing: " + e.t + " on line:"+ line_no
                + " col:" + (e.p - last_line - 2)
                + (part ? (" part: " + part) : "") + "\n" + str));
        }
        else {
            throw new Error(apf.formatErrorString(0, null,
                "Compiling live markup function",
                "Error whilst compiling: " + e.message + "\nInput:\n" + str
                + "\nGenerated:\n" + apf.lm.lastCode()));
        }
    }

    /**
     * description of the method.
     * Remarks:
     *   function{type:1,xpaths:[ model,name], props: ['obj.propname','obj2.otherpropname'], asyncs=1}
     *   this is a normal compiled function with extra properties
     *   if the xpath model and/or name is '#' it means it is a runtime calculated modelname or xpath.
     *   obj{type:2, str:str} it was single string by cfg option !alwayscode
     *   obj{type:3, xpaths:[ model, name ] } it was a single xpath  by cfg simplexpath
     *
     * @param  {String}  str      the code to compile
     * @param  {Object}  options
     *   Properties:
     *   {Boolean} withopt     creates with(_w){  code using an options block. (reqd for precall)
     *   {Boolean} precall     wraps 1 async call into precallstore. call with _w._pc = 1 to precall, second time to execute.
     *   {Boolean} alwayscb    always call callback function, even if not async
     *   {Boolean} nostring    even generate code for a simple string
     *   {Number} xpathmode    default type of root level xpath in code mode
     *      Possible values:
     *      0: value
     *      1: value with createnode
     *      2: node
     *      3: node with createnode
     *      4: nodes
     *      5: xpathobj        returns a {model:model,xpath:xpath} object from xpaths
     *   {Boolean} parsecode   start in codemode. if 0 its textmode.
      *  {Boolean} nostate       dont' use _valst macro on [xpath] in namespaced xml.
     *   {Boolean} editable    use the _valed macro for <xml>[xpath]</xml> in namespaced xml.
     *   {Boolean} langedit    use of language items in namespaced xml text.
     *   {Boolean} injectself  injects self:: to suitable xpaths
     *   {Boolean} event       its an event thats being compiled, results in no returnvalue for this function.
     *                         and the first argument is now an 'e' for the event object.
     *
     * @return  {Function} returns a function with extra properties
     *   Properties:
     *   {Number}  type         description
     *      Possible values:
     *      1  Function return type
     *      2  Parsed data is a pure string
     *      3  Function return type, but its a single xpath
     *   {Array}   xpaths       array of [model,xpath, model,xpath] pairs if model
     *                          or xpath is '#', its dynamic if model is null its a local xpath
     *   {Number}  models        number of models
     *   {Array}   props        description
     *   {Number}  asyncs       description
     *   {String]  str            optional, returned with type 2
     */
    var cache    = {},
        emptyCfg = {};
    this.resetCache = function(){
        cache = {};
    };
	
    this.compile = function(istr, cfg){
        if (!cfg)
            cfg = emptyCfg;
		if(istr == null || !istr.length){
			return cfg.nostring?function(){return istr}:{
                type: 2,
                str :istr
            };
		}
			
        var c, f,
            key = (cfg.xpathmode | (cfg.withopt && 0x10) | (cfg.precall && 0x20)
                | (cfg.alwayscb && 0x40) | (cfg.nostring && 0x80)  | (cfg.parsecode && 0x100)
                | (cfg.nostate && 0x200) | (cfg.editable && 0x400) | (cfg.langedit && 0x800)
                | (cfg.injectself && 0x1000) | (cfg.event && 0x2000)) + istr;

        if (c = cache[key])
            return c;

        c_injectself = cfg.injectself,  c_xpathmode = cfg.xpathmode||0,
        c_statexpath = cfg.nostate ? 0 : 6, c_elemxpath = cfg.editable ? 7:0;

        xpath_lut_node = cfg.langedit ? xpath_lut_node_langedit : xpath_lut_node_normal;

        o_props = {}, o_xpathpairs = [], s = [], o = ["","","",""], str = istr,
        str_len = str.length;
        ol = scope = segment = o.length,
        o_segs = o_xpaths = o_asyncs = o_models = nesting = line_no = last_type = last_line = 0;

        if (cfg.parsecode) {
            parse_mode = 0, sl = 2, s[0] = ol, s[1]  = "{{", last_tok = "{",
            cf_mode_output = cfg.event ? "" : (c_xpathmode <= 1 ? cf_str_output : cf_obj_output);
        }
        else
            parse_mode = 2, sl = last_tok = 0, cf_mode_output = cf_str_output;

        if (cfg.nothrow) {
            str.replace(parserx, parser);
        }
        else {
            try {
                str.replace(parserx, parser);
            }
            catch(e) {
                handleError(e, last_line);
                return null;
            }
        }

        if (cfg.parsecode) {
            if (nesting || s[sl - 1].length == 1)
                handleError({
                    t: "Unclosed " + s[sl-1] + " found at end in codemode",
                    p: str_len
                },last_line);
            if (segment!=ol)
                o_segs++
        }
        if (!cfg.nostring && (parse_mode == 2 && segment == 4 || ol == 4)) {
            return {
                type: 2,
                str : o.slice(5, -1).join("").replace(/\\n/g, "\n").replace(/\\"/g, '"')
            }; // string only
        }
        if (o_asyncs || cfg.alwayscb) {
            if (cfg.event) { // event
                if (parse_mode == 1)
                    o[3] = "";
                o[ol++] = cc_o_blk_ce;
            }
            else if (c_xpathmode) { // object return
                if (parse_mode == 1) {
                    o[3]    = (o[3] != cf_block_o) ? cc_o_blk_o : cc_o_blk_ob,
                    o[ol++] = cc_o_blk_cb;
                }
                else
                    o[3] = cc_o_cb_o, o[ol++] = cc_o_cb_c;
            }
            else { // value return
                if (parse_mode == 1)
                    o[3] = (o[3] != cf_block_o) ? cc_v_blk_o : cc_v_blk_ob,
                    o[ol++] = cc_v_blk_cb;
                else
                    o[3] = cc_v_cb_o, o[ol++] = cc_v_cb_c;
            }

            if (cfg.withopt)
                o[2] = cc_opt_o, o[ol++] = cc_opt_c;

            if (o_asyncs) {
                if (cfg.precall)
                    o[1] = cc_pc_o, o[ol++] = cc_pc_c;
                else
                    o[1] = cc_async_o, o[ol++] = cc_async_c;
            }

            o[0] = cfg.event 
                ? cc_fe_async_o
                : ((c_xpathmode == 1 || c_xpathmode == 3) ? cc_fc_async_o : cc_f_async_o);
            o[ol++] = cc_f_c;
        }
        else {
            if (cfg.event) { // event
                if (parse_mode == 1)
                    o[3] = "";
            }
            else if(c_xpathmode) { // object return
                if (parse_mode == 1) {
                    o[3]    = (o[3] != cf_block_o) ? cc_o_blk_o : cc_o_blk_ob,
                    o[ol++] = cc_o_blk_c;
                }
                else
                    o[3] = cc_o_ret_o, o[ol++] = cc_o_ret_c;
            }
            else { // value return
                if (parse_mode == 1) {
                    o[3]    = (o[3] != cf_block_o) ? cc_v_blk_o : cc_v_blk_ob,
                    o[ol++] = cc_v_blk_c;
                }
                else
                    o[3] = cc_v_ret_o, o[ol++] = cc_v_ret_c;
            }
            if (cfg.withopt)
                o[2] = cc_opt_o, o[ol++] = cc_opt_c;

            o[0] = cfg.event
                ? (cfg.withopt ? cc_fe_opt_o : cc_fe_o)
                : (cfg.withopt
                    ? ((c_xpathmode == 1 || c_xpathmode == 3) ? cc_fc_opt_o : cc_f_opt_o)
                    : ((c_xpathmode == 1 || c_xpathmode == 3) ? cc_fc_o : cc_f_o));
            o[ol++] = cc_f_c;
        }

        if (cfg.nothrow) {
            f = apf.lm_exec.compile(o.join(""));
        }
        else {
            try {
                f = apf.lm_exec.compile(o.join(""));
            }
            catch(e){
                handleError(e,last_line);
                return null;
            }
        }
        f.type   = (o_segs == 1 && o_xpaths == 1) ? 3 : 1;
        f.xpaths = o_xpathpairs, f.models = o_models,
        f.props  = o_props, f.asyncs = o_asyncs;

        cache[key] = f;
        return f;
    };

	/**
     * description of the method.
     * Remarks:
     * @param  {String}  str      the code to compile
     * @param  {Object}  options
     *   Properties:
     *   {Boolean} node      tries to return a node, used as a dual-compile with 'normal mode'
     *
     * @return  {Function} returns a function with extra properties
     *   Properties:
     *   {Number}  type         description
     *      Possible values:
     *      1  Function return type
     *      2  Parsed data is a pure string
     *      3  Function return type, but its a single xpath
     *   {Array}   xpaths       array of [model,xpath, model,xpath] pairs if model
     *                          or xpath is '#', its dynamic if model is null its a local xpath
     *   {Number}  models        number of models
     *   {Array}   props        description
     *   {Number}  asyncs       description
     *   {String]  str          optional, returned with type 2
     */
	
    this.compileMatch = function(strarray, cfg){
        if (!cfg)
            cfg = emptyCfg;

        o_props = {}, o_xpathpairs = [], o = [cc_f_match_o, cc_m_o], s = [],
        nesting = 0, ol = o.length, xpath_lut_node = xpath_lut_node_normal;

        for (var st, ob, i = 0, j = strarray.length; i < j; i += 2) {
            if (str = strarray[i]) {
                str_len = s.length, c_xpathmode = 2;
                if (i)
                    o[ol++] = cc_m_brk;
                o[ol++] = "";
                s[0] = ob = ol = scope = segment = o.length, cf_mode_output = cf_obj_output;
                line_no = last_type = o_segs = o_xpaths = o_asyncs = parse_mode = last_line = 0;
                sl = 2, s[1]  = "{{", last_tok = "{";
                c_injectself = 1;

                if (cfg.nothrow) {
                    str.replace(parserx, parser);
                }
                else {
                    try {
                        str.replace(parserx, parser);
                    }
                    catch(e) {
                        handleError(e,last_line);
                        return null;
                    }
                }

                if (nesting || s[sl - 1].length == 1)
                    handleError({
                        t: "Unclosed " + s[sl - 1] + " found at end in codemode",
                        p: str_len
                    });

                if (o_asyncs)
                    handleError({t:"Asynchronous calls not supported in match/value"});

                if (parse_mode == 1) { // block mode
                    o[ob - 1] = (o[ob - 1] != cf_block_o) ? cf_mode_output : "",
                    o[ol++]   = cc_m_m_blk;
                }
                else // value mode
                    o[ob-1] = cc_m_m_value_o, o[ol++] = cc_m_m_value_c;
            }
            if (str = strarray[i + 1]) {
                str_len = s.length;
                if(!strarray[i] && i)
                    o[ol++] = cc_m_brk;
                o[ol++] = "";
                ob = ol = scope = segment = o.length, cf_mode_output = cf_str_output;
                c_xpathmode = c_injectself = last_tok = sl = line_no = o_segs = o_xpaths =
                last_type = o_asyncs = last_line = 0;
				if(cfg.node)
					c_xpathmode = 2;
                parse_mode = 2, c_injectself = 0;
				
                if (cfg.nothrow) {
                    str.replace(parserx, parser);
                }
                else {
                    try {
                        str.replace(parserx, parser);
                    }
                    catch(e) {
                        handleError(e,last_line);
                        return null;
                    }
                }

                if (o_asyncs)
                    handleError({t:"Asynchronous calls not supported in match/value"});
				
				if(cfg.node){
					if (parse_mode == 2 && segment == ob || ol == ob)
						o[ob-1] = cc_m_n_string;
					else
						o[ob-1] = cc_m_n_o, o[ol++] = cc_m_n_c;
				}else{
					if (parse_mode == 2 && segment == ob || ol == ob)
						o[ob-1] = cc_m_v_string;
					else
						o[ob-1] = cc_m_v_o, o[ol++] = cc_m_v_c;
				}

                if (strarray[i])
                    o[ol++] = cc_m_c;
                else
                    break;
            }
            else {
                if (!strarray[i])
                    handleError({t:"Both match and value are empty"});

				if(cfg.node)
					o[ol++] = cc_m_n_ret;				
				else
					o[ol++] = cc_m_v_ret;				
				
				c_xpathmode = 2;
					
                o[ol++] = cc_m_c;
            }
        }
        o[ol++] = cc_f_c;

        var f;
        if (cfg.nothrow) {
            f = apf.lm_exec.compile(o.join(""));
        }
        else {
            try{
                f = apf.lm_exec.compile(o.join(""));
            }
            catch(e){
                handleError(e,last_line);
                return null;
            }
        }

        f.type  = 1, f.xpaths = o_xpathpairs,
        f.props = o_props, f.asyncs = o_asyncs;
        return f;
    };

    this.setWarnLevel = function(lvl){
        apf.lm_exec.setWarnLevel(lvl);
    };
})();

// apf lm_exec makes sure there is no scope pollution for eval'ed live markup.
apf.lm_exec = new (function(){
    var wlvl = 3; // 0: no warnings 1: language/models missing, 2:nodes missing, 3:all failed xpaths

    //warning functions
    this.setWarnLevel = function(lvl){
        wlvl = lvl;
    };

    function wxpath(x, t){
        apf.console.warn("Live Markup warning in " + t + ", no results for xpath: '" + x + "'");
    }

    function wnode(x, t){
        apf.console.warn("Live Markup warning in " + t + ", xpath on null node: '" + x + "'");
    }

    function wmodel(m, x, t){
        apf.console.warn("Live Markup warning in " + t + ", xpath on empty model: '" + m + "' xpath: '" + x + "'");
    }

    function wlang(x, t){
        apf.console.warn("Live Markup warning in " + t + ", language symbol not found: '" + x + "'");
    }

    // xml parse function used by all livemarkup objects
    function xmlParse(str){
        var n = apf.getXmlDom("<_apflmlist_>" + str + "</_apflmlist_>");
        if (!n || !(n = n.documentElement))
            return null;
        return (n.firstChild == n.lastChild) ? n.firstChild : n;
    }

    // value of node by xpath
    function __val(n, x){
        if (!n)
            return (wlvl > 1 && wnode(x),"")
        return (n = (n.nodeType != 1 && n || (n = n.selectSingleNode(x)) 
          && (n.nodeType != 1 && n || (n = n.firstChild) && n.nodeType!=1 && n)))
          && n.nodeValue || (wlvl > 2 && wxpath(x, "_val"),"");
    }

    // value of model node by xpath
    function __valm(m, x){
        var n;
        if (!m || !(n = (m.charAt && ((m.charAt(0) == "<" && xmlParse(m))
          || ((n = apf.nameserver.lookup.model[m]) && n.data)))
          || (m.$isModel ? m.data : (m.charAt ? 0 : m))))
            return (wlvl > 0 && wmodel(m, x, "_valm"),"");
        return (n = (n.nodeType != 1 && n || (n = n.selectSingleNode(x)) 
          && (n.nodeType != 1 && n || (n = n.firstChild) && n.nodeType!=1 && n)))
          && n.nodeValue || (wlvl > 2 && wxpath(x),"");
    }

    function __nod(n, x){			// node by xpath
        return n ? n.selectSingleNode(x) : (wlvl > 1 && wnode(x, "_nod"),null);
    }

    function _nods(n, x){			// array of nodes by xpath
        return n ? n.selectNodes(x) : (wlvl > 1 && wnode(x, "_nods"),[]);
    }

    function __nodm(m, x){			// node of model by xpath
        var n;
        if (!m || !(n = (m.charAt && ((m.charAt(0) == "<" && xmlParse(m))
          || ((n = apf.nameserver.lookup.model[m]) && n.data)))
          || (m.$isModel ? m.data : (m.charAt ? 0 : m))))
            return (wlvl > 0 && wmodel(m, x, "_nodm"),null);

        return n.selectSingleNode(x);
    }

    function _nodsm(m, x){			// array of nodes from model by xpath
        var n;
        if (!m || !(n = (m.charAt && ((m.charAt(0) == "<" && xmlParse(m))
          || ((n = apf.nameserver.lookup.model[m]) && n.data)))
          || (m.$isModel ? m.data : (m.charAt ? 0 : m))))
            return (wlvl > 0 && wmodel(m, x, "_nodsm"),[]);

        return n.selectNodes(x);
    }

    function __cnt(n, x){		 // count nodes by xpath
        return n ? n.selectNodes(x).length:(wlvl > 1 && wnode(x, "_cnt"),0);
    }

    function __cntm(m, x){		// count nodes from model by xpath
        var n;
        if (!m || !(n = (m.charAt && ((m.charAt(0) == "<" && xmlParse(m))
          || ((n = apf.nameserver.lookup.model[m]) && n.data)))
          || (m.$isModel ? m.data : (m.charAt ? 0 : m))))
            return (wlvl>0&&wmodel(m,x,"_cntm"),0);

        return n.selectNodes(x).length;
    }

    function _xpt(n, x){		// return the query wrapped in an object
        return {
            xpath   : x,
            toString: function(){
                return "LM Xpath object: " + this.x
            }
        };
    }

    function _xptm(m, x){		// return the query with model wrapped in an object
        return {
            model:    m,
            xpath:    x,
            toString: function(){
                return "LM Xpath object with model: " + this.x
            }
        };
    }

    //----- the following functions are combined model and normal mode ------

    function _xml(n, m, x){		// serialize node by xpath via .xml
        if(n) x = m;
        else if(!m || !(n=(m.charAt && ((m.charAt(0)=="<" && xmlParse(m)) ||
            ((n = apf.nameserver.lookup.model[m]) && n.data))) ||
        (m.$isModel?m.data:(m.charAt?0:m))))
            return (wlvl>0&&wmodel(m,x,"_xml"),"");

        return (n && (n = n.selectSingleNode(x))) && n.xml ||
        (wlvl>0&&!n&&wnode(x,"_xml"),"");
    }

    function _xmls(n, m, x){	// serialize nodes by xpath with .xml concatenated
        if(n) x = m;
        else if(!m || !(n=(m.charAt && ((m.charAt(0)=="<" && xmlParse(m)) ||
            ((n = apf.nameserver.lookup.model[m]) && n.data))) ||
        (m.$isModel?m.data:(m.charAt?0:m))))
            return (wlvl>0&&wmodel(m,x,"_xmls"),"");
        for(var i = 0,j = ((n=n.selectNodes(x))).length,o = [];i<j;i++)
            o[i] = n[i].xml;
        return o.join("");
    }

    function _valcr(n, cr, m, x){ // value with a create flag
        if(n) x = m;
        else if(!m || !(n=(m.charAt && ((m.charAt(0)=="<" && xmlParse(m)) ||
            ((n = apf.nameserver.lookup.model[m]) && n.data))) ||
        (m.$isModel?m.data:(m.charAt?0:m))))
            return (wlvl>0&&wmodel(m,x,"_valcr"),"");

        if(cr){
            apf.createNodeFromXpath( ni, x );
        }else
        if( n = ni.selectSingleNode(x) ){
            return (n = (n.nodeType != 1 && n || (n = n.selectSingleNode(x)) &&
                (n.nodeType != 1 && n || (n = n.firstChild) && n.nodeType!=1 && n))) && n.nodeValue || ""
        }
        return (wlvl>2&&wxpath(x,"_valcr"),"");
    }

    function _nodcr(n, cr, m, x){ // node with create flag
        if(n) x = m;
        else if(!m || !(n=(m.charAt && ((m.charAt(0)=="<" && xmlParse(m)) ||
            ((n = apf.nameserver.lookup.model[m]) && n.data))) ||
        (m.$isModel?m.data:(m.charAt?0:m))))
            return (wlvl>0&&wmodel(m,x,"_nodcr"),null);
        return n.selectSingleNode(x) || (cr && apf.createNodeFromXpath( n, x ));
    }

    function _valst(n, x){  	// a value with state holding
        var m = apf.xmldb.findModel(n);
        if(!m)
            return (wlvl>0&&wmodel(m,x,"_valst"),"");
        return "[" + m.id + "::" + apf.xmlToXpath(n, m.data, true) + "/" + x + "]";
    }

    function _valed(n, m, x){ 	// a value with editable div
        if(n) x = m;
        return "<div contenteditable='true' class='contenteditable'>CONTENT_EDITABLE_TODO</div>";
    }

    function _nod_del(n, m, x){ // delete node
        if(n) x = m;
        else if(!m || !(n=(m.charAt && ((m.charAt(0)=="<" && xmlParse(m)) ||
            ((n = apf.nameserver.lookup.model[m]) && n.data))) ||
        (m.$isModel?m.data:(m.charAt?0:m))))
            return (wlvl>0&&wmodel(m,x,"_nod_del"),null);
        if( !(n=n.selectSingleNode(x)) )
            return (wlvl>2&&wxpath(m,x,"_nod_del"),null);
        apf.xmldb.removeNode(n);
    }

    function _nods_del(n, m, x){ // delete nodes
        if(n) x = m;
        else if(!m || !(n=(m.charAt && ((m.charAt(0)=="<" && xmlParse(m)) ||
            ((n = apf.nameserver.lookup.model[m]) && n.data))) ||
        (m.$isModel?m.data:(m.charAt?0:m))))
            return (wlvl>0&&wmodel(m,x,"_nods_del"),null);

        if(!(n = n.selectNodes(x)))
            return;
        apf.xmldb.removeNodeList(n);
    }

    function _nod_asn(n, m, x, v){ // assign node
        if(n) v = x, x = m;
        else if(!m || !(n=(m.charAt && ((m.charAt(0)=="<" && xmlParse(m)) ||
            ((n = apf.nameserver.lookup.model[m]) && n.data))) ||
        (m.$isModel?m.data:(m.charAt?0:m))))
            throw new Error(apf.formatErrorString(0,0,"LM Xpath Assign",
                "Cannot assign to nonresolving model:"+m+"\nxpath:"+x+"\nvalue:"+v));

        if(!n || (x && !(n=apf.createNodeFromXpath(n, x))) )
            throw new Error(apf.formatErrorString(0,0,"LM Xpath Assign",
                "Cannot assign could not resolve \nxpath:"+x+"\nvalue:"+v));

        var c;
        if(!v || (v.charAt && (c=v.charAt(0)!="<")) || typeof(v)=="number"){
            apf.setNodeValue( n, v, true);
            return v;
        }
        if(!c){
            if(n.nodeType!=1)
                throw new Error(apf.formatErrorString(0,0,"LM Xpath Assign",
                    "Cannot assign to a non-element node\nxpath:"+x+"\nvalue:"+v));

            if(!(c = xmlParse(v)))
                throw new Error(apf.formatErrorString(0,0,"LM Xpath append",
                    "Cannot append broken XML.\nxpath:"+x+"\nvalue:"+v));
            if(c.tagName != "_apflmlist_"){
                return apf.xmldb.replaceNode( c, n );
            }else{
                c = c.childNodes;
                apf.xmldb.replaceNode( n = c[0], n );
                for(var i = 0, j = c.length;i<j;i++)
                    n = apf.xmldb.appendChild( n.parentNode, c[0], n.nextSibling );
                return n;
            }
        }else{
            if(v.length){ //@todo implement this its an array thingy
                throw new Error(apf.formatErrorString(0,0,"LM Xpath Assign",
                    "Assign of xpath nodelists not yet supported\nxpath:"+x+"\nvalue:"+v));
            }else{
                if(!v.selectNodes)
                    throw new Error(apf.formatErrorString(0,0,"LM Xpath Assign",
                        "Cannot assign non-element node\nxpath:"+x+"\nvalue:"+v));

                if(v.nodeType == 2){
                    if(n.nodeType != 2)
                        throw new Error(apf.formatErrorString(0,0,"LM Xpath Assign",
                            "Cannot assign attribute node to replace non attribute, use += xpath:"+x+"\nvalue:"+v));

                    apf.xmldb.removeAttribute(c = n.ownerElement || n.selectSingleNode(".."),
                        n.nodeName);

                    apf.xmldb.setAttribute(c, v.nodeName, v.nodeValue);

                    c.getAttributeNode(v.nodeName);
                }else
                    apf.xmldb.replaceNode(v, n);
            }
        }
        return v;
    }

    function _nods_asn(n, m, x, v){ // assign nodes
        if(n) v = x, x = m;
        else if(!m || !(n=(m.charAt && ((m.charAt(0)=="<" && xmlParse(m)) ||
            ((n = apf.nameserver.lookup.model[m]) && n.data))) ||
        (m.$isModel?m.data:(m.charAt?0:m))))
            throw new Error(apf.formatErrorString(0,0,"LM Xpath Assign",
                "Cannot assign to nonresolving model:"+m+"\nxpath:"+x+"\nvalue:"+v));

        for(var i = 0, j = (n = n.selectNodes(x)).length;i<j;i++)
            _nod_asn( n[i], null, v);

        return v;
    }


    function _nod_add(n, m, x, v){ // add node
        if(n) v = x, x = m;
        else if(!m || !(n=(m.charAt && ((m.charAt(0)=="<" && xmlParse(m)) ||
            ((n = apf.nameserver.lookup.model[m]) && n.data))) ||
        (m.$isModel?m.data:(m.charAt?0:m))))
            throw new Error(apf.formatErrorString(0,0,"LM Xpath append",
                "Cannot append to nonresolving model:"+m+"\nxpath:"+x+"\nvalue:"+v));

        if(!n || (x && !(n=n.selectSingleNode(x))) ){ // can only add when the xpath exists.
            return _nod_asn(n,0,x,v);
        }

        var c;
        if(!v || (v.charAt && (c=v.charAt(0)!="<")) || typeof(v)=="number"){
            apf.setNodeValue( n,  // append v to node value
                v= ((n = (n.nodeType != 1 && n || (n = n.selectSingleNode(x)) &&
                    (n.nodeType != 1 && n || (n = n.firstChild) && n.nodeType!=1 && n))) && n.nodeValue || "")+v,
                true);
            return v;
        }
        if(!c){
            if(n.nodeType!=1)
                throw new Error(apf.formatErrorString(0,0,"LM Xpath append",
                    "Cannot append to a non-element node\nxpath:"+x+"\nvalue:"+v));
            // check the parsed XML.
            if(!(c = xmlParse(v)))
                throw new Error(apf.formatErrorString(0,0,"LM Xpath append",
                    "Cannot append broken XML.\nxpath:"+x+"\nvalue:"+v));
            if(c.tagName != "_apflmlist_"){
                return apf.xmldb.appendChild( n.parentNode, xmlParse(v), n.nextSibling );
            }else{
                c = c.childNodes;
                for(var i = 0, j = c.length;i<j;i++) // c nodelist gets smaller.
                    n = apf.xmldb.appendChild( n.parentNode, c[0], n.nextSibling );
                return n;
            }
        }else{
            if(v.length){ //@todo implement this, its an array rhs
                throw new Error(apf.formatErrorString(0,0,"LM Xpath append",
                    "Nodelists not yet supported\nxpath:"+x+"\nvalue:"+v));
            }else{
                if(!v.selectNodes)
                    throw new Error(apf.formatErrorString(0,0,"LM Xpath append",
                        "Cannot assign non-element node\nxpath:"+x+"\nvalue:"+v));

                if(v.nodeType == 2){
                    if(n.nodeType != 1)
                        throw new Error(apf.formatErrorString(0,0,"LM Xpath append",
                            "Cannot append attribute to anything but element node"));

                    apf.xmldb.setAttribute(c = n.ownerElement || n.selectSingleNode(".."),
                        v.nodeName, v.nodeValue);

                    apf.xmldb.removeAttribute(v.ownerElement || v.selectSingleNode(".."),
                        v.nodeName);

                    return c.getAttributeNode(v.nodeName);
                }else
                    return apf.xmldb.appendChild( n.parentNode, v, n.nextSibling );
            }
        }
    }

    function _nods_add(n, m, x, v){ // add nodes
        if(n) v = x, x = m;
        else if(!m || !(n=(m.charAt && ((m.charAt(0)=="<" && xmlParse(m)) ||
            ((n = apf.nameserver.lookup.model[m]) && n.data))) ||
        (m.$isModel?m.data:(m.charAt?0:m))))
            throw new Error(apf.formatErrorString(0,0,"LM Xpath Assign",
                "Cannot append to nonresolving model:"+m+"\nxpath:"+x+"\nvalue:"+v));

        for(var i = 0, j = (n = n.selectNodes(x)).length;i<j;i++)
            _nod_add( n[i], null, v);

        return v;
    }

    function _asn(o, p, v){		// assign propert
        if(!o || typeof(o)!="object")
            throw new Error(apf.formatErrorString(0,0,"LM Property Assign",
                "Cannot assign property on non object, property:"+p));

        if(o.setAttribute)
            o.setAttribute(p,v);
        else
            o[p] = v;
        return v;
    }

    function _add(o, p, v){		// += property
        return _asn(o,p,o && o[p]+v);
    }

    function _sub(o, p, v){		// -= propery
        return _asn(o,p,o && o[p]-v);
    }

    function _div(o, p, v){		// /= property
        return _asn(o,p,o && o[p]/v);
    }

    function _mul(o, p, v){		// *= property
        return _asn(o,p,o && o[p]*v);
    }

    // macro implementations
    function _local(n){			// local(x) for local n
        // check what n is.. if string parse
        if(n && n.charAt && n.charAt(0)=="<")
            return apf.getXmlDom(n).documentElement;
        if(!n && wlvl>1)wnode("-","_local");
        return n;
    }

    function _tagName(n1, n2){	// tagname macro
        return (n2 && n2.tagName) || (n1 && n1.tagName);
    }

    function _localName(n1, n2){	// localname macro
        return (n2 && n2[apf.TAGNAME]) || (n1 && n1[apf.TAGNAME]);
    }

    function _nodeValue(n,n2){		// value of a node, or localnode.
        if(n2) n = n2;
        return (n = (n.nodeType != 1 && n ||
            (n.nodeType != 1 && n || (n = n.firstChild) && n.nodeType!=1 && n))) && n.nodeValue || ""
    }

    // Language processing
    var langrx = /(\\*)\$\[(.*?)\]/g;
    var lang = apf.language;

	apf.$lm_has_lang = 0;

    function _lngrx(tok,esc,x){	// language replacement regex callback
        apf.$lm_has_lang = 1;
		if(esc)
			return "$["+x+"]";
         return lang.words[x] || (wlvl>1&&wlang(x,"_lngrx"),"");
    }

    function __ret(r){			// return function, translates $[lang] things in data
        if(r && r.indexOf && r.indexOf("$[")!=-1)
            return r.replace(langrx, _lngrx);
        return r;
    }

    function __lng(x,x2){			// the language macro
        apf.$lm_has_lang = 1;
        return lang.words[x] || (wlvl>1&&wlang(x,"_lng"),"");
    }

    function _lnged(x,x2){			// editable language macro
        apf.$lm_has_lang = 1;
        return lang.words[x] || (wlvl>1&&wlang(x,"_lnged"),"");
    }

    function _injself(s){			// self inject helper func
        return s.charAt?s.replace(selfrx, "$1self::"):s;
    }

	apf.$lmx = null;

    function _async(_n,_c,_a,_w,_f,_this,obj,func,args){ // Async handling
        var i = _a.i, v;

        if(!_a.ret)_a.ret = [];

        if (_a[i])
            return _a.ret[i];

        _a[i] = true;   // flag this ID so args dont get computed again

        if (!obj.exec)
            return  _a.ret[i]=(func)?obj[func].apply(obj,args):obj.apply(obj,args);
		
        if(_w && _w._pc){
            _w._pc = {
                obj:obj,
                func: func,
                args:args,
                _c:_c
            };
        }else{
            obj.exec(func,args,function(data, state, extra){
                if (state!= apf.SUCCESS){
                    _c(null, state, extra);
                }else{
					apf.$lmx = extra;
                    _a.ret[i] = data;

                    if (_w)
                        _f.call(_this,_n,_c,_w,_a);
                    else
                        _f.call(_this,_n,_c,_a);
                }
            });
        }
        throw({
            x:1
        });
    }

    function _pc(_w){ // precall
        var o;
        if(typeof(o = _w._pc) != "object" || !o)
            return;

        o.obj.exec(o.func,o.args, o._c);

        throw({x:1});
    }

    this.compile = function(code){
        // up-scope much used functions (see if it helps?)
        var _ret = __ret, _val = __val,_valm = __valm, _nod = __nod,
        _nodm = __nodm, _cnt = __cnt, _cntm = __cntm, _lng = __lng;
        eval(code);
        return _f;
    }
})();


/*FILEHEAD(/var/lib/platform/source/trunk/core/parsers/url.js)SIZE(4451)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Object that represents a URI, broken down to its parts, according to RFC3986.
 * All parts are publicly accessible after parsing like 'url.port' or 'url.host'.
 * Example:
 * <code>
 *   var url = new apf.url('http://usr:pwd@www.test.com:81/dir/dir.2/index.htm?q1=0&&test1&test2=value#top');
 *   alert(url.port); //will show '81'
 *   alert(url.host); //will show 'www.test.com'
 *   alert(url.isSameLocation()) // will show 'true' when the browser is surfing on the www.test.com domain
 *
 * </code>
 *
 * @see http://tools.ietf.org/html/rfc3986
 * @constructor
 * @parser
 * @default_private
 *
 * @author      Mike de Boer
 * @version     %I%, %G%
 * @since       1.0
 */
apf.url = function(str) {
    var base;
    if (str.indexOf(":") == -1 && (base = location.toString()).indexOf(":") != -1) {
        base = new apf.url(base);
        str = apf.getAbsolutePath(base.protocol + "://" + base.host + "/"
            + (base.directory.charAt(base.directory.length - 1) == "/"
                 ? base.directory
                 : base.directory + '/'), str).replace(/\/\/\/\//, "///");
    }
    var o    = apf.url.options,
    m        = o.parser[o.strictMode ? "strict" : "loose"].exec(str),
    i        = 14;
    this.uri = str.toString(); //copy string

    while (i--)
        this[o.key[i]] = m[i] || "";

    this[o.q.name] = {};
    var _self = this;
    this[o.key[12]].replace(o.q.parser, function($0, $1, $2){
        if ($1)
            _self[o.q.name][$1] = $2;
    });

    /**
     * Checks if the same origin policy is in effect for this URI.
     * @see http://developer.mozilla.org/index.php?title=En/Same_origin_policy_for_JavaScript
     *
     * @returns {Boolean}
     */
    this.isSameLocation = function(){
        // filter out anchors
        if (this.uri.length && this.uri.charAt(0) == "#")
            return false;
        // totally relative -- ../../someFile.html
        if (!this.protocol && !this.port && !this.host)
            return true;

        // scheme relative with port specified -- foo.com:8080
        if (!this.protocol && this.host && this.port
          && window.location.hostname == this.host
          && window.location.port     == this.port) {
            return true;
        }
        // scheme relative with no-port specified -- foo.com
        if (!this.protocol && this.host && !this.port
          && window.location.hostname == this.host
          && window.location.port     == 80) {
            return true;
        }
        return window.location.protocol == (this.protocol + ":")
            && window.location.hostname == this.host
            && (window.location.port    == this.port || !window.location.port && !this.port);
    }
};

apf.url.options = {
    strictMode: false,
    key: ["source", "protocol", "authority", "userInfo", "user", "password",
          "host", "port", "relative", "path", "directory", "file", "query",
          "anchor"],
    q  : {
        name  : "queryKey",
        parser: /(?:^|&)([^&=]*)=?([^&]*)/g
    },
    parser: {
        strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
        loose : /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    }
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/parsers/xpath.js)SIZE(21925)TIME(1265038748)*/


/**
 * @private
 */
apf.runXpath = function(){

/**
 *    Workaround for the lack of having an XPath parser on safari.
 *    It works on Safari's document and XMLDocument object.
 *
 *    It doesn't support the full XPath spec, but just enought for
 *    the skinning engine which needs XPath on the HTML document.
 *
 *    Supports:
 *    - Compilation of xpath statements
 *    - Caching of XPath statements
 *
 * @parser
 * @private
 */
apf.XPath = {
    cache : {},

    getSelf : function(htmlNode, tagName, info, count, num, sResult){
        var numfound = 0, result = null, data = info[count];

        if (data)
            data[0](htmlNode, data[1], info, count + 1, numfound++ , sResult);
        else
            sResult.push(htmlNode);
    },

    getChildNode : function(htmlNode, tagName, info, count, num, sResult){
        var numfound = 0, result = null, data = info[count];

        var nodes = htmlNode.childNodes;
        if (!nodes) return; //Weird bug in Safari
        for (var i = 0; i < nodes.length; i++) {
            //if (nodes[i].nodeType != 1)
                //continue;

            if (tagName && (tagName != nodes[i].tagName) && (nodes[i].style
              ? nodes[i].tagName.toLowerCase()
              : nodes[i].tagName) != tagName)
                continue;// || numsearch && ++numfound != numsearch
            
            htmlNode = nodes[i];

            if (data)
                data[0](nodes[i], data[1], info, count + 1, numfound++ , sResult);
            else
                sResult.push(nodes[i]);
        }

        //commented out :  && (!numsearch || numsearch == numfound)
    },

    doQuery : function(htmlNode, qData, info, count, num, sResult){
        var result = null, data = info[count];
        var query = qData[0];
        var returnResult = qData[1];
        try {
            var qResult = eval(query);
        }catch(e){
            //apf.console.error(e.name + " " + e.type + ":" + apf.XPath.lastExpr + "\n\n" + query);
            return;
        }

        if (returnResult)
            return sResult.push(qResult);
        if (!qResult || qResult.dataType == apf.ARRAY && !qResult.length) 
            return;

        if (data)
            data[0](htmlNode, data[1], info, count + 1, 0, sResult);
        else
            sResult.push(htmlNode);
    },

    getTextNode : function(htmlNode, empty, info, count, num, sResult){
        var data  = info[count],
            nodes = htmlNode.childNodes;

        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].nodeType != 3 && nodes[i].nodeType != 4)
                continue;

            if (data)
                data[0](nodes[i], data[1], info, count + 1, i, sResult);
            else
                sResult.push(nodes[i]);
        }
    },

    getAnyNode : function(htmlNode, empty, info, count, num, sResult){
        var data  = info[count],
            nodes = htmlNode.getElementsByTagName("*");//childNodes;

        for (var i = 0; i < nodes.length; i++) {
            if (data)
                data[0](nodes[i], data[1], info, count + 1, i, sResult);
            else
                sResult.push(nodes[i]);
        }
    },

    getAttributeNode : function(htmlNode, attrName, info, count, num, sResult){
        if (!htmlNode || htmlNode.nodeType != 1) return;

        if (attrName == "*") {
            var nodes = htmlNode.attributes;
            for (var i = 0; i < nodes.length; i++) {
                arguments.callee.call(this, htmlNode, nodes[i].nodeName, info,
                    count, i, sResult);
            }
            return;
        }

        var data = info[count],
            value = htmlNode.getAttributeNode(attrName);//htmlNode.attributes[attrName];//

        if (data)
            data[0](value, data[1], info, count + 1, 0, sResult);
        else if (value)
            sResult.push(value);
    },

    getAllNodes : function(htmlNode, x, info, count, num, sResult){
        var data = info[count],
            tagName  = x[0],
            inclSelf = x[1],
            prefix   = x[2],
            nodes, i, l;

        if (inclSelf && (htmlNode.tagName == tagName || tagName == "*")) {
            if (data)
                data[0](htmlNode, data[1], info, count + 1, 0, sResult);
            else
                sResult.push(htmlNode);
        }

        if (tagName == "node()") {
            tagName = "*";
            prefix = "";
            if (apf.isIE) {
                nodes = htmlNode.getElementsByTagName("*");
            }
            else {
                nodes = [];
                (function recur(x){
                    for (var n, i = 0; i < x.childNodes.length; i++) {
                        n = x.childNodes[i];
                        if (n.nodeType != 1)
                            continue;
                        nodes.push(n);
                        
                        recur(n);
                    }
                })(htmlNode);
            }
        }
        else {
            nodes = htmlNode.getElementsByTagName((prefix
              && (apf.isGecko || apf.isOpera || htmlNode.nodeFunc) ? prefix + ":" : "") + tagName);
        }

        for (i = 0, l = nodes.length; i < l; i++) {
            if (data)
                data[0](nodes[i], data[1], info, count + 1, i, sResult);
            else
                sResult.push(nodes[i]);
        }
    },

    getAllAncestorNodes : function(htmlNode, x, info, count, num, sResult){
        var data = info[count],
            tagName  = x[0],
            inclSelf = x[1],
            i        = 0,
            s        = inclSelf ? htmlNode : htmlNode.parentNode;
        while (s && s.nodeType == 1) {
            if (s.tagName == tagName || tagName == "*" || tagName == "node()") {
                if (data)
                    data[0](s, data[1], info, count + 1, ++i, sResult);
                else
                    sResult.push(s);
            }
            s = s.parentNode
        }
    },

    getParentNode : function(htmlNode, empty, info, count, num, sResult){
        var data = info[count],
            node = htmlNode.parentNode;

        if (data)
            data[0](node, data[1], info, count + 1, 0, sResult);
        else if (node)
            sResult.push(node);
    },

    //precsiblg[3] might not be conform spec
    getPrecedingSibling : function(htmlNode, tagName, info, count, num, sResult){
        var data = info[count],
            node = htmlNode.previousSibling;

        while (node) {
            if (tagName != "node()" && (node.style
              ? node.tagName.toLowerCase()
              : node.tagName) != tagName){
                node = node.previousSibling;
                continue;
            }

            if (data)
                data[0](node, data[1], info, count+1, 0, sResult);
            else if (node) {
                sResult.push(node);
                break;
            }
        }
    },

    //flwsiblg[3] might not be conform spec
    getFollowingSibling : function(htmlNode, tagName, info, count, num, sResult){
        var result = null, data = info[count];

        var node = htmlNode.nextSibling;
        while (node) {
            if (tagName != "node()" && (node.style
              ? node.tagName.toLowerCase()
              : node.tagName) != tagName) {
                node = node.nextSibling;
                continue;
            }

            if (data)
                data[0](node, data[1], info, count+1, 0, sResult);
            else if (node) {
                sResult.push(node);
                break;
            }
        }
    },

    multiXpaths : function(contextNode, list, info, count, num, sResult){
        for (var i = 0; i < list.length; i++) {
            info = list[i][0];
            var rootNode = (info[3]
                ? contextNode.ownerDocument.documentElement
                : contextNode);//document.body
            info[0](rootNode, info[1], list[i], 1, 0, sResult);
        }

        sResult.makeUnique();
    },

    compile : function(sExpr){
        var isAbsolute = sExpr.match(/^\//);//[^\/]/

        sExpr = sExpr.replace(/\[(\d+)\]/g, "/##$1")
            .replace(/\|\|(\d+)\|\|\d+/g, "##$1")
            .replace(/\.\|\|\d+/g, ".")
            .replace(/\[([^\]]*)\]/g, function(match, m1){
                return "/##" + m1.replace(/\|/g, "_@_");
            }); //wrong assumption think of |

        if (sExpr == "/" || sExpr == ".")
            return sExpr;

        //Mark // elements
        //sExpr = sExpr.replace(/\/\//g, "/[]/self::");

        //Check if this is an absolute query
        return this.processXpath(sExpr.replace(/\/\//g, "descendant::"), isAbsolute);
    },

    processXpath : function(sExpr, isAbsolute){
        var results = [],
            i, l, m, query;
        sExpr = sExpr.replace(/'[^']*'/g, function(m){
            return m.replace("|", "_@_");
        });

        sExpr = sExpr.split("\|");
        for (i = 0, l = sExpr.length; i < l; i++)
            sExpr[i] = sExpr[i].replace(/_\@\_/g, "|");//replace(/('[^']*)\_\@\_([^']*')/g, "$1|$2");

        if (sExpr.length == 1) {
            sExpr = sExpr[0];
        }
        else {
            for (i = 0, l = sExpr.length; i < l; i++)
                sExpr[i] = this.processXpath(sExpr[i]);
            results.push([this.multiXpaths, sExpr]);
            return results;
        }

        var sections   = sExpr.split("/");
        for (i = 0, l = sections.length; i < l; i++) {
            if (sections[i] == "." || sections[i] == "")
                continue;
            else if (sections[i] == "..")
                results.push([this.getParentNode, null]);
            else if (sections[i].match(/^[\w-_\.]+(?:\:[\w-_\.]+){0,1}$/))
                results.push([this.getChildNode, sections[i]]);//.toUpperCase()
            else if (sections[i].match(/^\#\#(\d+)$/))
                results.push([this.doQuery, ["num+1 == " + parseInt(RegExp.$1)]]);
            else if (sections[i].match(/^\#\#(.*)$/)) {
                //FIX THIS CODE
                query = RegExp.$1;
                m     = [query.match(/\(/g), query.match(/\)/g)];
                if (m[0] || m[1]) {
                    while (!m[0] && m[1] || m[0] && !m[1]
                      || m[0].length != m[1].length){
                        if (!sections[++i]) break;
                        query += "/" + sections[i];
                        m = [query.match(/\(/g), query.match(/\)/g)];
                    }
                }

                results.push([this.doQuery, [this.compileQuery(query)]]);
            }
            else if (sections[i] == "*")
                results.push([this.getChildNode, null]); //FIX - put in def function
            else if (sections[i].substr(0,2) == "[]")
                results.push([this.getAllNodes, ["*", false]]);//sections[i].substr(2) ||
            else if (sections[i].match(/descendant-or-self::node\(\)$/))
                results.push([this.getAllNodes, ["*", true]]);
            else if (sections[i].match(/descendant-or-self::([^\:]*)(?:\:(.*)){0,1}$/))
                results.push([this.getAllNodes, [RegExp.$2 || RegExp.$1, true, RegExp.$1]]);
            else if (sections[i].match(/descendant::([^\:]*)(?:\:(.*)){0,1}$/))
                results.push([this.getAllNodes, [RegExp.$2 || RegExp.$1, false, RegExp.$1]]);
            else if (sections[i].match(/ancestor-or-self::([^\:]*)(?:\:(.*)){0,1}$/))
                results.push([this.getAllAncestorNodes, [RegExp.$2 || RegExp.$1, true, RegExp.$1]]);
            else if (sections[i].match(/ancestor::([^\:]*)(?:\:(.*)){0,1}$/))
                results.push([this.getAllAncestorNodes, [RegExp.$2 || RegExp.$1, false, RegExp.$1]]);
            else if (sections[i].match(/^\@(.*)$/))
                results.push([this.getAttributeNode, RegExp.$1]);
            else if (sections[i] == "text()")
                results.push([this.getTextNode, null]);
            else if (sections[i] == "node()")
                results.push([this.getChildNode, null]);//FIX - put in def function
            else if (sections[i].match(/following-sibling::(.*)$/))
                results.push([this.getFollowingSibling, RegExp.$1.toLowerCase()]);
            else if (sections[i].match(/preceding-sibling::(.*)$/))
                results.push([this.getPrecedingSibling, RegExp.$1.toLowerCase()]);
            else if (sections[i] == "self::node()")
                results.push([this.getSelf, null]);
            else if (sections[i].match(/self::(.*)$/))
                results.push([this.doQuery, ["apf.XPath.doXpathFunc(htmlNode, 'local-name') == '" + RegExp.$1 + "'"]]);
            else {
                //@todo FIX THIS CODE
                //add some checking here
                query = sections[i];
                m     = [query.match(/\(/g), query.match(/\)/g)];
                if (m[0] || m[1]) {
                    while (!m[0] && m[1] || m[0] && !m[1] || m[0].length != m[1].length) {
                        if (!sections[++i]) break;
                        query += "/" + sections[i];
                        m = [query.match(/\(/g), query.match(/\)/g)];
                    }
                }

                results.push([this.doQuery, [this.compileQuery(query), true]])

                //throw new Error("---- APF Error ----\nMessage : Could not match XPath statement: '" + sections[i] + "' in '" + sExpr + "'");
            }
        }

        results[0][3] = isAbsolute;
        return results;
    },

    compileQuery : function(code){
        return new apf.CodeCompilation(code).compile();
    },

    doXpathFunc : function(contextNode, type, nodelist, arg2, arg3, xmlNode){
        if (!nodelist || nodelist.length == 0)
            nodelist = "";

        if (type == "not")
            return !nodelist;

        var arg1, i, l;
        if (typeof nodelist == "object" || nodelist.dataType == apf.ARRAY) {
            if (nodelist && !nodelist.length)
                nodelist = [nodelist];
            
            var res = false, value;
            for (i = 0, l = nodelist.length; i < l; i++) {
                xmlNode = nodelist[i];
                if (!xmlNode || typeof xmlNode == "string") {
                    value = xmlNode;
                }
                else {
                    if (xmlNode.nodeType == 1 && xmlNode.firstChild && xmlNode.firstChild.nodeType != 1)
                        xmlNode = xmlNode.firstChild;
                    value = xmlNode.nodeValue;
                }

                if (res = arguments.callee.call(this, contextNode, type, value, arg2, arg3, xmlNode))
                    return res;
            }
            return res;
        }
        else {
            arg1 = nodelist;
        }

        switch(type){
            case "position":
                return apf.getChildNumber(contextNode) + 1;
            case "format-number":
                return apf.formatNumber(arg1); //@todo this should actually do something
            case "floor":
                return Math.floor(arg1);
            case "ceiling":
                return Math.ceil(arg1);
            case "starts-with":
                return arg1 ? arg1.substr(0, arg2.length) == arg2 : false;
            case "string-length":
                return arg1 ? arg1.length : 0;
            case "count":
                return arg1 ? arg1.length : 0;
            case "last":
                return arg1 ? arg1[arg1.length-1] : null;
            case "local-name":
                return (xmlNode ? xmlNode.tagName : contextNode.tagName).split(":").pop();//[apf.TAGNAME]
            case "substring":
                return arg1 && arg2 ? arg1.substring(arg2, arg3 || 0) : "";
            case "contains":
                return arg1 && arg2 ? arg1.indexOf(arg2) > -1 : false;
            case "concat":
                var str = ""
                for (i = 1, l = arguments.length; i < l; i++) {
                    if (typeof arguments[i] == "object") {
                        str += getNodeValue(arguments[i][0]);
                        continue;
                    }
                    str += arguments[i];
                }
                return str;
            case "translate":
                for (i = 0, l = arg2.length; i < l; i++)
                    arg1 = arg1.replace(arg2.substr(i,1), arg3.substr(i,1));
                return arg1;
        }
    },

    selectNodeExtended : function(sExpr, contextNode, match){
        var sResult = this.selectNodes(sExpr, contextNode);

        if (sResult.length == 0)
            return null;
        if (!match)
            return sResult;

        for (var i = 0, l = sResult.length; i < l; i++) {
            if (getNodeValue(sResult[i]) == match)
                return [sResult[i]];
        }

        return null;
    },
    
    getRoot : function(xmlNode){
        while (xmlNode.parentNode && xmlNode.parentNode.nodeType == 1)
            xmlNode = xmlNode.parentNode;
        
        return xmlNode;
    },

    selectNodes : function(sExpr, contextNode){
        if (!this.cache[sExpr])
            this.cache[sExpr] = this.compile(sExpr);

        
        if (sExpr.length > 20) {
            this.lastExpr    = sExpr;
            this.lastCompile = this.cache[sExpr];
        }
        
        
        if (typeof this.cache[sExpr] == "string"){
            if (this.cache[sExpr] == ".")
                return [contextNode];
            if (this.cache[sExpr] == "/") {
                return [(contextNode.nodeType == 9
                    ? contextNode.documentElement
                    : this.getRoot(contextNode))];
            }
        }

        if (typeof this.cache[sExpr] == "string" && this.cache[sExpr] == ".")
            return [contextNode];

        var info     = this.cache[sExpr][0],
            rootNode = (info[3]
                ? (contextNode.nodeType == 9
                    ? contextNode.documentElement
                    : this.getRoot(contextNode))
                : contextNode),//document.body*/
            sResult  = [];

        info[0](rootNode, info[1], this.cache[sExpr], 1, 0, sResult);

        return sResult;
    }
};

function getNodeValue(sResult){
    if (sResult.nodeType == 1)
        return sResult.firstChild ? sResult.firstChild.nodeValue : "";
    if (sResult.nodeType > 1 || sResult.nodeType < 5)
        return sResult.nodeValue;
    return sResult;
}

/**
 * @constructor
 * @private
 */
apf.CodeCompilation = function(code){
    this.data = {
        F : [],
        S : [],
        I : [],
        X : []
    };

    this.compile = function(){
        code = code.replace(/ or /g, " || ")
            .replace(/ and /g, " && ")
            .replace(/!=/g, "{}")
            .replace(/=/g, "==")
            .replace(/\{\}/g, "!=");

        // Tokenize
        this.tokenize();

        // Insert
        this.insert();
        
        code = code.replace(/, \)/g, ", htmlNode)");

        return code;
    };

    this.tokenize = function(){
        //Functions
        var data = this.data.F;
        code = code.replace(/(translate|format-number|contains|substring|local-name|last|position|round|starts-with|string|string-length|sum|floor|ceiling|concat|count|not)\s*\(/g,
            function(d, match){
                return (data.push(match) - 1) + "F_";
            }
        );

        //Strings
        data = this.data.S;
        code = code.replace(/'([^']*)'/g, function(d, match){
                return (data.push(match) - 1) + "S_";
            })
            .replace(/"([^"]*)"/g, function(d, match){
                return (data.push(match) - 1) + "S_";
            });

        //Xpath
        data = this.data.X;
        code = code.replace(/(^|\W|\_)([\@\.\/A-Za-z\*][\*\.\@\/\w\-]*(?:\(\)){0,1})/g,
            function(d, m1, m2){
                return m1 + (data.push(m2) - 1) + "X_";
            })
            .replace(/(\.[\.\@\/\w]*)/g, function(d, m1, m2){
                return (data.push(m1) - 1) + "X_";
            });

        //Ints
        data = this.data.I;
        code = code.replace(/(\d+)(\W)/g, function(d, m1, m2){
            return (data.push(m1) - 1) + "I_" + m2;
        });
    };

    this.insert = function(){
        var data = this.data;
        code = code.replace(/(\d+)X_\s*==\s*(\d+S_)/g, function(d, nr, str){
                return "apf.XPath.selectNodeExtended('"
                    +  data.X[nr].replace(/'/g, "\\'") + "', htmlNode, " + str + ")";
            })
            .replace(/(\d+)([FISX])_/g, function(d, nr, type){
                var value = data[type][nr];

                if (type == "F") {
                    return "apf.XPath.doXpathFunc(htmlNode, '" + value + "', ";
                }
                else if (type == "S") {
                    return "'" + value + "'";
                }
                else if (type == "I") {
                    return value;
                }
                else if (type == "X") {
                    return "apf.XPath.selectNodeExtended('"
                        + value.replace(/'/g, "\\'") + "', htmlNode)";
                }
            })
            .replace(/, \)/g, ")");
    };
};

}



/*FILEHEAD(/var/lib/platform/source/trunk/core/debug/profiler.js)SIZE(24827)TIME(1265032027)*/




/*FILEHEAD(/var/lib/platform/source/trunk/core/debug/debug.js)SIZE(9707)TIME(1258118722)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Returns a string giving information on a javascript object.
 *
 * @param {mixed} obj the object to investigate
 */
apf.dump2 =
apf.vardump2 = function(obj, depth, norecur, stack){
    if (apf.isWebkit) //@todo RIK please fix this issue.
        return "";
    
    if (!obj) return obj + "";
    if (!stack)stack = "";
    if (!depth) depth = 0;

    var str;
    switch (obj.dataType) {
        case apf.STRING:
            return "\"" + obj + "\"";
        case apf.NUMBER:
            return obj;
        case apf.BOOLEAN:
            return (obj ? "true" : "false");
        case apf.DATE:
            return "Date(\"" + obj + "\)";
        case apf.ARRAY:
            if(obj[obj.length-2]=='$__vardump'){
                return "this"+obj[obj.length-1]; 
            }
            obj.push('$__vardump',stack);
            str = ["[ "];
            for (var i = 0; i < obj.length-2; i++) {
                str.push( str.length>1?",":"",
                    (norecur && depth > 0 ? "{/*"+typeof(obj[i])+"*/}" :
                    apf.vardump2(obj[i], depth + 1, norecur, stack+'['+i+']')) );
            }
            str.push( " ]");
            obj.pop();obj.pop();
            return str.join('');
        default:
            if (typeof obj == "function")
                return "{/*function*/}";
            if (obj.nodeType !== undefined && obj.style && depth != 0)
                return "{/*HTML Element: " + obj.tagName + "*/}";
            if (obj.nodeType !== undefined)
                return "{/*XML Element : " + obj.tagName + "*/}";
                //return depth == 0 ? "[ " + (obj.xml || obj.serialize()) + " ]" : "XML Element";
            if (norecur && depth > 0)
                return "{/*object/*}";

            //((typeof obj[prop]).match(/(function|object)/) ? RegExp.$1 : obj[prop])
            if (obj['$__vardump']) return "this"+obj['$__vardump']+"";
            obj['$__vardump'] = stack;
            str = ["{\n"];
            
            for (var prop in obj) if(prop!='$__vardump'){
                try {
                    var propname = (parseInt(prop)==prop)?"0x"+("00000000"+parseInt(prop).toString(16)).slice(-8):prop;
                    if(str.length>1)str.push(",\n");
                    str.push( "\t".repeat(depth+1), propname, ": ",
                      (norecur && depth > 0 ? "{/*"+typeof(obj[prop])+"*/}":
                        apf.vardump2(obj[prop], depth + 1, norecur, stack+'.'+prop)) );
                } catch(e) {
                    str.push( "\t".repeat(depth+1) , prop , ": null /*ERROR*/");
                }
            }
            str.push( "\n", ("\t".repeat(depth)), "}");
            
            function cleanup(obj){
                if(!obj['$__vardump'])return;
                delete obj['$__vardump'];
                for(var prop in obj){
                    var v = obj[prop];
                    if(typeof(v)=='object')cleanup(obj);
                }
            }
            
            //if(depth==0)
            cleanup(obj);
            
            return str.join('');
    }
};

if (apf.isOpera) {
    window.console = {};
    ["log", "debug", "info", "warn", "error"].forEach(function(type) {
        window.console[type] = function() {
            if (typeof arguments === "undefined") return null;
            if (arguments.length === 1) { // single argument provided
                opera.postError(type + ": " + arguments[0]);
                return type + ": " + arguments[0];
            }
            var s      = arguments[0],
                // string substitution patterns of firebug console
                regexp = /%([sdifo])/g,
                i      = 0,
                match  = null;
            // replace found matches with given arguments
            while (match = regexp.exec(s)) {
                s = s.replace(match[0], String(arguments[++i]));
            }
            // display log messages
            var len = arguments.length;
            while (len > i++) {
                if (arguments[i]) {
                    s += ' ';
                    s += String(arguments[i]);
                }
            }
            opera.postError(type + ": " + s);
        };
    });
}

/**
 * Returns a string giving more detailed informations on a javascript object.
 *
 * @param {mixed} obj the object to investigate
 */
apf.dump =
apf.vardump = function (obj, depth, recur, stack){
    if(!obj) return obj + "";
    if(!depth) depth = 0;

    switch(obj.dataType){
        case "string":    return "\"" + obj + "\"";
        case "number":    return obj;
        case "boolean": return obj ? "true" : "false";
        case "date": return "Date[" + new Date() + "]";
        case "array":
            var str = "{\n";
            for(var i=0;i < obj.length;i++){
                str += "     ".repeat(depth+1) + i + " => " + (!recur && depth > 0 ? typeof obj[i] : apf.vardump(obj[i], depth+1, !recur)) + "\n";
            }
            str += "     ".repeat(depth) + "}";
            
            return str;
        default:
            if(typeof obj == "function") return "function";
            //if(obj.xml) return depth==0 ? "[ " + obj.xml + " ]" : "XML Element";
            if(obj.xml || obj.serialize) return depth==0 ? "[ " + (obj.xml || obj.serialize()) + " ]" : "XML Element";
            
            if(!recur && depth>0) return "object";
        
            //((typeof obj[prop]).match(/(function|object)/) ? RegExp.$1 : obj[prop])
            var str = "{\n";
            for(prop in obj){
                try{
                    str += "     ".repeat(depth+1) + prop + " => " + (!recur && depth > 0? typeof obj[prop] : apf.vardump(obj[prop], depth+1, !recur)) + "\n";
                }catch(e){
                    str += "     ".repeat(depth+1) + prop + " => [ERROR]\n";
                }
            }
            str += "     ".repeat(depth) + "}";
            
            return str;
    }
}

String.prototype.s = function(){
    return this.replace(/[\r\n]/g, "");
}

/**
 * Alerts string giving information on a javascript object.
 * This is older version of this function
 *
 * @param {mixed} obj the object to investigate
 */
apf.alert_r = function(obj, recur){
    alert(apf.vardump(obj, null, recur));
}

/**
 * Alerts string giving information on a javascript object.
 *
 * @param {mixed} obj the object to investigate
 */
apf.alert_r2 = function(obj, recur){
    alert(apf.vardump2(obj, null, !recur));
}

/**
 * Object timing the time between one point and another.
 *
 * @param {Boolean} nostart whether the profiler should start measuring at creation.
 * @constructor
 */
apf.ProfilerClass = function(nostart){
    this.totalTime = 0;

    /**
     * Starts the timer.
     * @param {Boolean} clear resets the total time.
     */
    this.start = function(clear){
        if (clear) this.totalTime = 0;
        this.startTime = new Date().getTime();

        this.isStarted = true;
    }

    /**
     * Stops the timer.
     * @method
     */
    this.stop =
    this.end = function(){
        if (!this.startTime) return;
        this.totalTime += new Date().getTime() - this.startTime;
        this.isStarted = false;
    }

    /**
     * Sends the total time to the console.
     * @param {String} msg Message displayed in the console.
     */
    this.addPoint = function(msg){
        this.end();
        apf.console.time("[TIME] " + (msg || "Profiled Section") + ": " + this.totalTime + "ms");
        this.start(true);
    }

    if (!nostart)
        this.start();
};

apf.Latometer = new apf.ProfilerClass(true);//backward compatibility

if (self.navigator && navigator.userAgent.indexOf("Opera") != -1) {
    window.console = {};
    ["log", "debug", "info", "warn", "error"].forEach(function(type) {
        window.console[type] = function() {
            if (typeof arguments === "undefined") return null;
            if (arguments.length === 1) { // single argument provided
                opera.postError(type + ": " + arguments[0]);
                return type + ": " + arguments[0];
            }
            var s      = arguments[0],
                // string substitution patterns of firebug console
                regexp = /%([sdifo])/g,
                i      = 0,
                match  = null;
            // replace found matches with given arguments
            while (match = regexp.exec(s)) {
                s = s.replace(match[0], String(arguments[++i]));
            }
            // display log messages
            var len = arguments.length;
            while (len > i++) {
                if (arguments[i]) {
                    s += ' ';
                    s += String(arguments[i]);
                }
            }
            opera.postError(type + ": " + s);
        };
    });
}




/*FILEHEAD(/var/lib/platform/source/trunk/core/debug/debugwin.js)SIZE(76998)TIME(1263340864)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.DebugInfoStack = [];

Function.prototype.toHTMLNode = function(highlight){
    var code, line1, line2;

    TYPE_OBJECT     = "object";
    TYPE_NUMBER     = "number";
    TYPE_STRING     = "string";
    TYPE_ARRAY      = "array";
    TYPE_DATE       = "date";
    TYPE_REGEXP     = "regexp";
    TYPE_BOOLEAN    = "boolean";
    TYPE_FUNCTION   = "function";
    TYPE_DOMNODE    = "dom node";
    TYPE_APFNODE    = "APF Element";

    STATE_UNDEFINED = "undefined";
    STATE_NULL      = "null";
    STATE_NAN       = "nan";
    STATE_INFINITE  = "infinite";

    /**
     * @private
     */
    function getType(variable){
        if (variable === null)
            return STATE_NULL;
        if (variable === undefined)
            return STATE_UNDEFINED;
        if (typeof variable == "number" && isNaN(variable))
            return STATE_NAN;
        if (typeof variable == "number" && !isFinite(variable))
            return STATE_INFINITE;


        if (typeof variable == "object") {
            if (variable.hasFeature)
                return TYPE_APFNODE;
            if (variable.tagName || variable.nodeValue)
                return TYPE_DOMNODE;
        }

        if (typeof variable.dataType == "undefined")
            return TYPE_OBJECT;

        return variable.dataType;
    }

    //anonymous
    code         = this.toString();
    var endLine1 = code.indexOf("\n");
    line1        = code.slice(0, endLine1);
    line2        = code.slice(endLine1+1);

    var res      = /^function(\s+(.*?)\s*|\s*?)\((.*)\)(.*)$/.exec(line1);
    if (res) {
        var name = res[1];
        var args = res[3];
        var last = res[4]; //NOT USED?

        if (this.arguments) {
            var argName, namedArgs = args.split(",");
            args = [];

            for (var i = 0; i < this.arguments.length; i++) {
                //if(i != 0 && arr[i]) args += ", ";
                argName  = (namedArgs[i] || "NOT_NAMED").trim();// args += "<b>" + arr[i] + "</b>";

                var info = ["Name: " + argName];
                var id   = apf.DebugInfoStack.push(info) - 1;

                args.push("<a href='javascript:void(0)' onclick='alert(apf.DebugInfoStack["
                    + id + "].join(\"\\n\"));event.cancelBubble=true;'>" + argName + "</a>");
                info.push("Type: " + getType(this.arguments[i]));
                
                //@todo fix this
                //info.push("Value: " + apf.vardump(this.arguments[i], null, false));
            }
        }
        else if (apf.isGecko) {
            args = args.splitSafe(",");
            var result = [];
            var argName;
            for (var i = 0; i < args.length; i++) {
                var firstChar = args[i].charAt(0);
                
                if (firstChar == "[")
                    argName = "object";
                else if (firstChar == '"')
                    argName = "string";
                else if (firstChar == 't' || firstChar == 'f')
                    argName = "boolean";
                else 
                    argName = "number";    
                
                var info = ["Type: " + argName];
                var id   = apf.DebugInfoStack.push(info) - 1;

                result.push("<a href='javascript:void(0)' onclick='alert(apf.DebugInfoStack["
                    + id + "].join(\"\\n\"));event.cancelBubble=true;'>" + argName + "</a>");
                info.push("Value: " + apf.vardump(args[i], null, false));
            }
            
            args = result;
        }

        line2 = line2.replace(/\{/ , "");
        line2 = line2.substr(0, line2.length-2);

        if (!highlight) {
            //fine common start whitespace count
            line2 = apf.debugwin.outdent(line2);
            line2 = line2.replace(/ /g, "&nbsp;");
            line2 = line2.replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;");
            line2 = line2.replace(/\n/g, "</nobr><br><nobr>&nbsp;&nbsp;&nbsp;&nbsp;");
            line2 = "{<br><nobr>&nbsp;&nbsp;&nbsp;" + line2 + "</nobr><br>}";
        }
        else {
            line2 = "{\n" + line2 + "\n}\n";
            var div = dp.SyntaxHighlighter.HighlightString(line2, false, false);
        }

        var d = document.createElement("div");
        res   = "<div>\
            <div style='padding:0px 0px 2px 0px;cursor:default;' onclick=\"\
              var oFirst = this.getElementsByTagName('img')[0];\
              var oLast = this.getElementsByTagName('div')[0];\
              if (oLast.style.display == 'block') {\
                  oLast.style.display = 'none';\
                  oFirst.src='" + apf.debugwin.resPath + "arrow_right.gif';\
              } else {\
                  oLast.style.display = 'block';\
                  oFirst.src='" + apf.debugwin.resPath + "arrow_down.gif';\
              }\
              if (apf.layout)\
                 apf.layout.forceResize(apf.debugwin.$ext);\
              event.cancelBubble=true\">\
                <nobr>"
                      + (this.url
                        ? "<a href='" + this.url + "' target='_blank' style='float:right'>" 
                                + apf.getFilename(this.url) + 
                            " (" + this.line + ")</a>"
                        : "")
                      + "<img width='9' height='9' src='" + apf.debugwin.resPath
                      + "arrow_right.gif' style='margin:0 3px 0 2px;' />"
                      + (name.trim() || "anonymous") + "(" + args.join(", ") + ")&nbsp;\
                </nobr>\
                <div onclick='event.cancelBubble=true' onselectstart='if (apf.dragMode) return false; event.cancelBubble=true' style='\
                  cursor: text;\
                  display: none;\
                  padding: 0px;\
                  background-color: #f6f6f6;\
                  color: #222;\
                  overflow: auto;\
                  margin-top: 2px;'>\
                    <blockquote></blockquote>\
                </div>\
            </div>\
        </div>";
        d.innerHTML = res;
        var b = d.getElementsByTagName("blockquote")[0];

        if (highlight) {
            b.replaceNode(div);
        }
        else {
            b.insertAdjacentHTML("beforeBegin", line2);
            b.parentNode.removeChild(b);
        }

        return d.firstChild;
    }
    else {
        return this.toString();
    }
}

/* *****************
 ** Error Handler **
 *******************/

apf.debugwin = {
    useDebugger  : apf.getcookie("debugger") == "true",
    profileGlobal: apf.getcookie("profileglobal") == "true",
    resPath      : "",
    errorTable   : "debug_panel_errortable",
    contextDiv   : "debug_panel_amlcontext",
    stackTrace   : "debug_panel_stacktrace",//null, //blockquote[0]
    logView      : "jvlnviewlog",
    debugConsole : "apfDebugExpr",
    lmConsole  : "apfLmExpr",
    
    outdent : function(str, skipFirst){
        var lines = str.split("\n");
        for (var min = 1000, m, i = skipFirst ? 1 : 0; i < lines.length; i++) {
            if (!lines[i].trim()) 
                continue;
                
            m = lines[i].match(/^[\s \t]+/);
            if (!m) {
                min = 0;
                break;
            }
            else min = Math.min(min, m[0].length);
        }
        if (min) {
            for (var i = skipFirst ? 1 : 0; i < lines.length; i++) {
                lines[i] = lines[i].substr(min);
            }
        }
        return lines.join("\n");
    },

    init : function(){
        if (apf.getcookie("highlight") == "true" && self.BASEPATH) {
            //<script class="javascript" src="../Library/Core/Highlighter/shCore.uncompressed.js"></script>
            //<script class="javascript" src="../Library/Core/Highlighter/shBrushJScript.js"></script>
            apf.include(BASEPATH + "Library/Core/Highlighter/shCore.uncompressed.js");
            apf.include(BASEPATH + "Library/Core/Highlighter/shBrushJScript.js");
            //<link type="text/css" rel="stylesheet" href="../Library/Core/Highlighter/SyntaxHighlighter.css" />
            apf.loadStylesheet(BASEPATH + "Library/Core/Highlighter/SyntaxHighlighter.css");
        }
        else if (self.SyntaxHighlighterCSS) {
            apf.importCssString(SyntaxHighlighterCSS);
        }
        else {
            apf.setcookie("highlight", false)
        }

        if (!this.useDebugger) {
            apf.debugwin.toggleDebugger(false);
            //window.onerror = apf.debugwin.errorHandler;

            if (apf.isGecko)
                var error = Error;

            if (apf.isOpera || apf.isWebkit || apf.isGecko) {
                self.Error = function(msg){
                    apf.debugwin.errorHandler(msg, location.href, 0);
                }
                self.Error.custom = true;
            }

            if (apf.isGecko) {
                apf.addEventListener("load", function(){
                    self.Error = error;
                });
            }
        }

        if (apf.getcookie("profilestartup") == "true" && !apf.profiler.isRunning) {
            if (this.profileGlobal)
                apf.profiler.init(window, 'window');
            else
                apf.profiler.init(apf, 'apf');
            apf.profiler.start();
        }

        apf.addEventListener("hotkey", function(e){
            if (e.keyCode == 120 || e.ctrlKey && e.altKey && e.keyCode == 68) {
                apf.debugwin.activate();
            }
        })
    },

    hide : function(){
        this.$ext.style.display = "none";
        document.body.style.marginRight = "0";
        
        if (apf.isIE8) {
            document.body.style.overflow = "";
            document.body.style.position = "";
        }
    },
    
    show : function(e, filename, linenr){
        var list = [], seen = {}, i;

        if (apf.loadScreen)
            apf.loadScreen.hide();

        if (!apf.isIE && !apf.isWebkit && !Error.custom) {

            var stack = new Error().stack.split("\n");
            for (i = 0; i < stack.length; i++) {
                stack[i].trim().match(/^([\w_\$]*)(\(.*?\))?@(.*?):(\d+)$/);
                var name = RegExp.$1,
                    args = RegExp.$2,
                    url  = RegExp.$3,
                    line = RegExp.$4;
                
                list.push(Function.prototype.toHTMLNode.call({
                    toString : function(){
                        return "function " + name + (args || "()") + "{\n...\n}";
                    },
                    url : url,
                    line: line
                }));
            }
        }
        else {
            //Opera doesnt support caller... weird...
            try {
                var loop = apf.isIE
                  ? this.show.caller.caller
                  : this.show.caller.caller
                      ? this.show.caller.caller.caller
                      : this.show.caller.caller;
                if (loop) {
                    try {
                        do {
                            if (seen[loop.toString()])
                                break; //recursion checker
                            seen[loop.toString()] = true;
                            //str += loop.toHTML();
                            list.push(loop.toHTMLNode(apf.getcookie("highlight") == "true"));
                            loop = loop.caller;
                        }
                        while (list.length < 30 && loop && loop.caller && loop.caller.caller != loop);
                    }
                    catch(a) {
                        list=[];
                    }
                }
            }
            catch(e){}
        }

        if (apf.isIE8) {
            document.body.style.overflow = "auto";
            //document.body.style.position = "static";
        }
        
        if (!apf.debugwin.win)
            this.createWindow();

        if (e) {
            var parsed = this.formatError(e);
            this.errorTable.innerHTML = parsed.table;
            this.errorTable.parentNode.style.display = "block";
            
            if (parsed.amlcontext.trim()) {
                this.contextDiv.parentNode.style.display = "block";
                this.contextDiv.innerHTML = parsed.amlcontext;
            }
            else
                this.contextDiv.parentNode.style.display = "none";
        }
        else {
            this.errorTable.parentNode.style.display = "none";
            this.contextDiv.parentNode.style.display = "none";
        }
        
        if (list.length) {
            this.stackTrace.innerHTML = "";
            for (i = 0; i < list.length; i++) {
                try{
                    this.stackTrace.appendChild(list[i]);
                }catch(e){}
            }
            
            this.stackTrace.parentNode.style.display = "block";
        }
        else {
            this.stackTrace.parentNode.style.display = "none";
        }

        this.$ext.style.display = "block";
        
        if(apf.layout)
            apf.layout.forceResize(this.$ext);
        
        this.logView.scrollTop = this.logView.scrollHeight;

        //!self.ERROR_HAS_OCCURRED && 
        if (apf.addEventListener)
            apf.addEventListener("debug", this.debugHandler);
    },
    
    debugHandler : function(e){
        if (!apf.debugwin.logView) return;

        apf.debugwin.logView.insertAdjacentHTML("beforeend", e.message);
        apf.debugwin.logView.style.display = "block";
        apf.debugwin.logView.scrollTop     = apf.debugwin.logView.scrollHeight;
    },

    formatError: function(e) {
        var parse         = e.message.split(/\n===\n/),
            amlContext    = apf.highlightXml(parse[1] ? apf.debugwin.outdent(parse[1].trim(true), true).replace(/\t/g, "&nbsp;&nbsp;&nbsp;").replace(/ /g, "&nbsp;") : ""),
                //.replace(/</g, "&lt;").replace(/\n/g, "<br />"),
            errorMessage  = parse[0].replace(/---- APF Error ----\n/g, "")
                .replace(/</g, "&lt;").replace(/Message: \[(\d+)\]/g, "Message: [<a title='Visit the manual on error code $1' style='color:blue;text-decoration:none;' target='_blank' href='http://www.ajax.org#docs/errors/$1'>$1</a>]"),
                //.replace(/(\n|^)([\w ]+:)/gm, "$1<strong>$2</strong>"),//.replace(/\n/g, "<br />"),
            errorTable    = [];

        errorMessage.replace(/(?:([\w ]+):(.*)(?:\n|$)|([\s\S]+))/gi, function(m, m1, m2) {
            if (!errorTable.length)
                errorTable.push("<table border='0' cellpadding='0' cellspacing='0'>");
            if (m1) {
                if (errorTable.length != 1) {
                    errorTable.push("</td></tr>");
                }
                errorTable.push("<tr><td class='debug_error_header'>",
                    m1, ":</td><td>", m2, "</td>", "</tr>");
            }
            else {
                if (errorTable[errorTable.length - 1] != "</tr>")
                    errorTable.push("</td></tr><tr><td>&nbsp;</td>", "<td>");
                else
                    errorTable.push("<tr><td>&nbsp;</td>", "<td>");
                errorTable.push(m);
            }
        });
        errorTable.push("</td></tr></table>");

        return {table: errorTable.join(''), amlcontext: amlContext || ""};
    },

    states      : {},
    setSelected : function(clear){
        var oSelect = document.getElementById("dbgMarkupSelect");

        for (var selected, value = "", i = 0; i < oSelect.childNodes.length; i++) {
            if (oSelect.childNodes[i].selected) {
                value = oSelect.childNodes[i].text;
                selected = oSelect.childNodes[i];
                break;
            }
        }

        if (clear) {
            if (this.lastValue)
                this.states[this.lastValue] = document.getElementById("dbgMarkupInput").value;
            document.getElementById("dbgMarkupInput").value = this.states[value] || "";
        }

        this.lastValue = value;

        if (value.match(/^AML/)) {
            if (dbgMarkup.getModel())
                dbgMarkup.getModel().unregister(dbgMarkup);

            if (selected.value)
                dbgMarkup.load(apf.includeStack[selected.value]);
            else
                dbgMarkup.load(apf.document.documentElement);

            return;
        }

        var xpath = document.getElementById("dbgMarkupInput").value;
        var instruction = value + (value.match(/^#/) ? ":select" : "")
        + (xpath ? ":" + xpath : "");

        apf.setModel(instruction, dbgMarkup);
    },

    exec : function(action){
        if (!action.match(/undo|redo/) && !dbgMarkup.selected)
            return alert("There is no xml element selected. Action not executed");

        switch(action){
            case "remove":
                dbgMarkup.remove(dbgMarkup.selected, true);
                break;
            case "undo":
                dbgMarkup.getActionTracker().undo();
                break;
            case "redo":
                dbgMarkup.getActionTracker().redo();
                break;
            case "textnode":
                dbgMarkup.setTextNode(dbgMarkup.selected, "new value");
                break;
            case "attribute":
                dbgMarkup.setAttributeValue(dbgMarkup.selected, "new", "value");
                break;
        }
    },

    initMarkup : function(oHtml){
        if (!apf.DOMParser)
            return;// alert("Sorry, the depencies for the Data Debugger could not be loaded");

        if (oHtml.getAttribute("inited")) return;
        oHtml.setAttribute("inited", "true");

        /**
         * @todo change the .attribute to be in the debugmarkup namespace
         * @todo fix the edit state
         */
        var skinXml = '\
        <a:skin id="debug" xmlns:a="' + apf.ns.aml + '">\
            <a:markupedit name="debugmarkup">\
                <a:style><![CDATA[\
                    .debugmarkup{\
                        background : url(' + this.resPath + 'splitter_docs.gif) no-repeat 50% bottom;\
                        font-family : Monaco, \'Courier New\';\
                        font-size : 11px;\
                        cursor : default;\
                        padding-bottom : 4px;\
                    }\
                    .debugmarkup blockquote{\
                        margin : 0;\
                        padding : 0px;\
                        overflow : auto;\
                        width : 100%;\
                        height : 100%;\
                        position : relative;\
                        line-height : 1.4em;\
                    }\
                    .debugmarkup dl,\
                    .debugmarkup dt,\
                    .debugmarkup dd{\
                        margin : 0;\
                        display:inline;\
                    }\
                    .debugmarkup dt,\
                    .debugmarkup span{\
                        color : #0000FF;\
                    }\
                    .debugmarkup dt{\
                        cursor : hand;\
                        cursor : pointer;\
                    }\
                    .attribute dl,\
                    .attribute dt,\
                    .attribute dd{\
                        display : inline;\
                    }\
                    #override .debugmarkup .textedit{\
                        background-color : white;\
                        color : black;\
                        border : 1px solid black;\
                        padding : 1px 2px 1px 2px;\
                        margin : 2px -4px -2px -3px;\
                        line-height : 1em;\
                    }\
                    #override strong.textedit{\
                        position : relative;\
                    }\
                    #override DIV .attribute DT,\
                    #override DIV .attribute DD{\
                        cursor : text;\
                    }\
                    .attribute dt{\
                        color : #191970;\
                    }\
                    .attribute dd{\
                        color : #FF0000;\
                    }\
                    .debugmarkup dt,\
                    .attribute,\
                    .debugmarkup .selected span{}\
                    .debugmarkup dl.attribute{\
                        padding : 0 0 0 5px;\
                    }\
                    .debugmarkup dl{\
                        height : 18px;\
                        white-space : normal;\
                    }\
                    .debugmarkup dl dt{\
                        white-space : normal;\
                        padding : 1px 2px 2px 2px;\
                    }\
                    .debugmarkup dl dl{\
                        height : 14px;\
                        white-space : nowrap;\
                    }\
                    .debugmarkup dl dl dt{\
                        white-space : nowrap;\
                    }\
                    /*\*/html>body*.debugmarkup dl{height : 12px;}/**/\
                    .debugmarkup span{\
                        display : inline;\
                        padding : 2px;\
                    }\
                    .debugmarkup u{\
                        text-decoration : none;\
                    }\
                    .debugmarkup strong{\
                        font-weight : normal;\
                    }\
                    .debugmarkup .textnode strong{\
                        cursor : text;\
                    }\
                    .debugmarkup DIV{\
                        cursor : default;\
                        padding : 0 0 0 14px;\
                        position : relative;\
                    }\
                    .debugmarkup .selected dl,\
                    .debugmarkup .selected dd,\
                    .debugmarkup .selected dt,\
                    .debugmarkup .selected span,\
                    .debugmarkup .selected strong{\
                        background-color : #25a8e7;\
                        color : #FFFFFF;\
                    }\
                    #override .debugmarkup .highlight{\
                        background-color : #FFFF00;\
                        color : #000000;\
                    }\
                    .debugmarkup I{\
                        width : 9px;\
                        height : 9px;\
                        position : absolute;\
                        left : 2px;\
                        top : 5px;\
                        background-repeat : no-repeat;\
                    }\
                    .debugmarkup I.pluslast {\
                        background-image:url(' + this.resPath + 'splus.gif);\
                    }\
                    .debugmarkup I.minlast {\
                        background-image:url(' + this.resPath + 'smin.gif);\
                    }\
                    .debugmarkup I.plus {\
                        background-image:url(' + this.resPath + 'splus.gif);\
                    }\
                    .debugmarkup I.min {\
                        background-image:url(' + this.resPath + 'smin.gif);\
                    }\
                    .debugmarkup DIV BLOCKQUOTE{\
                        margin : 0;\
                        padding : 0 0 0 10px;\
                        display : none;\
                        height : 0;\
                        overflow : hidden;\
                        width : auto;\
                    }\
                ]]></a:style>\
                <a:presentation>\
                    <a:main container="blockquote" startclosed="false">\
                        <div class="debugmarkup">\
                            <blockquote> </blockquote>\
                        </div>\
                    </a:main>\
                    <a:item class="dl" begintag="dl/dt" begintail="dl/span" endtag="span" attributes="dl" openclose="i" select="dl" container="blockquote">\
                        <div><dl><dt>-</dt><span> </span></dl><blockquote> </blockquote><span>-</span><i> </i></div>\
                    </a:item>\
                    <a:attribute name="dt" value="dd">\
                        <dl class="attribute"><dt> </dt>="<dd> </dd>"</dl>\
                    </a:attribute>\
                    <a:textnode text="strong" tag="u">\
                        <strong class="textnode"><u> </u><strong>-</strong></strong>\
                    </a:textnode>\
                    <a:loading>\
                        <div class="loading"><span> </span><label>Loading...</label></div>\
                    </a:loading>\
                    <a:empty container=".">\
                        <div class="empty"></div>\
                    </a:empty>\
                </a:presentation>\
            </a:markupedit>\
        </a:skin>';
        apf.skins.Init(apf.xmldb.getXml(skinXml));

        document.documentElement.setAttribute("id", "override");

        var oInt = document.getElementById("apf_markupcontainer");
        apf.test = oHtml;

        //Get all models
        var options, i, list = apf.nameserver.getAllNames("model");
        for (options = [], i = 0; i < list.length; i++)
            options.push("<option>" + list[i] + "</option>");

        //Get all components
        list = apf.all;
        for (i = 0; i < list.length; i++) {
            if (list[i] && list[i].name && list[i].hasFeature
              && list[i].hasFeature(apf.__DATABINDING__))
                options.push("<option>#" + list[i].name + "</option>");
        }

        if (!options.length)
            options.push("<option></option>");

        options.push("<option>AML Main</option>");
        for (i = 0; i < apf.includeStack.length; i++) {
            if (typeof apf.includeStack[i] == "boolean") continue;
            options.push("<option value='" + i + "'>AML "
                + apf.getFilename(apf.includeStack[i].getAttribute("filename"))
                + "</option>");
        }

        options   = options.join('').replace(/option>/, "option selected='1'>");
        var first = options ? options.match(/>([^<]*)</)[1] : "";

        oHtml.getElementsByTagName("label")[0].insertAdjacentHTML("afterend",
            "<select id='dbgMarkupSelect' style='margin-top:2px;float:left;' onchange='apf.debugwin.setSelected(true)' onkeydown='event.cancelBubble=true;'>" + options + "</select>");

        var dbgMarkup = new apf.markupedit({
            id            : "dbgMarkup",
            htmlNode      : oInt,
            skin          : "debugmarkup",
            skinset       : "debug",
            model         : first || null,
            height        : 160,
            minheight     : 110,
            resizable     : "vertical",
            "render-root" : true,
            each          : "node()[local-name(.)]"
        });

        
        if (apf.layout && !apf.hasSingleRszEvent) {
            apf.layout.setRules(apf.getFirstElement(oInt), "resize",
                "apf.layout.forceResize(apf.debugwin.$ext);");
            apf.layout.queue(oInt.firstChild);
        }
        
    },

    PROFILER_ELEMENT   : null,
    PROFILER_BUTTON    : null,
    PROFILER_HEADS     : null,
    PROFILER_SUMMARY   : null,
    PROFILER_PROGRESS  : '<span class="debug_profilermsg debug_progress">The profiler is running. Click \'Stop\' to see its report.</span>',
    PROFILER_NOPROGRESS: '<span class="debug_profilermsg">The profiler is currently inactive. Click \'Start\' to begin profiling your code.<span>',
    initProfiler: function(oHtml) {
        this.PROFILER_ELEMENT = document.getElementById('apfProfilerOutput');
        this.PROFILER_BUTTON  = document.getElementById('apfProfilerAction');
        this.PROFILER_SUMMARY = document.getElementById('apfProfilerSummary');
        this.showProgress();

        if (apf.profiler && apf.profiler.isRunning)
            this.toggleFold(document.getElementById('apfProfilerPanel'));
    },

    startStop: function(input) {
        input.disabled = true;
        if (!apf.profiler.isRunning) {
            if (!apf.profiler.isInitialized()) {
                if (this.profileGlobal)
                    apf.profiler.init(window, 'window');
                else
                    apf.profiler.init(apf, 'apf');
            }
            apf.profiler.start();
            this.showProgress();
        }
        else {
            var data = apf.profiler.stop();
            this.PROFILER_ELEMENT.innerHTML = data.html;
            this.PROFILER_SUMMARY.innerHTML = data.duration + "ms, " + data.total + " calls";
            this.PROFILER_BUTTON.innerHTML  = "Start";
        }
        input.disabled = false;
    },

    showProgress: function() {
        if (!this.PROFILER_ELEMENT) return;
        if (apf.profiler.isRunning) {
            this.PROFILER_ELEMENT.innerHTML = this.PROFILER_PROGRESS;
            //this.PROFILER_BUTTON.innerHTML  = "Stop";
        }
        else {
            this.PROFILER_ELEMENT.innerHTML = this.PROFILER_NOPROGRESS;
            //this.PROFILER_BUTTON.innerHTML  = "Start";
        }
    },

    resortResult: function(th) {
        //if (!radio.checked) return;
        var data = apf.profiler.resortStack(parseInt(th.getAttribute('rel')));

        this.PROFILER_ELEMENT.innerHTML = data.html;
        this.PROFILER_SUMMARY.innerHTML = data.duration + "ms, " + data.total + " calls";
    },

    toggleProfileStartup: function(checked) {
        if (apf.setcookie)
            apf.setcookie("profilestartup", checked);
    },

    toggleProfileGlobal: function(checked) {
        this.profileGlobal = checked;
        if (checked)
            apf.profiler.reinit(window, 'window');
        else
            apf.profiler.reinit(apf, 'apf');
        if (apf.setcookie)
            apf.setcookie("profileglobal", checked);
    },

    toggleFold: function(oNode, corrScroll, corrFocus) {
        if (typeof corrScroll == "undefined")
            corrScroll = false;
        if (typeof corrFocus == "undefined")
            corrFocus  = false;

        var oFirst = oNode.getElementsByTagName('img')[0];
        var oLast  = oNode.lastChild;
        while (oLast.nodeType != 1) 
            oLast = oLast.previousSibling;
            
        if (apf.getStyle(oLast, "display") == "block"){
            oLast.style.display = "none";
            oFirst.src          = this.resPath + "arrow_gray_right.gif";
        }
        else {
            oLast.style.display = "block";
            oFirst.src          = this.resPath + "arrow_gray_down.gif";
            if (corrScroll)
                oLast.scrollTop = oLast.scrollHeight;
            if (corrFocus) {
                oFirst = oLast.firstChild;
                while (oFirst.nodeType != 1) oFirst = oFirst.nextSibling;
                oFirst.focus();
            }
        }
        
        if (apf.layout)
            apf.layout.forceResize(this.$ext);
        
    },
    
    $getOption : function(){
        return 7; // muuh? what's this?
    },

    focusFix   : {"INPUT":1,"TEXTAREA":1,"SELECT":1},
    createWindow : function (e, stackTrace, errorInfo){
        if (!apf.debugwin.win)
            apf.debugwin.win = document.getElementById("apf_debugwin");
        if (apf.debugwin.win) return;

        var elError, p, m, o;

        if (document.body) {
            elError    = document.body.appendChild(document.createElement("div"));
            elError.id = "apf_debugwin";
        }
        else {
            document.write("<div id='apf_debugwin'></div>");
            elError = document.getElementById("apf_debugwin");
        }

        elError.style.position = apf.supportFixedPosition ? "fixed" : "absolute";

        elError.host = this;
        this.name    = "Debug Window";
        this.localName = "debugwin";

        elError.onmousedown  = function(e) {
            if (!e) e = event;

            if (!apf.window)
                return;

            
            if (apf.hasFocusBug
              && !apf.debugwin.focusFix[(e.srcElement || e.target).tagName]) {
                apf.window.$focusfix();
            }
            

            (e || event).cancelBubble = true;
        };

        this.dispatchEvent    = function(){}
        elError.onkeydown     =
        elError.onkeyup       = function(e){
            if (!e) e = event;

            if (apf.debugwin.focusFix[(e.srcElement || e.target).tagName])
                (e || event).cancelBubble = true;
        }

        if (apf.isIE) {
            apf.setStyleRule("BODY", "overflow", "", 0);

            p = apf.getBox(apf.getStyle(document.body, "padding"));
            m = apf.getBox(apf.getStyle(document.body, "margin"));
            o = [apf.getStyle(document.documentElement, "overflow"),
                     apf.getStyle(document.documentElement, "overflowX"),
                     apf.getStyle(document.documentElement, "overflowY")];
        }
        else {
            p = [parseInt(apf.getStyle(document.body, "padding-top")),
                 parseInt(apf.getStyle(document.body, "padding-right")),
                 parseInt(apf.getStyle(document.body, "padding-bottom")),
                 parseInt(apf.getStyle(document.body, "padding-left"))];
            m = [parseInt(apf.getStyle(document.body, "margin-top")),
                 parseInt(apf.getStyle(document.body, "margin-right")),
                 parseInt(apf.getStyle(document.body, "margin-bottom")),
                 parseInt(apf.getStyle(document.body, "margin-left"))];
            o = [apf.getStyleRule("html", "overflow") || "auto",
                     apf.getStyleRule("html", "overflow-x") || "auto",
                     apf.getStyleRule("html", "overflow-y") || "auto"];
        }

        
        this.resPath = (apf.config.resourcePath || apf.basePath) + "resources/";
        
        

        apf.importCssString("\
            html{\
                height : 100%;\
                overflow : hidden;\
                overflow-x : hidden;\
                overflow-y : hidden;\
                margin-bottom : " + (p[0] + m[0] + p[2] + m[2]) + "px;\
            }\
            body{\
                height : 100%;\
                position : relative;\
                overflow  : " + o[0] + ";\
                overflow-x : " + o[1] + ";\
                overflow-y : " + o[2] + ";\
                margin : 0 605px 0 0;\
                padding : " + (p[0] + m[0]) + "px " +
                              (p[1] + m[1]) + "px " +
                              (p[2] + m[2]) + "px " +
                              (p[3] + m[3]) + "px;\
                width : auto;\
            }\
            #apf_debugwin {\
                top: 0px;\
                border-left: 1px solid #bbb;\
                text-align: left;\
                width: 500px;\
                background: #fff url(" + this.resPath + "splitter_handle_vertical.gif) no-repeat 1px 50%;\
                right: 0px;\
                font-family: 'Lucida Grande', Arial, Monaco, 'MS Sans Serif';\
                font-size: 11px;\
                color: #333;\
                overflow: hidden;\
                z-index: 99999;\
                height: 100%;\
                padding-left: 4px;\
                display : none;\
            }\
            #cbTW, #cbHighlight, #toggledebug{\
                float: left;\
            }\
            #apf_debugwin button, #apf_debugwin select, #apf_debugwin input, #apf_debugwin label{\
                font-size: 10px;\
            }\
            #override #apf_debugwin{\
                letter-spacing: 0;\
                font-family: 'Lucida Grande', Arial;\
            }\
            #apf_debugwin label{\
                padding: 5px 0 0 1px;\
                width: auto;\
            }\
            #apf_debugwin button{\
                padding: 0;\
                margin: 0 0 2px 0;\
            }\
            #apf_debugwin .debug_header{\
                position: relative;\
                background: url(" + this.resPath + "backgrounds.png) repeat-x 0 -145px;\
                border-bottom: 1px solid #505050;\
                height: 66px;\
                -moz-user-select: none;\
                -khtml-user-select: none;\
                user-select: none;\
            }\
            #apf_debugwin .debug_header_cont{\
                background: url(" + this.resPath + "ajax_logo.png) no-repeat right 4px;\
                width: 100%;\
                height: 66px;\
            }\
            #apf_debugwin .debug_closebtn,\
            #apf_debugwin .debug_closebtn_hover{\
                cursor: hand;\
                cursor: pointer;\
                right: 0px;\
                top: 3px;\
                z-index: 1000;\
                margin: 0px;\
                width: 16px;\
                height: 16px;\
                overflow: hidden;\
                padding: 0;\
                position: absolute;\
                background: url(" + this.resPath + "buttons.png) no-repeat -176px -16px;\
            }\
            #apf_debugwin .debug_closebtn_hover{\
                background-position: -176px 0px;\
            }\
            #apf_debugwin .debug_logos{\
                background: url(" + this.resPath + "apf_logo.png) no-repeat 5px 5px;\
                position: absolute;\
                top: 0px;\
                height: 50px;\
                width: 200px;\
                padding: 14px 4px 4px 68px;\
                margin: 0;\
                font-family: Arial, sans-serif, Tahoma, Verdana, Helvetica;\
                color: #fff;\
                font-weight: 100;\
                font-size: 14px;\
                letter-spacing: 0px;\
                line-height: 15px;\
            }\
            #apf_debugwin .debug_logos .debug_apf{\
                display: block;\
            }\
            #apf_debugwin .debug_logos .debug_apf strong{\
                font-weight: 900;\
                font-family: \'Arial Black\';\
                letter-spacing: -1px;\
            }\
            #apf_debugwin .debug_logos .debug_apf_slogan{\
                font-style: italic;\
                font-size: 9px;\
                line-height: 10px;\
                display : block;\
            }\
            #apf_debugwin .debug_panel_head .debug_btn{\
                top:3px;\
                position:relative;\
                background: url(" + this.resPath + "buttons.png) no-repeat -192px 0;\
                width: 16px;\
                height: 16px;\
            }\
            #apf_debugwin .debug_panel_head .debug_btn_down{\
                background-position: -192px -16px;\
            }\
            #apf_debugwin .debug_toolbar{\
                position: relative;\
                height: 22px;\
                background: url(" + this.resPath + "backgrounds.png) repeat-x 0 -57px;\
                padding: 0 0 0 4px;\
                font-size: 10px;\
                font-family: 'Lucida Grande', 'MS Sans Serif', Arial;\
                vertical-align: middle;\
                overflow: hidden;\
                -moz-user-select: none;\
                -khtml-user-select: none;\
                user-select: none;\
                cursor : default;\
            }\
            #apf_debugwin .debug_toolbar .input_text{\
                border:1px solid #bfbfbf;\
                padding : 2px;\
            }\
            #apf_debugwin .debug_toolbar_inner{\
                border-top: 1px solid #cacaca;\
                border-bottom: 1px solid #cacaca;\
            }\
            #apf_debugwin .debug_toolbar .debug_btn{\
                position: relative;\
                border-right: 1px solid #b8b8b8;\
                width: 24px;\
                height: 22px;\
                float: left;\
                cursor: pointer;\
                cursor: hand;\
            }\
            #apf_debugwin .debug_toolbar .debug_btnright{\
                float: right !important;\
                border-right: none;\
                border-left: 1px solid #b8b8b8;\
            }\
            #apf_debugwin .debug_toolbar .debug_btn span{\
                position: absolute;\
                background: url(" + this.resPath + "buttons.png) no-repeat 0 0;\
                width: 16px;\
                height: 16px;\
                top: 4px;\
                left: 4px;\
            }\
            #apf_debugwin .debug_toolbar .debug_btn span.reboot{\
                background-position: -16px 0;\
            }\
            #apf_debugwin .debug_toolbar .debug_btn span.undo{\
                background-position: -32px 0;\
            }\
            #apf_debugwin .debug_toolbar .debug_btn span.redo{\
                background-position: -48px 0;\
            }\
            #apf_debugwin .debug_toolbar .debug_btn span.online{\
                background-position: -64px 0;\
            }\
            #apf_debugwin .debug_toolbar .debug_btn span.offline{\
                background-position: -80px 0;\
            }\
            #apf_debugwin .debug_toolbar .debug_btn span.reset{\
                background-position: -96px 0;\
            }\
            #apf_debugwin .debug_toolbar .debug_btn span.start{\
                background-position: -112px 0;\
            }\
            #apf_debugwin .debug_toolbar .debug_btn span.remove{\
                background-position: -128px 0;\
            }\
            #apf_debugwin .debug_toolbar .debug_btn span.textnode{\
                background-position: -144px 0;\
            }\
            #apf_debugwin .debug_toolbar .debug_btn span.attribute{\
                background-position: -160px 0;\
            }\
            #apf_debugwin .debug_toolbar .debug_btn_down span.exec{\
                background-position: 0 -16px;\
            }\
            #apf_debugwin .debug_toolbar .debug_btn_down span.reboot{\
                background-position: -16px -16px;\
            }\
            #apf_debugwin .debug_toolbar .debug_btn_down span.undo{\
                background-position: -32px -16px;\
            }\
            #apf_debugwin .debug_toolbar .debug_btn_down span.redo{\
                background-position: -48px -16px;\
            }\
            #apf_debugwin .debug_toolbar .debug_btn_down span.online{\
                background-position: -64px -16px;\
            }\
            #apf_debugwin .debug_toolbar .debug_btn_down span.offline{\
                background-position: -80px -16px;\
            }\
            #apf_debugwin .debug_toolbar .debug_btn_down span.reset{\
                background-position: -96px -16px;\
            }\
            #apf_debugwin .debug_toolbar .debug_btn_down span.start{\
                background-position: -112px -16px;\
            }\
            #apf_debugwin .debug_toolbar .debug_btn_down span.remove{\
                background-position: -128px -16px;\
            }\
            #apf_debugwin .debug_toolbar .debug_btn_down span.textnode{\
                background-position: -144px -16px;\
            }\
            #apf_debugwin .debug_toolbar .debug_btn_down span.attribute{\
                background-position: -160px -16px;\
            }\
            #apf_debugwin .debug_footer{\
                width: 100%;\
                position: relative;\
                bottom: 0px;\
                border-bottom: 0;\
                border-left: 1px solid #a3a3a3;\
                -moz-user-select: none;\
                -khtml-user-select: none;\
                user-select: none;\
            }\
            #apf_debugwin .debug_footer img{\
                position: absolute;\
                top: 0px;\
                right: 0px;\
                border: 0;\
                margin: 0;\
                padding: 0;\
            }\
            #apf_debugwin .debug_panel{\
                cursor:default;\
                border-left: 1px solid #a3a3a3;\
                padding: 0;\
                margin: 0;\
                font-family: 'Lucida Grande', 'MS Sans Serif', Arial;\
            }\
            #apf_debugwin .debug_panel_head{\
                background: url(" + this.resPath + "backgrounds.png) repeat-x 0 0;\
                height: 17px;\
                padding: 2px 0 0 0;\
                -moz-user-select: none;\
                -khtml-user-select: none;\
                user-select: none;\
            }\
            #apf_debugwin .debug_panel_head img{\
                margin: 2px 0 0 6px;\
            }\
            #apf_debugwin .debug_panel_head strong{\
                color: #826e6e;\
            }\
            #apf_debugwin .debug_panel_headsub{\
                margin-right: 5px;\
                float: right;\
                margin-top: -4px;\
            }\
            #apf_debugwin .debug_panel_body_base{\
                cursor: text;\
                background: white url(" + this.resPath + "shadow.gif) no-repeat 0 0;\
                padding: 4px;\
                font-family: Monaco, Courier New;\
                margin: 0;\
            }\
            #apf_debugwin .debug_panel_body_error{\
                padding: 0;\
                margin: 0;\
            }\
            #apf_debugwin .debug_panel_body_error table{\
                font-family: 'Lucida Grande', 'MS Sans Serif', Arial;\
                font-size: 10px;\
                width: 100%;\
            }\
            #apf_debugwin .debug_panel_body_error td{\
                padding: 2px;\
                border-bottom: 1px solid #e4e4e4;\
                border-left: 1px solid #e4e4e4;\
                margin: 0;\
            }\
            #apf_debugwin .debug_panel_body_error .debug_error_header{\
                background-color: #449ad0;\
                border-bottom: 1px solid #79afd1;\
                border-left: none;\
                padding-left: 4px;\
                color: #fff;\
                width: 65px;\
                -moz-user-select: none;\
                -khtml-user-select: none;\
                user-select: none;\
            }\
            #apf_debugwin .debug_panel_body_none{\
                display: none;\
            }\
            #apf_debugwin .debug_panel_body_markup{\
                padding: 0;\
                white-space: nowrap;\
            }\
            #apf_debugwin .debug_panel_body_aml{\
                padding: 0;\
                white-space: nowrap;\
                padding : 10px;\
                font-family : 'Lucida Grande', Verdana;\
                font-size : 8.5pt;\
                white-space : normal;\
                overflow : auto;\
                max-height : 200px;\
            }\
            #apf_debugwin .debug_panel_body_data{\
                min-height: 130px;\
                white-space: nowrap;\
                overflow: auto;\
                display: none;\
                padding : 0;\
            }\
            #apf_debugwin .debug_panel_body_profiler{\
                padding: 0px;\
                font-family: 'Lucida Grande', 'MS Sans Serif', Arial;\
                font-size: 9px;\
                height: 180px;\
                overflow: auto;\
                display: block;\
            }\
            #apf_debugwin .debug_panel_body_log{\
                height: 250px;\
                overflow: auto;\
                font-size: 8pt;\
                font-family: 'Lucida Grande', Verdana;\
            }\
            #apf_debugwin .debug_panel_body_console{\
                width: 391px;\
                height: 100px;\
                border: 0;\
                overflow: auto;\
                font-size: 12px;\
            }\
            #apf_debugwin .debug_panel_body_lm{\
                padding : 0;\
                font-size: 8pt;\
                font-family: 'Lucida Grande', Verdana;\
            }\
            #apf_debugwin .debug_panel_body_lm blockquote{\
                height : 194px;\
                border : 0;\
                border-right : 1px solid #bfbfbf;\
                background : transparent;\
                margin : 0;\
                padding : 3px;\
                overflow : auto;\
            }\
            #apf_debugwin .debug_panel_body_lm .apf_empty {\
                color : #AAA;\
                text-align : center;\
                padding : 5px;\
                display : block;\
            }\
            #apf_debugwin .debug_panel_body_lm textarea{\
                width : 50%;\
                float : right;\
                height : 194px;\
                background : url(" + this.resPath + "spacer.gif);\
                overflow : auto;\
                border : 0;\
                margin : 0;\
                border-left : 1px solid #bfbfbf;\
                margin-left : 3px;\
                font-size: 12px;\
                position : relative;\
                padding : 3px;\
            }\
            #apf_debugwin .debug_profilermsg{\
                margin: 4px;\
                font-weight: 500;\
                height: 20px;\
                line-height: 20px;\
                vertical-align: middle;\
                overflow: visible;\
                padding: 4px;\
            }\
            #apf_debugwin .debug_progress{\
                background-image: url(" + this.resPath + "progress.gif);\
                background-repeat: no-repeat;\
                background-position: center left;\
                padding-left: 22px;\
            }\
            #apf_debugwin .debug_console_btn{\
                font-family: 'Lucida Grande', 'MS Sans Serif', Arial;\
                font-size: 8pt;\
                margin: 0 0 0 3px;\
            }\
            #apf_debugwin .debug_check_use{\
                position: relative;\
                top: 4px;\
                font-family: 'Lucida Grande', 'MS Sans Serif', Arial;\
                font-size: 8pt;\
            }");

        document.body.style.display = "block";

        var canViewMarkup = apf.nameserver && apf.markupedit ? true : false,
            useProfiler   = false;

        elError.innerHTML = "\
            <div class='debug_header'>\
                <div class='debug_header_cont'>\
                    <div onselectstart='if (apf.dragMode) return false; event.cancelBubble=true' class='debug_logos'>\
                        &nbsp;\
                    </div>\
                    <div class='debug_closebtn' onmouseover='this.className=\"debug_closebtn_hover\"' \
                      onmouseout='this.className=\"debug_closebtn\"' onclick='apf.debugwin.hide()' title='Close'>&nbsp;</div>\
                </div>\
            </div>\
            <div class='debug_panel' onclick='apf.debugwin.toggleFold(this);'>\
                <div class='debug_panel_head'>\
                    <img width='9' height='9' src='" + this.resPath + "arrow_gray_down.gif' />&nbsp;\
                    <strong>Error</strong>\
                </div>\
                <div id='" + this.errorTable + "' onclick='event.cancelBubble=true' \
                  onselectstart='if (apf.dragMode) return false; event.cancelBubble=true'\
                  class='debug_panel_body_base debug_panel_body_error'>@todo</div>\
            </div>\
            <div class='debug_panel' onclick='apf.debugwin.toggleFold(this);'>\
                <div class='debug_panel_head'>\
                    <img width='9' height='9' src='" + this.resPath + "arrow_gray_down.gif' />&nbsp;\
                    <strong>AML related to the error</strong>\
                </div>\
                <div id='" + this.contextDiv + "' onclick='event.cancelBubble=true' \
                  onselectstart='if (apf.dragMode) return false; event.cancelBubble=true' \
                  class='debug_panel_body_base debug_panel_body_aml'>@todo</div>\
            </div>\
            <div class='debug_panel' onclick='apf.debugwin.toggleFold(this);'>\
                <div class='debug_panel_head'>\
                    <img width='9' height='9' src='" + this.resPath + "/arrow_gray_right.gif' />&nbsp;\
                    <strong>Stack Trace</strong>\
                </div>\
                <div id='" + this.stackTrace + "' class='debug_panel_body_base debug_panel_body_none'></div>\
            </div>" +
        (apf.lm
         ? "<div class='debug_panel' onclick='apf.debugwin.toggleFold(this);'>\
                <div class='debug_panel_head'>\
                    <img width='9' height='9' src='" + this.resPath + "arrow_gray_right.gif' />&nbsp;\
                    <strong>LM Debugger (beta)</strong>\
                </div>\
                <div onclick='event.cancelBubble=true' \
                  class='debug_panel_body_base debug_panel_body_lm debug_panel_body_none'>\
                    <textarea id='" + this.lmConsole + "' onkeyup='if(document.getElementById(\"dbgLmCheck\").checked || event.keyCode==13) apf.debugwin.run(\"lm\");'\
                      onselectstart='if (apf.dragMode) return false; event.cancelBubble=true'\
>/* LM example */\n\
<h4>{node()/node()|text()}</h4>\n\
\n\
<p>This document contains [%#'//node()'] nodes.</p>\n\
\n\
<p>The first node is called <b>[%n.tagName]</b>, and has [%#'node()'] child[%#'node()' == 1 ? '' : 'ren'].</p></textarea>\
                    <blockquote id='apf_lm_output'><span class='apf_empty'>No LM Parsed</span></blockquote>\
                    <div class='debug_toolbar debug_toolbar_inner'>\
                        <label style='float:left;padding:4px 3px 0 0;'>Data instruction: </label>\
                        <input id='dbgLmInput' onkeydown='if(event.keyCode==13) apf.debugwin.run(\"lm\");event.cancelBubble=true;' \
                            style='margin-top:2px;width:150px;float:left;' class='input_text'\
                            onselectstart='if (apf.dragMode) return false; event.cancelBubble=true' />\
                        <label for='dbgLmCheck' style='float:right;padding:3px 5px 0 1px'>Don't update in real-time.</label>\
                        <input id='dbgLmCheck' style='float:right' checked='checked' type='checkbox' />\
                    </div>\
                </div>\
            </div>"
         : "") +
        (canViewMarkup
         ? "<div class='debug_panel' onclick='apf.debugwin.initMarkup(this);apf.debugwin.toggleFold(this);'>\
                <div class='debug_panel_head'>\
                    <img width='9' height='9' src='" + this.resPath + "arrow_gray_right.gif' />&nbsp;\
                    <strong>Data Editor (beta)</strong>\
                </div>\
                <div onclick='event.cancelBubble=true' onselectstart='if (apf.dragMode) return false; event.cancelBubble=true'\
                  class='debug_panel_body_base debug_panel_body_markup debug_panel_body_none'>\
                    <div id='apf_markupcontainer'> </div>\
                    <div class='debug_toolbar debug_toolbar_inner'>\
                        <label style='float:left'>Model:</label>\
                        <label style='float:left'>XPath:</label>\
                        <input id='dbgMarkupInput' onkeydown='if(event.keyCode==13) apf.debugwin.setSelected(true);event.cancelBubble=true;' \
                            style='margin-top:2px;width:90px;float:left' class='input_text'\
                            onselectstart='if (apf.dragMode) return false; event.cancelBubble=true' />\
                        <div onclick='apf.debugwin.exec(\"remove\")' class='debug_btn debug_btnright' title='Remove'\
                          onmousedown='apf.debugwin.btnMouseDown(this)' onmouseup='apf.debugwin.btnMouseUp(this)'>\
                            <span class='remove'> </span>\
                        </div>\
                        <div onclick='apf.debugwin.exec(\"textnode\")' class='debug_btn debug_btnright' title='Textnode'\
                          onmousedown='apf.debugwin.btnMouseDown(this)' onmouseup='apf.debugwin.btnMouseUp(this)'>\
                            <span class='textnode'> </span>\
                        </div>\
                        <div onclick='apf.debugwin.exec(\"attribute\")' class='debug_btn debug_btnright' title='Attribute'\
                          onmousedown='apf.debugwin.btnMouseDown(this)' onmouseup='apf.debugwin.btnMouseUp(this)'>\
                            <span class='attribute'> </span>\
                        </div>\
                        <div onclick='apf.debugwin.exec(\"redo\")' class='debug_btn debug_btnright' title='Redo'\
                          onmousedown='apf.debugwin.btnMouseDown(this)' onmouseup='apf.debugwin.btnMouseUp(this)'>\
                            <span class='redo'> </span>\
                        </div>\
                        <div onclick='apf.debugwin.exec(\"undo\")' class='debug_btn debug_btnright' title='Undo'\
                          onmousedown='apf.debugwin.btnMouseDown(this)' onmouseup='apf.debugwin.btnMouseUp(this)'>\
                            <span class='undo'> </span>\
                        </div>\
                    </div>\
                </div>\
            </div>"
         : "") +
        (useProfiler
         ? "<div class='debug_panel' id='apfProfilerPanel' onclick='apf.debugwin.toggleFold(this);'>\
                <div class='debug_panel_head'>\
                    <img width='9' height='9' src='" + this.resPath + "arrow_gray_right.gif' />&nbsp;\
                    <strong>Javascript Profiler (beta)</strong>\
                </div>\
                <div onclick='event.cancelBubble=true' onselectstart='if (apf.dragMode) return false; event.cancelBubble=true' style='display:none;'>\
                    <div id='apfProfilerOutput' class='debug_panel_body_base debug_panel_body_profiler'></div>\
                    <div id='apfProfilerSummary' style='float:right;font-size:9px;margin-right:10px;'></div>\
                    <div class='debug_toolbar debug_toolbar_inner'>\
                        <div id='apfProfilerAction' onclick='apf.debugwin.startStop(this);' class='debug_btn' title='Start'\
                          onmousedown='apf.debugwin.btnMouseDown(this)' onmouseup='apf.debugwin.btnMouseUp(this)'>\
                            <span class='start'> </span>\
                        </div>\
                        <input id='cbProfileGlobal' type='checkbox' onclick='\
                          apf.debugwin.toggleProfileGlobal(this.checked);\
                          event.cancelBubble = true;'" + (this.profileGlobal ? " checked='checked'" : "") + "/>\
                        <label for='cbProfileGlobal' onclick='event.cancelBubble=true'>\
                            Profile window object\
                        </label>\
                        <input id='cbProfileStartup' type='checkbox' onclick='\
                          apf.debugwin.toggleProfileStartup(this.checked);\
                          event.cancelBubble = true;'" + (apf.isTrue(apf.getcookie("profilestartup")) ? " checked='checked'" : "") + "/>\
                        <label for='cbProfileStartup' onclick='event.cancelBubble=true'>\
                            Profile startup\
                        </label>\
                    </div>\
                </div>\
            </div>"
         : "") +
           "<div class='debug_panel' onclick='apf.debugwin.toggleFold(this, true);'>\
                <div class='debug_panel_head'>\
                    <div class='debug_panel_headsub'>\
                        <div class='debug_btn' title='Open window'\
                          onmouseover='apf.debugwin.btnMouseDown(this)' onmouseout='apf.debugwin.btnMouseUp(this)'\
                          onclick='\
                              apf.debugwin.showLogWindow();\
                              event.cancelBubble = true;'\
                        >&nbsp;</div>\
                    </div>\
                    <img width='9' height='9' src='" + this.resPath + "arrow_gray_down.gif' />&nbsp;\
                    <strong>Log Viewer</strong>\
                </div>\
                <div id='" + this.logView + "' onclick='event.cancelBubble=true'\
                  onselectstart='if (apf.dragMode) return false; event.cancelBubble=true'\
                  class='debug_panel_body_base debug_panel_body_log'>" 
                    + apf.console.debugInfo.join('').replace(/\{imgpath\}/g, this.resPath) +
               "</div>\
            </div>\
            <div class='debug_panel' onclick='apf.debugwin.toggleFold(this, false, true);'>\
                <div class='debug_panel_head'>\
                    <img width='9' height='9' src='" + this.resPath + "arrow_gray_down.gif' />&nbsp;\
                    <strong>Javascript console</strong>\
                </div>\
                <div onclick='event.cancelBubble=true'>\
                    <textarea id='" + this.debugConsole + "' onkeydown='return apf.debugwin.consoleTextHandler(event);'\
                      onselectstart='if (apf.dragMode) return false; event.cancelBubble=true'\
                      class='debug_panel_body_base debug_panel_body_console'>" + apf.getcookie('jsexec') + "</textarea>\
                    <div class='debug_toolbar debug_toolbar_inner'>\
                        <div id='apfDebugExec' onclick='apf.debugwin.jRunCode(apf.debugwin.debugConsole.value)' title='Run Code'\
                          class='debug_btn' onmousedown='apf.debugwin.btnMouseDown(this)' onmouseup='apf.debugwin.btnMouseUp(this)'>\
                            <span class='exec'> </span>\
                        </div>\
                        <div onclick='apf.debugwin.run(\"reboot\")' class='debug_btn' title='Reboot Application'\
                          onmousedown='apf.debugwin.btnMouseDown(this)' onmouseup='apf.debugwin.btnMouseUp(this)'>\
                            <span class='reboot'> </span>\
                        </div>\
                        <div onclick='apf.debugwin.run(\"undo\")' class='debug_btn' title='Undo'\
                          onmousedown='apf.debugwin.btnMouseDown(this)' onmouseup='apf.debugwin.btnMouseUp(this)'>\
                            <span class='undo'> </span>\
                        </div>\
                        <div onclick='apf.debugwin.run(\"redo\")' class='debug_btn' title='Redo'\
                          onmousedown='apf.debugwin.btnMouseDown(this)' onmouseup='apf.debugwin.btnMouseUp(this)'>\
                            <span class='redo'> </span>\
                        </div>\
                        <div onclick='apf.debugwin.run(\"reset\")' class='debug_btn' title='Clear offline cache'\
                          onmousedown='apf.debugwin.btnMouseDown(this)' onmouseup='apf.debugwin.btnMouseUp(this)'>\
                            <span class='reset'> </span>\
                        </div>\
                        <div onclick='apf.debugwin.run(\"online\")' class='debug_btn' title='Go Online'\
                          onmousedown='apf.debugwin.btnMouseDown(this)' onmouseup='apf.debugwin.btnMouseUp(this)'>\
                            <span class='online'> </span>\
                        </div>\
                        <div onclick='apf.debugwin.run(\"offline\")' class='debug_btn' title='Go Offline'\
                          onmousedown='apf.debugwin.btnMouseDown(this)' onmouseup='apf.debugwin.btnMouseUp(this)'>\
                            <span class='offline'> </span>\
                        </div>\
                    </div>\
                </div>\
            </div>\
            <div id='lastElement' class='debug_footer debug_toolbar'>\
                <input id='toggledebug' type='checkbox' onclick='apf.debugwin.toggleDebugger(this.checked)'" + (apf.isTrue(apf.getcookie("debugger")) ? " checked='checked'" : "") + " />\
                <label for='toggledebug' class='debug_check_use'>Use browser's debugger</label>\
            </div>";

        this.errorTable   = document.getElementById(this.errorTable);
        this.contextDiv   = document.getElementById(this.contextDiv);
        this.stackTrace   = document.getElementById(this.stackTrace);
        this.logView      = document.getElementById(this.logView);
        this.debugConsole = document.getElementById(this.debugConsole);
        this.lmConsole  = document.getElementById(this.lmConsole);

        if (!this.$ext && apf.Interactive) {
            this.$ext     = elError;
            this.$pHtmlDoc = document;

            if (false) { //@todo temp disabled because of issues
                this.$propHandlers = [];
                apf.implement.call(this, apf.Interactive);
    
                this.minwidth  = 400;
                this.minheight = 442;
                this.maxwidth  = 10000;
                this.maxheight = 10000;
    
                this.resizable     = "horizontal";
                this.resizeOutline = true;
                this.$propHandlers["resizable"].call(this, "horizontal");
    
                if (apf.isIE) {
                    this.debugConsole.parentNode.style.width = "auto";
                    this.debugConsole.parentNode.style.paddingTop = "108px";
                    this.debugConsole.style.position = "absolute";
                    this.debugConsole.style.marginTop = "-108px";
                }
            }

            
            if (apf.layout) {
                apf.layout.setRules(elError, "resize",
                    "var oHtml = document.getElementById('" + elError.id + "');\
                    var o = document.getElementById('jvlnviewlog');\
                    var l = document.getElementById('lastElement');\
                    if (!o || !l) return;\
                    var scrollHeight = l.offsetTop + l.offsetHeight;\
                    var shouldSize = scrollHeight - o.offsetHeight + 200 < oHtml.offsetHeight;\
                    o.style.height = (shouldSize\
                        ? oHtml.offsetHeight - scrollHeight + o.offsetHeight - 8\
                        : 190) + 'px';\
                    oHtml.style.overflowY = shouldSize ? 'hidden' : 'auto';\
                    oHtml.style.right = '0px';\
                    oHtml.style.left = '';\
                    document.body.style.marginRight = \
                        oHtml.offsetWidth + 'px';\
                    if (apf.isIE8) {\
                        document.body.style.height = \
                            (document.documentElement.offsetHeight \
                            - apf.getHeightDiff(document.body) - 4) + 'px';\
                    }\
                    var o = document.getElementById('apfDebugExpr');\
                    if (o.parentNode.offsetWidth)\
                        o.style.width = (o.parentNode.offsetWidth \
                            - (apf.isGecko ? 4 : 8)) + 'px';\
                ");
                apf.layout.queue(elError);
            }
            
        }
        else
            this.$ext = elError;

        if (apf.hasFocusBug) {
            apf.sanitizeTextbox(this.debugConsole);
            if (this.lmConsole)
                apf.sanitizeTextbox(this.lmConsole);
        }

        clearInterval(apf.Init.interval);
        ERROR_HAS_OCCURRED = true;

        this.initProfiler(this);
        
        apf.getWindowWidth = function(){
            return document.body.offsetWidth;
        }
        apf.getWindowHeight = function(){
            return document.body.offsetHeight;
        }
    },

    run : function(action){
        switch(action){
            case "undo":
                apf.window.getActionTracker().undo();
                break;
            case "redo":
                apf.window.getActionTracker().redo();
                break;
            
            case "reset":
                apf.offline.clear();
                break;
            
            case "reboot":
                apf.reboot();
                break;
            
            case "online":
                if (apf.offline.detector.detection != "manual") {
                    apf.console.info("Switching to manually network detection.");
                    apf.offline.detector.detection = "manual";
                    apf.offline.detector.stop();
                }

                apf.offline.goOnline();
                break;
            case "offline":
                if (apf.offline.detector.detection != "manual") {
                    apf.console.info("Switching to manually network detection.");
                    apf.offline.detector.detection = "manual";
                    apf.offline.detector.stop();
                }

                apf.offline.goOffline()
                break;
            
            case "lm":
                if (!apf.debugwin.$lm) {
                    apf.debugwin.$lm = new apf.LmImplementation();
                    apf.debugwin.$lm.modelcache = {};
                }
                
                var ds = document.getElementById("dbgLmInput").value;
                if (!ds)
                    return alert("Missing data instruction");
                
                var xml = apf.debugwin.$lm.modelcache[ds];
                var lmCode, result = document.getElementById("apf_lm_output");
                if (!xml) {
                    apf.debugwin.$lm.modelcache[ds] = -1;
                    
                    apf.getData(ds, {callback: function(data, state, extra){
                        if (state != apf.SUCCESS) {
                            delete apf.debugwin.$lm.modelcache[ds];
                            result.innerHTML = "<span class='apf_empty'>Retrieving data by the data instruction given '" + ds + "' has failed.\n" + extra.message + "</span>";
                            return true;
                        }
                        
                        try {
                            apf.debugwin.$lm.modelcache[ds] = data.nodeType 
                                ? data 
                                : data && apf.getXml(data.replace(/\<\!DOCTYPE[^>]*>/, "")) || -10;
                        }
                        catch(e) {
                            apf.debugwin.$lm.modelcache[ds] = -10;
                        }
                        
                        apf.debugwin.run("lm");
                    }}); //Can this error?
                    
                    return;
                }
                else if (!xml.nodeType && xml == -1)
                    return;

                try{
                    if (!xml.nodeType && xml == -10)
                        lmCode = "<span class='apf_empty'>Data source did not return any data</span>";
                    else 
                        lmCode = (apf.debugwin.$lm.compile(this.lmConsole.value))(xml) 
                }
            	catch(e){
            		result.innerHTML = "Live Markup Compilation error:\n" + e.message;
            		return;
            	}
                
                result.innerHTML = lmCode;

                break;
        }
    },

    jRunCode : function(code){
        apf.setcookie("jsexec", code);

        apf.console.write("<span style='color:blue'><span style='float:left'>&gt;&gt;&gt;</span><div style='margin:0 0 0 30px'>"
            + code.replace(/ /g, "&nbsp;").replace(/\t/g, "&nbsp;&nbsp;&nbsp;").replace(/</g, "&lt;").replace(/\n/g, "\n<br />") + "</div></span>", "info", null, null, null, true);

        var doIt = function(){
            var x = eval(code);

            if (x === null)
                x = "null";
            else if (x === undefined)
                x = "undefined";

            try {
                var str;
                if (x.nodeType) {
                    if (x.serialize)
                        str = x.serialize();
                    else if (x.style)
                        str = x.outerHTML
                    else
                        str = apf.getCleanCopy(x).xml;
                }
                else str = x.toString();
                
                apf.console.write(str
                    .replace(/</g, "&lt;")
                    .replace(/\n/g, "\n<br />"), "info", null, null, null, true);
            }catch(e){
                apf.console.write(x
                    ? "Could not serialize object"
                    : x, "error", null, null, null, true);
            }
        }

        if (apf.debugwin.useDebugger)
            doIt();
        else {
            try{
                doIt();
            }
            catch(e) {
                apf.console.write(e.message, "error", null, null, null, true);
            }
        }
    },

    consoleTextHandler: function(e) {
        if (!e) e = window.event;
        var oArea = e.target || e.srcElement;
        if (e.keyCode == 9) {
            document.getElementById("apfDebugExec").focus();
            e.cancelBubble = true;
            return false;
        }
        else if(e.keyCode == 13 && e.ctrlKey) {
            apf.debugwin.jRunCode(oArea.value);
            return false;
        }
    },

    btnMouseDown: function(oBtn) {
        oBtn.className = oBtn.className.replace("debug_btn_down", "")
            + " debug_btn_down";
    },

    btnMouseUp: function(oBtn) {
        oBtn.className = "debug_btn"
            + ((oBtn.className.indexOf('right') > -1) ? " debug_btnright" : "");
    },

    consoleBtnHandler: function(e) {
        if (!e) e = window.event;
        if (e.shiftKey && e.keyCode == 9) {
            e.cancelBubble = true;
            return false;
        }
    },

    consoleExecHandler: function(e) {
        if (!e) e = window.event;
        if (e.shiftKey && e.keyCode == 9) {
            document.getElementById("apfDebugExpr").focus();
            e.cancelBubble = true;
            return false;
        }
    },

    showLogWindow : function (checked){
        apf.console.showWindow();
    },

    toggleHighlighting : function (checked){
        apf.setcookie("highlight", checked);
    },

    toggleDebugger : function(checked){
        this.useDebugger = checked;

        if (apf.setcookie)
            apf.setcookie("debugger", checked)

        if (!checked) {
            if (!apf.loaded && typeof oldWinError == "object")
                oldWinError = this.errorHandler;
            else
                window.onerror = this.errorHandler;
        }
        else
            window.onerror = null;
    },

    errorHandler : function(message, filename, linenr, isForced){
        if (!message) message = "";

        var e = message 
            ? {
                message : message.indexOf("aml file") > -1
                    ? message
                    : "js file: [line: " + linenr + "] "
                        + apf.removePathContext(apf.hostPath, filename) + "\n" + message
            }
            : null;

        if (!isForced) {
            apf.console.error("[line " + linenr + "] " + message
                .split(/\n\n===\n/)[0].replace(/</g, "&lt;")
                .replace(/\n/g, "\n<br />"));
        }

        apf.debugwin.show(e, filename, linenr);

        return true;
    },

    activate : function(msg){
        //apf.debugwin.toggleDebugger(false);

        if (document.getElementById("apf_debugwin")) {
            if (apf.isIE8) {
                document.body.style.overflow = "auto";
                //document.body.style.position = "static";
            }
            
            document.getElementById("apf_debugwin").style.display = "block";

            
            if (apf.layout)
                apf.layout.forceResize(this.$ext);
            
        }
        else {
            apf.debugwin.errorHandler(msg, null, null, true);
        }
    }
}

/**
 * Displays the debug window. Same as pressing F9 or Ctrl-Shift-D.
 */
apf.showDebugWindow = function(){
    apf.debugwin.activate();
}




/*FILEHEAD(/var/lib/platform/source/trunk/elements/bindingrule.js)SIZE(8662)TIME(1264618245)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @define bindings element containing all the binding rules for the data 
 * bound elements referencing this element.
 * Example:
 * <code>
 *  <a:model id="mdlList">
 *      <data>
 *          <item date="2009-11-12" deleted="0"></item>
 *          <item date="2009-11-11" deleted="0"></item>
 *      </data>
 *  </a:model>
 *  <a:bindings id="bndFolders" >
 *      <a:caption match="[@date]" />
 *      <a:icon match="[@icon]" />
 *      <a:each match="[item]" sort="[@date]" />
 *  </a:bindings>
 *  <a:list 
 *    id       = "list" 
 *    width    = "200" 
 *    height   = "200" 
 *    model    = "mdlList" 
 *    bindings = "bndFolders" />
 * </code>
 * @see element.smartbinding
 *
 * @constructor
 * @apfclass
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 *
 * @default_private
 */
apf.BindingRule = function(struct, tagName){
    this.$init(tagName || true, apf.NODE_HIDDEN, struct);
};

(function(){
    this.$bindingRule = true;
    
    this.compile = function(prop){
        return (this["c" + prop] = apf.lm.compile(this[prop], {
            xpathmode  : 3,
            injectself : true
        }));
    };
    
    this.$compile = function(prop, options){
        return (this["c" + prop + "2"] = apf.lm.compile(this[prop], options));
    };

    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        value : 1,
        match : 1
    }, this.$attrExcludePropBind);

    this.$propHandlers["value"] = 
    this.$propHandlers["match"] = function(value, prop){
        delete this["c" + prop];
        
        if (this.$amlLoaded) {
            //Find parent that this rule works on
            var node = this;
            while (node && node.$bindingRule) 
                node = node.parentNode;
            
            if (!node) return;
            
            //Reload parent to propagate change
            apf.queue.add("reload" + node.$uniqueId, function(){
                node.reload();
            });
            
            //Recompile ruleset
            if (node.$bindings.$isCompiled)
                node.$bindings.$compiled = node.$bindings.compile(
                    this.localName != "each" && this.localName);
        }
    };
    
    /**** DOM Handlers ****/
    
    /*this.addEventListener("DOMAttrModified", function(e){
        
    });*/
    
    this.addEventListener("DOMNodeInserted", function(e){
        //Find parent that this rule works on
        var node = this;
        while (node.$bindingRule) 
            node = node.parentNode;
        
        //Reload parent to propagate change
        //@todo trigger should be maintained on node itself to prevent dual reload
        apf.queue.add("reload" + node.$uniqueId, function(){
            node.reload();
        });

        //If this node is added, add to set
        if (e.currentTarget == this) {
            (node.$bindings[this.localName] 
                || (node.$bindings[this.localName] = [])).push(this);
        }
        //@todo apf3.0 test if proc instr and cdata needs to be serialized
        //Else just update the binding value
        else  if (!this.attributes.getNamedItem("value"))
            this.value = apf.serializeChildren(this);
        //Or do nothing
        else return;

        //Recompile ruleset
        if (node.$bindings.$isCompiled)
            node.$bindings.$compiled = node.$bindings.compile(
                this.localName != "each" && this.localName);
    });
    
    this.addEventListener("DOMNodeRemoved", function(e){
        //Find parent that this rule works on
        var first, node = this;
        while (node && node.$bindingRule) 
            node = node.parentNode;
       
        if (!node)
            return;
       
        //If this node is removed, remove to set
        if (e.currentTarget == this) {
            if (node.$bindings && node.$bindings[this.localName])
                node.$bindings[this.localName].remove(this);
            else
                return;
        }
        //@todo apf3.0 test if proc instr and cdata needs to be serialized
        //Else just update the binding value
        else  if (!this.attributes.getNamedItem("value") && (first = this.firstChild)) {
            if (first.nodeType == this.NODE_PROCESSING_INSTRUCTION) {
                if (first.target == "lm")
                    this.value = "{" + first.nodeValue + "}";
                else
                    this.value = first.nodeValue;
            }
            else
                this.value = apf.serializeChildren(this).trim();
        }
        //Or do nothing
        else return;

        //Reload parent to propagate change
        apf.queue.add("reload" + node.$uniqueId, function(){
            node.reload();
        });

        //Recompile ruleset
        if (node.$bindings.$isCompiled)
            node.$bindings.$compiled = node.$bindings.compile(
                this.localName != "each" && this.localName);
    });

    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        
        if (!this.match && (!this.value && !this.childNodes.length && !this.get
          || this.localName == "each") || this.select) {
            throw new Error(apf.formatErrorString(0, this, "Bindingrule",
                "Missing attribute 'match'")); //@todo apf3.0 turn this into a good error
        }
        

        var first;
        if (!this.value && (first = this.$aml 
          && this.$aml.firstChild || this.firstChild)) {
            if (first.nodeType == this.NODE_PROCESSING_INSTRUCTION) {
                if (first.target == "lm")
                    this.value = "{" + first.nodeValue + "}";
                else
                    this.value = first.nodeValue;
            }
            else
                this.value = apf.serializeChildren(this.$aml).trim();
        }
        
        //Find the parent this rule works on
        var pNode = this.parentNode;
        while (pNode.$bindingRule)
            pNode = pNode.parentNode;

        //Add the rule to the set
        var bindings = pNode.$bindings || (pNode.$bindings = new apf.ruleList());
        (bindings[this.localName] || (bindings[this.localName] = [])).push(this);
        
        //Compile if necessary
        if (pNode.localName != "bindings" && (this.localName != "each" || !this.childNodes.length)) {
            var ns = this;
            while((ns = ns.nextSibling) && ns.nodeType != 1);
            
            if (!ns || !ns.$bindingRule) {
                pNode.$cbindings = pNode.$bindings.compile(
                  pNode.$bindings.$isCompiled ? this.localName : null);
                
                pNode.dispatchEvent("bindingsload", {
                    bindings: pNode.$bindings, 
                    compiled: pNode.$cbindings
                });
                pNode.$checkLoadQueue();
            }
        }
    });
}).call(apf.BindingRule.prototype = new apf.AmlElement());

apf.aml.setElement("icon",       apf.BindingRule);
apf.aml.setElement("image",      apf.BindingRule);
apf.aml.setElement("caption",    apf.BindingRule);
apf.aml.setElement("css",        apf.BindingRule);
apf.aml.setElement("selectable", apf.BindingRule);
apf.aml.setElement("value",      apf.BindingRule);
apf.aml.setElement("src",        apf.BindingRule);
apf.aml.setElement("collapsed",  apf.BindingRule);
apf.aml.setElement("empty",      apf.BindingRule);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/toc.js)SIZE(8289)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Element acting as the navigational instrument for any
 * element based on BaseTab. This element displays buttons
 * which can be used to navigate the different pages of for instance
 * a submitform or pages element. This element is page validation
 * aware and can display current page progress when connected to
 * a submitform.
 *
 * @constructor
 * @define toc
 * @addnode elements
 *
 * @inherits apf.Presentation
 * @todo test if this element still works with the refactored basetab
 *    
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 */
apf.toc = function(struct, tagName){
    this.$init(tagName || "toc", apf.NODE_VISIBLE, struct);
};

(function(){
    /**** Properties and Attributes ****/
    
    this.$supportedProperties.push("represent");

    /**
     * @attribute {String} represent the id of the element to display 
     * navigation for.
     */
    this.$propHandlers["represent"] = function(value){
        var _self = this;
        $setTimeout(function(){
            var amlNode = _self.$represent = self[value];

            amlNode.addEventListener("afterswitch", function(e){
                _self.$setActivePage(e.nextId);
            });
            
            if (amlNode.$drawn) {
                _self.$createReflection();
            }
            else {
                amlNode.$amlLoaders.push(function(){
                    toc.$createReflection();
                });
            }
        });
    }
    
    /**** Public methods ****/
    
    /**
     * Navigates to a page of the represented element.
     * @param {Number} nr the child number of the page to activate.
     */
    this.gotoPage = function(nr){
        if (this.disabled) return false;

        if (this.$represent.isValid && !this.$represent.testing) {
            var i, test,
                pages        = this.$represent.getPages(),
                activepagenr = this.$represent.activepagenr;
            for (i = activepagenr; i < nr; i++) {
                pages[i].$ext.style.position = "absolute"; //hack
                pages[i].$ext.style.top      = "-10000px"; //hack
                pages[i].$ext.style.display  = "block"; //hack
                test = !this.$represent.isValid || this.$represent
                    .isValid(i < activepagenr, i < activepagenr, pages[i]);
                //false, activepagenr == i, pages[i], true);
                pages[i].$ext.style.display  = ""; //hack
                pages[i].$ext.style.position = ""; //hack
                pages[i].$ext.style.top      = ""; //hack
                pages[i].$ext.style.left     = ""; //hack
                pages[i].$ext.style.width    = "1px";
                pages[i].$ext.style.width    = "";
    
                if (!test)
                    return this.$represent.set(i);
            }
        }
        
        if (this.$represent.showLoader)
            this.$represent.showLoader(true, nr); 

        var _self = this;
        $setTimeout(function(){
            _self.$represent.set(nr);
        }, 1);
        //setTimeout("apf.lookup(" + this.$represent.$uniqueId + ").set(" + nr + ");", 1);
    };
    
    /**** Private Methods ****/
    
    this.$setActivePage = function(active){
        if (this.disabled) return false;

        //Find previous known index and make sure it has known indexes after
        if (!this.pagelookup[active]) {
            var page, last, is_between;
            for (page in this.pagelookup) {
                if (page < active)
                    last = page;
                if (page > active)
                    is_between = true;
            }
            if (!last || !is_between) return; //exit if there are no known indices
            active = last;
        }

        for (var isPast = true, i = 0; i < this.pages.length; i++) {
            if (this.pagelookup[active] == this.pages[i]) {
                this.$setStyleClass(this.pages[i], "present", ["future", "past", "hover"]);
                isPast = false;
            }
            else if (isPast) {
                    this.$setStyleClass(this.pages[i], "past", ["future", "present",]);
            }
            else {
                this.$setStyleClass(this.pages[i], "future", ["past", "present"]);
            }
            
            if (i == this.pages.length - 1)
                this.$setStyleClass(this.pages[i], "last");
        }
    };
    
    this.$createReflection = function(){
        var i, oCaption, oPage,
            l     = {},
            pages = this.$represent.getPages(),
            l2    = pages.length,
            p     = [];
        
        for (i = 0; i < l2; i++) {
            this.$getNewContext("page");
            oCaption = this.$getLayoutNode("page", "caption");
            oPage    = this.$getLayoutNode("page");
            this.$setStyleClass(oPage, "page" + i);
            
            oPage.setAttribute("onmouseover", 'apf.lookup(' + this.$uniqueId 
                + ').$setStyleClass(this, "hover", null);');
            oPage.setAttribute("onmouseout", 'apf.lookup(' + this.$uniqueId 
                + ').$setStyleClass(this, "", ["hover"]);');
            
            if(!pages[i].getAttribute("caption")){
                
                apf.console.warn("Page element without caption found.");
                
                //continue;
            }
            else {
                apf.setNodeValue(oCaption, 
                    pages[i].getAttribute("caption") || "");
            }

            oPage.setAttribute("onmousedown", "setTimeout(function(){\
                    apf.lookup(" + this.$uniqueId + ").gotoPage(" + i + ");\
                });");
            p.push(apf.insertHtmlNode(oPage, this.$int));
            l[i] = p[p.length - 1];
        }
        
        //xmldb.htmlImport(p, this.$int);
        this.pages      = p;
        this.pagelookup = l;
        
        this.$setActivePage(0);
        
        
        if (apf.isGecko) {
            var tocNode = this;
            $setTimeout(function(){
                tocNode.$ext.style.height = tocNode.$ext.offsetHeight + 1 + "px";
                tocNode.$ext.style.height = tocNode.$ext.offsetHeight - 1 + "px";
            }, 10);
        }
        
    };
    
    /**** Init ****/
    
    this.$draw = function(){
        //Build Main Skin
        this.$ext     = this.$getExternal(); 
        this.oCaption = this.$getLayoutNode("main", "caption", this.$ext);
        this.$int     = this.$getLayoutNode("main", "container", this.$ext);
    };

    
    this.addEventListener("DOMNodeInsertedIntoDocument", function() {
        if (!this.represent) {
            throw new Error(apf.formatErrorString(1013, this, 
                "Find representation", 
                "Could not find representation for the Toc: '" 
                + this.name + "'", this));
        }
    });
    
}).call(apf.toc.prototype = new apf.Presentation());

apf.aml.setElement("toc", apf.toc);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/portal.js)SIZE(24937)TIME(1264772818)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element displaying a rectangle consisting of one or more columns
 * which contain zero or more windows. Each window is loaded with specific
 * content described in aml. Each of these so-called 'docklets'
 * can have specific data loaded from a datasource and can
 * be instantiated more than once.
 * Example:
 * <code>
 *  <a:portal columns="60%,40%">
 *      <a:bindings>
 *          <a:src select="@src" />
 *          <a:collapsed select="@collapsed" default="0" />
 *          <a:icon value="icoDocklet.png" />
 *          <a:column select="@column" />
 *          <a:caption select="@name" />
 *          <a:each select="docklet" />
 *      </a:bindings>
 *      <a:model>
 *          <docklets>
 *              <docklet name="Usage"    src="usage.xml"    column="0" />
 *              <docklet name="Billing"  src="history.xml"  column="0" />
 *              <docklet name="Orders"   src="orders.xml"   column="1" />
 *              <docklet name="Features" src="features.xml" column="1" />
 *          </docklets>
 *      </a:model>
 *  </a:portal>
 * </code>
 * Remarks:
 * A docklet xml is a piece of aml that should be in the following form:
 * <code>
 *  <a:docklet xmlns:a="http://ajax.org/2005/aml" 
 *    caption="Billing History" icon="icoBilling.gif" name="BillHistory">
 *      <a:script><![CDATA[
 *          function BillHistory(){
 *              this.$init();
 *
 *              this.$create = function(xmlSettings, oDocklet){
 *                  //Process xml settings
 *              }
 *          }
 *          BillHistory.prototype = new apf.portal.Docklet();
 *      ]]></a:script>
 *
 *      <!-- the edit panel of the window -->
 *      <a:config>
 *          ...
 *      </a:config>
 *
 *      <!-- the body of the window -->
 *      <a:body>
 *          ...
 *      </a:body>
 *  </a:docklet>
 * </code>
 *
 * @constructor
 * @allowchild {smartbinding}
 * @addnode elements:portal
 *
 * @inherits apf.MultiSelect
 * @inherits apf.DataAction
 * @inherits apf.Cache
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.9
 *
 * @binding src       Determines the data instruction that loads the docklet from it's datasource.
 * @binding collapsed Determines whether the docklet is collapsed after init.
 * @binding icon      Determines the icon of the docklet.
 * @binding column    Determines the column in which the docklet is created.
 * @binding caption   Determines the caption of the docklet.
 */
apf.portal = function(struct, tagName){
    this.$init(tagName || "portal", apf.NODE_VISIBLE, struct);
    
    this.$columns   = [];
};

(function(){
    this.implement(
        //apf.Cache,
        
        apf.DataAction
        
    );

    this.$focussable     = false;
    this.buttons         = "edit|min|close";

    this.$deInitNode = function(xmlNode, htmlNode){
        cacheDocklet.call(this, apf.findHost(htmlNode));
    };

    this.$updateNode = function(xmlNode, htmlNode){
        var docklet = apf.findHost(htmlNode);
        docklet.setProperty("buttons", this.$applyBindRule("buttons", xmlNode) || "");
        docklet.draggable = this.$applyBindRule("draggable", xmlNode);
    };

    this.$moveNode = function(xmlNode, htmlNode){
        if (!htmlNode)
            return;
    };
    this.select = function(){}
    
    this.findColumnNr = function(x, y){
        var el = document.elementFromPoint(x, y);

        //search for element
        while (!el.isColumn && el.parentNode) {
            el = el.parentNode;
        }

        return el.isColumn && this.$columns.indexOf(el) || 0;
    }
    
    this.$moveDocklet = function(docklet) {
        var colNr = this.$columns.indexOf(docklet.$ext.parentNode) || 0;
        
        var dataNode = docklet.dataNode;
        
        //@todo hacky, should be via executeAction
        dataNode.setAttribute("column", colNr);
        
        //more hack stuff
        //determine docklet xml position by the html position
        var nr = apf.xmldb.getChildNumber(docklet.oExt), 
        	  nodes = dataNode.selectNodes("../node()[@column='" + colNr + "']");
        if (nodes[nr] != dataNode) {
        		var jmlNode = apf.findHost(docklet.oExt.nextSibling);
        		dataNode.parentNode.insertBefore(dataNode, jmlNode && jmlNode.dataNode || null);
        }
        
        this.dispatchEvent("widgetmove");
    }
    
    this.columns = "33.33%,33.33%,33.33%";
    this.$columnWidths  = this.columns.splitSafe(",");
    
     /**
     * @attribute {String} columns a comma seperated list of column sizes.
     * A column size can be specified in a number (size in pixels) or using
     * a number and a % sign to indicate a percentage.
     * Defaults to "33%, 33%, 33%".
     * Example:
     * <code>
     *  <a:portal columns="25%, 50%, 25%">
     *      ...
     *  </a:portal>
     * </code>
     *
     * @todo make this dynamic
     */
    this.$propHandlers["columns"] = function(value){
        if (!value) return;
        this.$columnWidths = value.splitSafe(",");

        var col, nodes, pHtmlNode, amlNode, node;
        while (this.$columns.length > this.$columnWidths.length) {
            col = this.$columns.pop();
            col.host = null;
            
            nodes = col.childNodes
            pHtmlNode = this.$columns[0];
            for (var i = nodes.length - 1; i >= 0; i--) {
                if ((node = nodes[i]).nodeType != 1)
                    continue;
                    
                pHtmlNode.appendChild(node);
                amlNode = apf.findHost(node);
                amlNode.$pHtmlNode = pHtmlNode;
                amlNode.dataNode.setAttribute("column", 0); //@todo wrong!! apf3.0
            }

            apf.destroyHtmlNode(col);
        }
        
        for (var last, col, size, i = 0; i < this.$columnWidths.length; i++) {
            size = this.$columnWidths[i];
            if (!this.$columns[i]) {
                this.$getNewContext("column");
                col = apf.insertHtmlNode(this.$getLayoutNode("column"), this.$int, this.$int.lastChild);
                this.$columns.push(col);
        
                col.isColumn = true;
                col.host = this;
            }
            else {
                col = this.$columns[i];
                this.oInt.insertBefore(col, this.oInt.lastChild);
            }
            
            this.$setStyleClass(col, (last = (i == this.$columnWidths.length - 1)) 
                ? "collast" : "", ["collast"]);

            size.match(/(%|px|pt)/);
            var unit = RegExp.$1 || "px";
            col.style.width = (parseInt(size) - (apf.isIE && apf.isIE < 8 && last ? 1 : 0)) + unit;
        }
    }

    /**** Keyboard support ****/

    //Handler for a plane list
    
    this.addEventListener("keydown", function(e){
        var key      = e.keyCode;
        var ctrlKey  = e.ctrlKey;
        var shiftKey = e.shiftKey;
        var altKey   = e.altKey;

        if (!this.selected)
            return;

        switch (key) {
            default:
                break;
        }
    }, true);
    

    /**** Databinding and Caching ****/

    function cacheDocklet(docklet){
        var srcUrl = docklet.$srcUrl;
        if (!srcUrl)
            throw new Error("Something went terribly wrong"); //@todo

        if (docklet.$dockletClass.$unload)
            docklet.$dockletClass.$unload();

        //Cache settings panel
        var amlNodes = [], amlNode, widget = docklet_cache[srcUrl];
        if (docklet.oSettings) {
            var nodes = docklet.oSettings.childNodes;
            while(nodes.length) {
                amlNode = apf.findHost(widget.fragSettings.appendChild(nodes[0]));
                if (amlNode)
                    amlNodes.push(amlNode.removeNode(null, true));
            }
        }
        
        //Cache oInt
        var nodes = docklet.$int.childNodes;
        while(nodes.length) {
            amlNode = apf.findHost(widget.fragInt.appendChild(nodes[0]));
            if (amlNode) 
                amlNodes.push(amlNode.removeNode(null, true));
        }
        var nodes = docklet.childNodes;
        for (var i = nodes.length - 1; i >= 0; i--)
            amlNodes.push(nodes[i].removeNode(null, true));
        
        widget.amlNodes = amlNodes;
        docklet.oSettings = docklet.$int = null;
        docklet.childNodes = [];//@todo hack!! apf3.0 - the childNodes array isnt cleaned correctly. The parsing sees this as that all the children are already rendered
        dockwin_cache.push(docklet);
        
        //Remove from document
        docklet.parentNode = null;
        docklet.$ext.parentNode.removeChild(docklet.$ext);
        
        return srcUrl;
    }

    this.$getCurrentFragment = function(){
        var fr, col, fragment = [];
        for (var i = 0, l = this.$columns.length; i < l; i++) {
            col = this.$columns[i];
            for (var j = col.childNodes.length -1; j >= 0; j--) {
                if (col.childNodes[j].nodeType != 1)
                    continue;
                
                fragment.push(cacheDocklet.call(this, apf.findHost(col.childNodes[j])));
            }
        }

        return fragment;
    };

    this.$setCurrentFragment = function(fragment){
        var dataNode, pHtmlNode, srcUrl, docklet, nodes = this.getTraverseNodes();
        for (var i = 0, l = nodes.length; i < l; i++) {
            dataNode  = nodes[i];
            pHtmlNode = this.$columns[this.$applyBindRule("column", dataNode) || 0];
            srcUrl    = this.$applyBindRule("src", dataNode) || "file:"
                        + this.$applyBindRule("url", dataNode);
            docklet   = getDockwin.call(this, dataNode, pHtmlNode);
            createWidget.call(this, srcUrl, null, docklet, dataNode); //assuming cache
        }
    };

    var oEmpty;
    this.$setClearMessage = function(msg){
         if (!oEmpty) {
            if (!this.$hasLayoutNode("empty"))
                return;
            
            this.$getNewContext("empty");

            var xmlEmpty = this.$getLayoutNode("empty");
            if (!xmlEmpty) return;

            oEmpty = apf.insertHtmlNode(xmlEmpty, this.$int);
        }
        else {
            this.$int.appendChild(oEmpty);
        }
        
        var empty  = this.$getLayoutNode("empty", "caption", oEmpty);
        if (empty)
            apf.setNodeValue(empty, msg || "");
        if (oEmpty)
            oEmpty.setAttribute("id", "empty" + this.$uniqueId);
    };

    this.$removeClearMessage = function(){
        var oEmpty = document.getElementById("empty" + this.$uniqueId);
        if (oEmpty)
            oEmpty.parentNode.removeChild(oEmpty);
        //else this.$int.innerHTML = ""; //clear if no empty message is supported
    };

    var docklet_cache = {};
    function createWidget(srcUrl, strXml, docklet, dataNode){
        var widget;
        //Caching
        while(widget = docklet_cache[srcUrl]) {
            if (!widget.fragInt.childNodes.length)
                srcUrl += "_";
            else break;
        }
        
        if (!widget && !strXml) {
            srcUrl = "error";
            widget = docklet_cache["error"];
        }

        docklet.$getLayoutNode("main", "container", docklet.$ext)
            .innerHTML = "";
        docklet.$srcUrl = srcUrl;

        if (widget) {
            var xmlNode = widget.xmlNode;
            
            if (xmlNode.getAttribute("width"))
                docklet.setProperty("width", xmlNode.getAttribute("width"));
            else
                docklet.$ext.style.width = "auto";
            
            docklet.oSettings = docklet.$getLayoutNode("main", "settings_content", docklet.$ext);
            docklet.$int = docklet.$getLayoutNode("main", "container", docklet.$ext);
            
            docklet.$int.appendChild(widget.fragInt);
            if (docklet.oSettings)
                docklet.oSettings.appendChild(widget.fragSettings);
            
            var amlNodes = widget.amlNodes || [];//@todo temp workaround apf3.0
            for (var i = 0, l = amlNodes.length; i < l; i++)
                if (amlNodes[i].hasFeature)
                    docklet.appendChild(amlNodes[i], null, true);
            
            docklet.$dockletClass = widget.dockletClass;
            
            if (widget.dockletClass.load)
                widget.dockletClass.load(dataNode, docklet);
        }
        else {
            var uId = apf.all.length;
            var col = [];
            strXml = strXml.replace(/\b(id|actiontracker|group)="([^"]*)"|\b(id|actiontracker|group)='([^']*)''/g, 
              function(m, n1, id1, n2, id2){
                var id = id1 || id2;
                col.push(id);
                if (id1) return n1 + '="' + id + "_" + uId + '"';
                if (id2) return n2 + "='" + id + "_" + uId + "'";
              });
            //@todo make the id's regexp safe
            if (col.length) {
                strXml = strXml.replace(new RegExp("\\b(" + col.join("|") + ")\\b", "g"), 
                  function(m, id){
                    return id + "_" + uId;
                  });
            }
            
            var dockletWidget = this.ownerDocument.$domParser.parseFromString(strXml, "text/xml", {
                //nodelay  : true,
                docFrag  : docklet,
                doc      : docklet.ownerDocument,
                htmlNode : docklet.$int
            }).firstChild;
            
            var name = dockletWidget.name;
    
            if (dockletWidget.width)
                docklet.setProperty("width", dockletWidget.width);
            else
                docklet.$ext.style.width = "auto";
    
            //Create dockletClass
            if (!self[name])
                throw new Error("could not find docklet class '" + name + "'"); //@todo proper error apf3.0
    
            //instantiate class
            var dockletClass = new self[name]().$init();
            this.docklets.push(dockletClass);
            dockletClass.create(dataNode, docklet, this);
            if (dockletClass.load)
                dockletClass.load(dataNode, docklet);
            
            docklet.$dockletClass = dockletClass;
            
            docklet_cache[srcUrl] = {
                srcUrl       : srcUrl,
                xmlNode      : dockletWidget.$aml,
                fragInt      : document.createDocumentFragment(),
                fragSettings : document.createDocumentFragment(),
                dockletClass : dockletClass
            };
        }

        docklet.$refParent = this.$int;
    }
    
    var dockwin_cache = [];
    function getDockwin(dataNode, pHtmlNode){
        var docklet;
        
        var columns = this.$applyBindRule("columns", this.xmlRoot);
        if (columns != this.columns) {
            this.setProperty("columns", columns);
            pHtmlNode = this.$columns[this.$applyBindRule("column", dataNode) || 0];
        }
        
        if (docklet = dockwin_cache.pop()) {
            docklet.parentNode = this;
            pHtmlNode.appendChild(docklet.$ext);
            docklet.$pHtmlNode = pHtmlNode;
            //docklet.setProperty("skin", this.$applyBindRule("skin", dataNode) || "docklet"); //@todo (apf3.0) or something like that
            
            var skin = this.$applyBindRule("dockskin", dataNode) || "docklet";
            //if(skin == "dockblank") debugger;
            if (docklet.skin != skin)
                docklet.$forceSkinChange(docklet.skin = skin);
            docklet.show();
        }
        //Creating
        else {
            //, null, true
            docklet = new apf.modalwindow({
                htmlNode  : pHtmlNode,
                skinset   : apf.getInheritedAttribute(this.parentNode, "skinset"),
                skin      : this.$applyBindRule("dockskin", dataNode) || "docklet",
                draggable : true,
                visible   : true
            });
            docklet.implement(apf.modalwindow.widget);
            docklet.parentNode = this;
            
            docklet.$create();
            
            docklet.addEventListener("beforestatechange", function(e){
                if (e.to.maximized)
                    docklet.$ext.parentNode.style.zIndex = 100000;
                
                return this.$dockletClass.dispatchEvent("beforestatechange", e);
            });
            docklet.addEventListener("afterstatechange", function(e){
                if (e.from.maximized)
                    docklet.$ext.parentNode.style.zIndex = 1;
                
                this.$dockletClass.dispatchEvent("afterstatechange", e);

                if (e.to.closed)
                    this.remove(this.dataNode);
            });
        }
        
        docklet.dataNode = dataNode;
        apf.xmldb.nodeConnect(apf.xmldb.getXmlDocId(dataNode), dataNode, docklet.$ext, this)
        
        if (this.$hasBindRule("buttons"))
            docklet.setProperty("buttons", this.$applyBindRule("buttons", dataNode) || this.buttons);
        docklet.setProperty("state", this.$applyBindRule("state", dataNode) || "normal");
        docklet.setProperty("title", this.$applyBindRule("caption", dataNode));
        docklet.setProperty("icon", this.$applyBindRule("icon", dataNode));
        
        docklet.show();
        
        return docklet;
    }
    
    //@todo hack to prevent oInt.innerHTML to be cleared
    this.$clear = function(){}

    this.docklets     = [];
    var xml_cache     = {};
    this.$add = function(dataNode, Lid, xmlParentNode, htmlParentNode, beforeNode){
        //Build window
        var pHtmlNode = this.$columns[this.$applyBindRule("column", dataNode) || 0];
        var srcUrl = this.$applyBindRule("src", dataNode) || "file:"
            + this.$applyBindRule("url", dataNode);

        //@todo this should be much nicer
        if (!pHtmlNode) {
            var cols = this.$applyBindRule("columns", this.xmlRoot)
            if (cols && cols != this.columns)
                this.setProperty("columns", cols);
            pHtmlNode = this.$columns[this.$applyBindRule("column", dataNode) || 0];
            
            if (!pHtmlNode) //@todo
                throw new Error(apf.formatErrorString(0, this, "Building docklet",
                    "Cannot find column to hook docklet on. Seems like a timing error"));
        }

        var docklet = getDockwin.call(this, dataNode, pHtmlNode);

        if (xml_cache[srcUrl]) {
            var strXml = xml_cache[srcUrl];
            createWidget.call(this, srcUrl, strXml, docklet, dataNode);
        }
        else {
            //@todo add loading to window
            docklet.$getLayoutNode("main", "container", docklet.$ext)
                .innerHTML = "<div class='loading'>Loading...</div>";
            
            //@todo this should be getData (apf3.0)
            var model = new apf.model(), _self = this;
            model.$loadFrom(srcUrl, {callback: function(data, state, extra){
                //if (this.isLoaded)
                    //return true;

                //@todo retry
                if (!data || state != apf.SUCCESS) {
                    createWidget.call(_self, "error", "<a:docklet xmlns:a='" + apf.ns.apf + "' name='dockerror'>\
                        <a:script><![CDATA[\
                            function dockerror(){\
                                this.init = this.load = function(x,d){\
                                    d.setAttribute('buttons', '');\
                                    d.setAttribute('icon', '');\
                                    d.setAttribute('title', 'Error')\
                                }\
                            }\
                        ]]></a:script>\
                        <a:body>\
                            <a:label style='margin:0 auto 0 auto'>Error loading this widget</a:label>\
                        </a:body>\
                    </a:docklet>", docklet, dataNode);
                    
                    return true;
                }

                //hmmm this is not as optimized as I'd like (going through the xml parser twice)
                var strXml = data;//xmlNode.xml || xmlNode.serialize();

                
                if (apf.isSafariOld) {
                    strXml = strXml.replace(/name/, "name='"
                        + xmlNode.getAttribute("name") + "'");
                    xml_cache[srcUrl] = strXml;
                }
                else 
                
                {
                    xml_cache[srcUrl] = strXml;//xmlNode.cloneNode(true);
                }

                createWidget.call(_self, srcUrl, strXml, docklet, dataNode);
                this.isLoaded = true;
            }});
        }
    };

    this.$fill = function(){
        
    };
    
    this.addEventListener("beforeload", function(e){
        if (!this.$columns.length) {
            var cols = this.$applyBindRule("columns", e.xmlNode)
            if (cols && cols != this.columns)
                this.setProperty("columns", cols);
        }
    });
    
    this.addEventListener("xmlupdate", function(e){
        //if (e.action.match(/add|insert|move/))
            //apf.AmlParser.parseLastPass();
        
        var cols = this.$applyBindRule("columns", this.xmlRoot)
        if (cols && cols != this.columns)
            this.setProperty("columns", cols);
    });

    this.$selectDefault = function(xmlNode){
        if (this.select(this.getFirstTraverseNode(xmlNode), null, null, null, true))
            return true;
        else {
            var nodes = this.getTraverseNodes(xmlNode);
            for(var i = 0; i < nodes.length; i++) {
                if (this.$selectDefault(nodes[i]))
                    return true;
            }
        }
    };

    /**** Init ****/

    this.$draw = function(){
        //Build Main Skin
        this.$ext = this.$getExternal();
        this.$int = this.$getLayoutNode("main", "container", this.$ext);
    };

    this.$loadAml = function(x){
        if (document.elementFromPointAdd)
            document.elementFromPointAdd(this.$ext);
    };

}).call(apf.portal.prototype = new apf.MultiSelect());


apf.aml.setElement("portal",    apf.portal);
apf.aml.setElement("src",       apf.BindingRule);
apf.aml.setElement("column",    apf.BindingRule);
//apf.aml.setElement("state",     apf.BindingRule);
apf.aml.setElement("draggable", apf.BindingRule);
apf.aml.setElement("dockskin",  apf.BindingRule);
apf.aml.setElement("buttons",   apf.BindingRule);
apf.aml.setElement("caption",   apf.BindingRule);
apf.aml.setElement("traverse",  apf.BindingRule);

/**
 * @constructor
 */
apf.portal.Docklet = function(){}
apf.portal.Docklet.prototype = new apf.Class();
apf.portal.Docklet.prototype.create = function(xmlSettings, oWidget, oPortal){
    this.xmlSettings = xmlSettings
    this.oWidget = oWidget;

    if (this.$create)
        this.$create(xmlSettings, oWidget, oPortal);
};




/*FILEHEAD(/var/lib/platform/source/trunk/elements/audio.js)SIZE(12970)TIME(1264464063)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element that is able to play an audio file or remote stream
 * Example:
 * <code>
 *  <a:audio id="myAudio"
 *   src      = "http://my-mediaserver.com/demo.mp3"
 *   autoplay = "true"
 *   volume   = "20">
 *    Audio Codec not supported.
 *  </a:audio>
 * </code>
 * 
 * @return {Audio} Returns a new audio
 * @type {Audio}
 * @inherits apf.Media
 * @constructor
 * @allowchild {text}
 * @addnode elements:audio
 *
 * @link http://www.whatwg.org/specs/web-apps/current-work/#audio
 *
 * @author      Mike de Boer
 * @version     %I%, %G%
 * @since       1.0
 */
apf.audio = function(struct, tagName){
    this.$init(tagName || "audio", apf.NODE_VISIBLE, struct);
};

(function() {
    this.$supportedProperties.push("waveform", "peak", "EQ", "ID3");

    this.$mainBind = "src";

    /**
     * Load a audio by setting the URL pointer to a different audio file
     *
     * @param {String} sAudio
     * @type {Object}
     */
    this.loadMedia = function() {
        if (!this.player) return this;

        this.setProperty("currentSrc",   this.src);
        this.setProperty("networkState", apf.Media.NETWORK_LOADING);
        this.player.load(this.src);
        return this;
    };

    /**
     * Seek the audio to a specific position.
     *
     * @param {Number} iTo The number of seconds to seek the playhead to.
     * @type {Object}
     */
    this.seek = function(iTo) {
        if (this.player && iTo >= 0 && iTo <= this.duration)
            this.player.seek(iTo);
    };

    /**
     * Set the volume of the audio to a specific range (0 - 100)
     *
     * @param {Number} iVolume
     * @type {Object}
     */
    this.setVolume = function(iVolume) {
        if (this.player)
            this.player.setVolume(iVolume);
    };

    /**
     * Guess the mime-type of a audio file, based on its filename/ extension.
     *
     * @param {String} path
     * @type {String}
     */
    this.$guessType = function(path) {
        // make a best-guess, based on the extension of the src attribute (file name)
        var ext  = path.substr(path.lastIndexOf(".") + 1),
            type = "";
        if (apf.hasAudio && ((ext == "ogg" || ext == "wav") || (ext == "mp3" && apf.isWebkit)))
            type = "audio/ogg";
        else if (ext == "mp3")
            type = "audio/flash";

        return type;
    };

    /**
     * Find the correct audio player type that will be able to playback the audio
     * file with a specific mime-type provided.
     *
     * @param {String} mimeType
     * @type {String}
     */
    this.$getPlayerType = function(mimeType) {
        if (!mimeType) return null;

        var playerType = null;

        var aMimeTypes = mimeType.splitSafe(",");
        if (aMimeTypes.length == 1)
            aMimeTypes = aMimeTypes[0].splitSafe(";");

        for (var i = 0, l = aMimeTypes.length; i < l; i++) {
            if (mimeType.indexOf("ogg") > -1)
                playerType = "TypeNative";
            if (mimeType.indexOf("flash") > -1)
                playerType = "TypeFlash";
            else if (mimeType.indexOf("quicktime") > -1)
                playerType = "TypeQT";
            else if (mimeType.indexOf("wmv") > -1)
                playerType = apf.isMac ? "TypeQT" : "TypeWmp";
            else if (mimeType.indexOf("silverlight") > -1)
                playerType = "TypeSilverlight";

            if (this.$isSupported(playerType))
                return playerType;
        }

        return playerType;
    };

    /**
     * Checks if a specified playerType is supported by JPF or not...
     *
     * @param {String} [playerType]
     * @type {Boolean}
     */
    this.$isSupported = function(playerType) {
        playerType = playerType || this.playerType;
        return (apf.audio[playerType]
            && apf.audio[playerType].isSupported());
    };

    /**
     * Initialize and instantiate the audio player provided by getPlayerType()
     *
     * @type {Object}
     */
    this.$initPlayer = function() {
        this.player = new apf.audio[this.playerType](this, this.$ext, {
            src         : this.src,
            width       : this.width,
            height      : this.height,
            autoLoad    : true,
            autoPlay    : this.autoplay,
            showControls: this.controls,
            volume      : this.volume,
            mimeType    : this.type
        });
        return this;
    };

    /**
     * The 'init' event hook is called when the player control has been initialized;
     * usually that means that the active control (flash, QT or WMP) has been loaded
     * and is ready to load a file.
     * Possible initialization errors are also passed to this function.
     *
     * @param {Object} e Event data, specific to this hook, containing player data.
     * @type {void}
     */
    this.$initHook = function(e) {
        if (e.error) {
            var oError = this.MediaError(e.error);
            if (this.dispatchEvent("error", {
                error  : oError,
                bubbles: true
              }) === false)
                throw oError;
        }

        this.loadMedia();
    };

    /**
     * The 'cuePoint' event hook is called when the player has set a cue point in
     * the audio file.
     *
     * @ignore
     * @type {void}
     */
    this.$cuePointHook = function() {}; //ignored

    /**
     * The 'playheadUpdate' event hook is called when the position of the playhead
     * that is currently active (or 'playing') is updated.
     * This feature is currently handled by {@link element.audio.method.$changeHook}
     *
     * @ignore
     * @type {void}
     */
    this.$playheadUpdateHook = function() {}; //ignored

    /**
     * The 'error' event hook is called when an error occurs within the internals
     * of the player control.
     *
     * @param {Object} e Event data, specific to this hook, containing player data.
     * @type {void}
     */
    this.$errorHook = function(e) {
        apf.console.log("Error: <audio>");
        apf.console.error(e.error);
    };

    /**
     * The 'progress' event hook is called when the progress of the loading sequence
     * of an audio file is updated. The control signals us on how many bytes are
     * loaded and how many still remain.
     *
     * @param {Object} e Event data, specific to this hook, containing player data.
     * @type {void}
     */
    this.$progressHook = function(e) {
        // bytesLoaded, totalBytes
        this.setProperty("bufferedBytes", {start: 0, end: e.bytesLoaded, length: e.bytesLoaded});
        this.setProperty("totalBytes", e.totalBytes);
        var iDiff = Math.abs(e.bytesLoaded - e.totalBytes);
        if (iDiff <= 20)
            this.setProperty("readyState", apf.Media.HAVE_ENOUGH_DATA);
    };

    /**
     * The 'stateChange' event hook is called when the internal state of a control
     * changes. The state of internal properties of an audio control may be
     * propagated through this function.
     *
     * @param {Object} e Event data, specific to this hook, containing player data.
     * @type {void}
     */
    this.$stateChangeHook = function(e) {
        //for audio, we only use this for connection errors: connectionError
        if (e.state == "connectionError") {
            this.networkState = apf.Media.HAVE_NOTHING;
            //this.setProperty("readyState", this.networkState);
            this.$propHandlers["readyState"].call(this, this.networkState);
        }
    };

    /**
     * The 'change' event hook is called when a) the volume level changes or
     * b) when the playhead position changes.
     *
     * @param {Object} e Event data, specific to this hook, containing player data.
     * @type {void}
     */
    this.$changeHook = function(e) {
        if (typeof e.volume != "undefined") {
            this.volume = e.volume;
            this.muted  = (e.volume > 0);
            this.setProperty("volume", e.volume);
        }
        else {
            this.duration = this.player.getTotalTime();
            this.position = e.playheadTime / this.duration;
            if (isNaN(this.position)) return;
            this.setProperty("position", this.position);
            this.currentTime = e.playheadTime;
            this.setProperty("currentTime", this.currentTime);
        }
    };

    /**
     * The 'complete' event hook is called when a control has finished playing
     * an audio file completely, i.e. the progress is at 100%.
     *
     * @param {Object} e Event data, specific to this hook, containing player data.
     * @type {void}
     */
    this.$completeHook = function(e) {
        this.paused = true;
        this.setProperty("paused", true);
    };

    /**
     * When a audio player signals that is has initialized properly and is ready
     * to play, this function sets all the flags and behaviors properly.
     *
     * @param {Object} e Event data, specific to this hook, containing player data.
     * @type {Object}
     */
    this.$readyHook = function(e) {
        this.setProperty("networkState", apf.Media.NETWORK_LOADED);
        this.setProperty("readyState",   apf.Media.HAVE_FUTURE_DATA);
        this.setProperty("duration",     this.player.getTotalTime());
        this.seeking  = false;
        this.seekable = true;
        this.setProperty("seeking", false);
        if (this.autoplay)
            this.play();
        return this;
    };

    /**
     * The 'metadata' event hook is called when a control receives metadata of an
     * audio file, like ID3, waveform pattern, peak and equalizer data.
     *
     * @param {Object} e Event data, specific to this hook, containing player data.
     * @type {void}
     */
    this.$metadataHook = function(e) {
        this.oVideo.setProperty("readyState", apf.Media.HAVE_METADATA);
        if (e.waveData)
            this.setProperty("waveform", e.waveData);
        if (e.peakData)
            this.setProperty("peak", e.peakData);
        if (e.eqData)
            this.setProperty("EQ", e.eqData);
        if (e.id3Data)
            this.setProperty("ID3", e.id3Data);
    };

    /**
     * Build Main Skin
     *
     * @type {void}
     */
    this.$draw = function(){
        this.$ext = this.$pHtmlNode.appendChild(document.createElement("div"));
        this.$ext.className = "apf_audio " + (this.getAttributeNode("class") || "");
        this.$int = this.$ext;
    };

    /**
     * Parse the block of AML that constructs the HTML5 compatible <AUDIO> tag
     * for arguments like URL of the audio, volume, mimetype, etc.
     *
     * @type {void}
     */
    this.addEventListener("DOMNodeInsertedIntoDocument", function() {
        if (this.setSource())
            this.$propHandlers["type"].call(this, this.type);
    });

    this.$destroy = function(bRuntime) {
        if (this.player && this.player.$detroy)
            this.player.$destroy();
        delete this.player;
        this.player = null;

        if (bRuntime)
            this.$ext.innerHTML = "";
    };
}).call(apf.audio.prototype = new apf.Media());

apf.aml.setElement("audio", apf.audio);

apf.audio.TypeInterface = {
    properties: ["src", "volume", "showControls", "autoPlay", "totalTime", "mimeType"],

    /**
     * Set and/or override the properties of this object to the values
     * specified in the opions argument.
     *
     * @param {Object} options
     * @type {Object}
     */
    setOptions: function(options) {
        if (options == null) return this;
        // Create a hash of acceptable properties
        var hash = this.properties;
        for (var i = 0; i < hash.length; i++) {
            var prop = hash[i];
            if (options[prop] == null) continue;
            this[prop] = options[prop];
        }
        return this;
    },

    /**
     * Utility method; get an element from the browser's document object, by ID.
     *
     * @param {Object} id
     * @type {HTMLDomElement}
     */
    getElement: function(id) {
        return apf.flash.getElement(id);
    }
};




/*FILEHEAD(/var/lib/platform/source/trunk/elements/actionrule.js)SIZE(3884)TIME(1257329183)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @attribute {String} match
 * @attribute {String} set
 * @attribute {String} undo
 * @attribute {String} lock
 * @define update
 * @attribute {String} get 
 * @attribute {String} parent
 * @define add
 * @attribute {Boolean} get 
 * @attribute {Boolean} parent
 */
apf.ActionRule = function(struct, tagName){
    this.$init(tagName || true, apf.NODE_HIDDEN, struct);
};

(function(){
    this.$actionRule = true;
    
    this.compile = function(prop, options){
        return (this["c" + prop] = apf.lm.compile(this[prop], 
            options || {xpathmode: 2}));
    }
    
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        set    : 1,
        get    : 1,
        undo   : 1,
        lock   : 1,
        match  : 1,
        parent : 1
    }, this.$attrExcludePropBind);

    this.$propHandlers["set"]   = 
    this.$propHandlers["get"]   = 
    this.$propHandlers["parent"]   = 
    this.$propHandlers["match"] = function(value, prop){
        delete this["c" + prop];
    }

    /**** DOM Handlers ****/

    this.addEventListener("DOMNodeInserted", function(e){
        if (e.currentTarget == this) {
            var pNode = this.parentNode;
            if (!pNode.$actions)
                pNode.$actions = new apf.ruleList();
            
            (pNode.$actions[this.localName] 
              || (pNode.$actions[this.localName] = [])).push(this);
        }
        else {
            if (this.attributes.getNamedItem("value"))
                return;
            
             //@todo apf3.0 test if proc instr and cdata needs to be serialized
            this.value = apf.serializeChildren(this);
       }
    });

    this.addEventListener("DOMNodeRemoved", function(e){
        if (e.currentTarget == this) {
            this.parentNode.$actions[this.localName].remove(this);
        }
        else {
            if (this.attributes.getNamedItem("value"))
                return;
            
             //@todo apf3.0 test if proc instr and cdata needs to be serialized
            this.value = apf.serializeChildren(this);
       }
    });

    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (!this.get)
            this.get = apf.serializeChildren(this.$aml).trim();
        
        var actions = this.parentNode.$actions 
          || (this.parentNode.$actions = new apf.ruleList());
        
        (actions[this.localName] || (actions[this.localName] = [])).push(this);
    });
}).call(apf.ActionRule.prototype = new apf.AmlElement());

apf.aml.setElement("rename", apf.ActionRule);   
apf.aml.setElement("remove", apf.ActionRule);
apf.aml.setElement("add",    apf.ActionRule);
apf.aml.setElement("update", apf.ActionRule);
apf.aml.setElement("copy",   apf.ActionRule);
apf.aml.setElement("move",   apf.ActionRule);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/flowchart.js)SIZE(50670)TIME(1264896063)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Element with which you can add and remove graphical blocks and create 
 * connections between them. Block could be rotated, flipped, resized, 
 * renamed, locked and moved.
 *
 * Example:
 * Flowchart component
 * <code>
 *  <a:model id="modelName">
 *      <flowchart>
 *          <block
 *            id     = "b1"
 *            type   = "current_source_cc"
 *            left   = "500"
 *            top    = "520" 
 *            width  = "56"
 *            height = "56"
 *            lock   = "false"
 *            flipv  = "true"
 *            fliph  = "false">
 *          </block>
 *          <block
 *            id     = "b5" 
 *            type   = "mosfet_p" 
 *            left   = "800" 
 *            top    = "400" 
 *            width  = "56" 
 *            height = "56" 
 *            lock   = "0">
 *              <connection value="[b1]" output="3" input="3" />
 *          </block>
 *      </flowchart>
 *  </a:model>
 *  <a:flowchart id="WF" template="template.xml" model="modelName">
 *      <a:each match="[block]">
 *          <a:move match="[@move] != false &amp;&amp; [@lock] != true"></a:move>
 *          <a:resize match="[@resize] == true &amp;&amp; [@lock] != true"></a:resize>
 *          <a:css match="{true}" default="locked"></a:css>
 *          <a:left match="[@left]"></a:left>
 *          <a:top match="[@top]"></a:top>
 *          <a:id match="[@id]"></a:id>
 *          <a:width match="[@width]"></a:width>
 *          <a:height match="[@height]"></a:height>
 *          <a:flipv match="[@flipv]"></a:flipv>
 *          <a:fliph match="[@fliph]"></a:fliph>
 *          <a:rotation match="[@rotation]"></a:rotation>
 *          <a:lock match="[@lock]"></a:lock>
 *          <a:type match="[@type]"></a:type>
 *          <a:caption match="[@caption]" default="Untitled block"></a:caption>
 *          <a:cap-pos match="[@cap-pos]"></a:cap-pos>
 *          <a:zindex match="[@zindex]"></a:zindex>
 *          <a:image match="[@src]"></a:image>
 *
 *          <!-- Connection Binding Rules -->
 *          <a:connection match="[block/connection]"></a:connection>
 *          <a:ref match="[@ref]"></a:ref>
 *          <a:blockinput match="[@input]"></a:blockinput>
 *          <a:blockoutput match="[@output]"></a:blockoutput>
 *          <a:blocklabel match="[@label]"></a:blocklabel>
 *      </a:each>
 *  </a:flowchart>
 * </code>
 *
 * @define flowchart
 * @attribute {String} template   the data instruction to load the xml for the
 * template that defines all the elements which are available on the flowchart.
 * 
 * @attribute {String} snap   snap block to grid; Default is false
 * Possible values:
 *     true       Block is snap to grid; @see grid-width, @see grid-height
 *     false      Block is not snap to grid;
 *     {Number}   Block is snap to grid; Grid size is equal to this value
 * 
 * @attribute {Number} grid-width    horizontal grid size, Default is 48px
 * @attribute {Number} grid-height   vertical grid size, Default is 48px
 * 
 * Example:
 * A template describing a single capacitor element
 * <code>
 *  <template>
 *      <element type = "capacitor"
 *        picture     = "elements/capacitor.png"
 *        dwidth      = "56"
 *        dheight     = "56"
 *        scaley      = "false"
 *        scalex      = "false"
 *        scaleratio  = "true">
 *          <input
 *            x        = "28"
 *            y        = "0"
 *            position = "top"
 *            name     = "1" />
 *          <input 
 *            x        = "28"
 *            y        = "56"
 *            position = "bottom"
 *            name     = "2" />
 *      </element>
 *  </template>
 * </code>
 *
 * @binding lock    immobilize block element on workarea, default is false.
 * Possible values:
 *     false   block element is not immobilized
 *     true    block element is immobilized
 * @binding fliph   Determines whether to mirror the block over the horizontal axis, default is false
 * Possible values:
 *     true    block element is flipped
 *     false   block element is not flipped
 * @binding flipv   Determines whether to mirror the block over the vertical axis, default is false
 * Possible values:
 *     true    block element is flipped
 *     false   block element is not flipped
 * @binding rotation   the rotation in degrees clockwise, default is 0
 * Possible values:
 *     0       0   degrees rotation
 *     90     90   degrees rotation
 *     180   180   degrees rotation
 *     270   270   degrees rotation
 * @binding id          Determines unique name
 * @binding image       Determines path to background image file 
 * @binding width       Determines horizontal size
 * @binding height      Determines vertical size
 * @binding type        Determines name of block with special abilities, which can be defined in separate file
 * @binding zindex      Determines z-index number
 * @binding left        Determines horizontal position
 * @binding top         Determines vertical position
 * 
 * @binding connection  Determines xml representation of connection element
 * @binding ref         Determines unique name of destination block which will be connected with source block
 * @binding blockinput  Determines input number of source block 
 * @binding blockoutput Determines input number of destination block
 * @binding blocklabel  Specifies a description of the block
 *
 * @constructor
 *
 * @inherits apf.DataAction
 * @inherits apf.Cache
 * @inherits apf.BaseList
 * @inherits apf.Rename
 *
 * @author      Lukasz Lipinski
 * @version     %I%, %G%
 */
apf.flowchart = function(struct, tagName){
    this.$init(tagName || "flowchart", apf.NODE_VISIBLE, struct);
};

(function() {
    this.implement(
        
        apf.DataAction,
        
        apf.Cache,
        apf.MultiSelect,
        apf.Rename
    );

    this.objCanvas    = null;
    this.nodes        = [];
    this.snap         = false;
    this.gridW        = 48;
    this.gridH        = 48;

    this.$flowVars     = {
        lastBlockId   : 0,
        template      : null,
        //torename      = null,
        resizeManager : null,

        xmlBlocks     : {},
        objBlocks     : {},
        xmlConnections: {},
        connToPaint   : []
    };

    this.$init(function() {
        var _self = this;
        var onkeydown_ = function(e) {
            e = (e || event);

            var key      = e.keyCode,
                ctrlKey  = e.ctrlKey,
                shiftKey = e.shiftKey,
                sel      = this.getSelection(),
                value    = this.snap 
                    ? ((key == 37 || key == 39 
                        ? this.gridW 
                        : (key == 38 || key == 40 
                            ? this.gridH 
                            : 0)) * (ctrlKey 
                                         ? 2 
                                         : (shiftKey 
                                             ? 3 
                                             : 1)))
                    : (ctrlKey 
                        ? 10 
                        : (shiftKey 
                            ? 100 
                            : 1)),
                disabled = _self.objCanvas.disableremove;

            if (!sel || disabled)
                return;

            switch (key) {
                case 37:
                    //Left Arrow
                    this.moveTo(sel, - value, 0);
                    break;
                case 38:
                    //Top Arrow
                    this.moveTo(sel, 0, - value);
                    break;
                case 39:
                    //Right Arrow
                    this.moveTo(sel, value, 0);
                    break;
                case 40:
                    //Bottom Arrow
                    this.moveTo(sel, 0, value);
                    break;
                case 46:
                    //Delete
                    _self.$flowVars.resizeManager.hide();

                    switch (_self.objCanvas.mode) {
                        case "normal":
                            //Removing Blocks
                            this.removeBlocks(sel);
                            break;
                        case "connection-change":
                            //Removing Connections
                            var connectionsToDelete = [],
                                connectors = _self.objCanvas.htmlConnectors;
                            for (var id in connectors) {
                                if (connectors[id].selected) {
                                    connectionsToDelete.push(connectors[id].other.xmlNode);
                                    connectors[id].destroy();
                                }
                            }
                            _self.removeConnectors(connectionsToDelete);
                            _self.objCanvas.mode = "normal";
                            break;
                    }
                    break;
            }

            return false;
        }

        
        this.addEventListener("keydown", onkeydown_, true);

        apf.addEventListener("contextmenu", function() {return false;});
        

        function $afterRenameMode() {
           _self.objCanvas.disableremove = false;
        }
        this.addEventListener("afterrename", $afterRenameMode);
        this.addEventListener("stoprename", $afterRenameMode);
    });
    
    this.$propHandlers["snap"] = function(value) {
        var isNumber = parseInt(value) > 0 ? true : false
        
        this.snap = this.objCanvas.snap = value == "true" || isNumber 
            ? true 
            : false;

        if (isNumber) {
            this.gridW = this.objCanvas.gridW = parseInt(value);
            this.gridH = this.objCanvas.gridH = parseInt(value);
        }
    }
    
    this.$propHandlers["grid-width"] = function(value) {
        this.gridW = this.objCanvas.gridW = parseInt(value);
    }
    
    this.$propHandlers["grid-height"] = function(value) {
        this.gridH = this.objCanvas.gridH = parseInt(value);
    }

    
    this.$getCaptionElement = function() {
        var objBlock = this.$flowVars.objBlocks[this.$applyBindRule("id", this.selected)];
        if (!objBlock)
            return;
        return objBlock.caption;
    };
    

    this.$beforeRename = function(e) {
        e = e || event;
        var target = e.srcElement || e.target;
        this.$selectCaption(target);

        this.objCanvas.disableremove = true;
        this.$deselectCaption(target);
        this.startRename();

        var rename_input = this.$pHtmlDoc.getElementById("txt_rename");
        this.$setStyleClass(rename_input, target.className);

        var c = rename_input;
        if ((target.className || "").indexOf("inside") != -1) {
            if (c.offsetHeight !== 0) {

                c.style.marginTop =
                    "-" + (Math.ceil(c.offsetHeight / 2)) + "px";
            }
        }

        return false;
    };


    this.$selectCaption = function(o) {
        if (!o || o.nodeType != 1) return;
        this.$setStyleClass(o, "selected");
    };

    this.$deselectCaption = function(o) {
        if (!o || o.nodeType != 1) return;
        this.$setStyleClass(o, "", ["selected"]);
    };

    this.$select = function(o) {
        if (!o)
            return;

        var objBlock = apf.flow.isBlock(o);

        if (objBlock) {
            if (this.$flowVars.resizeManager) {
                var prop = objBlock.other;

                if (prop.lock == 1)
                    return;

                this.$flowVars.resizeManager.grab(o, {
                    scalex     : prop.scalex,
                    scaley     : prop.scaley,
                    scaleratio : prop.scaleratio,
                    dwidth     : prop.dwidth,
                    dheight    : prop.dheight,
                    ratio      : prop.ratio,
                    snap       : this.snap,
                    gridH      : this.gridH,
                    gridW      : this.gridW
                });
            }
            this.$setStyleClass(o, "selected");

            if (objBlock.other.capPos !== "inside")
                this.$selectCaption(objBlock.caption);
        }
    };

    this.$deselect = function(o) {
        if (!o)
            return;
        this.$setStyleClass(o, "", ["selected"]);

        var objBlock = apf.flow.isBlock(o);
        if (!objBlock) return; //it might have been deleted recently...
        this.$deselectCaption(objBlock.caption);

        this.$flowVars.resizeManager.hide();
    };

    /* ********************************************************************
     PUBLIC METHODS
     *********************************************************************/

    /**
     * Updates the position of a block to vector [x, y] and the XML it is bound 
     * to. It's possible to back to previous state with Undo/Redo.
     * 
     * @param {Object} xmlNodeArray   array with xml representations of blocks elements
     * @param {Number} dl             horizontal alteration
     * @param {Number} dt             vertical alteration
     */
    this.moveTo = function(xmlNodeArray, dl, dt) {
        if(!xmlNodeArray) return;

        if (!xmlNodeArray.length)
            xmlNodeArray = [xmlNodeArray];

        var changes = [],
            setNames = ["top", "left"],
            node, value, i, l, j;
        for (i = 0, l = xmlNodeArray.length; i < l; i++) {
            for (j = 0; j < setNames.length; j++) {
                node = this.$getDataNode(
                  setNames[j], xmlNodeArray[i], this.$createModel);
                value = (setNames[j] == "left" ? dl : dt) 
                  + (parseInt(this.$applyBindRule(setNames[j], xmlNodeArray[i])) || 0);

                if (this.snap) {
                    var gridSize = setNames[j] == "top" ? this.gridH : this.gridW;
                    value = Math.round(value / gridSize) * gridSize;
                }

                if (node) {
                    var atAction = node.nodeType == 1 || node.nodeType == 3
                                || node.nodeType == 4
                        ? "setTextNode"
                        : "setAttribute";
                    var args = node.nodeType == 1
                        ? [node, value]
                        : (node.nodeType == 3 || node.nodeType == 4
                            ? [node.parentNode, value]
                            : [node.ownerElement || node.selectSingleNode(".."),
                               node.nodeName, value]);
                    changes.push({
                        func: atAction,
                        args: args
                    });
                }
            }
        }

        this.$executeAction("multicall", changes, "moveTo", xmlNodeArray);
    };

    /**
     * Set a new z-index of a block and the XML it is bound to. It's
     * possible to back to previous state with Undo/Redo.
     *
     * @param {XMLElement} xmlNode   xml representation of block element
     * @param {Number}     value     new z-index number
     */
    this.setZindex = function(xmlNode, value) {
        this.$executeSingleValue("setzindex", "zindex", xmlNode, value);
    };

    /**
     * Sets mode to canvas object. Modes adds new features. For example,
     * if connection-change mode is active, deleting connections
     * between blocks is possible. 
     * 
     * @private
     * @param {String} mode   Operations mode
     * 
     * Possible values:
     *     normal              all operations are allowed except operations from different modes
     *     connection-add      it's possible to add new connection between blocks, all operations from "normal" mode its allowed
     *     connection-change   it's possible to change existing connection, all operations from "normal" mode its allowed
     */
    this.setMode = function(mode) {
        this.objCanvas.setMode(mode);
    };

    /**
     * Returns current mode type. Modes adds new features. For example,
     * if connection-change mode is active, possible is deleting connections
     * between blocks. 
     * 
     * @private
     * @return {String} Operation mode
     * 
     * Possible values:
     *     normal             all operations are allowed except operations from different modes
     *     connection-add     it's possible to add new connection between blocks, all operations from "normal" mode its allowed
     *     connection-change  it's possible to change existing connection, all operations from "normal" mode its allowed
     *
     * 
     */
    this.getMode = function() {
        return this.objCanvas.getMode();
    };

    /**
     * Immobilise block element on workarea. This is an action.
     * It's possible to back to previous state with Undo/Redo.
     *
     * @param {XMLElement} xmlNode   xml representation of block element
     * @param {Boolean}    value     prohibit block move, default is false.
     * Possible values:
     *     true    block is locked
     *     false   block is unlocked
     */
    this.setLock = function(xmlNode, value) {
        this.$executeSingleValue("setlock", "lock", xmlNode, String(value));
    };

    /**
     * Rotate block element. This is an action. It's possible to back to
     * previous state with Undo/Redo
     *
     * @param {XMLElement}   xmlNode       xml representation of block element
     * @param {Number}       newRotation   the rotation in degrees clockwise, default is 0
     * Possible values:
     *     0       0 degrees rotation
     *     90     90 degrees rotation
     *     180   180 degrees rotation
     *     270   270 degrees rotation
     */
    this.rotate = function(xmlNode, newRotation/*, start*/) {
        var prevFlipV = this.$applyBindRule("flipv", xmlNode) == "true"
                ? true
                : false,
            prevFlipH = this.$applyBindRule("fliph", xmlNode) == "true"
                ? true
                : false,
            prevRotation = parseInt(this.$applyBindRule("rotation", xmlNode)) || 0,

            names = ["fliph", "flipv", "rotation"],
            values;

        if (prevFlipV && prevFlipH) {
            values = ["false", "false", (newRotation + 180) % 360];
        }
        else {
            values = [String(prevFlipH), String(prevFlipV), newRotation];

            if (Math.abs(newRotation - prevRotation) % 180 !== 0) {
                var
                w = parseInt(this.$applyBindRule("width", xmlNode)) || 0,
                h = parseInt(this.$applyBindRule("height", xmlNode)) || 0;

                names.push("width", "height");
                values.push(h, w);
            }
        }

        this.$executeMulticallAction("rotate", names, xmlNode, values);
    };

    /**
     * Mirrors the block over the vertical axis. This is an action.
     * It's possible to back to previous state with Undo/Redo.
     *
     * @param {XMLElement}   xmlNode   xml representation of block element
     * @param {Number}       newFlipV  new flip value, default is false
     * Possible values:
     *     true    block element is flipped
     *     false   block element is not flipped
     */
    this.flipVertical = function(xmlNode, newFlipV) {
        var prevFlipH  = this.$applyBindRule("fliph", xmlNode) == "true"
                ? true
                : false,
            prevRotate = this.$applyBindRule("rotation", xmlNode)
                ? parseInt(this.$applyBindRule("rotation", xmlNode))
                : 0;

        var values = prevFlipH && newFlipV
            ? ["false", "false", (prevRotate + 180) % 360]
            : [String(prevFlipH), String(newFlipV), prevRotate];

        this.$executeMulticallAction(
            "verticalFlip", ["fliph", "flipv", "rotation"], xmlNode, values);
    };

    /**
     * Mirrors the block over the horizontal axis. This is an action.
     * It's possible to back to previous state with Undo/Redo.
     *
     * @param {XMLElement}   xmlNode   xml representation of block element
     * @param {Number}       newFlipH  new flip value, default is false
     * Possible values:
     *     true    block element is flipped
     *     false   block element is not flipped
     */
    this.flipHorizontal = function(xmlNode, newFlipH) {
        var prevFlipV  = this.$applyBindRule("flipv", xmlNode) == "true"
                ? true
                : false,

            prevRotate = this.$applyBindRule("rotation", xmlNode)
                ? parseInt(this.$applyBindRule("rotation", xmlNode))
                : 0;

        var values = prevFlipV && newFlipH
            ? ["false", "false", (prevRotate + 180) % 360]
            : [String(newFlipH), String(prevFlipV), prevRotate];

        this.$executeMulticallAction(
            "horizontalFlip", ["fliph", "flipv", "rotation"], xmlNode, values);
    };

    /**
     * Resize block element in vertical and horizontal plane. This is an
     * action. It's possible to back to previous state with Undo/Redo.
     *
     * @param {XMLElement}   xmlNode     xml representation of block element
     * @param {Number}       newWidth    block element horizontal size
     * @param {Number}       newHeight   block element vertical size
     * @param {Number}       newTop      vertical position of block element
     * @param {Number}       newLeft     horizontal position of block element
     */
    this.resize = function(xmlNode, newWidth, newHeight, newTop, newLeft) {
        this.$executeMulticallAction(
            "resize",
            ["top", "left", "width", "height"],
            xmlNode,
            [newTop, newLeft, newWidth, newHeight]);
    };

    /**
     * Executes multi actions on one element in one call
     *
     * @param {String}      atName     the name of action rule defined in actions for this element.
     * @param {Object}      setNames   the names list of the binding rule defined in bindings for this element.
     * @type {String}
     * @param {XMLElement}  xmlNode    the xml representation of element to which rules are applied
     * @param {Object}      values     the new values list of the node
     * @type {String}
     */
    this.$executeMulticallAction = function(atName, setNames, xmlNode, values) {
        var i, node, value, atAction, args,
            changes = [],
            l       = setNames.length;
        for (i = 0; i < l; i++) {
            node = this.$getDataNode(
              setNames[i], xmlNode, this.$createModel);
            value = values[i];

            if (node) {
                atAction = node.nodeType == 1 || node.nodeType == 3
                            || node.nodeType == 4
                    ? "setTextNode"
                    : "setAttribute";
                args = node.nodeType == 1
                    ? [node, value]
                    : (node.nodeType == 3 || node.nodeType == 4
                        ? [node.parentNode, value]
                        : [node.ownerElement || node.selectSingleNode(".."),
                           node.nodeName, value]);
                changes.push({
                    func: atAction,
                    args: args
                });
            }
        }
        this.$executeAction("multicall", changes, atName, xmlNode);
    };

    /**
     * Creates new connection between two blocks. This is an action. It's
     * possible to back to previous state with Undo/Redo.
     *
     * @param {XMLElement}   sXmlNode   xml representation of source block element
     * @param {Number}       sInput     source block input number
     * @param {XMLElement}   dXmlNode   xml representation of destination block element
     * @param {Number}       dInput     destination block output number
     */
    this.addConnector = function(sXmlNode, sInput, dXmlNode, dInput) {
        var nXmlNode = this.xmlRoot.ownerDocument.createElement("connection");

        nXmlNode.setAttribute("ref", this.$applyBindRule("id", dXmlNode));
        nXmlNode.setAttribute("output", sInput);
        nXmlNode.setAttribute("input", dInput);

        this.$executeAction("appendChild", [sXmlNode, nXmlNode],
                           "addConnector", sXmlNode);
    };

    /**
     * Removes connections between blocks. It's possible to remove more
     * connections in one call. This is an action. It's possible to back
     * to previous state with Undo/Redo.
     *
     * @param {Object} xmlNodeArray   xml representations of connections elements
     */
    this.removeConnectors = function(xmlNodeArray) {
        var changes = [],
            i       = 0,
            l       = xmlNodeArray.length;

        for (; i < l; i++) {
            changes.push({
                func : "removeNode",
                args : [xmlNodeArray[i]]
            });
        }

        this.$executeAction("multicall", changes,
                           "removeConnectors", xmlNodeArray[0]);
    };

    /**
     * Creates new xml representation of block element
     *
     * @param {XMLElement}   parentXmlNode   xml representation of block parent node
     * @param {Number}       left            horizontal position
     * @param {Number}       top             vertical position
     * @param {String}       type            determines name of block with special abilities, which can be defined in separate file
     * @param {Number}       width           horizontal size
     * @param {Number}       height          vertical size
     * @param {String}       id              unique name
     */
    this.addBlock = function(type, left, top, caption) {
        if (!type)
            return;

        var elTemplate = this.$flowVars.template
            .selectSingleNode("//element[@type='" + type + "']");

        if (!elTemplate)
            return;

        var nXmlNode = this.xmlRoot.ownerDocument.createElement("block");

        nXmlNode.setAttribute("id",      "b" + (this.$flowVars.lastBlockId + 1));
        nXmlNode.setAttribute("left",    left || 20);
        nXmlNode.setAttribute("top",     top || 20);
        nXmlNode.setAttribute("width",   elTemplate.getAttribute("dwidth"));
        nXmlNode.setAttribute("height",  elTemplate.getAttribute("dheight"));
        nXmlNode.setAttribute("type",    type);
        nXmlNode.setAttribute("caption", caption);

        this.$executeAction("appendChild", [this.xmlRoot, nXmlNode],
                            "addBlock", this.xmlRoot);
    };

    /**
     * Removes xml representation of block. It's possible to remove more
     * xmlNodes in one call. This is an action. It's possible to back to
     * previous state with Undo/Redo.
     *
     * @param {Object}   xmlNodeArray   xml representations of blocks elements
     */
    this.removeBlocks = function(xmlNodeArray) {
        var id, id2, j, k,
            changes = [],
            ids     = [],
            i       = 0,
            l       = xmlNodeArray.length;

        for (; i < l; i++) {
            id = this.$applyBindRule("id", xmlNodeArray[i]);
            ids.push(id);

            changes.push({
                func : "removeNode",
                args : [xmlNodeArray[i]]
            });
        }

        /* Removing connections from other blocks */
        for (id2 in this.$flowVars.xmlConnections) {
            for (j = this.$flowVars.xmlConnections[id2].length - 1; j >= 0 ; j--) {
                for (k = 0, l = ids.length; k < l; k++) {
                    if (this.$flowVars.xmlConnections[id2][j].ref == ids[k]) {
                        changes.push({
                            func : "removeNode",
                            args : [this.$flowVars.xmlConnections[id2][j].xmlNode]
                        });
                    }
                }
            }
        }

        this.$executeAction("multicall", changes,
                            "removeBlocksWithConnections", xmlNodeArray);
    };

    this.$draw = function() {
        //Build Main Skin
        this.$ext = this.$getExternal();
        this.$int = this.$getLayoutNode("main", "container", this.$ext);

        this.objCanvas = new apf.flow.getCanvas(this.$int);
        apf.flow.init();
        /*apf.flow.onconnectionrename = function(e) {
            _self.$beforeRename(e);
        }*/
    };

    /* Action when block is removed  */
    this.$deInitNode = function(xmlNode, htmlNode) {
        var id = this.$applyBindRule("id", xmlNode);

        this.$flowVars.objBlocks[id].destroy();

        delete this.$flowVars.objBlocks[id];
        delete this.$flowVars.xmlBlocks[id];
        htmlNode.parentNode.removeChild(htmlNode);
        this.$flowVars.resizeManager.hide();
    }

    //this.$dragdrop = function(el, dragdata, candrop) {
    this.addEventListener("dragdrop", function(e){
        var blockPos  = apf.getAbsolutePosition(e.indicator),
            canvasPos = apf.getAbsolutePosition(this.objCanvas.htmlElement);

        apf.setNodeValue(this.$getDataNode("top",  e.data[0], true), parseInt(e.top) - canvasPos[1]);
        apf.setNodeValue(this.$getDataNode("left", e.data[0], true), blockPos[0] - canvasPos[0]);
    });

    this.$updateModifier = function(xmlNode, htmlNode) {
        apf.console.info("UPDATE")
        
        var fv       = this.$flowVars,
            blockId  = this.$applyBindRule("id", xmlNode),
            objBlock = fv.objBlocks[blockId],

            t = parseInt(this.$applyBindRule("top", xmlNode))
                ? this.$applyBindRule("top", xmlNode)
                : parseInt(objBlock.htmlElement.style.top),
            l = parseInt(this.$applyBindRule("left", xmlNode))
                ? this.$applyBindRule("left", xmlNode)
                : parseInt(objBlock.htmlElement.style.left);

        objBlock.moveTo(t, l);

        var w = parseInt(this.$applyBindRule("width", xmlNode))
                ? this.$applyBindRule("width", xmlNode)
                : objBlock.other.dwidth,
            h = parseInt(this.$applyBindRule("height", xmlNode))
                ? this.$applyBindRule("height", xmlNode)
                : objBlock.other.dheight;
        objBlock.resize(w, h);

        /* Rename */
        objBlock.setCaption(this.$applyBindRule("caption", xmlNode));

        /* Lock */
        var lock = this.$applyBindRule("lock", xmlNode) == "true"
            ? true
            : false;

        objBlock.setLock(lock);

        objBlock.changeRotation(
            this.$applyBindRule("rotation", xmlNode),
            this.$applyBindRule("fliph", xmlNode),
            this.$applyBindRule("flipv", xmlNode)
        );

        /* Checking for changes in connections */
        var j, l2, found, ref, output, input, label, type,
            cNew     = this.$getDataNode("connection", xmlNode, null, null, true),
            cCurrent = fv.xmlConnections[blockId] || [],
            i        = 0;
        l = cCurrent.length;

        //Checking for removed connections
        if (cCurrent.length) {
            for (; i < l; i++) {
                for (j = 0, found = false, l2 = cNew.length; j < l2; j++) {
                    if (cCurrent[i].xmlNode == cNew[j]) {
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    if (fv.objBlocks[blockId] && fv.objBlocks[cCurrent[i].ref]) {
                        var ConToDel = apf.flow.findConnector(
                            fv.objBlocks[blockId], cCurrent[i].output,
                            fv.objBlocks[cCurrent[i].ref], cCurrent[i].input);
                        if (ConToDel)
                            apf.flow.removeConnector(ConToDel.connector.htmlElement);
                        fv.xmlConnections[blockId].removeIndex(i);
                    }
                }
            }
        }
        else {
            delete fv.xmlConnections[blockId];
        }

        //Checking for new connections
        for (i = 0, l = cNew.length; i < l; i++) {
            found = false;
            if (cCurrent) {
                for (j = 0, l2 = cCurrent.length; j < l2; j++) {
                    if (cCurrent[j].xmlNode == cNew[i]) {
                        found = true;
                        break;
                    }
                }
            }

            if (!found) {
                ref    = this.$applyBindRule("ref", cNew[i]),
                output = this.$applyBindRule("blockoutput", cNew[i]),
                input  = this.$applyBindRule("blockinput", cNew[i]),
                label  = this.$applyBindRule("blocklabel", cNew[i]),
                type   = this.$applyBindRule("type", cNew[i]);

                if (fv.xmlBlocks[ref]) {
                    var r = fv.xmlConnections[blockId] || [];
                    r.push({
                        ref     : ref,
                        output  : output,
                        input   : input,
                        label   : label,
                        type    : type,
                        xmlNode : cNew[i]
                    });

                    new apf.flow.addConnector(this.objCanvas,
                        fv.objBlocks[blockId], fv.objBlocks[ref], {
                            output : output,
                            input  : input,
                            label  : label,
                            type   : type,
                            xmlNode: cNew[i]
                        }
                    );
                    fv.xmlConnections[blockId] = r;
                }
                else {
                    apf.console.info("Destination block doesn't exist.");
                }
            }
        }

        if (fv.resizeManager && xmlNode == this.selected && !lock)
            fv.resizeManager.show();
        else
            fv.resizeManager.hide();

        objBlock.updateOutputs();
        objBlock.onMove();
    };

    this.$add = function(xmlNode, Lid, xmlParentNode, htmlParentNode, beforeNode) {
        /* Creating Block */
        this.$flowVars.lastBlockId++;
        
        apf.console.info("ADD");
        this.$getNewContext("item");
        var block            = this.$getLayoutNode("item"),
            elSelect         = this.$getLayoutNode("item", "select"),
            elImage          = this.$getLayoutNode("item", "image"),
            elimageContainer = this.$getLayoutNode("item", "imagecontainer"),
            elCaption        = this.$getLayoutNode("item", "caption");

        if (elCaption)
            elCaption.setAttribute("ondblclick", 'apf.lookup(' + this.$uniqueId
                + ').$beforeRename(event); return false;');

        this.nodes.push(block);

        /* Set Css style */
        var style  = [], style2 = [], _style, k, l,
            left   = this.$applyBindRule("left", xmlNode) || 0,
            top    = this.$applyBindRule("top", xmlNode) || 0,
            zindex = this.$applyBindRule("zindex", xmlNode) || 1001;
        if (this.snap) {
            left = Math.round(left / this.gridW) * this.gridW;
            top  = Math.round(top  / this.gridH) * this.gridH;
        }
        
        style.push("z-index:" + zindex);
        style.push("left:" + left + "px");
        style.push("top:" + top + "px");

        if (this.$flowVars.template) {
            var elTemplate = this.$flowVars.template.selectSingleNode("//element[@type='"
                           + this.$applyBindRule("type", xmlNode) + "']");
            if (elTemplate) {
                var stylesFromTemplate = elTemplate.getAttribute("css");

                if (stylesFromTemplate) {
                    stylesFromTemplate = stylesFromTemplate.split(";");

                    for (k = 0, l = stylesFromTemplate.length; k < l; k++) {
                        _style = stylesFromTemplate[k].trim();
                        if (_style !== "") {
                            if (_style.substr(0, 5) == "color" && elCaption)
                                elCaption.setAttribute("style", [_style].join(";"));
                            else
                                style.push(_style);
                        }
                    }
                }
                var w = elTemplate.getAttribute("dwidth"),
                    h = elTemplate.getAttribute("dheight");
            }
        }

        if (this.$applyBindRule("id", xmlNode)) {
            var _id = this.$applyBindRule("id", xmlNode).substr(1);
            if (_id > this.$flowVars.lastBlockId)
                this.$flowVars.lastBlockId = _id;
        }

        var id     = this.$applyBindRule("id", xmlNode) || "b" + this.$flowVars.lastBlockId,
            width  = this.$applyBindRule("width", xmlNode) || w || 56,
            height = this.$applyBindRule("height", xmlNode) || h || 56,
            lock   = this.$applyBindRule("lock", xmlNode) || "false",
            capPos = this.$applyBindRule("cap-pos", xmlNode) || "outside";

        style.push("width:" + width + "px");
        style.push("height:" + height + "px");

        /* Set styles to block */
        block.setAttribute("style", style.join(";"));

        style2.push("width:" + width + "px");
        style2.push("height:" + height + "px");

        /* Set styles to image container */
        elImage.setAttribute("style", style2.join(";"));
        elimageContainer.setAttribute("style", style2.join(";"));
        /* End - Set Css style */

        xmlNode.setAttribute("id", id);
        xmlNode.setAttribute("width", width);
        xmlNode.setAttribute("height", height);
        xmlNode.setAttribute("lock", lock);
        xmlNode.setAttribute("left", left);
        xmlNode.setAttribute("top", top);
        xmlNode.setAttribute("zindex", zindex);
        xmlNode.setAttribute("cap-pos", capPos);

        if (elCaption)
            this.$setStyleClass(elCaption, capPos);

        elSelect.setAttribute(this.itemSelectEvent ||
            "onmousedown", 'var o = apf.lookup('
            + this.$uniqueId
            + '); o.select(this, event.ctrlKey, event.shiftKey)');

        apf.xmldb.nodeConnect(this.documentId, xmlNode, block, this);
        this.$flowVars.xmlBlocks[id] = xmlNode;

        /* Creating Connections */
        var r = [], i,
            connections = this.$getDataNode("connection", xmlNode, null, null, true);

        for (i = 0, l = connections.length; i < l; i++) {
            r.push({
                ref     : this.$applyBindRule("ref", connections[i]),
                output  : this.$applyBindRule("blockoutput", connections[i]),
                input   : this.$applyBindRule("blockinput", connections[i]),
                label   : this.$applyBindRule("blocklabel", connections[i]),
                type    : this.$applyBindRule("type", connections[i]),
                xmlNode : connections[i]
            });

        }

        
        var cssClass = this.$applyBindRule("css", xmlNode);
        if (cssClass) {
            this.$setStyleClass(block, cssClass);
            if (cssClass)
                this.dynCssClasses.push(cssClass);
        }
        
        
        if (r.length > 0)
            this.$flowVars.xmlConnections[id] = r;
    };

    this.$fill = function() {
        apf.insertHtmlNodes(this.nodes, this.$int);
        apf.console.info("FILL");
        var id, i, l,
            fv = this.$flowVars;
        for (id in fv.xmlBlocks) {
            var xmlBlock    = fv.xmlBlocks[id],
                htmlElement = apf.xmldb.findHtmlNode(xmlBlock, this),
                type        = this.$flowVars.xmlBlocks[id].getAttribute("type") || null,
                inputList   = {};

            if (type) {
                if (fv.template) {
                    var elTemplate = fv.template.selectSingleNode("element[@type='"
                        + this.$applyBindRule("type", xmlBlock) + "']");

                    if (elTemplate) {
                        var inputs = elTemplate.selectNodes("input");
                        
                        if (inputs) {
                            for (i = 0, l = inputs.length; i < l; i++) {
                                inputList[parseInt(inputs[i].getAttribute("name"))] = {
                                    x        : parseInt(inputs[i].getAttribute("x")),
                                    y        : parseInt(inputs[i].getAttribute("y")),
                                    position : inputs[i].getAttribute("position")
                                };
                            }
                        }
                    }
                }
            }

            var lock = this.$applyBindRule("lock", xmlBlock) == "true"
                    ? true
                    : false;
            var other = {};
            other['lock'] = lock;
            other['flipv'] = this.$applyBindRule("flipv", xmlBlock) == "true"
                ? true
                : false;
            other['fliph'] = this.$applyBindRule("fliph", xmlBlock) == "true"
                ? true
                : false;
            other['rotation'] = parseInt(this.$applyBindRule("rotation", xmlBlock)) || 0;
            other['inputList'] = inputList;
            other['type'] = type;
            other['picture'] = type && fv.template && elTemplate
                ? elTemplate.getAttribute("picture")
                : null;
            other['dwidth'] = type && fv.template && elTemplate
                ? parseInt(elTemplate.getAttribute("dwidth"))
                : 56;
            other['dheight'] = type && fv.template && elTemplate
                ? parseInt(elTemplate.getAttribute("dheight"))
                : 56;
            other['scalex'] = type && fv.template && elTemplate
                ? (elTemplate.getAttribute("scalex") == "true"
                    ? true
                    : false)
                : true;
            other['scaley'] = type && fv.template && elTemplate
                ? (elTemplate.getAttribute("scaley") == "true"
                    ? true
                    : false)
                : true;
            other['scaleratio'] = type && fv.template && elTemplate
                ? (elTemplate.getAttribute("scaleratio") == "true"
                    ? true
                    : false)
                : false;
            other['xmlNode'] = xmlBlock;
            other['caption'] = this.$applyBindRule("caption", xmlBlock);
            other['capPos'] = this.$applyBindRule("cap-pos", xmlBlock);

            var objBlock = apf.flow.isBlock(htmlElement);
            var _self    = this;

            if (objBlock) {
                this.$setStyleClass(htmlElement, "", ["empty"]);
                objBlock.other = other;
                objBlock.initBlock();
            }
            else {
                objBlock = apf.flow.addBlock(htmlElement, this.objCanvas, other);

                if (objBlock) {
                    objBlock.oncreateconnection = function(sXmlNode, sInput, dXmlNode, dInput) {
                        _self.addConnector(sXmlNode, sInput, dXmlNode, dInput);
                    };
                    objBlock.onremoveconnection = function(xmlNodeArray) {
                        _self.removeConnectors(xmlNodeArray);
                    };
                    fv.objBlocks[id] = objBlock;
                }
            }
        }

        for (id in fv.xmlBlocks) {
            var c = fv.xmlConnections[id] || [];

            for (i = 0, l = c.length; i < l; i++) {
                var con = apf.flow.findConnector(fv.objBlocks[id], c[i].output,
                                                 fv.objBlocks[c[i].ref], c[i].input);
                if (!con) {
                    if (fv.objBlocks[id] && fv.objBlocks[c[i].ref]) {
                        //it's called because connection labels must be aligned
                        fv.objBlocks[id].onMove();
                        
                        new apf.flow.addConnector(this.objCanvas, fv.objBlocks[id],
                                                  fv.objBlocks[c[i].ref], {
                            output  : c[i].output,
                            input   : c[i].input,
                            label   : c[i].label,
                            type    : c[i].type,
                            xmlNode : c[i].xmlNode
                        });
                    }
                    else {
                        fv.connToPaint.push({
                            id      : id,
                            id2     : c[i].ref,
                            output  : c[i].output,
                            input   : c[i].input,
                            label   : c[i].label,
                            type    : c[i].type,
                            xmlNode : c[i].xmlNode
                        });
                    }
                }
                else {
                    con.connector.other = {
                        output  : c[i].output,
                        input   : c[i].input,
                        label   : c[i].label,
                        type    : c[i].type,
                        xmlNode : c[i].xmlNode
                    };
                    con.connector.activateInputs();
                    con.connector.draw();
                }
            }
        }

        /* Try to draw rest of connections */
        for (i = fv.connToPaint.length - 1; i >= 0 ; i--) {
            if (fv.objBlocks[fv.connToPaint[i].id] && fv.objBlocks[fv.connToPaint[i].id2]) {
                new apf.flow.addConnector(this.objCanvas,
                                          fv.objBlocks[fv.connToPaint[i].id],
                                          fv.objBlocks[fv.connToPaint[i].id2], {
                    output  : fv.connToPaint[i].output,
                    input   : fv.connToPaint[i].input,
                    label   : fv.connToPaint[i].label,
                    type    : fv.connToPaint[i].type,
                    xmlNode : fv.connToPaint[i].xmlNode
                    });
                fv.connToPaint.removeIndex(i);
            }
        }

        this.nodes = [];

        if (!this.objCanvas.scrollPointer)
            this.objCanvas.addScrollPointer();
    };

    this.$destroy = function() {
        /*this.oPrevious.onclick = null;

        this.removeEventListener("onkeydown", onkeydown_);
        this.removeEventListener("mousescroll", onmousescroll_);

        this.x = null;*/
    };

    this.$loadAml = function(x) {
        /* Loading template */
        apf.getData(this.getAttribute("template"), {callback: 
            function(data, state, extra) {
                if (state == apf.SUCCESS) {
                    _self.loadTemplate(data);
                }
                else {
                    apf.console.info("An error has occurred: " + extra.message, 2);
                    return;
                }
            }
        });

        var _self = this,
            fv    = this.$flowVars;

        /* Resize */
        fv.resizeManager = new apf.resize();

        fv.resizeManager.onresizedone = function(w, h, t , l) {
            _self.resize(_self.selected, w, h, t, l);
        };

        fv.resizeManager.onresize = function(htmlElement, t, l, w, h) {
            if (!htmlElement)
                return;
            var objBlock = apf.flow.isBlock(htmlElement);
            objBlock.moveTo(t, l);
            objBlock.resize(w, h);
            objBlock.updateOutputs();
            objBlock.onMove();
        };

        apf.flow.onaftermove = function(dt, dl) {
            _self.moveTo(_self.selected, dl, dt);
        };

        apf.flow.onblockmove = function() {
            fv.resizeManager.show();
        };
    };

    /**
     * Loads a template for elements, which defines the type, size and other 
     * properties of blocks.
     * 
     * @see Template attribute
     * 
     * @param {XMLElement}   data   xml representation of template
     */
    this.loadTemplate = function(xmlRootNode) {
        if (typeof xmlRootNode != "object")
            xmlRootNode = apf.getXmlDom(xmlRootNode);
        if (xmlRootNode.nodeType == 9)
            xmlRootNode = xmlRootNode.documentElement;
        if (xmlRootNode.nodeType == 3 || xmlRootNode.nodeType == 4)
            xmlRootNode = xmlRootNode.parentNode;
        if (xmlRootNode.nodeType == 2)
            xmlRootNode = xmlRootNode.ownerElement 
                || xmlRootNode.parentNode 
                || xmlRootNode.selectSingleNode("..");
        
        this.$flowVars.template = xmlRootNode;
        this.$checkLoadQueue();
    };

    this.$canLoadData = function() {
        return this.$flowVars.template ? true : false;
    };

}).call(apf.flowchart.prototype = new apf.BaseList());

apf.aml.setElement("flowchart",   apf.flowchart);
apf.aml.setElement("resize",      apf.BindingRule);
apf.aml.setElement("left",        apf.BindingRule);
apf.aml.setElement("top",         apf.BindingRule);
apf.aml.setElement("id",          apf.BindingRule);
apf.aml.setElement("width",       apf.BindingRule);
apf.aml.setElement("height",      apf.BindingRule);
apf.aml.setElement("flipv",       apf.BindingRule);
apf.aml.setElement("fliph",       apf.BindingRule);
apf.aml.setElement("rotation",    apf.BindingRule);
apf.aml.setElement("lock",        apf.BindingRule);
apf.aml.setElement("type",        apf.BindingRule);
apf.aml.setElement("cap-pos",     apf.BindingRule);
apf.aml.setElement("zindex",      apf.BindingRule);
apf.aml.setElement("connection",  apf.BindingRule);
apf.aml.setElement("ref",         apf.BindingRule);
apf.aml.setElement("blockoutput", apf.BindingRule);
apf.aml.setElement("blockinput",  apf.BindingRule);
apf.aml.setElement("blocklabel",  apf.BindingRule);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/graph.js)SIZE(21558)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Element displays a chart.
 *
 * @classDescription This class creates a new chart
 * @return {Chart} Returns a new chart
 * @type {Chart}
 * @constructor
 * @allowchild {elements}, {anyaml}
 * @addnode elements:chart
 *
 * @author      Rik Arends
 * @version     %I%, %G%
 * @since       0.4
 */

 apf.Graph     = function(struct, tagName){
    this.$init(tagName || "graph", apf.NODE_VISIBLE, struct);
};

apf.aml.setElement("graph", apf.Graph);
 
(function(){
    //this.$attrExcludePropBind = apf.extend({
    //���style : 1
    //}, this.$attrExcludePropBind);

    //this.$supportedProperties = ["type","series","formula"];
    this.$focussable = false;

    this.$drawCode = 0;
    this.$_style = null;
	this.$docompile = true;
	this.$doinit = true;
	this.style = '';

    this.$microtime = 0;
	this.$datasource = null;
    this.$datamode = null;
	this.$datatype = null;
    this.dataslice = '1X';
    this.steps = 100;
    this.$data = null;
    this.$tilex = 0;
    this.$tiley = 0;
    this.m={x:0,y:0};
    this.nc = 0;
	this.$styletag = '';	
    this.$propHandlers["left"] = 
    this.$propHandlers["top"] =
    this.$propHandlers["width"] =
    this.$propHandlers["height"] =function(value){
    }
    
    this.$propHandlers["series"] = function(value){
        var v_yval = this.v_yval  = [];
        var v_xval = this.v_xval  = [];
        var v_zval = this.v_zval  = [];
        var v_time = this.v_time  = [];
        var v_caption = this.v_caption  = []; // mouseover title
        var v_class = this.v_class = []; // class
        var v_state = this.v_state = []; // class
        this.v_stateresolve = false;
        // x / y value array
        var p,v,n,k,l,t = (new Date()).getTime()*0.001, css;
        var series, split, delim, caption, cls, formula, length, mip;
        if (typeof value == "string") {
            series  = value;
            split   = ",";
            delim   = " ";
            css     = "#";
            caption = null;
        }
        else {
            series   = value.series;
            split    = value.split;
            caption  = value.caption;
            delim    = value.delim;
            css      = value.css;
            formula  = value.formula;
            length   = value.length;
        }
        
        if (!series)
            return;
        if(formula){
            //alert(formula);
            var mdl = this.getModel();
            if(!mdl.v_yval){
                var f = new Function('length','v_yval',apf.draw.baseMacro(
                        ["for(v = 0;v<length;v++){",
                            "v_yval[v] = ",[formula],";",
                        "}"]));
                f(length,v_yval);
                mdl.v_yval = v_yval;
            } else v_yval = mdl.v_yval;
            // now we need to generate the v_yval mipmapping array
            if(this.mipstep>1){
                var step = this.mipstep;
                // lets switch mipdiv type
                var v_yvalmip = this.v_yvalmip = [v_yval];
                var newd = [], oldd = v_yval,i, j, v, n, m, c;

                switch(this.mipset){
                    case 'avg':
                        while(oldd.length>10){
                            v_yvalmip.push(newd);
                            for(j=0,n=0,m=oldd.length;n<m;n++){
                                if(!(n%step)){
                                    if(n) newd[j++] = v / step;
                                    v = oldd[n];
                                }else v += oldd[n];
                            }
                            oldd= newd, newd = [];
                        }
                    break;
                    case 'add':
                        while(oldd.length>10){
                            v_yvalmip.push(newd);
                            for(j=0,n=0,m=oldd.length;n<m;n++){
                                if(!(n%step)){
                                    if(n) newd[j++] = v;
                                    v = oldd[n];
                                }else v += oldd[n];
                            }
                            oldd= newd, newd = [];
                        }
                    break;
                    case 'min':
                        while(oldd.length>10){
                            v_yvalmip.push(newd);
                            for(j=0,n=0,m=oldd.length;n<m;n++){
                                if(!(n%step)){
                                    if(n) newd[j++] = v;
                                    v = oldd[n];
                                }else if( v > (c=oldd[n])) v = c;
                            }
                            oldd= newd, newd = [];
                        }
                    break;
                    case 'max':
                        while(oldd.length>10){
                            v_yvalmip.push(newd);
                            for(j=0,n=0,m=oldd.length;n<m;n++){
                                if(!(n%step)){
                                    if(n) newd[j++] = v;
                                    v = oldd[n];
                                }else if( v < (c=oldd[n])) v = c;
                            }
                            oldd= newd, newd = [];
                        }
                    break;                
                }
                this.$datamode = 'series';
            }   
        }else{
            p = series.split(delim);
            for( v = 0; v < p.length; v++ ){
                
                this.v_time[v] = t;
                n = p[v].split(css);
                // todo, add support for procedural class selection
                this.v_state[v] = 0;
                if(n.length>1){// we have a clsname
                    this.v_class[v] = n[1];
                }
                
                if(caption){
                    k = n[0].split(caption);
                    if(k.length>1)
                        v_caption[v] = k[1];
                    k=k[0].split(split);
                }else k = n[0].split(split);
                var dim = 1;
                if ((l = k.length) > 0){
                    if (l == 1)
                        v_yval[v] = parseFloat(k[0]);
                    else if (l >= 2){
                        v_xval[v] = parseFloat(k[0]);
                        v_yval[v] = parseFloat(k[1]);
                        if(l>=3)
                            v_zval[v] = parseFloat(k[2]);
                    }
                }
            }
            // lets pick a series type
            this.$datamode = 'series';
            
        }
        // set source type
    }
    
    this.$propHandlers["formula"] = function(value){
        this.pformula = apf.draw.parseJSS(value);
        // set source type
        this.$datamode = 'math';
        this.$docompile = true;
    }
    
    this.$propHandlers["mode"] = function(value){
        this.$regenerate();
    }

    this.$propHandlers["style"] = function(value){
        this.$regenerate();
    }
    
    this.$propHandlers["a"] = 
    this.$propHandlers["b"] =
    this.$propHandlers["c"] = 
    this.$propHandlers["d"] = function(value){
        this.$redraw();
    }
    
    this.$redraw = function(now,resize){
        // call parent to repaint
        if(this.$parentChart)
            this.$parentChart.$redraw(now,resize);
    }
    
    this.$regenerate = function(){
        this.$_style = null;
        this.$docompile = true;
    }
    
    this.$drawGraph = function( v, doresize ){
		if(this.$doinit){
            this.$doinit = false;
            this.$parentAxis.$copySubPos(this);
			apf.draw.initLayer(this, this.$parentChart);
		}else if(doresize){
			// resize layer
            this.$parentAxis.$copySubPos(this);
 			apf.draw.resizeLayer(this, this.$parentChart);
		}
	    
		if(this.$docompile){
			// if we dont have a sourcetype, the data is not ready yet
			if(!this.$datamode) return this.$redraw();
		
            this.$docompile = false;
            var err = {};
			var mode = this.mode+this.$parentAxis.mode;
            // go and reparse style
           if(!this.$_style)this.$_style = 
                    apf.draw.parseStyle( apf.chart_draw['_'+mode], this.style+this.$styletag, err );
            if(this.$_style.graph && this.$_style.graph.$clslist && this.v_class){
                for(var t,c = this.v_class,s = this.v_state,i=0,j=c.length;i<j;i++){
                    if(t=c[i]){
                        s[i] = this.$_style.graph.$clslist[t];
                    }
                }
            }
            //alert(this.$datatype);
			this.$datatype = apf.chart_draw['dt_'+this.$datamode+this.dataslice](this);
			this.$drawCode  = apf.chart_draw[mode]( this, this.$datatype, this.$_style );
            // we'll also have to compile the balloon and knob code.
        }
	
        if (this.$drawCode){
            this.$drawCode( this, v);
            if(this._anim){
                this.$redraw();
            }
        }
    }
    
    this.$drawBalloons = function(v, doresize){
        if(this.$doinit){
            this.$doinit = false;
			apf.draw.initLayer(this, this.$parentChart);
		}else if(doresize){
			// resize layer
            this.$parentAxis.$copySubPos(this);
 			apf.draw.resizeLayer(this, this.$parentChart);
		}
	    
		if(this.$docompile){
			// if we dont have a sourcetype, the data is not ready yet
			if(!this.$datamode) return this.$redraw();
		
            this.$docompile = false;
            var err = {};
			var mode = this.mode+this.$parentAxis.mode;
            // go and reparse style
           if(!this.$_style){
				this.$_style = 
                    apf.draw.parseStyle( apf.chart_draw['_'+mode], this.style+this.$styletag, err );
            }
			if(this.$_style.graph.$clslist && this.v_class){
                for(var t,c = this.v_class,s = this.v_state,i=0,j=c.length;i<j;i++){
                    if(t=c[i]){
                        s[i] = this.$_style.graph.$clslist[t];
                    }
                }
            }
            //alert(this.$datatype);
			this.$datatype = apf.chart_draw['dt_'+this.$datamode+this.dataslice](this);
			this.$drawCode  = apf.chart_draw[mode]( this, this.$datatype, this.$_style );
            // lets get some ballooons.
            //this.$balloonCode = apf.chart_draw[
            // we'll also have to compile the balloon and knob code.
        }
	
        if (this.$drawCode){
            this.$drawCode( this, v);
            if(this._anim){
                this.$redraw();
            }
        }
    }
    
    this.$mouseDown = function(x,y,bt){

    }
    
    this.$mouseUp = function(x,y){

    }
    
    this.lastOver = -1;
    this.$mouseMove = function(dx,dy,bt,ox,oy,lx,ly){
	
        if (!this.$drawCode) //@todo en zo verder
            return;
        var m = this.m;m.x = lx*this.ds, m.y = ly*this.ds;
        var o = this.$drawCode( this, this.parentNode, this.m), l, nlt;
        var t = (new Date()).getTime()*0.001;
        var _self = this;
        function switchState(i, newstate, oldstate){
            var s,c,ht,v,vn;
            s = (v=_self.v_state[i])&0xffff0000, c = v&0xffff;
			
            ht = Math.min(1,(t-_self.v_time[i])*(_self.$_style.graph.$speedlut?(_self.$_style.graph.$speedlut[v]||1):1));
            _self.v_state[i] = vn = c | newstate;
            if(_self.$_style.graph.notransit==1 || _self.$_style.graph.nogap==1) ht = 1;
            _self.v_time[i]  = s==oldstate?(t-(1-ht)/(_self.$_style.graph.$speedlut?(_self.$_style.graph.$speedlut[vn]||1):1)):t;
        }
        
        function setState(i, newstate, t, lt){
            var s,c,v,vn;
            s = (v=_self.v_state[i])&0xffff0000, c = v&0xffff;
            _self.v_state[i] = vn = c | newstate, 
            _self.v_time[i]  = (t-(1-lt)/(this.$_style.graph.$speedlut?(this.$_style.graph.$speedlut[vn]||1):1));
        }
        
        if(o!=(l=this.lastOver)){
            var sb = apf.draw.stateBit;
            // we should remove the over-state from the last
            if(l>=0){
                switchState(l, sb.hoverout, sb.hoverin );
                
                if( this.$_style.graph.nogap==1 &&  t - this.lasttime<0.3 ){
                    if(t-this.lasttime==0){
                        //logw( this.$microtime - this.lastMicro);
                    }
                    var s = this.lastOut, e = l;
                    if( s > e )
                        for(var i = s;i>e;i--)
                            setState(i, sb.hoverout, t - (t-this.lasttime)*(1-(s-i)/(s-e)), 1);
                   else
                        for(var i = s;i<e;i++)
                            setState(i, sb.hoverout, t - (t-this.lasttime)*((e-i)/(e-s)), 1);
                }
                this.lasttime = t, this.lastOut = l, this.lastMicro = this.$microtime;
            }
            if(o>=0){
                switchState(o, sb.hoverin, sb.hoverout );
            }
  
            this.lastOver = o;
			this.$redraw();
        }
    }
    /**** Databinding ****/
    this.$load = function(XMLRoot){
	
        //Add listener to XMLRoot Node
        apf.xmldb.addNodeListener(XMLRoot, this);

        var v_yval = this.v_yval  = [];
        var v_xval = this.v_xval  = [];
        var v_zval = this.v_zval  = [];
        var v_time = this.v_time  = [];
        var v_caption = this.v_caption  = []; // mouseover title
        var v_state = this.v_state = []; // class

        if (this.$hasBindRule("series")) {
            var rule   = (this.$getBindRule("series", XMLRoot) || {})[4];
            this.setProperty("series", {
                series  : this.$applyBindRule("series", XMLRoot),
                split   : rule.getAttribute("split") || ",",
                datatype   : rule.getAttribute("datatype") || "1X",
                caption : rule.getAttribute("caption") || null,
                cls : rule.getAttribute("class") || null,
                delim   : rule.getAttribute("delimeter") || " ",
                formula : rule.getAttribute("formula") || null,
                length :  rule.getAttribute("length") || null,
                mip :  rule.getAttribute("mip") || null
                
            });
        }
        else if (this.$hasBindRule("formula")) {
            this.setProperty("formula", this.$applyBindRule("formula", XMLRoot));
        }
        else {
            // this.info = [];
            // this.ylabel = {};hoeveel 
            var v_nodes = this.v_nodes  = this.getTraverseNodes(XMLRoot);
            // x / y value array
            var n,p,v,k,length,t = (new Date()).getTime()*0.001;
            if (!this.$hasBindRule("y")){
                apf.console.warn("No y binding rule found for graph "
                                 + this.name + " [" + this.localName + "]");
            }
            else {
                var bz = this.$hasBindRule("z") ? true : false, 
                    bx = this.$hasBindRule("x") ? true : false;
                for (v = 0, length = v_nodes.length; v < length; v++) {
                    n = v_nodes[v];
                    //caching
                    //v_cacheid[apf.xmldb.nodeConnect(this.documentId, n, null, this)] = v;
                
                    this.v_time[v] = t;
                    v_yval[v] = parseFloat(this.$applyBindRule("y", n));
                    if (bx) {
                        v_xval[v] = parseFloat(this.$applyBindRule("x", n));
                        if (bz)
                            v_zval[v] = parseFloat(this.$applyBindRule("z", n));
                    }
                    var cls = this.$applyBindRule("css", n);
                    v_caption[v] = this.$applyBindRule("caption", n);
                    //// TODO write code that looks up class
                    v_state[v] = 0;
                }
                this.$sourcetype = 'seriesX';
            }
            
            if (length != this.length)
                this.setProperty("length", length);
            
        }
    };
    
/*	
addEventListener("DOMNodeInsertedIntoDocument", function( e ){

});
 $loadAml
 addEventListener("DOMNodeInserted", function( e ){

});
 addEventListener("DOMNodeRemoved", function( e ){

});
 addEventListener("DOMNodeRemovedFromDocument", function( e ){

});
	addEventListener("DOMNodeInsertedIntoDocument", function( e ){

	});
*/
    this.$xmlUpdate = function(action, xmlNode, listenNode, UndoObj){
	
        //Clear this component if some ancestor has been detached
        if (action == "redo-remove") {
            var retreatToListenMode = false, model = this.getModel(true);
            if (model) {
                var xpath = model.getXpathByAmlNode(this);
                if (xpath) {
                    var xmlNode = model.data.selectSingleNode(xpath);
                    if (xmlNode != this.xmlRoot)
                        retreatToListenMode = true;
                }
            }
            
            if (retreatToListenMode || this.xmlRoot == xmlNode) {
                //Set Component in listening state untill data becomes available again.
                return model.$waitForXml(this);
            }
        }
    
        if (this.$hasBindRule("series") || this.$hasBindRule("formula")) { 
            //Action Tracker Support
            if (UndoObj && !UndoObj.xmlNode)
                UndoObj.xmlNode = this.xmlRoot;
                
            
            //@todo apf3.0 check if this is still needed
            /*var lrule, rule;
            for (rule in this.bindingRules) {
                lrule = rule.toLowerCase();
                if (this.$supportedProperties.contains(lrule)) {
                    var value = this.$applyBindRule(rule, this.xmlRoot) || "";

                    if (this[lrule] != value)
                        this.setProperty(lrule, value, true);
                }
            }*/
            
        }
        else {
            //this should be made more optimal
            var v_yval = this.v_yval  = [];
            var v_xval = this.v_xval  = [];
            var v_zval = this.v_zval  = [];
            var v_time = this.v_time  = [];
            var v_caption = this.v_caption  = []; // mouseover title
            var v_state = this.v_state = []; // class
        
            //cacheid = xmlNode.getAttribute(apf.xmldb.xmlIdTag);
            // this.info = [];
            // this.ylabel = {};hoeveel 
            var v_nodes = this.v_nodes  = this.getTraverseNodes(this.xmlRoot);
            // x / y value array
            var n,p,v,k,length,t = (new Date()).getTime()*0.001;
            if (!this.$hasBindRule("y")){
                apf.console.warn("No y binding rule found for graph "
                                 + this.name + " [" + this.localName + "]");
            }
            else {
                var bz = this.$hasBindRule("z") ? true : false, 
                    bx = this.$hasBindRule("x") ? true : false;
                for (v = 0, length = v_nodes.length; v < length; v++) {
                    n = v_nodes[v];
                    //caching
                    //v_cacheid[apf.xmldb.nodeConnect(this.documentId, n, null, this)] = v;
                
                    this.v_time[v] = t;
                    v_yval[v] = parseFloat(this.$applyBindRule("y", n));
                    if (bx) {
                        v_xval[v] = parseFloat(this.$applyBindRule("x", n));
                        if (bz)
                            v_zval[v] = parseFloat(this.$applyBindRule("z", n));
                    }
                    var cls = this.$applyBindRule("css", n);
                    v_caption[v] = this.$applyBindRule("caption", n);
                    //// TODO write code that looks up class
                    v_state[v] = 0;
                }
                this.$sourcetype = 'seriesX';
            }
            //if (this.focussable)
                //apf.document.activeElement == this ? this.$focus() : this.$blur();

            
            if (length != this.length)
                this.setProperty("length", length);
            
			this.$redraw();
        }
    }
    
    /**** Selection ****/
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        this.$parentAxis = this.parentNode;
        this.$parentChart = this.$parentAxis.parentNode;
		var n = this.getElementsByTagNameNS(apf.ns.apf, "style");
		if(n.length>0){
			this.$styletag = n[0].firstChild.nodeValue;
		}
    });
}).call(apf.Graph.prototype = new apf.AmlElement());


/*FILEHEAD(/var/lib/platform/source/trunk/elements/remote.js)SIZE(13637)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element allowing data synchronization between multiple clients using the same
 * application or application part. This element is designed as thecore of 
 * collaborative application logic for Ajax.org Platform. The children of this
 * element specify how the uniqueness of {@link term.datanode data nodes} is determined. By pointing
 * models to this element, all changes to their data will be streamed through
 * this element to all listening client over a choosen protocol. 
 * Example:
 * This example shows a small application which is editable by all clients that
 * have started it. Any change to the data is synchronized to all participants.
 * <code>
 *  <a:teleport>
 *      <a:xmpp id="myXMPP"
 *        url           = "http://ajax.org:5280/http-bind" 
 *        model         = "mdlRoster" 
 *        connection    = "bosh" 
 *  </a:teleport>
 *  
 *  <a:remote transport="myXMPP" id="rmtPersons">
 *      <a:person unique="[@id]" />
 *  </a:remote>
 *  
 *  <a:model id="mdlPersons" remote="rmtPersons">
 *      <persons>
 *          <person id="1">mike</person>
 *          <person id="2">ruben</person>
 *      </persons>
 *  </a:model>
 *
 *  <a:list id="lstPersons" model="mdlPersons" width="200" height="100">
 *      <a:bindings>
 *          <a:each match="[person]" />
 *          <a:caption match="[text()]" />
 *          <a:icon value="icoUsers.gif" />
 *      </a:bindings>
 *  </a:list>
 *
 *  <a:button action="remove" target="lstPersons">Remove</a:button>
 *  <a:button action="rename" target="lstPersons">Rename</a:button>
 *  
 *  <a:button onclick="myXMPP.connect('testuser@ajax.org', 'testpass')">
 *      Login
 *  </a:button>
 * </code>
 * Remarks:
 * Although locking is solved in smartbindings it is directly connected
 * to remote smartbindings. When multiple people are working within the same
 * application it's important to have a system that prevents corruption of data
 * and data loss by either user overwriting records edited during the same period.
 * Ajax.org Platform has built in support for optimistic and pessimistic locking
 * in smartbindings. For more information please see {@link term.locking}.
 * 
 * Advanced:
 * There is a very small theoretical risk that a user initiates and finishes an 
 * action during the latency period of the rsb communication. Usually this 
 * latency is no more than 100 to 300ms which is near impossible for such action
 * to be performed. Therefor this is deemed acceptable.
 * 
 * Working in a multi user environment could imply that data has a high 
 * probability of changing. This might be a problem when syncing offline 
 * changes after several hours. This should be a consideration for the 
 * application architect.
 *
 * Another concern for offline use is the offline messaging feature of certain
 * collaborative protocols (i.e. xmpp). In many cases offline rsb messages should 
 * not be stored after the user has been offline for longer then a certain time.
 * For instance 10 minutes. An accumulation of change messages would create a
 * serious scaling problem and is not preferred. apf.offline has built in support
 * for this type of timeout. By setting the rsb-timeout attribute it is aware
 * of when the server has timed out. When this timeout is reached the application 
 * will reload all it's data from the server and discard all offline rsb 
 * messages before reconnecting to the server.
 *
 * @attribute {String} transport the name of the teleport element that provides a
 * bidirectional connection to (a pool of) other clients.
 * 
 * @see element.auth
 *
 * @define remote
 * @allowchild unique, {any}
 * @addnode elements
 *
 * @define unique Element defining what is unique about a set of data
 * elements. This enables remote smartbindings to point to xml data in 
 * the same way on all clients. This way changes that happen to these 
 * elements are described non-ambiguously. The tagName can be replaced
 * by the tagName of the {@link term.datanode data node} for which the uniqueness is specified.
 * Example:
 * This example shows a complex data set and a remote smartbinding that
 * specifies the uniqueness of all nodes concerned.
 * <code>
 *  <a:model id="mdlPersons" remote="rmtPersons">
 *      <universe>
 *          <galaxy name="milkyway">
 *              <planet id="ALS-3947">
 *                  <species>3564</species>
 *                  <species>8104</species>
 *              </planet>
 *              <planet id="Earth">
 *                  <person number="802354897">Mike</person>
 *                  <person number="836114798">Rik</person>
 *              </planet>
 *          </galaxy>
 *      </universe>
 *  </a:model>
 *
 *  <a:remote transport="myXMPP" id="rmtPersons">
 *      <a:person unique="[@number]" />
 *      <a:unique match="[self::galaxy]" unique="[@name]" />
 *      <a:planet unique="[@id]" />
 *      <a:species unique="[text()]" />
 *  </a:remote>
 * </code>
 * @attribute {String} select   the xpath that selects the set of {@link term.datanode data nodes} that share a similar uniqueness trait.
 * @attribute {String} unique   the xpath that retrieves the unique value for a specific {@link term.datanode data node}.
 */
/**
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.983
 *
 * @default_private
 * @constructor
 *
 * @todo Think about wrapping multiple messages in a single call
 * @todo Make RSB support different encoding protocols (think REX)
 */
apf.remote = function(struct, tagName){
    this.$init(tagName || "remote", apf.NODE_HIDDEN, struct);
};

(function(){
    this.lookup     = {};
    this.select     = [];
    this.models     = [];
    this.rsbQueue   = {};
    this.queueTimer = null;
    
    
    this.discardBefore = null;
    

    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        match : 1
    }, this.$attrExcludePropBind);
    
    this.sendChange = function(args, model){
        if (apf.xmldb.disableRSB)
            return;

        clearTimeout(this.queueTimer);
        //return this.transport.sendRSB(apf.serialize(args)); 
        this.queueMessage(args, model, this);
        if (!apf.isO3) {
            // use a timeout to batch consecutive calls into one RSB call
            var _self = this;
            this.queueTimer = $setTimeout(function() {
                _self.processQueue(_self);
            });
        }
        else {
            this.processQueue(this);
        }
    };
    
    this.buildMessage = function(args, model){
        for (var i = 0, l = args.length; i < l; i++) {
            if (args[i] && args[i].nodeType)
                args[i] = this.xmlToXpath(args[i], model.data);
        }
        
        return {
            model     : model.name,
            args      : args,
            timestamp : new Date().toGMTString()
        };
    };
    
    this.queueMessage = function(args, model, qHost){
        if (!model.id)
            model.setAttribute("id", "rmtRsbGen".appendRandomNumber(5));

        if (!qHost.rsbQueue)
            qHost.rsbQueue = {};
        if (!qHost.rsbQueue[model.id]) {
            qHost.rsbQueue[model.id] = [];
            qHost.rsbModel           = model;
        }
        // @todo do some more additional processing here...
        qHost.rsbQueue[model.id].push(this.buildMessage(args, model));
    };
    
    this.processQueue = function(qHost){
        if (qHost === this)
            clearTimeout(this.queueTimer);
        if (apf.xmldb.disableRSB) return;

        for (var model in qHost.rsbQueue) {
            if (!qHost.rsbQueue[model].length) continue;
            
            apf.console.info("Sending RSB message\n" + apf.serialize(qHost.rsbQueue[model]));
            
            this.transport.sendRSB(apf.serialize(qHost.rsbQueue[model]));
        }
        qHost.rsbQueue = {};
    };
    
    this.receiveChange = function(message){
        if (apf.xmldb.disableRSB)
            return;

        
        // @todo apf3.0 implement proper offline support in RSB
        if (apf.offline && apf.offline.inProcess == 2) { //We're coming online, let's queue until after sync
            queue.push(message);
            return;
        }
        
        
        //this.lastTime = new Date().getTime();
        if (message.timestamp < this.discardBefore)
            return;
        
        var model = apf.nameserver.get("model", message.model),
            q     = message.args;
        
        
        if (!model) {
            //Maybe make this a warning?
            throw new Error(apf.formatErrorString(0, this, 
                "Remote Smartbinding Received", "Could not find model when "
              + "receiving data for it with name '" + message.model + "'"));
        }
        
        
        //Maybe make this an error?
        var xmlNode = this.xpathToXml(q[1], model.data);
        
        if (!xmlNode) {
            throw new Error(apf.formatErrorString(0, this,
                "Remote Smartbinding Received", "Could get XML node from model "
              + "with Xpath '" + q[1] + "'"));
        }
        
        
        var disableRSB       = apf.xmldb.disableRSB,
            beforeNode;
        apf.xmldb.disableRSB = 2; //Feedback prevention

        switch (q[0]) {
            case "setTextNode":
                apf.xmldb.setTextNode(xmlNode, q[2], q[3]);
                break;
            case "setAttribute":
                apf.xmldb.setAttribute(xmlNode, q[2], q[3], q[4]);
                break;
            case "addChildNode":
                apf.xmldb.addChildNode(xmlNode, q[2], q[3],
                    this.xpathToXml(q[4], model.data), q[5]);
                break;
            case "appendChild":
                beforeNode = (q[3] ? this.xpathToXml(q[3], model.data) : null);
                if (typeof q[2] == "string")
                    q[2] = apf.getXml(q[2]);
                apf.xmldb.appendChild(xmlNode, //@todo check why there's cleanNode here
                    apf.xmldb.cleanNode(q[2]), beforeNode, q[4], q[5]);
                break;
            case "moveNode":
                beforeNode = (q[3] ? this.xpathToXml(q[3], model.data) : null);
                var sNode = this.xpathToXml(q[2], model.data);
                apf.xmldb.appendChild(xmlNode, sNode, beforeNode,
                    q[4], q[5]);
                break;
            case "removeNode":
                apf.xmldb.removeNode(xmlNode, q[2]);
                break;
        }

        apf.xmldb.disableRSB = disableRSB;
    };
    
    this.xmlToXpath = apf.xmlToXpath;
    this.xpathToXml = apf.xpathToXml;
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        
        apf.console.info(this.id
            ? "Creating remote [" + this.id + "]"
            : "Creating implicitly assigned remote");
        

        var _self = this;

        
        if (apf.offline && apf.offline.enabled) {
            var queue = [];
            apf.offline.addEventListener("afteronline", function(){
                for (var i = 0, l = queue.length; i < l; i++)
                    _self.receiveChange(queue[i]);

                queue.length = 0;
            });
        }
        
        
        /**
         * @attribute {String} transport the id of the teleport module instance 
         * that provides a means to sent change messages to other clients.
         */
        this.transport = self[this["transport"]];

        
        if (!this.transport) {
            throw new Error("Missing transport");//@todo make this a proper apf3.0 error
        }
        

        this.transport.addEventListener("datachange", function(e){
            var data = apf.unserialize(e.data),
                i    = 0,
                l    = data.length;//@todo error check here.. invalid message
            for (; i < l; i++)
                _self.receiveChange(data[i]);
        });
    });
}).call(apf.remote.prototype = new apf.AmlElement());

apf.aml.setElement("remote", apf.remote);
apf.aml.setElement("unique", apf.BindingRule);





/*FILEHEAD(/var/lib/platform/source/trunk/elements/auth.js)SIZE(22566)TIME(1260921691)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @define auth Centralized authentication handling. Not being logged in, after being
 * offline for a while can put the application
 * in a complex undefined state. The auth element makes sure the state is always
 * properly managed. When it gets signalled 'authentication required' it dispatches the
 * appropriate events to display a login box. It can automatically retry logging
 * in to one or more services using in memory stored username/password
 * combinations. It will queue all requests that require authentication until
 * the application is logged in again and will then empty the queue.
 * Example:
 * This example sets up apf.auth with two services that it can log into. 
 * <code>
 *  <a:appsettings>
 *      <a:auth>
 *           <a:service name   = "my-backend"
 *                      login  = "{comm.login(username, password)}"
 *                      logout = "{comm.logout()}" />
 *           <a:service name   = "my-jabber-server"
 *                      login  = "{myXmpp.login(username, password, domain)}"
 *                      logout = "{myXmpp.logout()}" />
 *      </a:auth>
 *  </a:appsettings>
 * </code>
 * Example:
 * A login window with different states managed by apf.auth
 * <code>
 *   <a:appsettings>
 *       <a:auth 
 *         login         = "{comm.login(username, password)}" 
 *         logout        = "{comm.logout()}"
 *         autostart     = "false"
 *         window        = "winLogin"
 *         fail-state    = "stFail"
 *         error-state   = "stError"
 *         login-state   = "stIdle"
 *         logout-state  = "stLoggedOut"
 *         waiting-state = "stLoggingIn" />
 *   </a:appsettings>
 *   <a:teleport>
 *       <a:rpc id="comm" protocol="cgi">
 *           <a:method name="login" url="http://localhost/login.php">
 *               <a:variable name="username" />
 *               <a:variable name="password" />
 *           </a:method>
 *           <a:method name="logout" url="http://localhost/logout.php" />
 *       </a:rpc>
 *   </a:teleport>
 *  
 *   <a:state-group
 *     loginMsg.visible  = "false"
 *     winLogin.disabled = "false">
 *       <a:state id="stFail"
 *         loginMsg.value   = "Username or password incorrect"
 *         loginMsg.visible = "true" />
 *       <a:state id="stError"
 *         loginMsg.value   = "An error has occurred. Please check your network."
 *         loginMsg.visible = "true" />
 *       <a:state id="stLoggingIn"
 *         loginMsg.value    = "Please wait whilst logging in..."
 *         loginMsg.visible  = "true"
 *         winLogin.disabled = "true"
 *         btnLogout.visible = "false" />
 *       <a:state id="stIdle"
 *         btnLogout.visible = "true" />
 *       <a:state id="stLoggedOut"
 *         btnLogout.visible = "false"
 *         loginMsg.visible  = "false"
 *         winLogin.disabled = "false" />
 *  </a:state-group>
 * 
 *  <a:window id="winLogin" visible="true" width="400" height="400">
 *      <a:label>Username</a:label>
 *      <a:textbox type="username" value="Lukasz" />
 *  
 *      <a:label>Password</a:label>
 *      <a:textbox type="password" value="ppp" />
 * 
 *      <a:label id="loginMsg" />
 *      <a:button action="login">Log in</a:button>
 *  </a:window>
 *  <a:button id="btnLogout" visible="false" action="logout">Log out</a:button>
 * </code>
 *
 * @event beforelogin   Fires before the log in request is sent to the service
 *   cancelable:    Prevents the log in from happening
 * @event beforelogout  Fires before the log out request is sent to the service
 *   cancelable:    Prevents the log out from happening
 * @event logincheck    Fires when log in data is received. Login is sometimes very complex, this event is dispatched to allow a custom check if a log in succeeded.
 *   bubbles: yes
 *   object:
 *     {Object} data     the data received from the log in request
 *     {Number} state    the return code of the log in request
 * @event loginfail     Fires when a log in attempt has failed
 * @event loginsuccess  Fires when a log in attempt succeeded
 * @event logoutcheck   Fires when log out data is received. Login is sometimes very complex, this event is dispatched to allow a custom check if a log out succeeded.
 *   bubbles: yes
 *   object:
 *     {Object} data     the data received from the log out request
 *     {Number} state    the return code of the log out request
 * @event logoutfail    Fires when a log out attempt has failed
 * @event logoutsuccess Fires when a log out attempt succeeded
 * @event authrequired  Fires when log in credentials are required, either because they are incorrect, or because they are unavailable.
 *   bubbles: yes
 *
 * @inherits apf.Class
 *
 * @attribute {String}  login           the {@link term.datainstruction data instruction} on how to log in to a service.
 * @attribute {String}  logout          the {@link term.datainstruction data instruction} on how to log out of a service.
 * @attribute {Boolean} autostart       whether to fire authrequired at startup. Defaults to true.
 * @attribute {String}  window          the id of the window element that offers a log in form to the user.
 * @attribute {String}  fail-state      the id of the state element which is activated when logging in failed because the credentials where incorrect.
 * @attribute {String}  error-state     the id of the state element which is activated when logging in failed because of an error (i.e. network disconnected).
 * @attribute {String}  login-state     the id of the state element which is activated when logging in succeeded.
 * @attribute {String}  waiting-state   the id of the state element which is activated when the user is waiting while the application is logging in.
 * @attribute {String}  logout-state    the id of the state element which is activated when the user is logged out.
 * @attribute {String}  model           the id of the model element which gets the data loaded given at login success.
 * @attribute {String}  remember        whether to remember the login credentials after the first successful login attempt. Will only be used i.c.w. RPC
 * @allowchild service
 * @define service  Element specifying a server to log into.
 * @attribute {String} name     the unique identifier of the service
 * @attribute {String} login    the {@link term.datainstruction data instruction} on how to log in to a service
 * @attribute {String} logout   the {@link term.datainstruction data instruction} on how to log out of a service
 * @see element.appsettings
 *
 * @default_private
 */

apf.auth = function(struct, tagName){
    this.$init(tagName || "auth", apf.NODE_HIDDEN, struct);

    this.$services    = {};
    this.$cache       = {};
    this.$queue       = [];
    this.$credentials = null;
};

apf.aml.setElement("auth", apf.auth);

(function(){
    this.$retry      = true;
    this.$loggedIn   = false;
    this.$needsLogin = false;
    this.$autoStart  = true;
    this.$hasHost    = false;

    /**
     * Indicates the state of the log in process.
     * Possible values:
     * 0 idle
     * 1 logging in
     * 2 logging out
     */
    this.inProcess  = 0;
    
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        login   : 1,
        logout  : 1
    }, this.$attrExcludePropBind);
    
    this.$booleanProperties["autostart"] = true;
    this.$booleanProperties["remember"]  = true;

    this.$supportedProperties.push("login", "logout", "fail-state", "error-state",
        "login-state", "logout-state", "waiting-state", "window", "autostart",
        "remember");

    this.$propHandlers["login"]         = 
    this.$propHandlers["login-state"]   = function(value){
        this.$services["default"] = value ? this : null;
        this.$needsLogin          = value ? true : false;
    };
    
    this.register = function(node){
        this.$services[node.name] = node;
        this.$needsLogin = true;
    };
    
    this.unregister = function(node){
        var prop;
        delete this.$services[node.name];
        if (!(prop in this.$services))
            this.$needsLogin = false;
    };
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        this.inited = true;

        if (this.parentNode && this.parentNode.$setAuth) {
            this.parentNode.$setAuth(this);
            this.$hasHost = true;
        }

        if (this.$autoStart && !this.$hasHost) {
            var _self = this;
            apf.addEventListener("load", function(){
                _self.authRequired();
                apf.removeEventListener("load", arguments.callee);
            });
        }
    });
    
    this.addEventListener("authrequired", function(){
        if (self[this.window]) {
            this.win = self[this.window];
            if (this.win) {
                this.win.show();
                return false;
            }
        }
    });

    this.addEventListener("beforelogin", function(){
        if (self[this["waiting-state"]]) {
            this.state = self[this["waiting-state"]];
            if (this.state)
                this.state.activate();
        }
    });

    function failFunction(e){
        var st = (e.state == apf.TIMEOUT
            ? self[this["error-state"]]
            : self[this["fail-state"]]) || self[this["fail-state"]]

        if (st) {
            this.state = st;
            if (this.state) {
                this.state.activate();
                return false;
            }
        }
    }
    
    this.addEventListener("loginfail",  failFunction);
    this.addEventListener("logoutfail", failFunction);

    this.addEventListener("logoutsuccess", function(){
        if (self[this["logout-state"]]) {
            this.state = self[this["logout-state"]];
            if (this.state)
                this.state.activate();
        }
    });

    this.addEventListener("loginsuccess", function(e){
        if (self[this.window]) {
            this.win = self[this.window];
            if (this.win)
                this.win.hide();
        }

        if (self[this["login-state"]]) {
            this.state = self[this["login-state"]];
            if (this.state)
                this.state.activate();
        }

        if (e.data && this.model) {
            this.model = apf.nameserver.get("model", this.model);
            if (this.model)
                this.model.load(e.data);
        }
    });

    /**
     * Log in to one or more services
     * @param {String}   username   the username portion of the credentials used to log in with
     * @param {String}   password   the password portion of the credentials used to log in with
     * @param {Function} [callback] code to be called when the application succeeds or fails logging in
     * @param {Object}   [options]  extra settings and variables for the login. These variables will be available in the {@link term.datainstruction data instruction} which is called to execute the actual log in.
     *   Properties:
     *   {Array} services   a list of names of services to be logged in to
     *   {String} service   the name of a single service to log in to
     */
    this.loginFn = function(username, password, callback, options){
        if (!options) options = {};

        options.username = username;
        options.password = password;

        if (this.dispatchEvent("beforelogin", options) === false)
            return false;

        this.inProcess = 1; //Logging in

        var pos = 0,
            len = 0,
            _self = this,
            doneCallback = function() {
                if (len != ++pos)
                    return;

                _self.inProcess = 0; //Idle
                _self.$loggedIn  = true;
                _self.clearQueue();

                if (callback)
                    callback();
            };

        if (this.$hasHost) { // child of Teleport element
            this.$credentials  = options;
            callback           = this.$hostCallback;
            this.$hostCallback = null;
            len                = 1;
            doneCallback();
            this.dispatchEvent("loginsuccess", {
                state   : 1,
                data    : null,
                bubbles : true
            });
            if (!this.remember)
                this.$credentials = null;
        }
        else {
            if (!options.service) {
                var s = options.$services || this.$services;
                for (var name in s) {
                    len++;
                    this.$do(name, options, "in", null, doneCallback);
                }
            }
            else if (options.service) {
                len = 1;
                this.$do(options.service, options, "in", null, doneCallback);
            }
        }
    };

    this.relogin = function(){
        if (this.dispatchEvent("beforerelogin") === false)
            return false;

        
        apf.console.info("Retrying login...", "auth");
        

        //@todo shouldn't I be using inProces here?
        var name, pos = 0, len = 0, _self = this,
            doneCallback = function(){
                if (len != ++pos)
                    return;

                _self.inProcess = 0; //Idle
                _self.$loggedIn  = true;
                _self.clearQueue();
            };

        for (name in this.$services) {
            if (!this.$cache[name])
                return false;
            len++;
            this.$do(name, this.$cache[name], "in", true, doneCallback);
        }

        return true;
    };

    this.$do = function(service, options, type, isRelogin, callback){
        var xmlNode = this.$services[service],
            _self   = options.userdata = this;

        
        options.ignoreOffline = true; //We don't want to be cached by apf.offline
        

        
        apf.console.info("Logging " + type + " on service '"
            + service + "'", "auth");
        

        //Execute login call
        options.callback = function(data, state, extra){
            if (state == apf.TIMEOUT && extra.retries < apf.maxHttpRetries)
                return extra.tpModule.retry(extra.id);

            /*
                Login is sometimes very complex, so this check is
                here to test the data for login information
            */
            var result = _self.dispatchEvent("log" + type + "check",
                apf.extend({
                    state   : state,
                    data    : data,
                    service : service,
                    bubbles : true
                }, extra)),

                loginFailed = typeof result == "boolean"
                    ? !result
                    : !(state == apf.SUCCESS || type == "out" && extra.http.status == 401);

            if (loginFailed) {
                _self.inProcess = 0; //Idle

                if (isRelogin) //If we're retrying then we'll step out here
                    return _self.authRequired();

                
                apf.console.info("Log " + type + " failure for service '"
                    + service + "'", "auth");
                

                var commError = new Error(apf.formatErrorString(0, null,
                    "Logging " + type, "Error logging in: " + extra.message));

                if (_self.dispatchEvent("log" + type + "fail", apf.extend({
                    error   : commError,
                    service : service,
                    state   : state,
                    data    : data,
                    bubbles : true
                }, extra)) !== false)
                    throw commError; //@todo ouch, too harsh?

                //@todo Call auth required again??

                return;
            }

            if (type == "in") {
                //If we use retry, cache the login information
                if (!isRelogin && _self.$retry) {
                    var cacheItem = {};
                    for (var prop in options) {
                        if ("object|array".indexOf(typeof options[prop]) == -1)
                            cacheItem[prop] = options[prop];
                    }
                    _self.$cache[service || "default"] = cacheItem;
                }
            }
            else {
                //Remove cached credentials
                if (_self.$cache[service || "default"])
                     _self.$cache[service || "default"] = null;

                _self.authRequired();
            }

            if (callback)
                callback();

            _self.dispatchEvent("log" + type + "success", apf.extend({
                state   : state,
                service : service,
                data    : data,
                bubbles : true
            }, extra));

            
            apf.console.info("Log " + type + " success for service '"
                + service + "'", "auth");
            
        };
        apf.saveData(xmlNode.getAttribute("log" + type), options);
    };

    this.clearQueue = function(){
        if (!this.$loggedIn) //Queue should only be cleared when we're logged in
            return;

        var queue = this.$queue.slice();
        this.$queue.length = 0;

        for (var i = 0; i < queue.length; i++) {
            var qItem = queue[i];

            //We might be logged out somewhere in this process (think sync)
            if (!this.$loggedIn) {
                this.$queue.push(qItem);
                continue;
            }

             //Specialty retry (protocol specific)
            if (qItem.retry)
                qItem.$retry.call(qItem.object);

            //Standard TelePort Module retry
            else if (qItem.id)
                qItem.tpModule.retry(qItem.id);

            
            //Dunno what's up, lets tell the developer
            else
                apf.console.warn("Unable to retry queue item after "
                  + "successfull logging in. It seems the protocol that sent "
                  + "the message doesn't allow it.");
            
        }

        //The queue might be filled somehow
        if (this.$queue.length)
            this.clearQueue();
    };

    /**
     * Log out of one or more services
     * @param {Function} [callback] code to be called when the application succeeds or fails logging out
     * @param {Object}   [options]  extra settings and variables for the login. These variables will be available out the {@link term.datainstruction data instruction} which is called to execute the actual log out.
     *   Properties:
     *   {Array} services   a list of names of services to be logged out of
     *   {String} service   the name of a single service to log out of
     */
    this.logoutFn = function(callback, options){
        if (!options) options = {};

        if (this.dispatchEvent("beforelogout", options) === false)
            return;

        this.$loggedIn = false;

        if (!options.service) {
            for (var name in this.$services)
                this.$do(name, options, "out", null, callback);
        }
        else if (options.service)
            this.$do(options.service, options, "out", null, callback);

    };

    /**
     * Signals services that a log in is required and fires authrequired event
     * @param {Object}   [options]  information on how to reconstruct a failed action, that detected a log in was required. (i.e. When an HTTP call fails with a 401 Auth Required the options object contains information on how to retry the http request)
     */
    this.authRequired = function(options, forceNoRetry){
        // If we're already logging in return
        if (options && options.userdata == this)
            return;

        // If we're supposed to be logged in we'll try to log in automatically
        if (this.$loggedIn && !forceNoRetry && this.$retry && this.relogin()) {
            var result = false;
        }
        else if (this.inProcess != 1) { //If we're not already logging in
            if (this.$hasHost && typeof options == "function") { //inside Teleport element
                if (this.$credentials)
                    return options();
                this.$hostCallback = options;
            }
            /*
                Apparently our credentials aren't valid anymore,
                or retry is turned off. If this event returns false
                the developer will call apf.auth.login() at a later date.
            */
            var result = this.dispatchEvent("authrequired", apf.extend({
                bubbles : true,
                data    : options && options.data
            }, options));
        }

        this.$loggedIn = false;

        if (result === false) {
            if (options) //Add communication to queue for later processing
                this.$queue.push(options);

            return true; //cancels error state in protocol
        }
    };

}).call(apf.auth.prototype = new apf.AmlElement());


/*FILEHEAD(/var/lib/platform/source/trunk/elements/template.js)SIZE(2502)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Defines a template for aml elements. 
 *
 * @constructor
 * @allowchild {elements}, {anyaml}
 *
 * @define template
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 */

apf.template = function(struct, tagName){
    this.$init(tagName || "template", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$focussable     = false;
    
    this.$frags = {};
    this.getNewInstance = function(htmlNode, id, xmlNode, preventLastPass){
        if (this.$frags[id]) {
            var frag = this.$frags[id];
        }
        else {
            var model, xpath, attr, frag = this.$frags[id] = this.cloneNode(true);
            frag.$int = htmlNode;
            if (xmlNode) { //@todo apf3.0 is this generic enough?
                model = apf.xmldb.findModel(xmlNode);
                xpath = apf.xmlToXpath(xmlNode, model.data, true) || ".";
                frag.attributes.push(attr = new apf.AmlAttr(frag, "model", ""));
                attr.inheritedValue = [model.name, xpath]; //@todo apf3.0 to be tested
            }
            frag.ownerDocument.$domParser.$continueParsing(frag, {delay:true});
        }
        
        return frag;
    }
    
    this.destroyInstance = function(id){
        var frag = this.$frags[id];
        delete this.$frags[id];

        frag.destroy(true);
    }
}).call(apf.template.prototype = new apf.AmlElement());

apf.aml.setElement("template", apf.template);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/item.js)SIZE(20352)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Item of a menu displaying a clickable area.
 * Example:
 *  <a:iconmap 
 *    id     = "tbicons" 
 *    src    = "toolbar.icons.gif"
 *    type   = "horizontal" 
 *    size   = "20" 
 *    offset = "2,2" />
 *  <a:menu id="menu1">
 *      <a:item icon="tbicons:1">Tutorials</a:item>
 *      <a:item icon="tbicons:5">Contact</a:item>
 *  </a:menu>
 *  <a:toolbar>
 *      <a:menubar>
 *          <a:button submenu="menu1">File</a:button>
 *      </a:menubar>
 *  </a:toolbar>
 * </code>
 * @define item, check, radio
 * @constructor
 *
 * @event click Fires when a user presses the mouse button while over this element.
 *   object:
 *   {XMLElement} xmlContext the xml data node that was selected in the opener at the time of showing the context menu.
 *   {AMLElement} opener the element that was clicked upon when showing the context menu.
 */
apf.radio = function(struct, tagName){
    this.$init(tagName || "radio", apf.NODE_HIDDEN, struct);
};

apf.check = function(struct, tagName){
    this.$init(tagName || "check", apf.NODE_HIDDEN, struct);
};

apf.item  = function(struct, tagName){
    this.$init(tagName || "item", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$focussable    = false;
    this.$childProperty = "caption";
    this.$canLeechSkin  = "item";

    this.implement(apf.ChildValue);

    /**** Properties and Attributes ****/
    
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        "match" : 1
    }, this.$attrExcludePropBind);

    this.$supportedProperties.push("submenu", "value", "match", "group", "icon",
                                   "checked", "selected", "disabled", "caption");

    /**
     * @attribute {String} [submenu] the id of the menu that is shown
     * when the user hovers over this menu item.
     * Example:
     * <code>
     *  <a:menu id="msub">
     *      <a:item icon="tbicons:12">test</a:item>
     *      <a:item icon="tbicons:14">test2</a:item>
     *  </a:menu>
     *
     *  <a:menu id="mmain">
     *      <a:item submenu="msub">Sub menu</a:item>
     *  </a:menu>
     * </code>
     */
    this.$propHandlers["submenu"] = function(value){
        apf.setStyleClass(this.$ext, "submenu");
    }
    
    /**
     * @attribute {String} value the value of this element.
     */

    /**
     * @attribute {String} [select] the xpath statement which works on the
     * xml context of the parent menu element to determine whether this
     * item is shown.
     * Example:
     * This example shows a list
     * <code>
     *  <a:list>
     *     [...]
     *
     *     <a:contextmenu menu="mnuXY" select="computer" />
     *     <a:contextmenu menu="mnuTest" />
     *  </a:list>
     *
     *  <a:menu id="mnuTest">
     *     <a:item select="person">Send an E-mail</a:Item>
     *     <a:item select="phone">Call Number</a:Item>
     *     <a:divider />
     *     <a:item select="phone">Remove</a:Item>
     *     <a:divider />
     *     <a:item select="person|phone">View Pictures</a:Item>
     *  </a:menu>
     *
     *  <a:menu id="mnuXY">
     *     <a:item>Reboot</a:Item>
     *  </a:menu>
     * </code>
     */
    this.$propHandlers["select"] = function(value){
        this.select = value
            ? "self::" + value.split("|").join("|self::")
            : value;
    }
    
    /**
     * @attribute {String} [group] the name of the group this item belongs
     * to.
     * Example:
     * <code>
     *  <a:menu>
     *      <a:radio group="example">item 1</a:radio>
     *      <a:radio group="example">item 2</a:radio>
     *      <a:radio group="example">item 3</a:radio>
     *      <a:radio group="example">item 4</a:radio>
     *  </a:menu>
     * </code>
     */

    
    /**
     * @attribute {String} hotkey the key combination a user can press
     * to active the function of this element. Use any combination of
     * Ctrl, Shift, Alt, F1-F12 and alphanumerical characters. Use a
     * space, a minus or plus sign as a seperator.
     * Example:
     * <code>
     *  <a:item hotkey="Ctrl+Q">Quit</a:item>
     * </code>
     */
    this.$propHandlers["hotkey"] = function(value){
        if (this.$hotkey)
            apf.setNodeValue(this.$hotkey, value);

        if (this.$lastHotkey)
            apf.removeHotkey(this.$lastHotkey);

        if (value) {
            this.$lastHotkey = value;
            var _self = this;
            apf.registerHotkey(value, function(){
                //hmm not very scalable...
                var buttons = apf.document.getElementsByTagNameNS(apf.ns.aml, "button");
                for (var i = 0; i < buttons.length; i++) {
                    if (buttons[i].submenu == _self.parentNode.name) {
                        var btn = buttons[i];
                        btn.$setState("Over", {});

                        $setTimeout(function(){
                            btn.$setState("Out", {});
                        }, 200);

                        break;
                    }
                }

                _self.$down();
                _self.$up();
                _self.$click();
            });
        }
    }
    
    /**
     * @attribute {String} icon the url of the image used as an icon or
     * a reference to an iconmap.
     */
    this.$propHandlers["icon"] = function(value){
        if (this.$icon)
            apf.skins.setIcon(this.$icon, value, this.parentNode.iconPath);
    }
    
    /**
     * @attribute {String} caption the text displayed on the item.
     */
    this.$propHandlers["caption"] = function(value){
        if (this.$caption)
            apf.setNodeValue(this.$caption, value);
    }
    
    /**
     * @attribute {Boolean} checked whether the item is checked.
     */
    this.$propHandlers["checked"] = function(value){
        if (this.localName != "check")
            return;

        if (apf.isTrue(value))
            apf.setStyleClass(this.$ext, "checked");
        else
            apf.setStyleClass(this.$ext, "", ["checked"]);
    }

    /**
     * @attribute {Boolean} checked whether the item is selected.
     */
    this.$propHandlers["selected"] = function(value){
        if (this.localName != "radio")
            return;

        if (apf.isTrue(value))
            apf.setStyleClass(this.$ext, "selected");
        else
            apf.setStyleClass(this.$ext, "", ["selected"]);
    }
    
    /**
     * @attribute {Boolean} disabled whether the item is active.
     */
    this.$propHandlers["disabled"] = function(value){
        if (apf.isTrue(value))
            apf.setStyleClass(this.$ext, "disabled");
        else
            apf.setStyleClass(this.$ext, "", ["disabled"]);
    }

    /**** Public Methods ****/

    /**
     * @private
     */
    this.enable = function(list){
        apf.setStyleClass(this.$ext,
            this.parentNode.$baseCSSname + "Disabled");
    };

    /**
     * @private
     */
    this.disable = function(list){
        apf.setStyleClass(this.$ext, null,
            [this.parentNode.$baseCSSname + "Disabled"]);
    };

    /**
     * @private
     */
    this.show = function(){
        this.$ext.style.display = "block";
    };

    /**
     * @private
     */
    this.hide = function(){
        this.$ext.style.display = "none";
    };

    /**** Dom Hooks ****/

    this.addEventListener("AMLReparent", function(beforeNode, pNode, withinParent){
        if (!this.$amlLoaded)
            return;

        if (!withinParent && this.skinName != pNode.skinName) {
            //@todo for now, assuming dom garbage collection doesn't leak
            this.loadAml();
        }
    });

    /**** Events ****/

    this.$down = function(){

    };

    this.$up = function(){
        if (this.localName == "radio")
            this.parentNode.select(this.group, this.value || this.caption);

        else if (this.localName == "check")
            this.$handlePropSet("checked", !this.checked);

        if (this.submenu) {
            this.$over(null, true);
            return;
        }

        this.parentNode.$hideTree = true;
        this.parentNode.hide();//true not focus?/

        this.parentNode.dispatchEvent("itemclick", {
            value : this.value || this.caption
        });

        //@todo Anim effect here?
    };

    this.$click = function(){
        this.dispatchEvent("click", {
            xmlContext : this.parentNode.xmlReference,
            opener     : this.parentNode.opener
        });
    };

    var timer;
    this.$out = function(e){
        if (apf.isChildOf(this.$ext, e.toElement || e.explicitOriginalTarget)
          || apf.isChildOf(this.$ext, e.srcElement || e.target))  //@todo test FF
            return;

        clearTimeout(timer);
        if (!this.submenu || this.$submenu(true)) {
            apf.setStyleClass(this.$ext, '', ['hover']);

            var sel = this.parentNode.$selected;
            if (sel && sel != this)
                apf.setStyleClass(sel.$ext, "", ["hover"]);

            this.parentNode.$selected = null;
        }
    };

    this.$over = function(e, force){
        if (this.parentNode.$selected == this)
            return;

        if (this.parentNode.$selected)
            apf.setStyleClass(this.parentNode.$selected.$ext, "", ["hover"]);

        apf.setStyleClass(this.$ext, "hover");
        this.parentNode.$selected = this;

        if (!force && (apf.isChildOf(this.$ext, e.toElement || e.explicitOriginalTarget)
          || apf.isChildOf(this.$ext, e.fromElement || e.target)))  //@todo test FF
            return;

        var ps = this.parentNode.$showingSubMenu;
        if (ps) {
            if (ps.name == this.submenu)
                return;

            ps.hide();
            this.parentNode.$showingSubMenu = null;
        }

        if (this.submenu) {
            if (force) {
                this.$submenu();
            }
            else {
                var _self = this;
                clearTimeout(timer);
                timer = $setTimeout(function(){
                    _self.$submenu();
                    timer = null;
                }, 200);
            }
        }
    };

    this.$submenu = function(hide, force){
        if (!this.submenu)
            return true;

        var menu = self[this.submenu];
        if (!menu) {
            
            throw new Error(apf.formatErrorString(0, this,
                "Displaying submenu",
                "Could not find submenu '" + this.submenu + "'", this.$aml));
            

            return;
        }

        if (!hide) {
            //if (this.parentNode.showingSubMenu == this.submenu)
                //return;

            this.parentNode.$showingSubMenu = menu;

            var pos = apf.getAbsolutePosition(this.$ext, this.parentNode.$ext.offsetParent);
            menu.display(pos[0] + this.$ext.offsetWidth - 3,
                pos[1] + 3, false, this,
                this.parentNode.xmlReference, this.parentNode.$uniqueId);
            menu.setAttribute("zindex", (this.parentNode.zindex || 1) + 1);
        }
        else {
            if (menu.visible && !force) {
                return false;
            }
            
            if(this.parentNode.$showingSubMenu) {
                this.parentNode.$showingSubMenu = null;
            }
            
            apf.setStyleClass(this.$ext, '', ['hover']);
            menu.hide();
            return true;
        }
    };

    /**** Init ****/
    
    this.$draw = function(isSkinSwitch){
        var p = this.parentNode;
        while (p.$canLeechSkin == "item")
            p = p.parentNode;

        //@todo apf3.0 rename doesnt work yet.
        //@todo apf3.0 implement DOM Mutation events for multiselect widgets
        //@todo apf3.0 implement attribute change triggers for icon, image, value, caption to updateNode this.$int
        //@todo apf3.x this should be rearchitected
        //@todo apf3.x the functions dont need to be overloaded if selectNodes would work properly
        if (p.hasFeature(apf.__MULTISELECT__)) {
            var _self = this;
            
            //@todo DOMNodeInserted should reset this
            //@todo DOMNodeRemoved should reset this
            if (!this.$hasSetSkinListener) {
                var f;
                this.parentNode.addEventListener("$skinchange", f = function(){
                    if (_self.$amlDestroyed) //@todo apf3.x
                        return;
                    
                    if (_self.$ext.parentNode)
                        this.$deInitNode(_self, _self.$ext);
    
                    var oInt = p == _self.parentNode ? p.$int : _self.parentNode.$int;
                    var node = oInt.lastChild;//@todo this should be more generic
                    p.$add(_self, _self.getAttribute(apf.xmldb.xmlIdTag) + "|" + this.$uniqueId, 
                        _self.parentNode, oInt != p.$int && oInt, null);
                    p.$fill();
                    
                    if (p.$isTreeArch) {
                        _self.$int = p.$getLayoutNode("item", "container", 
                           _self.$ext = node && node.nextSibling || oInt.firstChild);//@todo this should be more generic
                    }
                    else _self.$ext = node && node.nextSibling || oInt.firstChild;
                    
                    var ns = _self;
                    while((ns = ns.nextSibling) && ns.nodeType != 1);
        
                    if (!ns || ns.$canLeechSkin != "item")
                        p.dispatchEvent("afterload");
                });
                this.addEventListener("DOMNodeRemoved", function(e){
                    this.parentNode.removeEventListener("$skinchange", f);
                });
                
                this.$hasSetSkinListener = true;
            }
            
            if (!p.$itemInited) {
                p.canrename = false; //@todo fix rename
                p.$removeClearMessage(); //@todo this should be more generic
                p.$itemInited = [p.getTraverseNodes, p.getFirstTraverseNode, p.getTraverseParent];
                
                p.getTraverseNodes = function(xmlNode){
                    return (xmlNode || p).getElementsByTagNameNS(apf.ns.apf, "item");
                }
                p.getFirstTraverseNode = function(xmlNode){
                    return (xmlNode || p).getElementsByTagNameNS(apf.ns.apf, "item")[0];
                }
                p.getTraverseParent = function(xmlNode){
                    return xmlNode && xmlNode.parentNode;
                }
                p.each = (this.prefix ? this.prefix + ":" : "") + "item";

                //@todo this is all an ugly hack (copied to baselist.js line 868)
                p.$preventDataLoad = true;//@todo apf3.0 add remove for this

                p.$initingModel = true;
                p.$setDynamicProperty("icon", "[@icon]");
                p.$setDynamicProperty("image", "[@image]");
                p.$setDynamicProperty("caption", "[label/text()|@caption|text()]");
                p.$setDynamicProperty("eachvalue", "[value/text()|@value|text()]");
                p.$canLoadDataAttr = false;
                
                if (!p.xmlRoot)
                    p.xmlRoot = p;
            }
            
            this.$loadAml = function(){
                //hack
                if (!this.getAttribute("caption"))
                    this.setAttribute("caption", this.caption);
                
                var oInt = p == this.parentNode ? p.$int : this.parentNode.$int;
                var node = oInt.lastChild;//@todo this should be more generic
                if (!p.documentId)
                    p.documentId = apf.xmldb.getXmlDocId(this);
                p.$add(this, apf.xmldb.nodeConnect(p.documentId, this, null, p), 
                    this.parentNode, oInt != p.$int && oInt, null);
                p.$fill();
    
                if (p.$isTreeArch) {
                    this.$int = p.$getLayoutNode("item", "container", 
                       this.$ext = node && node.nextSibling || oInt.firstChild);//@todo this should be more generic
                }
                else this.$ext = node && node.nextSibling || oInt.firstChild;
                
                var ns = this;
                while((ns = ns.nextSibling) && ns.nodeType != 1);
    
                if (!ns || ns.$canLeechSkin != "item") {
                    p.dispatchEvent("afterload");
                    if (p.autoselect)
                        p.$selectDefault(this.parentNode);
                }
            }
            
            return;
        }
        
        this.$ext = this.$getExternal(this.$isLeechingSkin
          ? "item" //this.localName 
          : "main", null, function($ext){
            var o = 'apf.lookup(' + this.$uniqueId + ')';
            $ext.setAttribute("onmouseup",   o + '.$up(event)');
            $ext.setAttribute("onmousemove", o + '.$over(event)');
            $ext.setAttribute("onmouseout",  o + '.$out(event)');
            $ext.setAttribute("onmousedown", o + '.$down()');
            $ext.setAttribute("onclick",     o + '.$click()');
        });

        /*p.$getNewContext("item");
        var elItem = p.$getLayoutNode("item");*/
        
        //@todo if not elItem try using own skin

        apf.setStyleClass(this.$ext, this.localName);

        //this.$ext   = apf.insertHtmlNode(elItem, this.parentNode.$int);
        this.$caption = this.$getLayoutNode("item", "caption", this.$ext)
        this.$icon    = this.$getLayoutNode("item", "icon", this.$ext);
        this.$hotkey  = this.$getLayoutNode("item", "hotkey", this.$ext);

        if (!isSkinSwitch && this.nextSibling && this.nextSibling.$ext)
            this.$ext.parentNode.insertBefore(this.$ext, this.nextSibling.$ext);
    };

    /**
     * @private
     */
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        //var x = this.$aml;

        //this.skinName    = this.parentNode.skinName;
        var isSkinSwitch = this.$ext ? true : false;
        if (isSkinSwitch) {
            if (typeof this.checked !== "undefined")
                this.$handlePropSet("checked", this.checked);
            else if (typeof this.selected !== "undefined")
                this.$handlePropSet("selected", this.selected);

            if (this.disabled)
                this.$handlePropSet("disabled", this.disabled);

            if (this.caption)
                this.$handlePropSet("caption", this.caption);
        }
    });
}).call(apf.item.prototype = new apf.Presentation());

apf.radio.prototype =
apf.check.prototype = apf.item.prototype;

apf.aml.setElement("radio", apf.radio);
apf.aml.setElement("check", apf.check);
apf.aml.setElement("item",  apf.item);


/*FILEHEAD(/var/lib/platform/source/trunk/elements/modalwindow.js)SIZE(25330)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * @private
 */
apf.WinServer = {
    count : 9000,
    wins  : [],

    setTop : function(win, norecur){
        if (win.$opened) {
            if (win.$opened.visible)
                return;
            else 
                delete win.$opened;
        }
        
        var topmost;
        if (!norecur && this.wins.length) {
            var topmost = this.wins[this.wins.length - 1];
            if (topmost == win)
                return;
            
            if (!topmost.modal || !topmost.visible)
                topmost = null;
            else if (topmost && win.modal) {
                win.$opener = topmost;
                topmost.$opened = win;
                topmost = null;
            }
        }
        
        this.count += 2;

        win.setProperty("zindex", this.count);
        this.wins.remove(win);
        this.wins.push(win);

        if (topmost)
            this.setTop(topmost, true);

        return win;
    },

    setNext : function(){
        if (this.wins.length < 2) return;
        var nwin, start = this.wins.shift();
        do {
            if (this.setTop(nwin || start).visible)
                break;
            nwin = this.wins.shift();
        } while (start != nwin);
    },

    setPrevious : function(){
        if (this.wins.length < 2) return;
        this.wins.unshift(this.wins.pop());
        var nwin, start = this.wins.pop();
        do {
            if (this.setTop(nwin || start).visible)
                break;
            nwin = this.wins.pop();
        } while (start != nwin);
    },

    remove : function(win){
        this.wins.remove(win);
    }
}

/**
 * Element displaying a skinnable, draggable window with optionally
 * a min, max, edit and close button. This element is also used
 * as a portal widget container. Furthermore this element supports
 * docking in an alignment layout.
 * Example:
 * <code>
 *  <a:window 
 *    id        = "winMail"
 *    modal     = "false"
 *    buttons   = "min|max|close"
 *    title     = "Mail message"
 *    icon      = "icoMail.gif"
 *    visible   = "true"
 *    resizable = "true"
 *    minwidth  = "300"
 *    minheight = "290"
 *    width     = "500"
 *    height    = "400">
 *  </a:window>
 * </code>
 *
 * @constructor
 * @define modalwindow
 * @allowchild {elements}, {smartbinding}, {anyaml}
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @inherits apf.Presentation
 * @inherits apf.Docking
 * @inherits apf.Transaction
 *
 * @event show          Fires when the window is opened.
 * @event close         Fires when the window is closed.
 * @event editstart     Fires before the user edits the properties of this window. Used mostly for when this window is part of the {@link element.portal}.
 * @event editstop      Fires after the user edited the properties of this window. Used mostly for when this window is part of the {@link element.portal}.
 *   cancelable:   Prevents the edit panel from being closed.
 * @event statechange   Fires after the state of this window changed.
 *   object:
 *   {Boolean} minimized  whether the window is minimized.
 *   {Boolean} maximized  whether the window is maximized.
 *   {Boolean} normal     whether the window has it's normal size and position.
 *   {Boolean} edit       whether the window is in the edit state.
 *   {Boolean} closed     whether the window is closed.
 */
apf.toolwindow  = function(struct, tagName){
    this.$init(tagName || "toolwindow", apf.NODE_VISIBLE, struct);
};

apf.modalwindow = function(struct, tagName){
    this.$init(tagName || "modalwindow", apf.NODE_VISIBLE, struct);
};

apf.AmlWindow = function(struct, tagName){
    this.$init(tagName || "window", apf.NODE_VISIBLE, struct);
};

(function(){
    this.implement(
        
        apf.Docking,
        
        apf.BaseStateButtons
    );

    this.$isWindowContainer = true;
    this.collapsedHeight   = 30;
    this.canHaveChildren   = 2;
    this.visible           = false;
    this.showdragging      = false;
    this.kbclose           = false;
    this.$focussable       = apf.KEYBOARD;

    /**** Public Methods ****/

    

    /**
     * Sets the title of the window. Call-chaining is supported.
     * @param {String} caption the text of the title.
     */
    this.setTitle = function(caption){
        this.setProperty("title", caption, false, true);
        return this;
    };

    /**
     * Sets the icon of the window. Call-chaining is supported.
     * @param {String} icon the location of the image.
     */
    this.setIcon = function(icon){
        this.setProperty("icon", icon, false, true);
        return this;
    };
    
    //For modal elements
    this.show = function(callback){
        this.execAction = callback; //@todo Proper error handling??
        this.setProperty("visible", true, false, true);
        return this;
    }
    
    
    
    this.slideIn = function(sFrom, bSticky) {
        if (!sFrom)
            sFrom = "bottom";
        var _center = this.center;
        this.center = false;
        this.setProperty("visible", true);
        this.center = _center;
        
        var iFrom  = 0,
            iTo    = 0,
            innerW = (apf.isIE
                ? this.$ext.offsetParent.offsetWidth
                : window.innerWidth),
            innerH = (apf.isIE
                ? this.$ext.offsetParent.offsetHeight
                : window.innerHeight),
            cX     = Math.max(0, ((innerW - this.$ext.offsetWidth)  / 2)),
            cY     = Math.max(0, ((innerH - this.$ext.offsetHeight) / 3)),
            sType  = "top",
            pad    = 10;

        switch(sFrom) {
            case "top":
                iFrom = -(this.$ext.offsetHeight) - pad;
                iTo   = bSticky ? 0 : cY;
                break;
            case "left":
                iFrom = -(this.$ext.offsetWidth) - pad;
                iTo   = bSticky ? 0 : cX;
                sType = "left";
                break;
            case "bottom":
                iFrom = innerH + this.$ext.offsetHeight + pad;
                iTo   = bSticky ? innerH - this.$ext.offsetHeight : cY;
                break;
            case "right":
                iFrom = innerW + this.$ext.offsetLeft + pad;
                iTo   = bSticky ? innerW - this.$ext.offsetWidth : cX;
                sType = "left";
                break;
        }
        
        apf.tween.single(this.$ext, {
            steps   : apf.isIphone ? 5 : 30,
            interval: 10,
            from    : iFrom,
            to      : iTo,
            type    : sType,
            anim    : apf.tween.EASEIN
        });
        return this;
    };

    this.slideOut = function(sTo) {
        if (!sTo)
            sTo = "bottom";
        var iFrom = 0,
            iTo   = 0,
            sType = "top",
            pad   = 10;

        switch(sTo) {
            case "top":
                iFrom = this.$ext.offsetTop;
                iTo   = -(this.$ext.offsetHeight) - pad;
                break;
            case "left":
                iFrom = this.$ext.offsetLeft;
                iTo   = -(this.$ext.offsetWidth) - pad;
                sType = "left";
                break;
            case "bottom":
                iFrom = this.$ext.offsetTop;
                iTo = (apf.isIE
                    ? this.$ext.offsetParent.offsetHeight
                    : window.innerHeight) + this.$ext.offsetHeight + pad;
                break;
            case "right":
                iFrom = this.$ext.offsetLeft;
                iTo   = (apf.isIE
                    ? this.$ext.offsetParent.offsetWidth
                    : window.innerWidth) + this.$ext.offsetLeft + pad;
                sType = "left";
                break;
        }

        var _self = this;
        apf.tween.single(this.$ext, {
            steps   : apf.isIphone ? 5 : 30,
            interval: 10,
            from    : iFrom,
            to      : iTo,
            type    : sType,
            anim    : apf.tween.EASEOUT,
            onfinish: function() { _self.setProperty("visible", false); }
        });
        return this;
    };

    this.bringToFront = function(){
        apf.WinServer.setTop(this);
        return this;
    };

    
    /**
     * @todo change this to use setProperty
     * @private
     */
    this.syncAlignment = function(oItem){
        if (oItem.hidden == 3)
            apf.WinServer.setTop(this);

        if (oItem.state > 0) {
            this.$setStyleClass(this.$ext, this.$baseCSSname + "Min",
                [this.$baseCSSname + "Edit", this.$baseCSSname + "Max"]);
        }
        else {
            this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Min",
                this.$baseCSSname + "Edit", this.$baseCSSname + "Max"]);
        }
    };
    

    /**** Properties and Attributes ****/

    this.$booleanProperties["modal"]        = true;
    this.$booleanProperties["center"]       = true;
    this.$booleanProperties["transaction"]  = true;
    this.$booleanProperties["hideselects"]  = true;
    this.$booleanProperties["showdragging"] = true;
    this.$booleanProperties["kbclose"]      = true;
    this.$supportedProperties.push("title", "icon", "modal", "minwidth",
        "minheight", "hideselects", "center", "kbclose",
        "maxwidth", "maxheight", "showdragging", "transaction");

    /**
     * @attribute {Boolean} modal whether the window prevents access to the
     * layout below it.
     */
    this.$propHandlers["modal"] = function(value){
        if (value && !this.oCover) {
            var oCover = this.$getLayoutNode("cover");
            if (oCover) {
                this.oCover = apf.insertHtmlNode(oCover, this.$pHtmlNode);

                if (!this.visible)
                    this.oCover.style.display = "none";

                if (this.zindex)
                    this.oCover.style.zIndex = this.zindex;
            }
        }

        if (!value && this.oCover) {
            this.oCover.style.display = "none";
        }
    };

    /**
     * @attribute {Boolean} center centers the window relative to it's parent's
     * containing rect when shown.
     */
    this.$propHandlers["center"] = function(value){
        this.$ext.style.position = "absolute"; //@todo no unset
    };

    /**
     * @attribute {String} title the text of the title.
     */
    this.$propHandlers["title"] = function(value){
        if (this.oTitle)
            this.oTitle.nodeValue = value;
    };

    /**
     * @attribute {String} icon the location of the image.
     */
    this.$propHandlers["icon"] = function(value){
        if (!this.oIcon) return;

        this.oIcon.style.display = value ? "block" : "none";
        apf.skins.setIcon(this.oIcon, value, this.iconPath);
    };

    var hEls = [], wasVisible;
    this.$propHandlers["visible"] = function(value){
        if (apf.isTrue(value)){
            if (this.oCover){
    			if (this.oCover.offsetParent) {
                    //@todo apf3.0 ie8 too high...
                    this.oCover.style.height = Math.max(this.oCover.offsetParent.scrollHeight,
                        document.documentElement.offsetHeight) + 'px';
                    this.oCover.style.width  = this.oCover.offsetParent.scrollWidth + 'px';
    			}
                this.oCover.style.display = "block";
            }

            this.state = this.state.split("|").remove("closed").join("|");

            this.$ext.style.display = "block"; //Some form of inheritance detection

            
            if (apf.layout && this.$int)
                apf.layout.forceResize(this.$int); //@todo this should be recursive down
            
            //if (this.modal) 
                //this.$ext.style.position = "fixed";
            
            if (this.center) {
                var size = !this.$ext.offsetParent || this.$ext.offsetParent.tagName == "BODY"
                    ? [apf.getWindowWidth(), apf.getWindowHeight()]
                    : [this.$ext.offsetParent.offsetWidth, this.$ext.offsetParent.offsetHeight, 0, 0];

                if (size.length == 2) {
                    size.push(document.documentElement.scrollLeft, 
                      document.documentElement.scrollTop);
                }
                
                //@todo it's better to add this to the layout queue
                //this.$ext.offsetWidth
                //this.$ext.offsetHeight
                this.$ext.style.left = (Math.max(0, ((
                    size[0] - parseInt(this.width))/2)) + size[2]) + "px";
                this.$ext.style.top  = (Math.max(0, ((
                    size[1] - parseInt(this.height))/3)) + size[3]) + "px";
            }

            if (!apf.canHaveHtmlOverSelects && this.hideselects) {
                hEls = [];
                var nodes = document.getElementsByTagName("select");
                for (var i = 0; i < nodes.length; i++) {
                    var oStyle = apf.getStyle(nodes[i], "display");
                    hEls.push([nodes[i], oStyle]);
                    nodes[i].style.display = "none";
                }
            }

            if (this.modal)
                this.bringToFront();
            
            if (!this.$rendered) {
                this.addEventListener("afterrender", function(){
                    
                    //@todo make widget a tagname and alias
                    if (this.$amlLoaded && (this.model 
                      || (!this.dockable || !this.aData) && !this.$isWidget 
                      && this.localName != "toolwindow"))
                        this.focus(false, {mouse:true});
                    
                });
            }
            else {
                
                //@todo make widget a tagname and alias
                if (this.$amlLoaded && (this.model 
                  || (!this.dockable || !this.aData) && !this.$isWidget 
                  && this.localName != "toolwindow"))
                    this.focus(false, {mouse:true});
                
            }
            
            if (apf.isIE) {
                var cls = this.$ext.className;
                this.$ext.className = "rnd" + Math.random();
                this.$ext.className = cls;
            }
            var _self = this;
            $setTimeout(function() {
                _self.dispatchEvent("show");
            });
        }
        else { //if (apf.isFalse(value)) 
            //this.setProperty("visible", false);
            if (this.oCover)
                this.oCover.style.display = "none";

            this.$ext.style.display = "none";

            if (!apf.canHaveHtmlOverSelects && this.hideselects) {
                for (var i = 0; i < hEls.length; i++) {
                    hEls[i][0].style.display = hEls[i][1];
                }
            }

            if (this.hasFocus())
                apf.window.moveNext(true, this, true);//go backward to detect modals

            this.dispatchEvent("close");
            
            this.visible = false;
        }

        wasVisible = value;
    };

    this.$propHandlers["zindex"] = function(value){
        this.$ext.style.zIndex = value + 1;
        if (this.oCover)
            this.oCover.style.zIndex = value;
    };

    /**** Keyboard ****/

    
    
    if (!apf.isIphone) {
    
    this.addEventListener("keydown", function(e){
        var key      = e.keyCode;
        var ctrlKey  = e.ctrlKey;
        var shiftKey = e.shiftKey;

        /*if (key > 36 && key < 41) {
            if (this.hasFeature && this.hasFeature(apf.__ANCHORING__))
                this.$disableAnchoring();
        }*/

        var retValue = false;
        switch (key) {
            /*case 9:
                break;
            case 13:
                break;
            case 32:
                break;*/
            case 38:
            //UP
                if (shiftKey && this.resizable)
                    this.setProperty("height", Math.max(this.minheight || 0,
                        this.$ext.offsetHeight - (ctrlKey ? 50 : 10)));
                else if (this.draggable)
                    this.setProperty("top",
                        this.$ext.offsetTop - (ctrlKey ? 50 : 10));
                break;
            case 37:
            //LEFT
                if (shiftKey && this.resizable)
                    this.setProperty("width", Math.max(this.minwidth || 0,
                        this.$ext.offsetWidth - (ctrlKey ? 50 : 10)));
                else if (this.draggable)
                    this.setProperty("left",
                        this.$ext.offsetLeft - (ctrlKey ? 50 : 10));
                break;
            case 39:
            //RIGHT
                if (shiftKey && this.resizable)
                    this.setProperty("width", Math.min(this.maxwidth || 10000,
                        this.$ext.offsetWidth + (ctrlKey ? 50 : 10)));
                else if (this.draggable)
                    this.setProperty("left",
                        this.$ext.offsetLeft + (ctrlKey ? 50 : 10));
                break;
            case 40:
            //DOWN
                if (shiftKey && this.resizable)
                    this.setProperty("height", Math.min(this.maxheight || 10000,
                        this.$ext.offsetHeight + (ctrlKey ? 50 : 10)));
                else if (this.draggable)
                    this.setProperty("top",
                        this.$ext.offsetTop + (ctrlKey ? 50 : 10));
                break;
            default:
                retValue = null;
                return;
        }
        
        if (apf.hasSingleRszEvent)
            apf.layout.forceResize(this.$int);
        
        return retValue;
    }, true);
    
    this.addEventListener("keydown", function(e){
        if (e.keyCode == 27 && this.buttons.indexOf("close") > -1 
          && (!this.dockable || !this.aData) && this.kbclose)
            this.close();
    });
    
    }
    

    

    /**** Init ****/

    this.$draw = function(){
        this.popout = apf.isTrue(this.getAttribute("popout"));
        if (this.popout)
            this.$pHtmlNode = document.body;

        this.$ext = this.$getExternal(null, null, function(oExt){
            this.$initButtons(oExt);
        });
        this.oTitle   = this.$getLayoutNode("main", "title", this.$ext);
        this.oIcon    = this.$getLayoutNode("main", "icon",  this.$ext);
        this.oDrag    = this.$getLayoutNode("main", "drag",  this.$ext);
        this.$buttons = this.$getLayoutNode("main", "buttons",  this.$ext);
        this.oDrag.host = this;

        if (this.popout)
            this.$ext.style.position = "absolute";

        if (this.oIcon)
            this.oIcon.style.display = "none";

        
        if (!apf.isIphone) {
        
        
        var _self = this;
        this.oDrag.onmousedown = function(e){
            if (!e) e = event;

            //because of some issue I don't understand oExt.onmousedown is not called
            if (!_self.$isWidget && (!_self.aData || !_self.dockable || _self.aData.hidden == 3))
                apf.WinServer.setTop(_self);

            if (_self.$lastState.maximized)
                return false;

            
            if (_self.aData && _self.dockable) {
                if (_self.$lastState.normal) //@todo
                    _self.startDocking(e);
                return false;
            }
            
        };

        this.$ext.onmousedown = function(){
            
            var p = apf.document.activeElement;
            if (p && p.$focusParent != _self && p.$focusParent.modal)
                return false;
            
            
            //Set ZIndex on oExt mousedown
            if (!_self.$isWidget && (!_self.aData || !_self.dockable || _self.aData.hidden == 3))
                apf.WinServer.setTop(_self);

            if (!_self.$lastState.normal)
                return false;
        }
        this.$ext.onmousemove = function(){
            if (!_self.$lastState.normal)
                return false;
        }
        
        }
        
        

        /*var v;
        if (!((v = this.getAttribute("visible")).indexOf("{") > -1 || v.indexOf("[") > -1)) {
            this.$aml.setAttribute("visible", "{" + apf.isTrue(v) + "}");
        }*/
    };

    this.$loadAml = function(x){
        apf.WinServer.setTop(this);

        this.$int = this.$getLayoutNode("main", "container", this.$ext);

        
        if (!apf.isIphone) {
        
            if (this.oTitle) {
                var _self = this;
                (this.oTitle.nodeType != 1
                  ? this.oTitle.parentNode
                  : this.oTitle).ondblclick = function(e){
                    if (_self.state.indexOf("normal") == -1)
                        _self.restore();
                    else if (_self.buttons.indexOf("max") > -1)
                        _self.maximize();
                    else if (_self.buttons.indexOf("min") > -1)
                        _self.minimize();
                }
            }
    
            if (typeof this.draggable == "undefined") {
                (this.$propHandlers.draggable
                    || apf.GuiElement.propHandlers.draggable).call(this, true);
                this.draggable = true;
            }

            if (typeof this.buttons == "undefined")
                this.buttons = "";
                //this.setProperty("buttons", "min|max|close");
        
        }
        

        if (this.modal === undefined && this.oCover) {
            this.$propHandlers.modal.call(this, true);
            this.modal = true;
        }

        //Set default visible hidden
        if (!this.visible) {
            this.$ext.style.display = "none";

            if (this.oCover)
                this.oCover.style.display = "none";
        }
        
        else if (this.modal) {
            var _self = this;
            apf.queue.add("focus", function(){
                _self.focus(false, {mouse:true});
            });
        }
        

        if (this.minwidth === undefined)
            this.minwidth  = this.$getOption("Main", "min-width");
        if (this.minheight === undefined)
            this.minheight = this.$getOption("Main", "min-height");
        if (this.maxwidth === undefined)
            this.maxwidth  = this.$getOption("Main", "max-width");
        if (this.maxheight === undefined)
            this.maxheight = this.$getOption("Main", "max-height");

        if (this.center && this.visible) {
            this.visible = false;
            this.$ext.style.display = "none"; /* @todo temp done for project */
            
            var _self = this;
            $setTimeout(function(){
                _self.setProperty("visible", true);
            });
        }
    };

    
    this.addEventListener("$skinchange", function(){
        if (this.title)
            this.$propHandlers["title"].call(this, this.title);

        if (this.icon)
            this.$propHandlers["icon"].call(this, this.icon);
    });
    

    this.$destroy = function(skinChange){
        if (this.oDrag) {
            this.oDrag.host = null;
            this.oDrag.onmousedown = null;
            apf.destroyHtmlNode(this.oDrag);
            this.oDrag = null;
        }

        this.oTitle =  this.oIcon = this.oCover = null;

        if (this.$ext && !skinChange) {
            this.$ext.onmousedown = null;
            this.$ext.onmousemove = null;
        }
    };
}).call(apf.modalwindow.prototype = new apf.Presentation());

apf.AmlWindow.prototype = apf.toolwindow.prototype = apf.modalwindow.prototype;

apf.aml.setElement("toolwindow",  apf.toolwindow);
apf.aml.setElement("modalwindow", apf.modalwindow);
apf.aml.setElement("window",      apf.modalwindow);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/xmpp.js)SIZE(84533)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Element implementing XMPP IM protocol.
 * Depends on implementation of XMPP server supporting bosh or http-poll,
 * because apf.xmpp creates connections through the HTTP protocol via {@link teleport.http}.
 * Example:
 * XMPP connector with new message notification
 * <code>
 *  <a:teleport>
 *      <a:xmpp id="myXMPP"
 *        url           = "http://my-jabber-server.com:5280/http-bind"
 *        model         = "mdlRoster"
 *        connection    = "bosh"
 *        onreceivechat = "messageReceived(arguments[0].from)" />
 *  </a:teleport>
 *
 *  <a:script>
 *      // This function is called when a message has arrived
 *      function messageReceived(from){
 *          alert('Received message from ' + from);
 *      }
 *
 *      // Send a message to John
 *      myXMPP.sendMessage('john@my-jabber-server.com', 'A test message', '',
 *          apf.xmpp.MSG_CHAT);
 *  </a:script>
 * </code>
 * Remarks:
 * Calls can be made to a server using a special {@link term.datainstruction data instruction}
 * format.
 * <code>
 *  submission="{myXmpp.notify([@bar], 'john@my-jabber-server.com')}"
 *  submission="{myXmpp.login([@foo], [@bar])}"
 *  submission="{myXmpp.logout()}"
 * </code>
 *
 * @event authfailure Fires when the authentication process failed or halted.
 *   bubbles: yes
 *   cancelable: Prevents an authentication failure to be thrown
 *   object:
 *     {String}        username   the username used for the login attempt
 *     {String}        server     the server address (URI) of the XMPP server
 *     {String}        message    a more detailed explanation of the error
 * @event connectionerror Fires when the connection with the XMPP server dropped.
 *   bubbles: yes
 *   cancelable: Prevents an connection error to be thrown
 *   object:
 *     {String}        username   the username used for the last-active session
 *     {String}        server     the server address (URI) of the XMPP server
 *     {String}        message    a more detailed explanation of the error
 * @event connected Fires when a login attempt has succeeded, and a session has been setup.
 *   bubbles: yes
 *   object:
 *     {String}        username   the username used for the last-active session
 * @event receivechat Fires when the user received a chat message from a contact.
 *   bubbles: yes
 *   object:
 *     {String}        from       the username of the contact that sent the message
 *     {String}        message    the body of the chat message
 * @event datachange Fires when a data-change message is received from one of the contacts.
 *   bubbles: yes
 *   object:
 *     {String}        data       the data-instruction of the changed data that
 *                                the RSB implementation can grok
 *
 * @define xmpp
 * @addnode teleport
 * 
 * @author      Mike de Boer
 * @version     %I%, %G%
 * @since       1.0
 * @constructor
 *
 * @inherits apf.Class
 * @inherits apf.BaseComm
 * @inherits apf.http
 * @namespace apf
 *
 * @default_private
 */

apf.xmpp = function(struct, tagName){
    this.$init(tagName || "xmpp", apf.NODE_HIDDEN, struct);

    this.$serverVars = {};
    this.$reqCount   = 0;
    this.$reqStack   = [];
    this.$listening  = false;
    this.$listener   = null;
    this.$sAJAX_ID   = this.$makeUnique("ajaxRSB");
    this.$retryCount = 0;
    this.$RID        = null;
};

(function() {
    this.$server     = null;
    this.timeout     = 10000;
    this.maxrequests = 2;
    this.useHTTP     = true;
    this.method      = "POST";

    this.$model         = null;
    this.$modelContent  = null;
    this.$xmppMethod    = apf.xmpp.CONN_BOSH;
    this.$isPoll        = false;
    this.$pollTimeout   = 2000;
    this.$autoRegister  = false;
    this.$autoConfirm   = true;
    this.$autoDeny      = false;
    this.$canMuc        = false;
    this.$modelContent  = {
        roster: true,
        chat  : true,
        typing: true
    };

    // munge often-used strings
    var SID     = "SID",
        JID     = "JID",
        CONN    = "connected",
        ROSTER  = "roster";

    /**
     * @attribute {String}   [type]           The type of method used to connect
     *                                        to the server. Defaults to 'binding'
     *   Possible values:
     *   poll
     *   binding
     * @attribute {Number}   [poll-timeout]   The number of milliseconds between
     *                                        each poll-request
     * @attribute {String}   [resource]       Name that will identify this client as it
     *                                        logs on the the Jabber network.
     *                                        Defaults to the application name.
     * @attribute {Boolean}  [auto-register]  Specifies if an entered username
     *                                        should be registered on the Jabber
     *                                        network automatically. Defaults to 'false'.
     * @attribute {String}   [auto-accept]    Specifies if an icoming presence
     *                                        subscription request should be accepted
     *                                        automatically. Defaults to 'true'
     * @attribute {String}   [auto-deny]      Specifies if an icoming presence
     *                                        subscription request should be denied
     *                                        automatically. Defaults to 'false'
     * @attribute {String}   [model]          Name of the model where roster and
     *                                        (chat) messages will be synchronized to.
     * @attribute {String}   [model-contents] Specifies the items that will be
     *                                        stored inside the model. Defaults to 'all'
     *   Possible values:
     *   all
     *   roster
     *   chat
     *   typing
     *   roster|typing
     *   roster|chat
     *   chat|typing
     * @attribute {String}   [muc-domain]     Domain name of the Multi User Chat
     *                                        service of an XMPP server. Defaults
     *                                        to the domain that is parsed from
     *                                        {@link element.xmpp.url}.
     * @attribute {String}   [muc-model]      Name of the model where chat messages
     *                                        sent and received from Multi User
     *                                        Chats will be synchronized to.
     */
    this.$booleanProperties["auto-register"] = true;
    this.$booleanProperties["auto-confirm"]  = true;
    this.$booleanProperties["auto-deny"]     = true;

    this.$supportedProperties.push("poll-timeout", "resource", "auto-register",
        "auto-confirm", "auto-deny", "model", "model-contents", "muc-domain",
        "muc-model");

    this.$propHandlers["type"] = function(value) {
        this.$xmppMethod = (value == "polling")
            ? apf.xmpp.CONN_POLL
            : apf.xmpp.CONN_BOSH;

        this.$isPoll = Boolean(this.$xmppMethod & apf.xmpp.CONN_POLL);
    };

    this.$propHandlers["poll-timeout"] = function(value) {
        this.$pollTimeout = parseInt(value) || 2000;
    };

    this.$propHandlers["resource"] = function(value) {
        this.resource = value || apf.config.name || "apf".appendRandomNumber(5);
    };

    this.$propHandlers["auto-register"] = function(value) {
        this.$autoRegister = value;
    };

    this.$propHandlers["auto-confirm"] = function(value) {
        this.$autoConfirm = value;
    };

    this.$propHandlers["auto-deny"] = function(value) {
        this.$autoDeny = value;
    };

    
    this.$propHandlers["model"] = function(value) {
        if (!value) return;
        // provide a virtual Model to make it possible to bind with this XMPP
        // instance remotely.
        // We agreed on the following format for binding: model-contents="roster|typing|chat"
        this.$model = apf.setReference(value,
            apf.nameserver.register("model", value, new apf.model()));
        // set the root node for this model
        this.$model.id = this.$model.name = value;
        this.$model.load("<xmpp/>");
    };

    this.$propHandlers["model-contents"] = function(value) {
        var aContents = (value || "all").splitSafe("\\|", 0, true),
            i         = 0,
            l         = aContents.length;
        this.$modelContent = {
            roster: aContents[0] == "all",
            chat  : aContents[0] == "all",
            typing: aContents[0] == "all"
        };
        for (; i < l; i++) {
            aContents[i] = aContents[i].trim();
            if (!this.$modelContent[aContents[i]])
                this.$modelContent[aContents[i]] = true;
        }
    };
    

    
    this.$propHandlers["muc-model"] = function(value) {
        // parse MUC parameters
        this.$mucDomain = this["muc-domain"] || "conference." + this.$domain;
        if (value) {
            this.$canMuc   = true;
            this.$mucModel = apf.setReference(value,
                apf.nameserver.register("model", value, new apf.model()));
            // set the root node for this model
            this.$mucModel.id   =
            this.$mucModel.name = value;
            this.$mucModel.load("<xmpp_muc/>");

            // magic!
            this.implement(apf.xmpp_muc);
        }
    };
    

    /*
     * Append any string with an underscore '_' followed by a five character
     * long random number sequence.
     *
     * @param     {String} s
     * @type      {String}
     * @exception {Error}  A general Error object
     * @private
     */
    function makeUnique(s) {
        if (typeof s != "string")
            throw new Error("Dependencies not met, please provide a string");

        return (s + "_").appendRandomNumber(5);
    }

    /*
     * Constructs a <body> tag that will be used according to XEP-0206, and
     * the more official RFCs.
     *
     * @param {Object} options
     * @param {String} content
     * @type  {String}
     * @private
     */
    function createBodyElement(options, content) {
        var i, aOut = ["<body "];

        for (i in options) {
            if (options[i] == null) continue;
            aOut.push(i, "='", options[i], "' ");
        }

        aOut.push(">", content || "", "</body>");

        return aOut.join("");
    }

    /*
     * Constructs a <stream> tag that will be used when polling is active instead
     * of the regular BOSH implementation.
     *
     * @param {String} prepend
     * @param {Object} options
     * @param {String} content
     * @type  {String}
     * @private
     */
    function createStreamElement(options, content) {
        if (!options)
            options = {};
        var aOut = [this.$serverVars[SID] || "0", ","];

        if (options.doOpen) {
            aOut.push("<stream:stream");
            for (var i in options) {
                if (i == "doOpen" || i == "doClose" || options[i] == null)
                    continue;
                aOut.push(" ", i, "='", options[i], "'");
            }
            aOut.push(">");
        }

        aOut.push(content || "");

        if (options.doClose)
            aOut.push("</stream:stream>");

        return aOut.join("");
    }

    /*
     * A cnonce parameter is used by the SASL implementation to do some
     * additional client-server key exchange. You can say that this is the
     * part of the handshake that is powered by the client (i.e. 'us').
     *
     * @param {Number} size Length of the cnonce
     * @type  {String}
     * @private
     */
    function generateCnonce(size) {
        var sTab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", //length: 62
            i, sCnonce = "";
        for (i = 0; i < size; i++)
            sCnonce += sTab.charAt(apf.randomGenerator.generate(0, 61));
        return sCnonce;
    }

    /*
     * Create a <response> tag completely according to the SASL rules as
     * described in RFC 2617.
     *
     * @param {Object} parts
     * @type  {String}
     * @private
     */
    function createAuthBlock(parts) {
        var i, aOut = [];

        for (i in parts) {
            if (parts[i] == null) continue;
            aOut.push(i, '="', parts[i], '",');
        }
        var sOut = aOut.join("").replace(/,$/, "");

        return "<response xmlns='" + apf.xmpp.NS.sasl + "'>"
            + apf.crypto.Base64.encode(sOut) + "</response>";
    }

    /*
     * Create an <iq> message node which is part of the XMPP standard base
     * specification and may contain session data, bind/ stream information
     * and presence.
     *
     * @param {Object} parts
     * @param {String} content
     * @type  {String}
     * @private
     */
    function createIqBlock(parts, content) {
        var i, aOut = ["<iq "];

        for (i in parts) {
            if (parts[i] == null) continue;
            aOut.push(i, "='", parts[i], "' ");
        }

        aOut.push(">", content || "", "</iq>");

        return aOut.join("");
    }

    /*
     * Create a <presence> message which is part of the XMPP standard base
     * specification and is used to transfer presence information (state of a
     * user) across the roster.
     *
     * @param {Object} options
     * @type  {String}
     * @private
     */
    function createPresenceBlock(options, content) {
        var aOut = ["<presence xmlns='", apf.xmpp.NS.jabber, "'"];
        if (options.type)
            aOut.push(" type='", options.type, "'");
        if (options.to)
            aOut.push(" to='", options.to, "'");
        if (options.from)
            aOut.push(" from='", options.from, "'");
        aOut.push(">");

        // show An XMPP complient status indicator. See the class constants
        // apf.xmpp.STATUS_* for options
        if (options.status)
            aOut.push("<show>", options.status, "</show>");

        // Usually this is set to some human readable string indicating what the
        // user is doing/ feels like currently.
        if (options.custom)
            aOut.push("<status>", options.custom, "</status>");

        aOut.push(content || "");

        aOut.push("</presence>");
        return aOut.join("");
    }

    /*
     * Create a <presence> message which is part of the XMPP standard base
     * specification and may contain text messages, usually for instant
     * messaging applications.
     *
     * @param {Object} options
     * @param {String} body
     * @type  {String}
     * @private
     */
    function createMessageBlock(options, body) {
        var aOut = ["<message xmlns='", apf.xmpp.NS.jabber, "' from='", 
            this.$serverVars[JID], "' to='", options.to, "' id='message_",
            ++this.$serverVars["mess_count"], "' xml:lang='",
            options["xml:lang"], "'"];
        if (options.type)
            aOut.push(" type='", options.type, "'");
        aOut.push(">");

        // A subject to be sent along
        if (options.subject)
            aOut.push("<subject>", options.subject, "</subject>");

        // This is used to identify threads in chat conversations
        // A thread is usually a somewhat random hash.
        if (options.thread)
            aOut.push("<thread>", options.thread, "</thread>");

        aOut.push("<body>", body, "</body></message>");
        return aOut.join("");
    }

    /*
     * Special version of getVar('RID'), because RID needs to upped by one each
     * time a request is sent to the XMPP server.
     *
     * @type {Number}
     * @private
     */
    this.$getRID = function() {
        if (this.$RID === null)
            this.$RID = parseInt("".appendRandomNumber(10));
        return this.$RID++;
    };

    // expose functions to interfaces:
    this.$makeUnique          = makeUnique;
    this.$createBodyElement   = createBodyElement;
    this.$createStreamElement = createStreamElement;
    this.$createIqBlock       = createIqBlock;
    this.$createPresenceBlock = createPresenceBlock;
    this.$createMessageBlock  = createMessageBlock;

    /*
     * Generic function that provides a basic method for making HTTP calls to
     * the XMPP server and processing the response in retries, error messages
     * or through a custom callback.
     *
     * @param     {Function} cb      Callback handling function to be executed when
     *                               the response is available
     * @param     {String}   s       Body of the request, usually an XML stanza
     * @param     {Boolean}  bIsBind Specifies whether this message is a message
     *                               sent over the established connection or a
     *                               protocol message. The user messages are
     *                               recorded when offline and sent when the
     *                               application comes online again.
     * @exception {Error}    A general Error object
     * @type      {XMLHttpRequest}
     */
    this.$doXmlRequest = function(cb, s) {
        if (cb && s)
            this.$reqStack.push({callback: cb, body: s});

        // execute this specific call AFTER the current one has finished...
        if (this.$reqCount >= this.maxrequests)
            return null;

        var _self = this,
            req   = this.$reqStack.shift();
        ++this.$reqCount;
        return this.get(this.url, {
            callback: function(data, state, extra) {
                --_self.$reqCount;
                if (_self.$reqStack.length)
                    _self.$doXmlRequest();

                if (_self.$isPoll) {
                    if (!data || data.replace(/^[\s\n\r]+|[\s\n\r]+$/g, "") == "") {
                        //state = apf.ERROR;
                        //extra.message = (extra.message ? extra.message + "\n" : "")
                        //                + "Received an empty XML document (0 bytes)";
                    }
                    else {
                        if (data.indexOf("<stream:stream") > -1
                          && data.indexOf("</stream:stream>") == -1)
                            data = data + "</stream:stream>";
                        data = apf.getXmlDom(data);
                        if (!apf.supportNamespaces)
                            data.setProperty("SelectionLanguage", "XPath");
                    }
                }

                if (state != apf.SUCCESS) {
                    var oError;
                    
                    oError = new Error(apf.formatErrorString(0, 
                        _self, "XMPP Communication error", 
                        "Url: " + extra.url + "\nInfo: " + extra.message));
                    
                    if (typeof req.callback == "function") {
                        req.callback.call(_self, data, state, extra);
                        return true;
                    }
                    else if (extra.tpModule.retryTimeout(extra, state, _self, oError) === true)
                        return true;
                    
                    //@TBD:Mike please talk to me about how to integrate onError() properly
                    onError.call(_self, apf.xmpp.ERROR_CONN, extra.message, state);
                    throw oError;
                }

                if (typeof req.callback == "function")
                    req.callback.call(_self, data, state, extra);
            }, 
            nocache       : true,
            useXML        : !this.$isPoll,
            ignoreOffline : true,
            data          : req.body || ""
        });
    };

    /*
     * ERROR_AUTH: Something went wrong during the authentication process; this function
     *             provides a central mechanism for dealing with this situation
     *
     * ERROR_CONN: Our connection to the server has dropped, or the XMPP server can not be
     *             reached at the moment. We will cancel the authentication process and
     *             dispatch a 'connectionerror' event
     *
     * @param {Number}  nType  Type of the error (apf.xmpp.ERROR_AUTH or apf.xmpp.ERROR_CONN)
     * @param {String}  sMsg   Error message/ description. Optional.
     * @param {Number}  nState State of the http connection. Optional, defaults to apf.ERROR.
     * @type  {Boolean}
     * @private
     */
    function onError(nType, sMsg, nState) {
        if (nType & apf.xmpp.ERROR_CONN) {
            if (this.$retryCount == 3) {
                this.$retryCount = 0;
                clearTimeout(this.$listener);
                this.$listener = null;
                return this.connect(this.$serverVars["username"], this.$serverVars["password"],
                    this.$serverVars["login_callback"],
                    this.$serverVars["register"] || this.$autoRegister)
            }
            this.$retryCount++;
        }
        else {
            this.$retryCount = 0;
        }

        var bIsAuth = nType & apf.xmpp.ERROR_AUTH,
            bIsConn = nType & apf.xmpp.ERROR_CONN;

        
        apf.console.log("[XMPP-" + (bIsAuth
            ? "AUTH"
            : bIsConn ? "CONN" : "REG")
            + "] onError called.", "xmpp");
        
        clearTimeout(this.$listener);
        this.$listener = null;
        //delete this.$serverVars["password"];

        var extra = {
            username : this.$serverVars["username"],
            server   : this.url,
            message  : sMsg || (bIsAuth
                ? "Access denied. Please check your username or password."
                : bIsConn 
                    ? "Could not connect to server, please contact your System Administrator."
                    : "Could not register for a new user account")
        },
        cb = this.$serverVars["login_callback"];
        if (cb) {
            delete this.$serverVars["login_callback"];
            return cb(null, nState || apf.ERROR, extra);
        }

        
        apf.console.error(extra.message + " (username: " + extra.username
                          + ", server: " + extra.server + ")", "xmpp");
        

        return this.dispatchEvent(bIsAuth
            ? "authfailure"
            : bIsConn ? "connectionerror" : "registererror", extra);
    }

    /**
     * Connect to the XMPP server with a username and password combination
     * provided.
     *
     * @param {String}   username   Name of the user on the XMPP server Virtual
     *                              Host
     * @param {String}   password   Password of the user
     * @param {Function} [callback] Function that will be called after the Async
     *                              login request
     * @param {Boolean}  [reg]      Specifies whether to auto-register a new user
     * @type  {void}
     */
    this.connect = function(username, password, callback, reg) {
        this.reset();

        this.$serverVars["username"]       = username;
        this.$serverVars["password"]       = password;
        this.$serverVars["login_callback"] = callback;
        this.$serverVars["register"]       = reg || this.$autoRegister;
        this.$serverVars["previousMsg"]    = [];
        
        this.$serverVars[ROSTER].registerAccount(username, this.$domain);
        
        
        if (this.$canMuc)
            this.$mucRoster.registerAccount(username, this.$domain);
        
        this.$doXmlRequest(processConnect, this.$isPoll
            ? createStreamElement.call(this, null, {
                doOpen         : true,
                to             : this.$domain,
                xmlns          : apf.xmpp.NS.jabber,
                "xmlns:stream" : apf.xmpp.NS.stream,
                version        : "1.0"
              })
            : createBodyElement({
                content        : "text/xml; charset=utf-8",
                hold           : "1",
                rid            : this.$getRID(),
                to             : this.$domain,
                route          : "xmpp:jabber.org:9999",
                secure         : "true",
                wait           : "120",
                ver            : "1.6",
                "xml:lang"     : "en",
                "xmpp:version" : "1.0",
                xmlns          : apf.xmpp.NS.httpbind,
                "xmlns:xmpp"   : apf.xmpp.NS.bosh
              })
        );
    };

    /**
     * Disconnect from the XMPP server. It suspends the connection with the
     * 'pause' attribute when using BOSH. Poll-based connection only need to
     * stop polling.
     *
     * @param {Function} callback Data instruction callback that will be called
     *                            after the Async request
     * @type {void}
     */
    this.disconnect = function(callback) {
        if (this.$serverVars[CONN]) {
            if (callback)
                this.$serverVars["logout_callback"] = callback;
            
            if (this.$canMuc)
                this.leaveAllRooms();
            
            this.$doXmlRequest(processDisconnect, this.$isPoll
                ? createStreamElement.call(this, null, {
                    doClose: true
                  })
                : createBodyElement({
                      pause : 120,
                      rid   : this.$getRID(),
                      sid   : this.$serverVars[SID],
                      xmlns : apf.xmpp.NS.httpbind
                  })
            );
        }
        else {
            this.reset();
            if (callback)
                callback(null, apf.SUCCESS);
        }
    };

    /**
     * Set all session variables to NULL, so the element may create a new
     * XMPP connection.
     *
     * @type {void}
     */
    this.reset = function() {
        var oRoster = this.$serverVars[ROSTER];
        if (oRoster)
            oRoster.reset();
        
        if (this.$canMuc && this.$mucRoster)
            this.$mucRoster.reset();
        
        // unregister ALL variables:
        for (var i in this.$serverVars)
            delete this.$serverVars[i];

        // apply some initial values to the serverVars global scoped Array
        this.$RID = null;
        this.$serverVars["cnonce"] = generateCnonce(14);
        this.$serverVars["nc"]     = "00000001";
        this.$serverVars[CONN]     = false;
        
        this.$serverVars[ROSTER]   = new apf.xmpp_roster(this.$model,
           this.$modelContent, this.resource);
        
        this.$serverVars["bind_count"] = 0;
        this.$serverVars["mess_count"] = 0;

    };

    /*
     * A new stream has been created, now we need to process the response body.
     *
     * Example:
     *   <body xmpp:version='1.0'
     *         authid='ServerStreamID'
     *         xmlns='http://jabber.org/protocol/httpbind'
     *         xmlns:xmpp='urn:xmpp:xbosh'
     *         xmlns:stream='http://etherx.jabber.org/streams'>
     *     <stream:features>
     *       <mechanisms xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
     *         <mechanism>DIGEST-MD5</mechanism>
     *         <mechanism>PLAIN</mechanism>
     *       </mechanisms>
     *     </stream:features>
     *   </body>
     *
     * @param {Object} oXml
     * @param {Number} state
     * @param {mixed}  extra
     * @type  {void}
     * @private
     */
    function processConnect(oXml, state, extra) {
        if (state != apf.SUCCESS)
            return onError.call(this, apf.xmpp.ERROR_CONN, extra.message, state);

        // reset retry/ connection counter
        this.$retryCount = 0;
        if (!this.$isPoll) {
            this.$serverVars[SID]       = oXml.getAttribute("sid");
            this.$serverVars["AUTH_ID"] = oXml.getAttribute("authid");
        }
        else {
            var aCookie = extra.http.getResponseHeader("Set-Cookie").splitSafe(";");
            this.$serverVars[SID]       = aCookie[0].splitSafe("=")[1];
            this.$serverVars["AUTH_ID"] = oXml.firstChild.getAttribute("id");
        }

        var oMech  = oXml.getElementsByTagName("mechanisms")[0],
            sXmlns = oMech.getAttribute("xmlns");
        // @todo apf3.0 hack for o3, remove when o3 is fixed
        this.$serverVars["AUTH_SASL"] = apf.isO3 || (sXmlns && sXmlns == apf.xmpp.NS.sasl);

        var aNodes = oXml.getElementsByTagName("mechanism"),
            i      = 0,
            l      = aNodes.length,
            found  = false,
            sMech;
        for (; i < l && !found; i++) {
            sMech = aNodes[i].firstChild.nodeValue;
            if (sMech == "DIGEST-MD5" || sMech == "PLAIN") {
                this.$serverVars["AUTH_TYPE"] = sMech;
                found = true;
            }
        }

        // feature detection:
        aNodes = oXml.getElementsByTagName("register");
        for (i = 0, l = aNodes.length; i < l; i++) {
            this.$serverVars["AUTH_REG"] =
                (aNodes[i].getAttribute("xmlns") == apf.xmpp.NS.feature_reg);
        }

        if (!found) {
            return onError.call(this, apf.xmpp.ERROR_AUTH,
                "No supported authentication protocol found. We cannot continue!");
        }
        return (this.$serverVars["AUTH_REG"] && this.$serverVars["register"])
            ? doRegRequest.call(this)
            : doAuthRequest.call(this);
    }

    /*
     * In-Band registration support; allows for automatically registering a
     * username to the XMPP server and direct login.
     * @see http://xmpp.org/extensions/attic/jep-0077-2.0.html
     * 
     * @type {void}
     * @private
     */
    function doRegRequest() {
        var sIq = createIqBlock({
                type  : "set",
                id    : makeUnique("reg")
            },
            "<query xmlns='" + apf.xmpp.NS.register + "'><username>"
                + this.$serverVars["username"] + "</username><password>"
                + this.$serverVars["password"] + "</password></query>"
        ),
        _self = this;
        this.$doXmlRequest(function(oXml) {
                if (oXml && oXml.nodeType) {
                    var iq = oXml.getElementsByTagName("iq")[0];
                    if ((iq && iq.getAttribute("type") == "error")
                      || oXml.getElementsByTagName("error").length) {
                        onError.call(_self, apf.xmpp.ERROR_REG,
                            "New account registration for account '"
                            + this.$serverVars["username"] + " failed.");
                    }
                    // registration successful, proceed with authentication
                    doAuthRequest.call(_self);
                }
                
                else if (!_self.$isPoll)
                    onError.call(_self, apf.xmpp.ERROR_CONN, null, apf.OFFLINE);
                
            }, _self.$isPoll
            ? createStreamElement.call(this, null, null, sIq)
            : createBodyElement({
                rid   : this.$getRID(),
                sid   : this.$serverVars[SID],
                xmlns : apf.xmpp.NS.httpbind
            }, sIq)
        );
    }

    /*
     * Proceeds with the authentication process after establishing a connection
     * or stream to the server OR after a successful In-Band registration
     * We also support Non-SASL Authentication
     * @see http://xmpp.org/extensions/attic/jep-0078-1.7.html
     *
     * @type {void}
     */
    function doAuthRequest() {
        if (this.$serverVars["AUTH_SASL"]) {
            // start the authentication process by sending a request
            var sType = this.$serverVars["AUTH_TYPE"],
                sAuth = "<auth xmlns='" + apf.xmpp.NS.sasl + "' mechanism='"
                    + sType + (sType == "PLAIN"
                        ? "'>" + this.$serverVars["username"] + "@" + this.$domain
                            + String.fromCharCode(0) + this.$serverVars["username"]
                            + String.fromCharCode(0) + this.$serverVars["password"]
                            + "</auth>"
                        : "'/>");
            this.$doXmlRequest((sType == "ANONYMOUS" || sType == "PLAIN")
                ? reOpenStream // skip a few steps...
                : processAuthRequest, this.$isPoll
                ? createStreamElement.call(this, null, null, sAuth)
                : createBodyElement({
                      rid   : this.$getRID(),
                      sid   : this.$serverVars[SID],
                      xmlns : apf.xmpp.NS.httpbind
                  }, sAuth)
            );
        }
        // do Non-SASL Authentication as described in JEP-0078
        else {
           var sIq = createIqBlock({
                    type  : "get",
                    id    : makeUnique("auth")
                },
                "<query xmlns='" + apf.xmpp.NS.auth + "'><username>"
                    + this.$serverVars["username"] + "</username></query>"
            );
            this.$doXmlRequest(processAuthRequest, this.$isPoll
                ? createStreamElement.call(this, null, null, sIq)
                : createBodyElement({
                    rid   : this.$getRID(),
                    sid   : this.$serverVars[SID],
                    xmlns : apf.xmpp.NS.httpbind
                }, sIq)
            );
        }
    }

    /*
     * The connection has been terminated (set to state 'paused'). Theoretically
     * it could be resumed, but doing a complete reconnect would be more secure
     * and stable for RSB and other implementations that rely on stable stream
     * traffic.
     *
     * Example:
     *   @todo: put the spec response here...
     *
     * @param {Object} oXml
     * @type  {void}
     * @private
     */
    function processDisconnect(oXml, state, extra) {
        
        apf.console.dir(oXml);
        
        var cb = this.$serverVars["logout_callback"];
        this.reset();
        if (cb)
            cb(oXml, state, extra);
    }

    /*
     * Check the response from the server to a challenge our connection manager
     * set up. When a <failure> node is detected, it means that the challenge
     * failed and thereby the authentication as well.
     *
     * @param {XMLDom} oXml
     * @type  {Boolean}
     * @private
     */
    function processChallenge(oXml) {
        if (!oXml || oXml.getElementsByTagName("failure").length)
            return false; // authentication failed!

        var oChallenge = oXml.getElementsByTagName("challenge");
        if (oChallenge.length && (oChallenge = oChallenge[0])) {
            var i, l, aChunk,
                b64_challenge = oChallenge.firstChild.nodeValue,
                aParts        = apf.crypto.Base64.decode(b64_challenge).split(",");

            for (i = 0, l = aParts.length; i < l; i++) {
                aChunk = aParts[i].split("=");
                this.$serverVars[aChunk[0]] = aChunk[1].trim().replace(/[\"\']/g, "");
            }

            
            apf.console.info("processChallenge: " + aParts.join("    "), "xmpp");
            
        }

        return true;
    }

    /*
     * The first challenge result should be be processed here and the second
     * challenge is sent to the server
     *
     * Response example:
     *   <body xmlns='http://jabber.org/protocol/httpbind'>
     *     <challenge xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
     *       cmVhbG09InNvbWVyZWFsbSIsbm9uY2U9Ik9BNk1HOXRFUUdtMmhoIixxb3A9
     *       ImF1dGgiLGNoYXJzZXQ9dXRmLTgsYWxnb3JpdGhtPW1kNS1zZXNzCg==
     *     </challenge>
     *   </body>
     *
     * @param {Object} oXml
     * @type  {void}
     * @private
     */
    function processAuthRequest(oXml) {
        if (this.$serverVars["AUTH_SASL"]) {
            if (!processChallenge.call(this, oXml))
                return onError.call(this, apf.xmpp.ERROR_AUTH);

            var sRealm = this.$serverVars["realm"],
                md5    = apf.crypto.MD5;
            if (!sRealm)
                this.$serverVars["realm"] = sRealm = this.$domain; //DEV: option to provide realm with a default

            if (sRealm)
                this.$serverVars["digest-uri"] = "xmpp/" + sRealm;

            
            apf.console.info("auth - digest-uri: " + this.$serverVars["digest-uri"], "xmpp");
            

            // for the calculations of A1, A2 and sResp below, take a look at
            // RFC 2617, Section 3.2.2.1
            var A1 = md5.str_md5(this.$serverVars["username"] + ":" + this.$domain
                    + ":" + this.$serverVars["password"]) // till here we hash-up with MD5
                    + ":" + this.$serverVars["nonce"] + ":" + this.$serverVars["cnonce"],

                A2 = "AUTHENTICATE:" + this.$serverVars["digest-uri"],

                sResp = md5.hex_md5(md5.hex_md5(A1) + ":"
                    + this.$serverVars["nonce"] + ":" + this.$serverVars["nc"]
                    + ":" + this.$serverVars["cnonce"]
                    + ":" + this.$serverVars["qop"] + ":" + md5.hex_md5(A2));

            
            apf.console.info("response: " + sResp, "xmpp");
            

            var sAuth = createAuthBlock({
                username    : this.$serverVars["username"],
                realm       : sRealm,
                nonce       : this.$serverVars["nonce"],
                cnonce      : this.$serverVars["cnonce"],
                nc          : this.$serverVars["nc"],
                qop         : this.$serverVars["qop"],
                "digest-uri": this.$serverVars["digest-uri"],
                response    : sResp,
                charset     : this.$serverVars["charset"]
            });
            this.$doXmlRequest(processFinalChallenge, this.$isPoll
                ? createStreamElement.call(this, null, null, sAuth)
                : createBodyElement({
                      rid   : this.$getRID(),
                      sid   : this.$serverVars[SID],
                      xmlns : apf.xmpp.NS.httpbind
                  }, sAuth)
            );
        }
        else {
            if (oXml && oXml.nodeType) {
                var iq = oXml.getElementsByTagName("iq")[0];
                if ((iq && iq.getAttribute("type") == "error")
                  || oXml.getElementsByTagName("error").length) {
                    return onError.call(this, apf.xmpp.ERROR_AUTH);
                }
                var aDigest,
                    bDigest = (aDigest = oXml.getElementsByTagName("digest")
                                && aDigest[0]),
                    sIq     = createIqBlock({
                        type  : "set",
                        id    : makeUnique("auth")
                    },
                    "<query xmlns='" + apf.xmpp.NS.auth + "'><username>"
                        + this.$serverVars["username"] + "</username><resource>"
                        + this.resource + "</resource>" + (bDigest
                            ? "<digest xmlns='" + apf.xmpp.NS.auth + ">"
                                + apf.crypto.SHA1(this.$serverVars["AUTH_ID"]
                                + this.$serverVars["password"]) + "</digest>"
                            : "<password xmlns='" + apf.xmpp.NS.auth + "'>"
                                + this.$serverVars["password"] + "</password>")
                        + "</query>"
                );
                this.$doXmlRequest(reOpenStream, this.$isPoll
                    ? createStreamElement.call(this, null, null, sIq)
                    : createBodyElement({
                        rid   : this.$getRID(),
                        sid   : this.$serverVars[SID],
                        xmlns : apf.xmpp.NS.httpbind
                    }, sIq)
                );
            }
            
            else if (!this.$isPoll)
                onError.call(this, apf.xmpp.ERROR_CONN, null, apf.OFFLINE);
            
        }
    }

    /*
     * The second a last part of the authentication process (handshake) should
     * be processed here. If the handshake was successful, we can close the
     * authentication/ handshake process.
     *
     * Response example:
     *   <body xmlns='http://jabber.org/protocol/httpbind'>
     *     <challenge xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
     *       cnNwYXV0aD1lYTQwZjYwMzM1YzQyN2I1NTI3Yjg0ZGJhYmNkZmZmZAo=
     *     </challenge>
     *   </body>
     *
     * @param {Object} oXml
     * @type  {void}
     * @private
     */
    function processFinalChallenge(oXml) {
        // register the variables that are inside the challenge body
        // (probably only 'rspauth')
        if (!processChallenge.call(this, oXml))
            return onError.call(this, apf.xmpp.ERROR_AUTH);

        var sAuth = createAuthBlock({});
        this.$doXmlRequest(reOpenStream, this.$isPoll
            ? createStreamElement.call(this, null, null, sAuth)
            : createBodyElement({
                  rid   : this.$getRID(),
                  sid   : this.$serverVars[SID],
                  xmlns : apf.xmpp.NS.httpbind
              }, sAuth)
        );
    }

    /*
     * Check if the authentication process has been closed and confirmed by the
     * XMPP server. If successful, we can start listening for incoming messages.
     *
     * Response example:
     *   <body xmlns='http://jabber.org/protocol/httpbind'>
     *     <success xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/>
     *   </body>
     *
     * @param {Object} oXml
     * @type  {void}
     * @private
     */
    function reOpenStream(oXml) {
        if (this.$serverVars["AUTH_SASL"]) {
            if (!processChallenge.call(this, oXml))
                return onError.call(this, apf.xmpp.ERROR_AUTH);
        }
        else {
            if (oXml && oXml.nodeType) {
                var iq = oXml.getElementsByTagName("iq")[0];
                if ((iq && iq.getAttribute("type") == "error")
                  || oXml.getElementsByTagName("error").length) {
                    return onError.call(this, apf.xmpp.ERROR_AUTH);
                }
                delete this.$serverVars["password"];
            }
            
            else if (!this.$isPoll)
                onError.call(this, apf.xmpp.ERROR_CONN, null, apf.OFFLINE);
            
        }

        //restart the stream request
        var _self = this;
        this.$doXmlRequest(function(oXml) {
                if (_self.$isPoll || oXml.getElementsByTagName("bind").length) {
                    // Stream restarted OK, so now we can actually start
                    // listening to messages!
                    _self.bind();
                }
            }, this.$isPoll
            ? createStreamElement.call(this, null, {
                doOpen         : true,
                to             : this.$domain,
                xmlns          : apf.xmpp.NS.jabber,
                "xmlns:stream" : apf.xmpp.NS.stream,
                version        : "1.0"
              })
            : createBodyElement({
                  rid            : this.$getRID(),
                  sid            : this.$serverVars[SID],
                  to             : this.$domain,
                  "xml:lang"     : "en",
                  "xmpp:restart" : "true",
                  xmlns          : apf.xmpp.NS.httpbind,
                  "xmlns:xmpp"   : apf.xmpp.NS.bosh
              })
        );
    }

    /**
     * Tell the XMPP server that the authentication/ handshake has been completed
     * and that we want to start listening for messages for this user.
     *
     * @type {void}
     */
    this.bind = function() {
        var sIq = createIqBlock({
            id    : "bind_" + ++this.$serverVars["bind_count"],
            type  : "set",
            xmlns : this.$isPoll ? null : apf.xmpp.NS.jabber
          },
          "<bind xmlns='" + apf.xmpp.NS.bind + "'>" +
             "<resource>" + this.resource + "</resource>" +
          "</bind>"
        );
        this.$doXmlRequest(processBindingResult, this.$isPoll
            ? createStreamElement.call(this, null, null, sIq)
            : createBodyElement({
                  rid   : this.$getRID(),
                  sid   : this.$serverVars[SID],
                  xmlns : apf.xmpp.NS.httpbind
              }, sIq)
        );
    };

    /*
     * Checks if the request to bind the message stream with the the current
     * user was successful and if YES, then we store the full Jabber ID (JID)
     * and can start listening for incoming messages.
     *
     * Response example:
     *  <body xmlns='http://jabber.org/protocol/httpbind'>
     *     <iq id='bind_1'
     *         type='result'
     *         xmlns='jabber:client'>
     *       <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>
     *         <jid>stpeter@jabber.org/httpclient</jid>
     *       </bind>
     *     </iq>
     *   </body>
     *
     * @param {Object} oXml
     * @type  {void}
     * @private
     */
    function processBindingResult(oXml) {
        var oJID = oXml.getElementsByTagName("jid")[0];
        if (oJID) {
            this.$serverVars[JID] = oJID.firstChild.nodeValue;
            var sIq = createIqBlock({
                    from  : this.$serverVars[JID],
                    id    : this.$sAJAX_ID,
                    to    : this.$domain,
                    type  : "set",
                    xmlns : apf.xmpp.NS.jabber
                },
                "<session xmlns='" + apf.xmpp.NS.session + "'/>"
            ),
            _self = this;
            this.$doXmlRequest(function(oXml) {
                    parseData.call(_self, oXml);
                    setInitialPresence.call(_self);
                }, this.$isPoll
                ? createStreamElement.call(this, null, null, sIq)
                : createBodyElement({
                    rid   : this.$getRID(),
                    sid   : this.$serverVars[SID],
                    xmlns : apf.xmpp.NS.httpbind
                }, sIq)
            );
        }
        else {
            //@todo: check for binding failures!
            onError.call(this, apf.xmpp.ERROR_AUTH);
        }
    }

    /*
     * On connect, the presence of the user needs to be broadcasted to all the
     * nodes in the roster to 'available' (or whatever the default status is).
     * The response of this presence callback is also the indicator for any
     * successful login sequence.
     *
     * @type {void}
     * @private
     */
    function setInitialPresence() {
        // NOW only we set the actual presence tag!
        var sPresence = createPresenceBlock({
            type: apf.xmpp.TYPE_AVAILABLE
        }),
        _self = this;
        this.$doXmlRequest(function(oXml) {
                parseData.call(_self, oXml);
                
                getRoster.call(_self);
                
            }, this.$isPoll
            ? createStreamElement.call(this, null, null, sPresence)
            : createBodyElement({
                rid   : this.$getRID(),
                sid   : this.$serverVars[SID],
                xmlns : apf.xmpp.NS.httpbind
            }, sPresence)
        );
    }
    
    /*
     * Retrieve the roster information from the XMPP server. The roster contains
     * a list of nodes to which user has subscribed to. Each roster item will
     * contain presence information and optionally group metadata.
     * Generally, this data is only used for IM applications (see RFC 3921,
     * Section 7.2).
     * This function SHOULD only be called on login.
     *
     * @type {void}
     * @private
     */
    function getRoster() {
        var sIq = createIqBlock({
                from  : this.$serverVars[JID],
                type  : "get",
                id    : makeUnique("roster")
            },
            "<query xmlns='" + apf.xmpp.NS.roster + "'/>"
        ),
        _self = this,
        v     = this.$serverVars;
        this.$doXmlRequest(function(oXml) {
                parseData.call(_self, oXml);
                _self.$listen();
                var cb  = v["login_callback"],
                    msg = v["previousMsg"];
                if (cb) {
                    cb(null, apf.SUCCESS, {
                        username : v["username"]
                    });
                    delete v["login_callback"];
                }
                // @todo apf3.0 properly test the delayed messaging after reconnect
                if (msg && msg.length) {
                    for (var i = 0, l = msg.length; i < l; i++)
                        _self.sendMessage.apply(_self, msg[i]);
                    delete msg;
                    v["previousMsg"] = [];
                }

                // flag as 'connected'
                v[CONN] = true;
                _self.dispatchEvent(CONN, {username: v["username"]});
            }, this.$isPoll
            ? createStreamElement.call(this, null, null, sIq)
            : createBodyElement({
                rid   : this.$getRID(),
                sid   : this.$serverVars[SID],
                xmlns : apf.xmpp.NS.httpbind
            }, sIq)
        );
    }
    
    /**
     * Open a PUSH connection to the XMPP server and wait for messages to
     * arrive (i.e. 'listen' to the stream).
     * Internal locking prevents us from firing more than one listener at a time.
     *
     * @type {void}
     */
    this.$listen = function() {
        if (this.$listening === true) return;

        this.$listening = true;

        
        apf.console.info("XMPP: Listening for messages...", "xmpp");
        

        this.$doXmlRequest(processStream, this.$isPoll
            ? createStreamElement.call(this)
            : createBodyElement({
                  rid   : this.$getRID(),
                  sid   : this.$serverVars[SID],
                  xmlns : apf.xmpp.NS.httpbind
              }, "")
        );
    };

    /*
     * If there is no proof that the 'listener' thread (or http connection) is
     * still open, reconnect it after the current callback sequence has completed
     * (hence the 'setTimeout' call).
     *
     * @see teleport.xmpp.methodlisten
     * @param {mixed}  data
     * @param {Number} state
     * @param {Object} extra
     * @type {void}
     * @private
     */
    function restartListener(data, state, extra) {
        clearTimeout(this.$listener);
        this.$listener = null;
        if (data || state) {
            if (state != apf.SUCCESS)
                return onError.call(this, apf.xmpp.ERROR_CONN, extra.message, state);
            else
                parseData.call(this, data);
        }

        if (this.$serverVars[CONN] && !this.$listening) {
            var _self = this;
            this.$listener = $setTimeout(function() {
                _self.$listen();
            }, this.$pollTimeout || 0);
        }
    }

    this.$restartListener = restartListener;

    /*
     * Handle the result of the stream listener and messages that arrived need
     * to be processed.
     *
     * @param {Object} oXml
     * @type  {void}
     * @private
     */
    function processStream(oXml, state) {
        clearTimeout(this.$listener);
        this.$listener = null;
        parseData.call(this, oXml);

        var bNoListener = (this.$listening === false); //experimental
        this.$listening = false;

        // start listening again...
        if (this.$serverVars[CONN] && !bNoListener) {
            var _self = this;
            this.$listener = $setTimeout(function() {
                _self.$listen();
            }, this.$pollTimeout || 0);
        }
    }

    /*
     * Parse the XML envelope received from the XMPP server. Since one XML
     * envelope may contain more than one message type, no if...else block can
     * be found (we check for all possible message types).
     *
     * @param {Object} oXml
     * @type  {void}
     * @private
     */
    function parseData(oXml) {
        if (oXml && oXml.nodeType) {
            this.$serverVars["previousMsg"] = [];
            // do other stuff... like processing the messages? :P
            var aMessages = oXml.getElementsByTagName("message");
            if (aMessages.length)
                parseMessagePackets.call(this, aMessages);

            var aPresence = oXml.getElementsByTagName("presence");
            
            if (aPresence.length)
                parsePresencePackets.call(this, aPresence);

            var aIQs = oXml.getElementsByTagName("iq");
            if (aIQs.length)
                parseIqPackets.call(this, aIQs);
        }
        
        else if (!this.$isPoll)
            onError.call(this, apf.xmpp.ERROR_CONN, null, apf.OFFLINE);
        
    }

    this.$parseData = parseData;

    /*
     * Retrieve a message by collecting all textnodes from a <body> element.
     *
     * @param {XMLDomElement} oNode
     * @type  {String}
     */
    function getMessage(oNode) {
        var node,
            msg = [],
            i   = 0,
            l   = oNode.childNodes.length;
        for (i = 0; i < l; i++) {
            if ((node = oNode.childNodes[i]) && node.nodeType == 3)
                msg.push(node.nodeValue);
        }
        return msg.join("").replace(/\&quot;/g, '"');
    }

    /*
     * One or more (instant-)messages have are arrived that need to be processed
     * and parsed to eventually show up in the GUI
     *
     * @see teleport.xmpp.methodparseData
     * @param {Array} aMessages
     * @type  {void}
     * @private
     */
    function parseMessagePackets(aMessages) {
        var sMsg, sFrom, sJID, oBody, bRoom,
            i = 0,
            l = aMessages.length;

        for (; i < l; i++) {
            sJID  = aMessages[i].getAttribute("from");
            bRoom = (aMessages[i].getAttribute("type") == "groupchat");
            
            if (sJID && !bRoom)
                this.$serverVars[ROSTER].getEntityByJID(sJID); //unsed var...yet?
            

            if (aMessages[i].getAttribute("type") == "chat" || bRoom) {
                oBody = aMessages[i].getElementsByTagName("body")[0];
                if (!(oBody && oBody.childNodes.length)) continue;
                
                sFrom = aMessages[i].getAttribute("from");
                sMsg  = getMessage(oBody);
                
                
                if (bRoom && sFrom == this.$mucRoster.fullJID)
                    return;
                
                if ((bRoom ? this.$mucRoster : this.$serverVars[ROSTER])
                  .updateMessageHistory(sFrom, sMsg)) {
                
                    this.dispatchEvent("receivechat", {
                        from   : sFrom,
                        message: sMsg
                    });
                
                }
                
            }
            else if (aMessages[i].getAttribute("type") == "normal") { //normal = Remote SmartBindings
                oBody = aMessages[i].getElementsByTagName("body")[0];
                if (!(oBody && oBody.childNodes.length)) continue;

                //Remote SmartBindings support
                sMsg = getMessage(oBody);
                
                apf.console.info("received the following from the server: "
                    + sMsg, "xmpp");
                
                this.dispatchEvent("datachange", { data: sMsg });
            }
        }
    }

    /*
     * One or more Presence messages have arrived that indicate something has
     * changed in the roster, e.g. the status of a node changed, a node was
     * disconnected, etc. All of these messages will update the local Roster.
     *
     * @see teleport.xmpp.methodparseData
     * @param {Array} aPresence
     * @type  {void}
     * @private
     */
    function parsePresencePackets(aPresence) {
        
        apf.console.info("parsePresencePackets: " + aPresence.length, "xmpp");
        
        
        for (var i = 0, l = aPresence.length; i < l; i++) {
            var sJID = aPresence[i].getAttribute("from"),
                aX   = aPresence[i].getElementsByTagName("x"),
                bMuc = (sJID.indexOf(this.$mucDomain) > -1);
            
            if (aX.length) {
                for (var o, k = 0, l2 = aX.length; k < l2; k++) {
                    switch (aX[k].getAttribute("xmlns")) {
                        case apf.xmpp.NS.muc_user:
                            if (this.$getStatusCode(aX[k], 201)) {
                                this.$mucSignal(apf.xmpp_muc.ROOM_CREATE, sJID);
                                break;
                            }
                            // status code=110 means ME
                            if (!this.$isRoom(sJID) || this.$getStatusCode(aX[k], 110))
                                break;
                            o = aX[k].getElementsByTagName("item")[0];
                            if (!o) break;
                            this.$mucRoster.getEntityByJID(sJID, {
                                roomJID    : o.getAttribute("jid"),
                                affiliation: o.getAttribute("affiliation"),
                                role       : o.getAttribute("role"),
                                status     : aPresence[i].getAttribute("type")
                                    || apf.xmpp.TYPE_AVAILABLE
                            });
                            break;
                    }
                }
            }
            
            if (sJID && !bMuc) {
                var oRoster = this.$serverVars[ROSTER],
                    oUser   = oRoster.getEntityByJID(sJID),
                    sType   = aPresence[i].getAttribute("type");
                    
                if (sType == apf.xmpp.TYPE_SUBSCRIBE) {
                    // incoming subscription request, deal with it!
                    incomingAdd.call(this, aPresence[i].getAttribute("from"));
                }
                // record any status change...
                if (oUser)
                    oRoster.update(oUser, sType || apf.xmpp.TYPE_AVAILABLE);
            }
        }
        
    }

    /*
     * One or more Iq messages have arrived that notify the user of system wide
     * events and results of its actions, e.g. the failure or success of setting
     * presence, connection errors, probe for supported features of nodes results,
     * etc.
     *
     * @see teleport.xmpp.methodparseData
     * @param {Array} aIQs
     * @type  {void}
     * @private
     */
    function parseIqPackets(aIQs) {
        
        apf.console.info("parseIqPackets: " + aIQs.length, "xmpp");
        

        for (var i = 0, l = aIQs.length; i < l; i++) {
            if (aIQs[i].getAttribute("type") != "result"
              && aIQs[i].getAttribute("type") != "error") continue;
            var aQueries = aIQs[i].getElementsByTagName("query"),
                sFrom    = aIQs[i].getAttribute("from");
            for (var j = 0, l2 = aQueries.length; j < l2; j++) {
                var aItems, k, l3;
                switch (aQueries[j].getAttribute("xmlns")) {
                    
                    case apf.xmpp.NS.roster:
                        aItems  = aQueries[j].getElementsByTagName("item");
                        var oRoster = this.$serverVars[ROSTER],
                            pBlocks = [];
                        for (k = 0, l3 = aItems.length; k < l3; k++) {
                            var sSubscr  = aItems[k].getAttribute("subscription"),
                                sGroup   = (aItems[k].childNodes.length > 0)
                                    ? aItems[k].firstChild.firstChild.nodeValue
                                    : "",
                                sJid     = aItems[k].getAttribute("jid");

                            var oContact = oRoster.getEntityByJID(sJid, {
                                subscription: sSubscr,
                                group       : sGroup
                            });
                            // now that we have a contact added to our roster,
                            // it's time to ask for presence
                            if (sSubscr == apf.xmpp.SUBSCR_TO
                              || sSubscr == apf.xmpp.SUBSCR_BOTH)
                                pBlocks.push(oContact);
                            else if (oContact.subscription == apf.xmpp.TYPE_SUBSCRIBED)
                                confirmAdd.call(this, oContact);
                        }
                        if (pBlocks.length)
                            this.requestPresence(pBlocks);
                        break;
                    
                    
                    case apf.xmpp.NS.disco_items:
                        if (!this.$canMuc) break;

                        var aErrors = aIQs[i].getElementsByTagName("error");
                        if (aErrors.length
                          && parseInt(aErrors[0].getAttribute("code")) == 404) {
                            // room not found, signal failure...
                            this.$mucSignal(apf.xmpp_muc.ROOM_NOTFOUND, sFrom);
                            break;
                        }

                        // no error found, we continue...
                        aItems = aQueries[j].getElementsByTagName("item");
                        var oRoom = this.$addRoom(sFrom, sFrom.split("@")[0]),
                            sJID;

                        this.$mucSignal(apf.xmpp_muc.ROOM_EXISTS, sFrom);

                        // @todo: add support for paging (<set> element)
                        for (k = 0, l3 = aItems.length; k < l3; k++) {
                            sJID  = aItems[k].getAttribute("jid");
                            if (sJID.indexOf("/") != -1)
                                this.$addRoomOccupant(sJID);
                            else if (aItems[k].hasAttribute("name"))
                                oRoom.subscription = aItems[k].getAttribute("name");
                        }
                        break;
                    case apf.xmpp.NS.muc_user:
                        // @todo implement;
                        break;
                    case apf.xmpp.NS.muc_owner:
                        this.$mucSignal(apf.xmpp_muc.ROOM_CREATE, sFrom);
                        break;
                    
                    default:
                        break;
                }
            }
        }
    }

    /**
     * Provides the ability to change the presence of the user on the XMPP
     * network to any of the types in the following format:
     * 'apf.xmpp.STATUS_*'
     *
     * @param {String} type   Status type according to the RFC
     * @param {String} status Message describing the status
     * @param {String} custom Custom status type
     * @type  {void}
     */
    this.setPresence = function(type, status, custom) {
        if (!this.$serverVars[CONN]) return false;

        this.$doXmlRequest(restartlistener, createBodyElement({
                rid   : this.$getRID(),
                sid   : this.$serverVars[SID],
                xmlns : apf.xmpp.NS.httpbind
            },
            createPresenceBlock({
                type  : type || apf.xmpp.TYPE_AVAILABLE,
                status: status,
                custom: custom
            }))
        );
    };

    /**
     * Provides the ability to request the presence of a contact from a users
     * roster.
     * 
     * @param {mixed} from Contact to get the presence data from (object or JID string)
     * @type  {void}
     */
    this.requestPresence = function(from) {
        if (!this.$serverVars[CONN]) return false;
        
        var oRoster = this.$serverVars[ROSTER];
        if (typeof from == "string")
            from = oRoster.getEntityByJID(from);
        if (!from) return false;

        var sPresence, aPresence = [];
        if (apf.isArray(from)) {
            for (var i = 0, l = from.length; i < l; i++) {
                aPresence.push(createPresenceBlock({
                    type: apf.xmpp.TYPE_PROBE,
                    to  : from[i].fullJID,
                    from: oRoster.fullJID
                }));
            }
        }
        else {
            aPresence.push(createPresenceBlock({
                type  : apf.xmpp.TYPE_PROBE,
                to    : from.fullJID,
                from  : oRoster.fullJID
            }));
        }
        sPresence = aPresence.join("");

        this.$doXmlRequest(restartListener, this.$isPoll
            ? createStreamElement.call(this, null, null, sPresence)
            : createBodyElement({
                rid   : this.$getRID(),
                sid   : this.$serverVars[SID],
                xmlns : apf.xmpp.NS.httpbind
            }, sPresence)
        );
        
    };

    /**
     * Provides the ability to add a new contact to the roster of a user.
     * Depending on the settings and/ or action of the contact, the add request
     * will be accepted or denied.
     * @see protocol description in RFC 3921
     * @link http://tools.ietf.org/html/rfc3921#page-27
     * 
     * @param {String}   jid        Contact to be added to the user's Roster
     * @param {Function} [callback] Synchronisation callback for Datainstructions
     * @type  {void}
     */
    this.addContact = function(jid, callback) {
        
        if (typeof jid != "string") return false;
        var oRoster  = this.$serverVars[ROSTER],
            oContact = oRoster.getEntityByJID(jid);
        if (oContact && (oContact.subscription == apf.xmpp.SUBSCR_TO
          || oContact.subscription == apf.xmpp.SUBSCR_BOTH))
            return this.requestPresence(oContact);

        // all clear, now we request a new roster item
        var sIq = createIqBlock({
                type  : "set",
                id    : makeUnique("set")
            },
            "<query xmlns='" + apf.xmpp.NS.roster + "'><item jid='" + jid
                + "' /></query>"
        ),
        _self = this;
        this.$doXmlRequest(function(oXml) {
                parseData.call(_self, oXml);
                _self.$listen();
                // if all is well, a contact is added to the roster.
                // <presence to='contact@example.org' type='subscribe'/>
                var sPresence = createPresenceBlock({
                    type  : apf.xmpp.TYPE_SUBSCRIBE,
                    to    : jid
                });
                _self.$doXmlRequest(function(oXml) {
                        if (!oXml || !oXml.nodeType) {
                            return !_self.$isPoll
                                ? onError.call(_self, apf.xmpp.ERROR_CONN, null, apf.OFFLINE)
                                : null;
                        }
                        _self.$listen();

                        var oPresence = oXml.getElementsByTagName("presence")[0];
                        if (oPresence.getAttribute("error")) {
                            sPresence = createPresenceBlock({
                                type  : apf.xmpp.TYPE_UNSUBSCRIBE,
                                to    : jid
                            });
                            _self.$doXmlRequest(function(data, state, extra){
                                if (callback)
                                    callback.call(_self, data, state, extra);

                                restartListener.call(_self, data, state, extra);
                            }, _self.$isPoll
                                ? createStreamElement.call(this, null, null, sPresence)
                                : createBodyElement({
                                    rid   : this.$getRID(),
                                    sid   : this.$serverVars[SID],
                                    xmlns : apf.xmpp.NS.httpbind
                                }, sPresence)
                            );
                        }
                        // all other events should run through the parseData()
                        // function and delegated to the Roster
                    }, _self.$isPoll
                    ? createStreamElement.call(_self, null, null, sPresence)
                    : createBodyElement({
                        rid   : _self.$getRID(),
                        sid   : _self.$serverVars[SID],
                        xmlns : apf.xmpp.NS.httpbind
                    }, sPresence)
                );
            }, this.$isPoll
            ? createStreamElement.call(this, null, null, sIq)
            : createBodyElement({
                rid   : this.$getRID(),
                sid   : this.$serverVars[SID],
                xmlns : apf.xmpp.NS.httpbind
            }, sIq)
        );
        
    };
    
    /*
     * Handler function that takes care of responses to the XMPP server upon
     * presence subscription request of the current user.
     * Depending on the settings of {@link attribute.auto-accept} and
     * {@link attribute.auto-deny} a contact will be denied to the Roster or
     * added.
     *
     * @param {String} sJID Contact that requested a subscription the user's
     *                      presence information
     * @type  {void}
     * @private
     */
    function incomingAdd(sJID) {
        if (this.$autoConfirm) {
            var sMsg = createIqBlock({
                    from  : this.$serverVars[JID],
                    type  : "get",
                    id    : makeUnique("roster")
                },
                "<query xmlns='" + apf.xmpp.NS.roster + "'><item jid='" + sJID
                    + "' /></query>"
            ) +  createPresenceBlock({
                type  : apf.xmpp.TYPE_SUBSCRIBED,
                to    : sJID
            });
            this.$doXmlRequest(restartListener, this.$isPoll
                ? createStreamElement.call(this, null, null, sMsg)
                : createBodyElement({
                    rid   : this.$getRID(),
                    sid   : this.$serverVars[SID],
                    xmlns : apf.xmpp.NS.httpbind
                }, sMsg)
            );
        }
        if (this.$autoDeny) {
            // <presence to='user@example.com' type='unsubscribed'/>
            var sPresence = createPresenceBlock({
                type  : apf.xmpp.TYPE_UNSUBSCRIBED,
                to    : sJID
            });
            this.$doXmlRequest(restartListener, this.$isPoll
                ? createStreamElement.call(this, null, null, sPresence)
                : createBodyElement({
                    rid   : this.$getRID(),
                    sid   : this.$serverVars[SID],
                    xmlns : apf.xmpp.NS.httpbind
                }, sPresence)
            );
        }
    }

    /*
     * Handler function that takes care of the final stage of adding a contact
     * to the user's roster: confirmation of the subscription state.
     *
     * @param {Object} oContact Contact that has accepted the invitation to connect
     * @type  {void}
     * @private
     */
    function confirmAdd(oContact) {
        var sPresence = createPresenceBlock({
            type  : apf.xmpp.TYPE_SUBSCRIBED,
            to    : oContact.jid
        });
        this.$doXmlRequest(restartListener, this.$isPoll
            ? createStreamElement.call(this, null, null, sPresence)
            : createBodyElement({
                rid   : this.$getRID(),
                sid   : this.$serverVars[SID],
                xmlns : apf.xmpp.NS.httpbind
            }, sPresence)
        );
    }
    
    var statusMap = {
        "online"      : apf.xmpp.STATUS_ONLINE,
        "offline"     : apf.xmpp.STATUS_OFFLINE,
        "away"        : apf.xmpp.STATUS_AWAY,
        "xa"          : apf.xmpp.STATUS_XA,
        "extendedaway": apf.xmpp.STATUS_XA,
        "onvacation"  : apf.xmpp.STATUS_XA,
        "dnd"         : apf.xmpp.STATUS_DND,
        "donotdisturb": apf.xmpp.STATUS_DND,
        "invisible"   : apf.xmpp.STATUS_INVISIBLE,
        "ffc"         : apf.xmpp.STATUS_FFC,
        "chatty"      : apf.xmpp.STATUS_FFC,
        "freeforchat" : apf.xmpp.STATUS_FFC
    };

    /**
     * Set the currently connected users' status to the status string provided
     * by sStatus, defaults to 'online'
     * 
     * @param {String} [sStatus] Optional. Possible values: online, offline,
     *                           away, extendedaway, onvacation, dnd,
     *                           donotdisturb, invisible, chatty, freeforchat.
     * @type  {void}
     */
    this.setStatus = function(sStatus) {
        sStatus = statusMap[sStatus] || apf.xmpp.STATUS_ONLINE;
        
        return this.setPresence(sStatus, sStatus);
    };

    /**
     * Provides the ability to send a (chat-)message to any node inside the user's
     * Roster. If the 'type' property is set, it must be one of the constants in
     * the following format:
     * 'apf.xmpp.MSG_*'
     *
     * @param {String}   to         Must be of the format 'node@domainname.ext'
     * @param {String}   message
     * @param {String}   [thread]   For threading messages, i.e. to log a conversation
     * @param {String}   [type]     Message type, defaults to 'chat'
     * @param {Function} [callback] Synchronisation callback for Datainstructions
     * @type  {void}
     */
    this.sendMessage = function(to, message, thread, type, callback) {
        if (!message) return false;
        var _self = this;

        
        /*
            Note: This mechanism can also be used to only sent chat messages
            to only contacts. This can be more useful than using XMPP's server
            storage solution, because of the feedback to user.
        */
        if (typeof apf.offline != "undefined" && !apf.offline.onLine) {
            if (apf.offline.queue.enabled) {
                //Let's record all the necesary information for future use (during sync)
                var info = {
                    to       : to,
                    message  : message,
                    thread   : thread,
                    callback : callback,
                    type     : type,
                    retry    : function(){
                        _self.sendMessage(this.to, this.message, 
                            this.thread, this.type, this.callback);
                    },
                    $object : [this.name, "new apf.xmpp()"],
                    $retry  : "this.object.sendMessage(this.to, this.message, \
                        this.thread, this.type, this.callback)"
                };

                apf.offline.queue.add(info);

                return true;
            }

            /*
                Apparently we're doing an XMPP call even though we're offline
                I'm allowing it, because the developer seems to know more
                about it than I right now
            */

            
            apf.console.warn("Trying to sent XMPP message even though \
                              application is offline.", "xmpp");
            
        }
        

        if (!this.$serverVars[CONN]) return false;

        var bRoom = (this.$canMuc && type == "groupchat"),
            aArgs = Array.prototype.slice.call(arguments),
            oUser;
        
        if (!bRoom)
            oUser = this.$serverVars[ROSTER].getEntityByJID(to);
        

        if (!oUser){
            
            throw new Error(apf.formatErrorString(0, this,
                        "XMPP sendMessage error: no valid 'to' address provided",
                        "To: " + to + "\nMessage: " + message));
            
            return false;
        }

        var sMsg = createMessageBlock.call(this, {
                type       : type || apf.xmpp.MSG_CHAT,
                to         : to,
                thread     : thread,
                "xml:lang" : "en"
            },
            "<![CDATA[" + message + "]]>");

        this.$doXmlRequest(function(data, state, extra){
                if (callback)
                    callback.call(_self, data, state, extra);

                _self.$serverVars["previousMsg"] = aArgs;
                restartListener.call(_self, data, state, extra);
            }, this.$isPoll
            ? createStreamElement.call(this, null, null, sMsg)
            : createBodyElement({
                rid   : this.$getRID(),
                sid   : this.$serverVars[SID],
                xmlns : apf.xmpp.NS.httpbind
            }, sMsg)
        );
    };

    
    this.sendRSB = function(message) {
        var oRoster = this.$serverVars[ROSTER];
        if (!oRoster) return;
        var aUsers = oRoster.getAllEntities(apf.xmpp.TYPE_AVAILABLE),
            i      = 0,
            l      = aUsers.length;
        for (; i < l; i++)
            this.sendMessage(aUsers[i].bareJID, message, null, apf.xmpp.MSG_NORMAL);
    };
    

    /**
     * Makes sure that a few header are sent along with all the requests to the
     * XMPP server. This function overrides the abstract found in apf.http
     *
     * @see teleport.http
     * @param {Object} http
     * @type {void}
     */
    this.$headerHook = function(http) {
        http.setRequestHeader("Host", this.$domain);
        http.setRequestHeader("Content-Type", this.$isPoll
            ? "application/x-www-form-urlencoded"
            : "text/xml; charset=utf-8");
    };

    /*
     * Shutdown and disconnect properly from the (running) XMPP session.
     * Disconnect and Garbage Collect.
     *
     * @type {void}
     */
    this.addEventListener("DOMNodeRemovedFromDocument", function() {
        this.disconnect();
    });
    
    
    
    /**
     * Instruction handler for XMPP protocols. It supports the following directives:
     * - xmpp:name.login(username, password)
     * - xmpp:name.logout()
     * - xmpp:name.notify(message, to_address, thread, type)
     */
    this.exec = function(method, args, callback){
        switch(method){
            case "login":
                this.connect(args[0], args[1], callback);
                break;
            case "logout":
                //@todo
                break;
            case "notify":
                this.sendMessage(args[1], args[0], args[2], args[3], callback);
                break;
            default:
                
                throw new Error(apf.formatErrorString(0, null, "Saving/Loading data", 
                    "Invalid XMPP method '" + method + "'"));
                
                break;
        }
    };
    
    
}).call(apf.xmpp.prototype = new apf.Teleport());

apf.aml.setElement("xmpp", apf.xmpp);

// Collection of shorthands for all namespaces known and used by this class
apf.xmpp.NS   = {
    sasl        : "urn:ietf:params:xml:ns:xmpp-sasl",
    httpbind    : "http://jabber.org/protocol/httpbind",
    feature_reg : "http://jabber.org/features/iq-register",
    bosh        : "urn:xmpp:xbosh",
    jabber      : "jabber:client",
    bind        : "urn:ietf:params:xml:ns:xmpp-bind",
    session     : "urn:ietf:params:xml:ns:xmpp-session",
    auth        : "jabber:iq:auth",
    roster      : "jabber:iq:roster",
    register    : "jabber:iq:register",
    data        : "jabber:x:data",
    stream      : "http://etherx.jabber.org/streams",
    disco_info  : "http://jabber.org/protocol/disco#info",
    disco_items : "http://jabber.org/protocol/disco#items",
    muc         : "http://jabber.org/protocol/muc",
    muc_user    : "http://jabber.org/protocol/muc#user",
    muc_owner   : "http://jabber.org/protocol/muc#owner"
};

apf.xmpp.CONN_POLL = 0x0001;
apf.xmpp.CONN_BOSH = 0x0002;

apf.xmpp.ERROR_AUTH = 0x0004;
apf.xmpp.ERROR_CONN = 0x0008;
apf.xmpp.ERROR_MUC  = 0x0010;
apf.xmpp.ERROR_REG  = 0x0011;

apf.xmpp.SUBSCR_FROM = "from";
apf.xmpp.SUBSCR_TO   = "to";
apf.xmpp.SUBSCR_BOTH = "both";
apf.xmpp.SUBSCR_NONE = "none";

apf.xmpp.TYPE_AVAILABLE   = ""; //no need to send 'available'
apf.xmpp.TYPE_UNAVAILABLE = "unavailable";
apf.xmpp.TYPE_PROBE       = "probe";
apf.xmpp.TYPE_SUBSCRIBED  = "subscribed";
apf.xmpp.TYPE_SUBSCRIBE   = "subscribe";
apf.xmpp.TYPE_UNSUBSCRIBE = "unsubscribe";
apf.xmpp.TYPE_UNSUBSCRIBED= "unsubscribed";

apf.xmpp.STATUS_ONLINE    = "online";
apf.xmpp.STATUS_OFFLINE   = "offline";
apf.xmpp.STATUS_SHOW      = "show";
apf.xmpp.STATUS_AWAY      = "away";
apf.xmpp.STATUS_XA        = "xa";
apf.xmpp.STATUS_DND       = "dnd";
apf.xmpp.STATUS_INVISIBLE = "invisible";
apf.xmpp.STATUS_FFC       = "chat";

apf.xmpp.MSG_CHAT      = "chat";
apf.xmpp.MSG_GROUPCHAT = "groupchat";
apf.xmpp.MSG_ERROR     = "error";
apf.xmpp.MSG_HEADLINE  = "headline";
apf.xmpp.MSG_NORMAL    = "normal";




/*FILEHEAD(/var/lib/platform/source/trunk/elements/actiontracker.js)SIZE(42273)TIME(1263513664)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element keeping track of all user actions that are triggered in GUI
 * elements. This element maintains a stack of actions and knows how to
 * undo & redo them. It is aware of how to synchronize the changes to the
 * backend data store.
 * Example:
 * <code>
 *   datagrid.getActionTracker().undo();
 * </code>
 * Remarks:
 * With offline support enabled the actiontracker can
 * serialize both its undo stack and its execution stack such that these can
 * be kept in between application sessions. This means that a user will be able
 * to close the application and start it at a later date whilst keeping his or
 * her entire undo/redo stack. Furthermore all changes done whilst being offline
 * will be synchronized to the data store when the application comes online.
 *
 * @constructor
 * @inherits apf.Class
 *
 * @define actiontracker
 * @addnode smartbinding, global
 * @event afterchange   Fires after a change to the action stack occurs
 *    object:
 *    {String} action the name of the action that was execution
 * @event beforechange  Fires before a change to the action stack will occur
 *   cancelable:    Prevents the execution of the action.
 *   object:
 *   {String}  action           the action to be executed
 *   {Array}   args             the arguments for the action
 *   {XmlNode} [xmlActionNode]  the rules to synchronize the changes to the server for both execution and undo. (See action rules)
 *   {AmlNode} [amlNode]        the GUI element that triggered the action
 *   {XmlNode} [selNode]        the relevant {@link term.datanode data node} to which the action node works on
 *   {Number}  [timestamp]      the start of the action that is now executed.
 * @event actionfail Fires when an action fails to be sent to the server.
 *   bubbles: true
 *   object:
 *     {Error}          error     the error object that is thrown when the event callback doesn't return false.
 *     {Number}         state     the state of the call
 *       Possible values:
 *       apf.SUCCESS  the request was successfull
 *       apf.TIMEOUT  the request has timed out.
 *       apf.ERROR    an error has occurred while making the request.
 *       apf.OFFLINE  the request was made while the application was offline.
 *     {mixed}          userdata  data that the caller wanted to be available in the callback of the http request.
 *     {XMLHttpRequest} http      the object that executed the actual http request.
 *     {String}         url       the url that was requested.
 *     {Http}           tpModule  the teleport module that is making the request.
 *     {Number}         id        the id of the request.
 *     {String}         message   the error message.
 * @see term.locking
 * @event actionsuccess Fires when an action is successfully sent to the server.
 *   bubbles: true
 *   object:
 *     {Number}         state     the state of the call
 *       Possible values:
 *       apf.SUCCESS  the request was successfull
 *       apf.TIMEOUT  the request has timed out.
 *       apf.ERROR    an error has occurred while making the request.
 *       apf.OFFLINE  the request was made while the application was offline.
 *     {mixed}          userdata  data that the caller wanted to be available in the callback of the http request.
 *     {XMLHttpRequest} http      the object that executed the actual http request.
 *     {String}         url       the url that was requested.
 *     {Http}           tpModule  the teleport module that is making the request.
 *     {Number}         id        the id of the request.
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 */
apf.actiontracker = function(struct, tagName){
    this.$init(tagName || "actiontracker", apf.NODE_HIDDEN, struct);
    
    this.$stackDone   = [];
    this.$stackUndone = [];
    this.$execStack   = [];
};

(function(){
    this.$lastExecStackItem = null;

    this.realtime   = true;
    this.undolength = 0;
    this.redolength = 0;

    /**
     * @attribute {Number}  !undolength the length of the undo stack.
     * @attribute {Number}  !redolength the length of the redo stack.
     * @attribute {Boolean} realtime    whether changes are immediately send to
     * the datastore, or held back until purge() is called.
     */
    this.$booleanProperties = {};
    this.$booleanProperties["realtime"] = true;
    this.$supportedProperties = ["realtime", "undolength", "redolength", "alias"];
    this.$handlePropSet = function(prop, value, force){
        //Read only properties
        switch (prop) {
            case "undolength":
                this.undolength = this.$stackDone.length;
                break;
            case "redolength":
                this.redolength = this.$stackUndone.length;
                break;
            
            default:
                this[prop] = value;
        }
    };
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (this.parentNode)
            this.parentNode.$at = this;
    });

    /**
     * Adds a new action handler which can be used by any actiontracker.
     * @param {String} action Specifies the name of the action
     * @param {Function} func Specifies the function that is executed when
     *                        Executing or undoing the action.
     */
    this.define = function(action, func){
        apf.actiontracker.actions[action] = func;
    };

    /**
     * Searches for the actiontracker that functions as a parent for this one.
     * @return {ActionTracker} Returns the parent actiontracker
     */
    this.getParent = function(){
        return this.parentNode && this.parentNode.getActionTracker
            ? this.parentNode.getActionTracker(true)
            : (apf.window.$at != this
                ? apf.window.$at
                : null);
    };

    /**
     * Executes an action, which later can be undone and of which the execution
     * can be synchronized to the data store.
     * @param {Object} options the details of the execution.
     *   Properties:
     *   {String}  action           the action to be executed
     *   {Array}   args             the arguments for the action
     *   {XmlNode} [xmlActionNode]  the rules to synchronize the changes to the server for both execution and undo. (See action rules)
     *   {AmlNode} [amlNode]        the GUI element that triggered the action
     *   {XmlNode} [selNode]        the relevant {@link term.datanode data node} to which the action node works on
     *   {Number}  [timestamp]      the start of the action that is now executed.
     */
    this.execute = function(options){
        if (this.dispatchEvent("beforechange", options) === false)
            return;

        //Execute action
        var UndoObj = new apf.UndoData(options, this);
        if (options.action)
            apf.actiontracker.actions[options.action](UndoObj, false, this);

        //Add action to stack
        UndoObj.id = this.$stackDone.push(UndoObj) - 1;

        this.setProperty("undolength", this.$stackDone.length);

        
        if (typeof apf.offline != "undefined") {
            var t = apf.offline.transactions;
            if (t.doStateSync) {
                t.addAction(this, UndoObj, "undo");
                t.clearActions(this, "redo");
            }
        }
        

        //Respond
        if (UndoObj.multiple) 
            this.$addToQueue(UndoObj.multiple, false, true);
        else
            this.$addToQueue(UndoObj, false);

        //Reset Redo Stack
        this.$stackUndone.length = 0;
        this.setProperty("redolength", this.$stackUndone.length);

        this.dispatchEvent("afterchange", {
            action   : "do"
        })

        //return stack id of action
        return UndoObj;
    };

    //deprecated??
    this.$addActionGroup = function(done, rpc){
        var UndoObj = new apf.UndoData("group", null, [
            //@todo apf.copyArray is deprecated and no longer exists
            apf.copyArray(done, UndoData), apf.copyArray(rpc, UndoData)
        ]);
        this.$stackDone.push(UndoObj);
        this.setProperty("undolength", this.$stackDone.length);

        this.dispatchEvent("afterchange", {action: "group", done: done});
    };

    /**
     * Synchronizes all held back changes to the data store.
     * @todo I don't really know if this stacking into the parent is
     * still used, for instance for apf.Transactions. please think
     * about it.
     */
    this.purge = function(nogrouping, forcegrouping){//@todo, maybe add noReset argument
        //var parent = this.getParent();

        //@todo Check if this still works together with transactions
        if (true) {//nogrouping && parent
            if (this.$execStack.length) {
                this.$execStack[0].undoObj.saveChange(this.$execStack[0].undo, this);
                this.$lastExecStackItem = this.$execStack[this.$execStack.length - 1];
            }
        }
        else if (parent) {
            /*
                Copy Stacked Actions as a single
                grouped action to parent ActionTracker
            */
            //parent.$addActionGroup(this.$stackDone, stackRPC);
            
            //Reset Stacks
            this.reset();
        }
    };

    /**
     * Empties the action stack. After this method is run running undo
     * or redo will not do anything.
     */
    this.reset = function(){
        this.$stackDone.length = this.$stackUndone.length = 0;

        this.setProperty("undolength", 0);
        this.setProperty("redolength", 0);

        this.dispatchEvent("afterchange", {action: "reset"});
    };

    /**
     * Revert the most recent action on the action stack
     */
    this.undo = function(id, single, rollback){
        change.call(this, id, single, true, rollback);
    };

    /**
     * Re-executes the last undone action
     */
    this.redo = function(id, single, rollback){
        change.call(this, id, single, false, rollback);
    };

    function change(id, single, undo, rollback){
        var undoStack = undo ? this.$stackDone : this.$stackUndone, //local vars switch
            redoStack = undo ? this.$stackUndone : this.$stackDone; //local vars switch

        if (!undoStack.length) return;
        
        if (single) {
            var UndoObj = undoStack[id];
            if (!UndoObj) return;

            
            if (id != undoStack.length - 1) //@todo callstack got corrupted?
                throw new Error("callstack got corrupted");
            
            undoStack.length--;
            redoStack.push(UndoObj); //@todo check: moved from outside if(single)

            
            if (typeof apf.offline != "undefined" && apf.offline.transactions.doStateSync) {
                apf.offline.transactions.removeAction(this, true, undo ? "undo" : "redo");
                apf.offline.transactions.addAction(this, UndoObj, undo ? "redo" : "undo");
            }
            

            //Undo Client Side Action
            if (UndoObj.action)
                apf.actiontracker.actions[UndoObj.action](UndoObj, undo, this);

            if (!rollback) {
                if (UndoObj.multiple) 
                    this.$addToQueue(UndoObj.multiple, undo, true);
                else
                    this.$addToQueue(UndoObj, undo);
            }

            //Set Changed Value
            this.setProperty("undolength", this.$stackDone.length);
            this.setProperty("redolength", this.$stackUndone.length);
            return UndoObj;
        }

        if (this.dispatchEvent("beforechange") === false)
            return;

        
        apf.console.info("Executing " + (undo ? "undo" : "redo"));
        

        //Undo the last X places - where X = id;
        if (id == -1)
            id = undoStack.length;

        if (!id)
            id = 1;

        var i = 0;
        while (i < id && undoStack.length > 0) {
            if (!undoStack[undoStack.length - 1]) {
                undoStack.length--;

                
                apf.console.error("The actiontracker is in an invalid \
                                   state. The entire undo and redo stack will \
                                   be cleared to prevent further corruption\
                                   This is a serious error, please contact \
                                   a specialist.");
                

                this.$stackDone   = [];
                this.$stackUndone = [];

                
                if (typeof apf.offline != "undefined") {
                    var t = apf.offline.transactions;
                    if (t.doStateSync)
                        t.clear("undo|redo");
                }
                

                return false;
            }
            else {
                change.call(this, undoStack.length - 1, true, undo, rollback);
                i++;
            }
        }

        this.dispatchEvent("afterchange", {
            action   : undo ? "undo" : "redo",
            rollback : rollback
        })
    }

    this.$receive = function(data, state, extra, UndoObj, callback){
        if (state == apf.TIMEOUT
          && extra.tpModule.retryTimeout(extra, state, this) === true)
            return true;

        if (state != apf.SUCCESS) {
            //Tell anyone that wants to hear about our failure :(
            if (this.dispatchEvent("actionfail", apf.extend(extra, {
                state   : state,
                message : "Could not sent Action RPC request for control "
                            + this.name
                            + "[" + this.localName + "] \n\n"
                            + extra.message,
                bubbles : true
            })) === false) {

                
                apf.console.warn("You have cancelled the automatic undo \
                    process! Please be aware that if you don't retry this call \
                    the queue will fill up and none of the other actions will \
                    be sent through.");
                

                return true; //don't delete the call from the queue
            }

            /*
                Undo the failed action. We're only undoing one item of the stack
                if the developer has told us using the @ignore-fail attribute
                that it's ok, the data will be safe if we undo only this one.

                @todo: Shouldn't the stackUndone be cleared after this... or
                       is it intuitive enough for the user that redo will
                       let the user retry the action??
            */
            if (typeof apf.offline != "undefined" && !apf.offline.reloading)
                this.undo(UndoObj.id, extra.userdata, true);

            if (callback)
                callback(!extra.userdata);

            if (!extra.userdata) {
                /*
                    Clearing the execStack, none of the changes will be send to
                    the server. This seems the best way right now and is related
                    to the todo item above.
                    
                    @todo: Think about adding ignore-fail to settings and 
                           actiontracker.
                */
                this.$execStack = [];
                
                var oError = new Error(apf.formatErrorString(0, this, 
                    "Executing action",
                    "Error sending action to the server:\n"
                    + (extra.url ? "Url:" + extra.url + "\n\n" : "") 
                    + extra.message));

                if ((UndoObj && UndoObj.xmlActionNode || extra.amlNode || apf)
                  .dispatchEvent("error", apf.extend({
                    error   : oError,
                    state   : state,
                    bubbles : true
                }, extra)) === false)
                    return;
                    
                throw oError;
            }
        }
        else {
            //Tell anyone that wants to hear about our success
            this.dispatchEvent("actionsuccess", apf.extend(extra, {
                state   : state,
                bubbles : true
            }, extra));

            
            //Send out the RSB message, letting friends know of our change
            UndoObj.processRsbQueue();
            

            if (callback)
                callback();
        }

        this.$queueNext(UndoObj, callback);
    };

    this.$addToQueue = function(UndoObj, undo, isGroup){
        /*
            Remove item from the execution stack if it's not yet executed
            to keep the stack clean
        */
        //@todo Implement this for isGroup if deemed useful
        if (!isGroup && this.$execStack.length && !UndoObj.state
          && this.$execStack[this.$execStack.length - 1].undoObj == UndoObj) {
            this.$execStack.length--;

            
            if (typeof apf.offline != "undefined" && apf.offline.transactions.enabled) //We want to maintain the stack for sync
                apf.offline.transactions.removeAction(this, true, "queue");
            

            
            UndoObj.clearRsbQueue();
            

            return;
        }

        // Add the item to the queue
        if (isGroup) { //@todo currently no offline support for grouped actions
            var undoObj, qItem = this.$execStack.shift();
            for (var i = 0; i < UndoObj.length; i++) {
                undoObj = UndoObj[i];
                this.$execStack.unshift({
                    undoObj : (undoObj.tagName 
                        ? undoObj 
                        : new apf.UndoData(undoObj, this)).preparse(undo, this),
                    undo   : undo
                });
            }
            if (qItem)
                this.$execStack.unshift(qItem);

            return;
        }

        var qItem = {
            undoObj : UndoObj.preparse(undo, this),
            undo   : undo

        };
        this.$execStack.push(qItem) - 1;

        
        if (typeof apf.offline != "undefined" && apf.offline.transactions.enabled) //We want to maintain the stack for sync
            apf.offline.transactions.addAction(this, qItem, "queue");
        

        //The queue was empty, yay! we're gonna exec immediately
        if (this.$execStack.length == 1 && this.realtime)
            UndoObj.saveChange(undo, this);
    };

    this.$queueNext = function(UndoObj, callback){
        /*
            These thow checks are so important, that they are also executed
            in release mode.
        */
        if (!this.$execStack[0] || this.$execStack[0].undoObj != UndoObj){
            throw new Error(apf.formatErrorString(0, this, "Executing Next \
                action in queue", "The execution stack was corrupted. This is \
                a fatal error. The application should be restarted. You will \
                lose all your changes. Please contact the administrator."));
        }

        //Reset the state of the undo item
        UndoObj.state = null;

        //Remove the action item from the stack
        var lastItem = this.$execStack.shift();

        
        if (typeof apf.offline != "undefined" && apf.offline.transactions.enabled) //We want to maintain the stack for sync
            apf.offline.transactions.removeAction(this, null, "queue");
        

        //Check if there is a new action to execute;
        if (!this.$execStack[0] || lastItem == this.$lastExecStackItem)
            return;

        // @todo you could optimize this process by using multicall, but too much for now

        //Execute action next in queue
        this.$execStack[0].undoObj.saveChange(this.$execStack[0].undo, this, callback);
    };

    
    this.$loadQueue = function(stack, type){
        if (type == "queue") {
            
            if (this.$execStack.length) { //@todo
                throw new Error("oops");
            }
            

            this.$execStack = stack;
        }

        
        else if (type == "undo") {
            
            if (this.$stackDone.length) //@todo
                throw new Error("oops");
            

            this.$stackDone = stack;
        }
        else if (type == "redo") {
            
            if (this.$stackUndone.length) //@todo
                throw new Error("oops");
            

            this.$stackUndone = stack;
        }
        

        
        else //@todo
            throw new Error("unknown");
        
    };

    this.$getQueueLength = function(){
        return this.$execStack.length;
    };

    this.$startQueue = function(callback){
        if (!this.$execStack[0] || this.$execStack[0].undoObj.state) //@todo This is gonna go wrong, probably
            return false;

        //Execute action next in queue
        this.$execStack[0].undoObj.saveChange(this.$execStack[0].undo, this, callback);
    };
    
}).call(apf.actiontracker.prototype = new apf.AmlElement());

apf.aml.setElement("actiontracker", apf.actiontracker);

/**
 * UndoData is the command object for the actiontracker. Each instance of this class
 * contains information about a single event in the application. It can be undone
 * and it knows how to synchronize the change to a (remote) data source.
 *
 * @constructor
 * @default_private
 */
apf.UndoData = function(settings, at){
    this.localName = "UndoData";
    this.extra     = {};
    
    this.rsbQueue  = {};
    
    apf.extend(this, settings);

    if (at)
        this.at = at;
    //Copy Constructor
    else if (settings && settings.tagName == "UndoData") {
        this.args    = settings.args.slice();
        
        this.rsbArgs = settings.rsbArgs.slice();
        
    }
    //Constructor
    else {
        /*
            @todo: Please check the requirement for this and how to solve
            this. Goes wrong with multiselected actions!
        */
        this.selNode = this.selNode || (this.action == "removeNode"
            ? this.args[0]
            : (this.amlNode
                ? this.amlNode.selected
                : null));
    }

    var options, _self = this;

    
    var serialState;
    this.$export = function(){
        if (serialState) //Caching
            return serialState;

        serialState = {
            action    : this.action,
            
            rsbModel  : this.rsbModel ? this.rsbModel.name : null,
            rsbQueue  : this.rsbQueue,
            
            at        : this.at.name,
            timestamp : this.timestamp,
            parsed    : options ? options.parsed : null, //errors when options is not defined
            userdata  : options ? options.userdata : null,
            extra     : {}
        };

        
        //this can be optimized
        var rsb = this.rsbModel
            ? this.rsbModel.rsb
            : apf.remote;
        

        //Record arguments
        var sLookup = (typeof apf.offline != "undefined" && apf.offline.sLookup)
            ? apf.offline.sLookup
            : (apf.offline.sLookup = {});
        if (!sLookup.count) sLookup.count = 0;
        var xmlNode, xmlId, args = this.args.slice();

        for (var i = 0; i < args.length; i++) {
            if (args[i] && args[i].nodeType) {
                if (!serialState.argsModel) {
                    var model = apf.nameserver.get("model",
                        apf.xmldb.getXmlDocId(args[i]));

                    if(model)
                        serialState.argsModel = model.name || model.$uniqueId;
                }

                args[i] = serializeNode(args[i]);
            }
        }

        var item, name;
        for (name in this.extra) {
            item = this.extra[name];
            serialState.extra[name] = item && item.nodeType
                ? serializeNode(item)
                : item;
        }

        //check this state and the unserialize function state and check the args and extra props
        serialState.args = args;

        
        if (!serialState.argsModel)
            apf.console.warn("Could not determine model for serialization \
                of undo state. Will not be able to undo the state when the \
                server errors. This creates a potential risk of loosing \
                all changes on sync!")
        

        return serialState;

        function serializeNode(xmlNode){
            /*
                If it's an attribute or directly connected to the root of the
                model we'll just record the xpath
            */
            if (xmlNode.nodeType == 2
              || apf.isChildOf(model.data, xmlNode, true)) {
                xmlId = xmlNode.getAttribute(apf.xmldb.xmlIdTag);
                return {
                    xpath  : rsb.xmlToXpath(xmlNode, model.data, true),
                    lookup : xmlId
                };
            }
            // So we've got a disconnected branch, lets serialize it
            else {
                var contextNode = xmlNode;
                while (contextNode.parentNode && contextNode.parentNode.nodeType == 1) //find topmost parent
                    contextNode = xmlNode.parentNode;

                xmlId = contextNode.getAttribute(apf.xmldb.xmlIdTag);
                if (!xmlId) {
                    xmlId = "serialize" + sLookup.count++;
                    contextNode.setAttribute(apf.xmldb.xmlIdTag, xmlId);
                }

                var obj = {
                    xpath  : rsb.xmlToXpath(xmlNode, contextNode, true),
                    lookup : xmlId
                }

                if (!sLookup[xmlId]) {
                    contextNode.setAttribute(apf.xmldb.xmlDocTag,
                        apf.xmldb.getXmlDocId(contextNode));

                    sLookup[xmlId] = contextNode;
                    obj.xml        = contextNode.xml || contextNode.serialize();
                }

                return obj;
            }
        }
    };

    this.$import = function(){
        
        if (this.rsbModel)
            this.rsbModel = apf.nameserver.get("model", this.rsbModel);
        

        if (this.argsModel) {
            var model = apf.nameserver.get("model", this.argsModel)
                || apf.lookup(this.argsModel);

            //Record arguments
            var sLookup =  (typeof apf.offline != "undefined" && apf.offline.sLookup)
                ? apf.offline.sLookup
                : (apf.offline.sLookup = {});
            if (!sLookup.count) sLookup.count = 0;

            var args = this.args,
                
                rsb  = this.rsbModel
                    ? this.rsbModel.rsb
                    : apf.remote,
                
                xmlNode, i, l, item, name;

            for (i = 0, l = args.length; i < l; i++) {
                if (args[i] && args[i].xpath)
                    args[i] = unserializeNode(args[i], model);
            }

            for (name in this.extra) {
                item = this.extra[name];
                if (item && item.xpath)
                    this.extra[name] = unserializeNode(item, model);
            }

            this.args = args;
        }

        options = {
            undoObj   : this,
            userdata  : this.userdata,
            parsed    : this.parsed
        }

        
        if (this.timestamp) {
            options.actionstart = this.timestamp;
            options.headers     = {"X-JPF-ActionStart": this.timestamp};
        }
        

        return this;

        function unserializeNode(xmlSerial, model){
            if (xmlSerial.xml) {
                xmlNode = apf.xmldb.getXml(xmlSerial.xml);
                sLookup[xmlNode.getAttribute(apf.xmldb.xmlIdTag)] = xmlNode;
            }
            else if (xmlSerial.lookup) {
                xmlNode = sLookup[xmlSerial.lookup];

                
                if (!xmlSerial.xpath) //@todo
                    throw new Error("Serialization error");
                
            }
            else
                xmlNode = null;

            return rsb.xpathToXml(xmlSerial.xpath, xmlNode || model.data);
        }
    };
    

    
    //Send RSB Message..
    this.processRsbQueue = function(){
        if (this.rsbModel)
            this.rsbModel.rsb.processQueue(this);
    };

    this.clearRsbQueue = function(){
        this.rsbQueue = 
        this.rsbModel = null;
    };
    

    /**
     * Save the change to a data source.
     * @param {Boolean} undo whether the change is undone.
     */
    this.saveChange = function(undo, at, callback){
        //Grouped undo/redo support
        if (this.action == "group") {
            var rpcNodes = this.args[1];
            at.$addToQueue(rpcNodes, undo, true);
            return at.$queueNext(this);
        }

        var dataInstruction;
        if (this.xmlActionNode) {
            dataInstruction = this.xmlActionNode.getAttribute(undo ? "undo" : "set");
            if (undo && !dataInstruction)
                dataInstruction = this.xmlActionNode.getAttribute("set");
        }

        if (!dataInstruction) {
            
            this.processRsbQueue();
            
            return at.$queueNext(this);
        }

        this.state = undo ? "restoring" : "saving";

        
        if (!options || options._pc === true) {
            throw new Error("Error in data instruction:" + dataInstruction); //@todo apf3.0 turn this into a proper apf error
        }
        
        
        if (options._pc == -2) {
            return at.$receive(null, apf.SUCCESS, {amlNode: this.amlNode}, 
                this, callback);
        }
        
        //options._precall = false;
        options.callback = function(data, state, extra){
            extra.amlNode = _self.amlNode;
            return at.$receive(data, state, extra, _self, callback);
        }
        options.ignoreOffline = true;

        apf.saveData(dataInstruction, options);
    };

    this.preparse = function(undo, at, multicall){
        var dataInstruction;
        if (this.xmlActionNode) {
            dataInstruction = this.xmlActionNode.getAttribute(undo ? "undo" : "set");
            if (undo && !dataInstruction)
                dataInstruction = this.xmlActionNode.getAttribute("set");
        }

        if (!dataInstruction)
            return this;

        options = apf.extend({
            //undoObj   : this,
            xmlNode   : this.action == "multicall" 
              ? this.args[0].xmlNode
              : this.selNode || this.xmlNode,
            userdata  : apf.isTrue(this.xmlActionNode.getAttribute("ignore-fail")),
            multicall : multicall,
            undo      : undo,
            _pc       : true,
            callback  : function(data, state, extra){
                options._pc = -2;
            }
        }, this.extra);

        
        if (this.timestamp) {
            options.actionstart = this.timestamp;
            options.headers     = {"X-JPF-ActionStart": this.timestamp};
        }
        

        apf.saveData(dataInstruction, options); //@todo please check if at the right time selNode is set
        
        if (options._pc === true)
            options._pc = -1; //if this is set then it overwrites the values set by livemarkup
        
        return this;
    };
};



/**
 * Default actions, that are known to the actiontracker
 * @todo test if the .extra speed impact matters
 * @todo ifdef the undo sections to only be there when the actiontracker is enabled
 * @private
 */
apf.actiontracker.actions = {
    "setTextNode" : function(UndoObj, undo){
        var q = UndoObj.args;

        // Set Text Node
        if (!undo)
            apf.xmldb.setTextNode(q[0], q[1], q[2], UndoObj);
        else //Undo Text Node Setting
            apf.xmldb.setTextNode(q[0], UndoObj.extra.oldValue, q[2]);
    },

    "setAttribute" : function(UndoObj, undo){
        var q = UndoObj.args;

        // Set Attribute
        if (!undo) {
            //Set undo info
            UndoObj.extra.name = q[1];
            UndoObj.extra.oldValue = q[0].getAttribute(q[1]);

            apf.xmldb.setAttribute(q[0], q[1], q[2], q[3], UndoObj);
        }
        // Undo Attribute Setting
        else {
            if (!UndoObj.extra.oldValue)
                apf.xmldb.removeAttribute(q[0], q[1]);
            else
                apf.xmldb.setAttribute(q[0], q[1], UndoObj.extra.oldValue, q[3]);
        }
    },

    "removeAttribute" : function(UndoObj, undo){
        var q = UndoObj.args;

        // Remove Attribute
        if (!undo) {
            // Set undo info
            UndoObj.extra.name = q[1];
            UndoObj.extra.oldValue = q[0].getAttribute(q[1]);

            apf.xmldb.removeAttribute(q[0], q[1], q[2], UndoObj);
        }
        //Undo Attribute Removal
        else
            apf.xmldb.setAttribute(q[0], q[1], UndoObj.extra.oldValue, q[2]);
    },

    /**
     * @deprecated Use "multicall" from now on
     */
    "setAttributes" : function(UndoObj, undo){
        var prop, q = UndoObj.args;

        // Set Attribute
        if (!undo) {
            // Set undo info
            var oldValues = {};
            for (prop in q[1]) {
                oldValues[prop] = q[0].getAttribute(prop);
                q[0].setAttribute(prop, q[1][prop]);
            }
            UndoObj.extra.oldValues = oldValues;

            apf.xmldb.applyChanges("attribute", q[0], UndoObj);
        }
        //Undo Attribute Setting
        else {
            for (prop in UndoObj.oldValues) {
                if (!UndoObj.extra.oldValues[prop])
                    q[0].removeAttribute(prop);
                else
                    q[0].setAttribute(prop, UndoObj.extra.oldValues[prop]);
            }

            apf.xmldb.applyChanges("attribute", q[0], UndoObj);
        }
    },

    "replaceNode" : function(UndoObj, undo){
        var q = UndoObj.args;

        //Set Attribute
        if (!undo)
            apf.xmldb.replaceNode(q[1], q[0], q[2], UndoObj);
        //Undo Attribute Setting
        else
            apf.xmldb.replaceNode(q[0], q[1], q[2], UndoObj);
    },

    "addChildNode" : function(UndoObj, undo){
        var q = UndoObj.args;

        //Add Child Node
        if (!undo)
            apf.xmldb.addChildNode(q[0], q[1], q[2], q[3], UndoObj);
        //Remove Child Node
        else
            apf.xmldb.removeNode(UndoObj.extra.addedNode);
    },

    "appendChild" : function(UndoObj, undo){
        var q = UndoObj.args;

        //Append Child Node
        if (!undo)
            apf.xmldb.appendChild(q[0], q[1], q[2], q[3], q[4], UndoObj);
        //Remove Child Node
        else
            apf.xmldb.removeNode(UndoObj.xmlNode);//q[1]
    },

    "moveNode" : function(UndoObj, undo){
        var q = UndoObj.args;

        //Move Node
        if (!undo)
            apf.xmldb.moveNode(q[0], q[1], q[2], q[3], UndoObj);
        //Move Node to previous position
        else
            apf.xmldb.moveNode(UndoObj.extra.oldParent, q[1],
                UndoObj.extra.beforeNode, q[3]);
    },

    "removeNode" : function(UndoObj, undo){
        var q = UndoObj.args;

        //Remove Node
        if (!undo)
            apf.xmldb.removeNode(q[0], q[1], UndoObj);
        //Append Child Node
        else
            apf.xmldb.appendChild(UndoObj.extra.parent,
                UndoObj.extra.removedNode, UndoObj.extra.beforeNode);
    },

    /**
     * @deprecated Use "multicall" from now on
     */
    "removeNodeList" : function(UndoObj, undo){
        if (undo) {
            var d = UndoObj.extra.removeList;
            for (var i = d.length - 1; i >= 0; i--) {
                apf.xmldb.appendChild(d[i].pNode,
                    d[i].removedNode, d[i].beforeNode);
            }
        }
        else
            apf.xmldb.removeNodeList(UndoObj.args, UndoObj);
    },

    "setUndoObject" : function(UndoObj, undo){
        var q = UndoObj.args;
        UndoObj.xmlNode = q[0];
    },

    "group" : function(UndoObj, undo, at){
        if (!UndoObj.$stackDone) {
            var done = UndoObj.args[0];
            UndoObj.$stackDone = done;
            UndoObj.$stackUndone = [];
        }

        at[undo ? "undo" : "redo"](UndoObj.$stackDone.length, false,
            UndoObj.$stackDone, UndoObj.$stackUndone);
    },
    
    "setProperty" : function(UndoObj, undo){
        var q = UndoObj.args;//amlNode, name, value

        if (!undo) {
            UndoObj.extra.oldValue = q[0][q[1]];
            q[0].setProperty(q[1], q[2], q[3], q[4]);
        }
        // Undo 
        else {
            q[0].setProperty(q[1], UndoObj.extra.oldValue);
        }
    },
    
    "setValueByXpath" : function(UndoObj, undo){
        var q = UndoObj.args;//xmlNode, value, xpath
        // Setting NodeValue and creating the node if it doesnt exist
        if (!undo) {
            if (UndoObj.extra.newNode) {
                apf.xmldb.appendChild(UndoObj.extra.parentNode, UndoObj.extra.newNode);
            }
            else {
                var newNodes = [];
                apf.setNodeValue(q[0], q[1], true, {
                    undoObj  : UndoObj,
                    xpath    : q[2],
                    newNodes : newNodes,
                    forceNew : q[3]
                });
    
                UndoObj.extra.newNode = newNodes[0];
            }
        }
        // Undo Setting NodeValue
        else {
            if (UndoObj.extra.newNode) {
                UndoObj.extra.parentNode = UndoObj.extra.newNode.parentNode;
                apf.xmldb.removeNode(UndoObj.extra.newNode);
            }
            else
                apf.setNodeValue(UndoObj.extra.appliedNode, UndoObj.extra.oldValue, true);
        }
    },

    //@todo please change .func to .action for constency reasons
    "multicall" : function(UndoObj, undo, at){
        var q = UndoObj.args;

        var dUpdate = apf.xmldb.delayUpdate;
        apf.xmldb.delayUpdate = true;

        // Set Calls
        if (!undo) {
            for(var i = 0; i < q.length; i++) {
                if (!q[i].extra)
                    q[i].extra = {};
                
                if (q[0].rsbModel)
                    q[i].rsbQueue = q[0].rsbQueue;
                
                apf.actiontracker.actions[q[i].func](q[i], false, at);
            }
            
            if (q[0].rsbModel) {
                UndoObj.rsbModel = q[0].rsbModel;
                UndoObj.rsbQueue = q[0].rsbQueue;
            }
            
        }
        // Undo Calls
        else {
            for (var i = q.length - 1; i >= 0; i--)
                apf.actiontracker.actions[q[i].func](q[i], true, at);
        }

        apf.xmldb.delayUpdate = dUpdate;

        //if (!dUpdate)
            //apf.xmldb.notifyQueued();
    },

    /**
     * @deprecated Use "multicall" from now on
     */
    "addRemoveNodes" : function(UndoObj, undo){
        var q = UndoObj.args;

        // Set Text Node
        if (!undo) {
            // Add
            for (var i = 0; i < q[1].length; i++){
                apf.xmldb.appendChild(q[0], q[1][i],
                    null, null, null, UndoObj);
            }

            // Remove
            for (var i = 0; i < q[2].length; i++)
                apf.xmldb.removeNode(q[2][i], null, UndoObj);
        }
        // Undo Text Node Setting
        else {
            // Add
            for (var i = 0; i < q[2].length; i++)
                apf.xmldb.appendChild(q[0], q[2][i]);

            // Remove
            for (var i = 0; i < q[1].length; i++)
                apf.xmldb.removeNode(q[1][i]);
        }
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/elements/param.js)SIZE(1681)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * element specifying an argument of a method in an rpc element.
 * @attribute {String}  name             the argument name.
 * @attribute {String}  [value]          the value of the argument.
 * @attribute {String}  [default]        the default value of the argument. If
 *                                       no value is specified when this function
 *                                       is called, the default value is used.
 */
apf.param = function(struct, tagName){
    this.$init(tagName || "param", apf.NODE_HIDDEN, struct);
};

apf.param.prototype = new apf.AmlElement();
apf.param.prototype.$parsePrio = "002";
apf.aml.setElement("variable", apf.param); //backwards compatibility
apf.aml.setElement("param", apf.param);


/*FILEHEAD(/var/lib/platform/source/trunk/elements/spinner.js)SIZE(15593)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/** 
 * This element is used to choosing number by plus/minus buttons.
 * When plus button is clicked longer, number growing up faster. The same
 * situation is for minus button. It's possible to increment and decrement
 * value by moving mouse cursor up or down with clicked input. Max and
 * min attributes define range with allowed values.
 * 
 * Example:
 * Spinner element with start value equal 6 and allowed values from range
 * (-100, 200)
 * <code>
 *  <a:spinner value="6" min="-99" max="199" width="200"></a:spinner>
 * </code>
 * 
 * Example:
 * Sets the value based on data loaded into this component.
 * <code>
 *  <a:model id="mdlSpinner">
 *      <data value="56"></data>
 *  </a:model>
 *  <a:spinner value="[@value]" model="mdlSpinner" />
 * </code>

 * Example:
 * Is showing usage of model in spinner connected with textbox
 * <code>
 *  <a:model id="mdlTest">
 *      <overview page="1" pages="50" />
 *  </a:model>
 *  <a:spinner 
 *    id      = "spinner" 
 *    min     = "0" 
 *    max     = "[@pages]" 
 *    model   = "mdlTest" 
 *    value   = "[@page]" 
 *    caption = "[@page] of [@pages]">
 *  </a:spinner>
 *  <a:textbox value="{spinner.caption}"></a:textbox>
 * </code>
 * 
 * @attribute {Number}   max       maximal allowed value, default is 64000
 * @attribute {Number}   min       minimal allowed value, default is -64000
 * @attribute {Number}   value     actual value displayed in component
 * 
 * @classDescription     This class creates a new spinner
 * @return {Spinner}     Returns a new spinner
 *
 * @author      
 * @version     %I%, %G%
 * 
 * @inherits apf.StandardBinding
 * @inherits apf.DataAction
 * @inherits apf.XForms
 *
 * @binding value  Determines the way the value for the element is retrieved 
 * from the bound data.
 */
apf.spinner = function(struct, tagName){
    this.$init(tagName || "spinner", apf.NODE_VISIBLE, struct);
    
    this.max     = 64000;
    this.min     = -64000;
    this.focused = false;
    this.value   = 0;
};

(function() {
    this.implement(
        
        apf.DataAction
        
        
    );

    this.$supportedProperties.push("width", "value", "max", "min", "caption");

    this.$propHandlers["value"] = function(value) {
        value = parseInt(value) || 0;
        
        this.value = this.oInput.value = (value > this.max
            ? this.max
            : (value < this.min
                ? this.min
                : value));
    };

    this.$propHandlers["min"] = function(value) {
        if (!(value = parseInt(value))) return;
        this.min = value;
        if (value > this.value)
            this.change(value);
    };

    this.$propHandlers["max"] = function(value) {
        if (!(value = parseInt(value))) return;
        this.max = value;

        if (value < this.value)
            this.change(value);
    };

    /* ********************************************************************
     PUBLIC METHODS
     *********************************************************************/

    

    /**
     * Sets the value of this element. This should be one of the values
     * specified in the values attribute.
     * @param {String} value the new value of this element
     */
    this.setValue = function(value) {
       this.setProperty("value", value, false, true);
    };

    /**
     * Returns the current value of this element.
     * @return {String}
     */
    this.getValue = function() {
        return this.value;
    };
    
    

    this.$enable = function() {
        this.oInput.disabled = false;
        this.$setStyleClass(this.oInput, "", ["inputDisabled"]);
    };

    this.$disable = function() {
        this.oInput.disabled = true;
        this.$setStyleClass(this.oInput, "inputDisabled");
    };

    this.$focus = function(e) {
        if (!this.$ext || this.disabled || this.focused)
            return;

        
        if (apf.hasFocusBug)
            apf.sanitizeTextbox(this.oInput);
        

        this.focused = true;
        this.$setStyleClass(this.oInput, "focus");
        this.$setStyleClass(this.$buttonPlus, "plusFocus");
        this.$setStyleClass(this.$buttonMinus, "minusFocus");
        
        if (this.oLeft)
            this.$setStyleClass(this.oLeft, "leftFocus");
    };

    this.$blur = function(e) {
        if (!this.$ext && !this.focused)
            return;

        this.$setStyleClass(this.oInput, "", ["focus"]);
        this.$setStyleClass(this.$buttonPlus, "", ["plusFocus"]);
        this.$setStyleClass(this.$buttonMinus, "", ["minusFocus"]);
        
        if (this.oLeft)
            this.$setStyleClass(this.oLeft, "" ["leftFocus"]);
        
        this.focused = false;
    };

    /* ***********************
     Keyboard Support
     ************************/
    
    this.addEventListener("keydown", function(e) {
        var key = e.keyCode,

        keyAccess = (key < 8 || (key > 8 && key < 37 && key !== 12)
            || (key > 40 && key < 46) || (key > 46 && key < 48)
            || (key > 57 && key < 96) || (key > 105 && key < 109)
            || (key > 109 && key !== 189));

       if (keyAccess)
           return false;

    }, true);

    this.addEventListener("keyup", function(e) {
        this.setValue(this.oInput.value);
    }, true);
    
    
    /**
     * @event click     Fires when the user presses a mousebutton while over this element and then let's the mousebutton go. 
     * @event mouseup   Fires when the user lets go of a mousebutton while over this element. 
     * @event mousedown Fires when the user presses a mousebutton while over this element. 
     */
    this.$draw = function() {
        var _self = this;

        //Build Main Skin
        this.$ext = this.$getExternal(null, null, function(oExt) {
            oExt.setAttribute("onmousedown",
                'this.host.dispatchEvent("mousedown", {htmlEvent : event});');
            oExt.setAttribute("onmouseup",
                'this.host.dispatchEvent("mouseup", {htmlEvent : event});');
            oExt.setAttribute("onclick",
                'this.host.dispatchEvent("click", {htmlEvent : event});');
        });

        this.$int         = this.$getLayoutNode("main", "container",   this.$ext);
        this.oInput       = this.$getLayoutNode("main", "input",       this.$ext);
        this.$buttonPlus  = this.$getLayoutNode("main", "buttonplus",  this.$ext);
        this.$buttonMinus = this.$getLayoutNode("main", "buttonminus", this.$ext);
        this.oLeft = this.$getLayoutNode("main", "left", this.$ext);

        
        apf.sanitizeTextbox(this.oInput);
        

        var timer,
            doc = (!document.compatMode || document.compatMode == 'CSS1Compat')
                ? document.html : document.body,
            z   = 0;

        /* Setting start value */
        this.oInput.value = this.value;

        this.oInput.onmousedown = function(e) {
            if (_self.disabled)
                return;
            
            e = e || window.event;

            clearTimeout(timer);

            var newval,
                value = parseInt(this.value) || 0,
                step  = 0,
                cy    = e.clientY,
                ot    = _self.$int.offsetTop, ol = _self.$int.offsetLeft,
                ow    = _self.$int.offsetWidth, oh = _self.$int.offsetHeight,
                func  = function() {
                    clearTimeout(timer);
                    timer = $setTimeout(func, 10);
                    if (!step)
                        return;

                    newval = value + step;
                    if (newval <= _self.max && newval >= _self.min) {
                        value += step;
                        _self.oInput.value = Math.round(value);
                    }
                    else {
                        _self.oInput.value = step < 0
                            ? _self.min
                            : _self.max;
                    }
                };
            func();

            function calcStep(e) {
                e = e || window.event;
                var x = e.pageX || e.clientX + (doc ? doc.scrollLeft : 0),
                    y = e.pageY || e.clientY + (doc ? doc.scrollTop  : 0),
                    nrOfPixels = cy - y;

                if ((y > ot && x > ol) && (y < ot + oh && x < ol + ow)) {
                    step = 0;
                    return;
                }

                step = Math.pow(Math.min(200, Math.abs(nrOfPixels)) / 10, 2) / 10;
                if (nrOfPixels < 0)
                    step = -1 * step;
            }
            
            document.onmousemove = calcStep;

            document.onmouseup = function(e) {
                clearTimeout(timer);

                var value = parseInt(_self.oInput.value);

                if (value != _self.value)
                    _self.change(value);
                document.onmousemove = document.onmouseup = null;
            };
        };

        /* Fix for mousedown for IE */
        var buttonDown = false;
        this.$buttonPlus.onmousedown = function(e) {
            if (_self.disabled)
                return;
            
            e = e || window.event;
            buttonDown = true;

            var value = (parseInt(_self.oInput.value) || 0) + 1,
                func  = function() {
                    clearTimeout(timer);
                    timer = $setTimeout(func, 50);
                    z++;
                    value += Math.pow(Math.min(200, z) / 10, 2) / 10;
                    value = Math.round(value);

                    _self.oInput.value = value <= _self.max
                        ? value
                        : _self.max;
                };

            apf.setStyleClass(this, "plusDown", ["plusHover"]);

            func();
        };

        this.$buttonMinus.onmousedown = function(e) {
            if (_self.disabled)
                return;
            
            e = e || window.event;
            buttonDown = true;

            var value = (parseInt(_self.oInput.value) || 0) - 1,
                func  = function() {
                    clearTimeout(timer);
                    timer = $setTimeout(func, 50);
                    z++;
                    value -= Math.pow(Math.min(200, z) / 10, 2) / 10;
                    value = Math.round(value);

                    _self.oInput.value = value >= _self.min
                        ? value
                        : _self.min;
                };

            apf.setStyleClass(this, "minusDown", ["minusHover"]);

            func();
        };

        this.$buttonMinus.onmouseout = function(e) {
            if (_self.disabled)
                return;
            
            clearTimeout(timer);
            z = 0;

            var value = parseInt(_self.oInput.value);

            if (value != _self.value)
                _self.change(value);

            apf.setStyleClass(this, "", ["minusHover"]);

            if (!_self.focused)
               _self.$blur(e);
        };

        this.$buttonPlus.onmouseout  = function(e) {
            if (_self.disabled)
                return;
            
            clearTimeout(timer);
            z = 0;

            var value = parseInt(_self.oInput.value);

            if (value != _self.value)
                _self.change(value);

            apf.setStyleClass(this, "", ["plusHover"]);

            if (!_self.focused)
               _self.$blur(e);
        };

        this.$buttonMinus.onmouseover = function(e) {
            if (_self.disabled)
                return;
                
            apf.setStyleClass(this, "minusHover");
        };

        this.$buttonPlus.onmouseover  = function(e) {
            if (_self.disabled)
                return;
                
            apf.setStyleClass(this, "plusHover");
        };

        this.$buttonPlus.onmouseup = function(e) {
            if (_self.disabled)
                return;
            
            e = e || event;
            e.cancelBubble = true;

            apf.setStyleClass(this, "plusHover", ["plusDown"]);

            clearTimeout(timer);
            z = 0;

            var value = parseInt(_self.oInput.value);

            if (!buttonDown) {
                value++;
                _self.oInput.value = value;
            }
            else {
                buttonDown = false;
            }

            if (value != _self.value)
                _self.change(value);
        };

        this.$buttonMinus.onmouseup = function(e) {
            if (_self.disabled)
                return;
            
            e = e || event;
            e.cancelBubble = true;

            apf.setStyleClass(this, "minusHover", ["minusDown"]);

            clearTimeout(timer);
            z = 0;

            var value = parseInt(_self.oInput.value);

            if (!buttonDown) {
                value--;
                _self.oInput.value = value;
            }
            else {
                buttonDown = false;
            }


            if (value != _self.value)
                _self.change(value);
        };

        this.oInput.onselectstart = function(e) {
            e = e || event;
            e.cancelBubble = true;
        };

        this.oInput.host = this;
    };

    this.$destroy = function() {
        this.oInput.onkeypress =
        this.oInput.onmousedown =
        this.oInput.onkeydown =
        this.oInput.onkeyup =
        this.oInput.onselectstart =
        this.$buttonPlus.onmouseover =
        this.$buttonPlus.onmouseout =
        this.$buttonPlus.onmousedown =
        this.$buttonPlus.onmouseup =
        this.$buttonMinus.onmouseover =
        this.$buttonMinus.onmouseout =
        this.$buttonMinus.onmousedown =
        this.$buttonMinus.onmouseup = null;
    };

}).call(apf.spinner.prototype = new apf.StandardBinding());


apf.aml.setElement("spinner", apf.spinner);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/datagrid.js)SIZE(49568)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */







/**
 * Element providing a sortable, selectable grid containing scrollable 
 * information. Grid columns can be reordered and resized.
 * Example:
 * This example shows a datagrid width several columns mixing percentage and
 * fixed size columns.
 * <code>
 *  <a:model id="mdlNews">
 *      <data>
 *          <news title="text 1" subtitle="text 11" date="2009-11-18"></news>
 *          <news title="text 2" subtitle="text 21" date="2009-11-19"></news>
 *          <news title="text 3" subtitle="text 31" date="2009-11-20"></news>
 *      </data>
 *  </a:model>
 *  <a:datagrid model="mdlNews" options="move|size">
 *      <a:each match="[news]">
 *          <a:column caption="Icon" type="icon" width="40" value="newspaper.png" />
 *          <a:column caption="Date" value="[@date]" width="70" />
 *          <a:column caption="Title" width="180" value="[@title]" />
 *          <a:column caption="Subtitle" value="[@subtitle]" width="100" />
 *      </a:each>
 *  </a:datagrid>
 * </code>
 * Example:
 * This example shows a propedit (property editor) component. The propedit 
 * component is an alias for the datagrid. It has a different skin and different
 * defaults. See {@link element.datagrid.attribute.template the template attribute}.
 * <code>
 *  <a:propedit template="mdlTemplate" />
 * </code>
 *
 * @constructor
 * @define datagrid, spreadsheet, propedit
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @inherits apf.MultiSelect
 * @inherits apf.Cache   
 * @inherits apf.StandardBinding
 * @inherits apf.Rename
 *
 * @event beforelookup  Fires before the value lookup UI is shown.
 *   cancelable: Prevents the lookup value from being processed.
 *   object:
 *   {String}      value     the value that has been found.
 *   {XMLElement}  xmlNode   the selected node.
 *   {HTMLElement} htmlNode  the node that is updated.
 * @event afterlookup   Fires after a lookup value is processed.
 *   object:
 *   {Mixed}       value     the value that has been found.
 *   {XMLElement}  xmlNode   the selected node.
 *   {HTMLElement} htmlNode  the node that is updated.
 *   {Nodeset}     nodes     ???.
 * @event multiedit     Fires before a multiedit request is done. Used to display the UI.
 *   object:
 *   {XMLElement} xmlNode   the selected node.
 *   {XMLElement} dataNode  the {@link term.datanode data node}.
 *   Example:
 *   <code>
 *      <a:propedit 
 *        lookupaml      = "tmpLookup"
 *        onbeforelookup = "clearLookup(event.xmlNode, event.value)" 
 *        onafterlookup  = "loadLookup(event.xmlNode, event.value, this)"
 *        onmultiedit    = "loadMultiEdit(event, this)">
 *          <a:bindings>
 *              <a:template select="self::product" value="mdlProps:product" />
 *          </bindings>
 *      </propedit>
 *
 *      <a:template id="tmpLookup" autoinit="true">
 *          <a:list id="lstLookup" skin="mnulist" style="width:auto;margin-bottom:3px" 
 *            model="mdlLookup" empty-message="No results" height="{lstLookup.length * 20}"
 *            autoselect="false">
 *              <a:bindings>
 *                  <a:caption select="self::picture"><![CDATA[
 *                      {name} | {description}
 *                  ]]></caption>
 *                  <!-- use @descfield -->
 *                  <a:caption><![CDATA[[
 *                      var field = n.parentNode.getAttribute("descfield");
 *                      %(value(field) || "[Geen Naam]");
 *                  ]]]></caption>
 *                  <a:icon select="self::product" value="package_green.png" />
 *                  <a:icon value="table.png" />
 *                  <a:each select="node()[local-name()]" />
 *              </bindings>
 *              <a:actions />
 *          </list>
 *          
 *          <a:toolbar>
 *              <a:bar>
 *                  <a:button id="btnLkpPrev" disabled="true" 
 *                      onclick="...">&lt; Previous</button>
 *                  <a:spinner id="spnLookup" width="40" 
 *                      min="1" max="1" onafterchange="..." />
 *                  <a:button id="btnLkpNext" disabled="true" 
 *                      onclick="...">Next &gt;</button>
 *              </bar>
 *          </toolbar>
 *      </template>
 *   </code>
 * @binding caption   Determines the caption of a node.
 * @binding css       Determines a css class for a node.
 * Example:
 * In this example a node is bold when the folder contains unread messages:
 * <code>
 *  <a:tree model="messages.xml">
 *      <a:bindings>
 *          <a:caption match="[@caption]" />
 *          <a:css match="[folder/message[@unread]]" value="highlighUnread" />
 *          <a:icon match="[@icon]" />
 *          <a:icon match="[folder]" value="icoDir.png" />
 *          <a:each match="[folder|message]" />
 *      </a:bindings>
 *  </a:tree>
 * </code>
 * @binding invalidmsg  Determines the error message that is shown when a cell is not valid.
 * @binding description Determines the text that is displayed under the expanded row.
 * @binding template    Determines the template that sets the column definition (for the datagrid) or property definition (for property editor).

 */
apf.spreadsheet = function(struct, tagName){
    this.$init(tagName || "spreadsheet", apf.NODE_VISIBLE, struct);
};

apf.datagrid    = function(struct, tagName){
    this.$init(tagName || "datagrid", apf.NODE_VISIBLE, struct);
};

(function(){
    this.$init(function(){
        this.$headings       = [],
        this.$cssRules       = []; //@todo Needs to be reset;
        this.$nodes          = [];
        this.$lastOpened     = {};
        
        this.$editors        = {};
        
        
        this.dynCssClasses = [];
        
    });
    
    this.implement(
        
        //apf.Rename
        
        
        //apf.DragDrop,
        
        
        apf.Cache,  
        
        
        apf.DataAction
        
    );
    
    this.$focussable     = true; // This object can get the focus
    this.multiselect     = true; // Enable MultiSelect
    this.bufferselect    = false;
    
    this.startClosed     = true;
    this.$animType       = apf.tween.NORMAL;
    this.$animSteps      = 3;
    this.$animSpeed      = 20;

    this.$curBtn         = null;
    this.$useTable       = false;
    //this.$lastcell       = null;
    //this.$lastcol        = 0;
    //this.$lastrow        = null;
    //this.$lastSorted     = null;
    //this.$lastCaptionCol = null;
    
    this.$widthdiff      = 0;
    this.$defaultwidth   = 0;
    this.$useiframe      = 0;
    
    
    this.$renameStartCollapse = false;
    
    
    this.$init(function() {
        this.addEventListener("keydown", keyHandler, true);
    });

    /**
     * @attribute {Boolean} iframe     whether this element is rendered inside an iframe. This is only supported for IE. Default is false for datagrid and true for spreadsheet and propedit.
     */
    this.$booleanProperties["iframe"]     = true;

    /**
     * This method imports a stylesheet defined in a multidimensional array 
     * @param {Array}    def Required Multidimensional array specifying 
     * @param {Object}    win Optional Reference to a window
     * @method
     * @deprecated
     */    
    function importStylesheet(def, win){
        for (var i = 0; i < def.length; i++) {
            if (!def[i][1]) continue;
            
            if (apf.isIE)
                (win || window).document.styleSheets[0].addRule(def[i][0],
                    def[i][1]);
            else
                (win || window).document.styleSheets[0].insertRule(def[i][0]
                    + " {" + def[i][1] + "}", 0);
        }
    }
    
    function scrollIntoView(){
        var Q = (this.current || this.$selected),
            o = this.$int;
        o.scrollTop = (Q.offsetTop) - 21;
    }

    /**** Keyboard Support ****/
    
    
    function keyHandler(e){
        var key      = e.keyCode,
            ctrlKey  = e.ctrlKey,
            shiftKey = e.shiftKey,
            selHtml  = this.$selected || this.$caret;
        
        if (!e.force && (!selHtml || this.renaming)) //@todo how about allowdeselect?
            return;

        var selXml = this.caret || this.selected,
            oInt   = this.$useiframe ? this.oDoc.documentElement : this.$int,
            margin, node, hasScroll, hasScrollX, hasScrollY, items, lines;

        switch (key) {
            case 13:
                if (this.$tempsel)
                    this.$selectTemp();
            
                this.choose(selHtml);
                break;
            case 32:
                if (ctrlKey || !this.isSelected(this.caret))
                    this.select(this.caret, true);
                return false;
            case 109:
            case 46:
                //DELETE
                if (this.disableremove) 
                    return;
                    
                if (this.celledit) {
                    this.rename(this.caret || this.selected, "");
                    return;
                }
            
                if (this.$tempsel)
                    this.$selectTemp();
            
                this.remove(this.mode ? this.caret : null); //this.mode != "check"
                break;
            case 36:
                //HOME
                this.$setTempSelected (this.getFirstTraverseNode(), false, shiftKey);
                this.$int.scrollTop = 0;
                return false;
            case 35:
                //END
                this.$setTempSelected (this.getLastTraverseNode(), false, shiftKey);
                this.$int.scrollTop = this.$int.scrollHeight;
                return false;
            case 107:
                //+
                if (this.more)
                    this.startMore();
                break;
            case 37:
                //LEFT
                if (this.$tempsel)
                    this.$selectTemp();
                    
                if (this.cellselect) {
                    if (this.$lastcell) {
                        if (this.$lastcell.previousSibling) {
                            this.selectCell({target:this.$lastcell.previousSibling},
                                this.$selected);
                        }
                    }
                    else {
                        this.selectCell({target:this.$selected.firstChild}, 
                            this.$selected);
                    }
                }
                else if (this.$withContainer)
                    this.slideToggle(this.$caret || this.$selected, 2)
                return false;
            case 107:
            case 39:
                //RIGHT
                if (this.$tempsel)
                    this.$selectTemp();
                    
                if (this.cellselect) {
                    if (this.$lastcell) {
                        if (this.$lastcell.nextSibling) {
                            this.selectCell({target:this.$lastcell.nextSibling},
                                this.$selected);
                        }
                    }
                    else {
                        this.selectCell({target:this.$selected.firstChild}, 
                            this.$selected);
                    }
                }
                else if (this.$withContainer)
                    this.slideToggle(this.$caret || this.$selected, 1)
                    
                return false;
            case 38:
                //UP
                if (!selXml && !this.$tempsel) 
                    return false;
                    
                node = this.$tempsel 
                    ? apf.xmldb.getNode(this.$tempsel) 
                    : selXml;

                margin    = apf.getBox(apf.getStyle(selHtml, "margin"));
                hasScroll = oInt.scrollHeight > oInt.offsetHeight;
                items     = Math.floor((oInt.offsetWidth
                    - (hasScroll ? 15 : 0)) / (selHtml.offsetWidth
                    + margin[1] + margin[3]));
                
                node = this.getNextTraverseSelected(node, false, items);
                if (node)
                    this.$setTempSelected (node, ctrlKey, shiftKey);
                else
                    return false;

                selHtml = apf.xmldb.findHtmlNode(node, this);
                if (selHtml.offsetTop <= oInt.scrollTop) {
                    oInt.scrollTop = (Array.prototype.indexOf.call(this.getTraverseNodes(), node) < items
                      ? 0
                      : selHtml.offsetTop - margin[0])
                        - parseInt(apf.getStyle(oInt, apf.isIE 
                            ? "paddingTop" 
                            : "padding-top"));
                }
                return false;
            case 40:
                //DOWN
                if (!selXml && !this.$tempsel) 
                    return false;
                    
                node = this.$tempsel 
                    ? apf.xmldb.getNode(this.$tempsel) 
                    : selXml;
                
                margin    = apf.getBox(apf.getStyle(selHtml, "margin"));
                hasScroll = oInt.scrollHeight > oInt.offsetHeight;
                items     = Math.floor((oInt.offsetWidth
                    - (hasScroll ? 15 : 0)) / (selHtml.offsetWidth
                    + margin[1] + margin[3]));
                
                node = this.getNextTraverseSelected(node, true, items);
                if (node)
                   this.$setTempSelected (node, ctrlKey, shiftKey);
                else
                    return false;
                
                selHtml = apf.xmldb.findHtmlNode(node, this);
                if (selHtml.offsetTop + selHtml.offsetHeight
                  > oInt.scrollTop + oInt.offsetHeight) // - (hasScroll ? 10 : 0)
                    oInt.scrollTop = selHtml.offsetTop
                        - oInt.offsetHeight + selHtml.offsetHeight
                        + margin[0]; //+ (hasScroll ? 10 : 0)
                
                return false;
            case 33:
                //PGUP
                if (!selXml && !this.$tempsel) 
                    return false;
                    
                node = this.$tempsel 
                    ? apf.xmldb.getNode(this.$tempsel) 
                    : selXml;
                
                margin     = apf.getBox(apf.getStyle(selHtml, "margin"));
                hasScrollY = oInt.scrollHeight > oInt.offsetHeight;
                hasScrollX = oInt.scrollWidth > oInt.offsetWidth;
                items      = Math.floor((oInt.offsetWidth
                    - (hasScrollY ? 15 : 0)) / (selHtml.offsetWidth
                    + margin[1] + margin[3])) || 1;
                lines      = Math.floor((oInt.offsetHeight
                    - (hasScrollX ? 15 : 0)) / (selHtml.offsetHeight
                    + margin[0] + margin[2]));
                
                node = this.getNextTraverseSelected(node, false, items * lines);
                if (!node)
                    node = this.getFirstTraverseNode();
                if (node)
                   this.$setTempSelected (node, ctrlKey, shiftKey);
                else
                    return false;
                
                selHtml = apf.xmldb.findHtmlNode(node, this);
                if (selHtml.offsetTop < oInt.scrollTop) {
                    oInt.scrollTop = (Array.prototype.indexOf.call(this.getTraverseNodes(), node) < items
                      ? 0
                      : selHtml.offsetTop - margin[0]) 
                        - parseInt(apf.getStyle(oInt, apf.isIE 
                            ? "paddingTop" 
                            : "padding-top"));
                }
                return false;
            case 34:
                //PGDN
                if (!selXml && !this.$tempsel) 
                    return false;

                node = this.$tempsel 
                    ? apf.xmldb.getNode(this.$tempsel) 
                    : selXml;
                
                margin     = apf.getBox(apf.getStyle(selHtml, "margin"));
                hasScrollY = oInt.scrollHeight > oInt.offsetHeight;
                hasScrollX = oInt.scrollWidth > oInt.offsetWidth;
                items      = Math.floor((oInt.offsetWidth - (hasScrollY ? 15 : 0))
                    / (selHtml.offsetWidth + margin[1] + margin[3])) || 1;
                lines      = Math.floor((oInt.offsetHeight - (hasScrollX ? 15 : 0))
                    / (selHtml.offsetHeight + margin[0] + margin[2]));
                
                node = this.getNextTraverseSelected(selXml, true, items * lines);
                if (!node)
                    node = this.getLastTraverseNode();
                if (node)
                   this.$setTempSelected (node, ctrlKey, shiftKey);
                else
                    return false;
                
                selHtml = apf.xmldb.findHtmlNode(node, this);
                if (selHtml.offsetTop + selHtml.offsetHeight
                  > oInt.scrollTop + oInt.offsetHeight) // - (hasScrollY ? 10 : 0)
                    oInt.scrollTop = selHtml.offsetTop
                        - oInt.offsetHeight + selHtml.offsetHeight
                        + margin[0]; //+ 10 + (hasScrollY ? 10 : 0)
                return false;
            default:
                if (this.celledit) {
                    if (!ctrlKey && !e.altKey && (key > 46 && key < 112 || key > 123))
                        this.startRename(null, true);
                    return;
                }
                else if (key == 65 && ctrlKey) {
                    this.selectAll();
                    return false;
                } 
                //@todo make this work with the sorted column
                else if (this.caption || (this.bindingRules || {})["caption"]) {
                    if (!this.xmlRoot) return;
                    
                    //this should move to a onkeypress based function
                    if (!this.lookup || new Date().getTime()
                      - this.lookup.date.getTime() > 300)
                        this.lookup = {
                            str  : "",
                            date : new Date()
                        };
                    
                    this.lookup.str += String.fromCharCode(key);
    
                    var nodes = this.getTraverseNodes(); //@todo start at current indicator
                    for (var v, i = 0; i < nodes.length; i++) {
                        v = this.$applyBindRule("caption", nodes[i]);
                        if (v && v.substr(0, this.lookup.str.length)
                          .toUpperCase() == this.lookup.str) {
                            
                            if (!this.isSelected(nodes[i])) {
                                if (this.mode == "check")
                                    this.setCaret(nodes[i]);
                                else
                                    this.select(nodes[i]);
                            }
                            
                            if (selHtml)
                                this.$int.scrollTop = selHtml.offsetTop
                                    - (this.$int.offsetHeight
                                    - selHtml.offsetHeight) / 2;
                            return;
                        }
                    }
                    return;
                }
                break;
        };
        
        this.lookup = null;
        //return false;
    }
    
    
    
    /**** Focus ****/
    // Too slow for IE
    
    this.$focus = function(){
        if (!this.$ext || (apf.isIE && this.$useiframe && this.cssfix)) //@todo fix this by fixing focussing for this component
            return;

        this.$setStyleClass(this.oFocus || this.$ext, this.$baseCSSname + "Focus");
        
        if (this.oDoc)
            this.$setStyleClass(this.oDoc.documentElement, this.$baseCSSname + "Focus");
    };

    this.$blur = function(){
        
        if (this.renaming)
            this.stopRename(null, true);
        

        //@todo fix this by fixing focussing for this component
        if (!this.$ext || (apf.isIE && this.$useiframe && this.cssfix))
            return;

        this.$setStyleClass(this.oFocus || this.$ext, "", [this.$baseCSSname + "Focus"]);
        
        if (this.oDoc)
            this.$setStyleClass(this.oDoc.documentElement, "", [this.$baseCSSname + "Focus"]);
    };
    
    /**** Private methods ****/
    
    this.$calcSelectRange = function(xmlStartNode, xmlEndNode){
        var r     = [],
            nodes = this.hasFeature(apf.__VIRTUALVIEWPORT__)
                ? this.xmlRoot.selectNodes(this.each)
                : this.getTraverseNodes(),
            f, i;
        for(f = false, i = 0; i < nodes.length; i++) {
            if (nodes[i] == xmlStartNode)
                f = true;
            if (f)
                r.push(nodes[i]);
            if (nodes[i] == xmlEndNode)
                f = false;
        }
        
        if (!r.length || f) {
            r = [];
            for (f = false, i = nodes.length - 1; i >= 0; i--) {
                if (nodes[i] == xmlStartNode)
                    f = true;
                if (f)
                    r.push(nodes[i]);
                if (nodes[i] == xmlEndNode)
                    f = false;
            }
        }
        
        return r;
    };
    
    /**** Sliding functions ****/
    
    /**
     * @private
     */
    this.slideToggle = function(htmlNode, force){
        if (this.noCollapse) 
            return;
        
        //var id = htmlNode.getAttribute(apf.xmldb.htmlIdTag); // unused?
        var container = htmlNode.nextSibling;

        if (apf.getStyle(container, "display") == "block") {
            if (force == 1) return;
            htmlNode.className = htmlNode.className.replace(/min/, "plus");
            this.slideClose(container, apf.xmldb.getNode(htmlNode));
        }
        else {
            if (force == 2) return;
            htmlNode.className = htmlNode.className.replace(/plus/, "min");
            this.slideOpen(container, apf.xmldb.getNode(htmlNode));
        }
    };
    
    /**
     * @private
     */
    this.slideOpen = function(container, xmlNode){
        var htmlNode = apf.xmldb.findHtmlNode(xmlNode, this);
        if (!container)
            container = htmlNode.nextSibling;

        if (this.singleopen) {
            var pNode = this.getTraverseParent(xmlNode),
                p     = (pNode || this.xmlRoot).getAttribute(apf.xmldb.xmlIdTag);
            if (this.$lastOpened[p] && this.$lastOpened[p][1] != xmlNode
              && this.getTraverseParent(this.$lastOpened[p][1]) == pNode)
                this.slideToggle(this.$lastOpened[p][0], 2);//lastOpened[p][1]);
            this.$lastOpened[p] = [htmlNode, xmlNode];
        }
        
        container.style.display = "block";

        var _self = this;

        apf.tween.single(container, {
            type    : 'scrollheight', 
            from    : 0, 
            to      : container.scrollHeight, 
            anim    : this.$animType,
            steps   : this.$animSteps,
            interval: this.$animSpeed,
            onfinish: function(container){
                if (xmlNode && _self.$hasLoadStatus(xmlNode, "potential")) {
                    $setTimeout(function(){
                        _self.$extend(xmlNode, container);
                    });
                    container.style.height = "auto";
                }
                else {
                    //container.style.overflow = "visible";
                    container.style.height = "auto";
                }
            }
        });
    };

    /**
     * @private
     */
    this.slideClose = function(container, xmlNode){
        if (this.noCollapse) return;
        
        if (this.singleopen) {
            var p = (this.getTraverseParent(xmlNode) || this.xmlRoot)
                .getAttribute(apf.xmldb.xmlIdTag);
            this.$lastOpened[p] = null;
        }
        
        container.style.height   = container.offsetHeight;
        container.style.overflow = "hidden";

        apf.tween.single(container, {
            type    : 'scrollheight', 
            from    : container.scrollHeight, 
            to      : 0, 
            anim    : this.$animType,
            steps   : this.$animSteps,
            interval: this.$animSpeed,
            onfinish: function(container, data){
               container.style.display = "none";
            }
        });
    };
    
    this.$findContainer = function(htmlNode) {
        var node = htmlNode.nextSibling;
        if (!node)
            return htmlNode;
        return node.nodeType == 1 ? node : node.nextSibling;
    };
    
    /**** Databinding ****/
    
    this.addEventListener("bindingsload", this.$loaddatabinding = function(e){
        var rules = e.bindings["column"];
        if (!rules || !rules.length)
            return;
        
        this.$headings = rules;
        
        var fixed = 0, found = false;
        for (var h, i = 0, l = rules.length; i < l; i++) {
            h = rules[i];
            
            
            if (!h.$width)
                throw new Error("missing width"); //temporary check
            
            
            if (!h.$isPercentage)
                fixed += parseFloat(h.$width) || 0;
            else 
                found = true;
        }
        
        if (!found) { //@todo removal???
            this.$isFixedGrid = true;
            this.$setStyleClass(this.$ext, "fixed");
            
            if (this.$useiframe)
                this.$setStyleClass(this.oDoc.documentElement, "fixed");
        }
        else {
            //@todo remove
        }

        if (fixed > 0 && !this.$isFixedGrid) {
            var vLeft = fixed + 5;
            
            //first column has total -1 * fixed margin-left. - 5
            //cssRules[0][1] += ";margin-left:-" + vLeft + "px;";
            //cssRules[1][1] += ";margin-left:-" + vLeft + "px;";
            this.$cssRules.push(["." + this.$baseCSSname + " .row" + this.$uniqueId,
                "padding-right:" + vLeft + "px;margin-right:-" + vLeft + "px"]);
        
            //headings and records have same padding-right
            this.$int.style.paddingRight  =
            this.$head.style.paddingRight = vLeft + "px";
        }
        
        this.$fixed = fixed;
        this.$first = 0;

        this.$withContainer = e.bindings.description ? true : false;

        //Activate CSS Rules
        importStylesheet(this.$cssRules, window);
        
        if (this.$useiframe)
            importStylesheet(this.$cssRules, this.oWin);
    });
    
    this.$add = function(xmlNode, sLid, xmlParentNode, htmlParentNode, beforeNode){
        //Build Row
        this.$getNewContext("row");
        var oRow = this.$getLayoutNode("row");
        oRow.setAttribute("id", sLid);
        oRow.setAttribute("class", "row" + this.$uniqueId);//"width:" + (totalWidth+40) + "px");
        
        oRow.setAttribute("ondblclick", 'var o = apf.lookup(' + this.$uniqueId + ');o.choose();'
            + (this.$withContainer ? 'o.slideToggle(this);' : '')
            + (this.celledit && !this.namevalue ? 'o.startRename();' : ''));
        
        if (this.hasFeature(apf.__DRAGDROP__)) {
            oRow.setAttribute("onmouseout", 'this.hasPassedDown = false;');
            oRow.setAttribute("onmousedown", 'var o = apf.lookup(' + this.$uniqueId + ');\
                var xmlNode = apf.xmldb.findXmlNode(this);\
                 var isSelected = o.isSelected(xmlNode);\
                 this.hasPassedDown = true;\
                 if (!o.hasFeature(apf.__DRAGDROP__) || !isSelected && !event.ctrlKey)\
                     o.select(this, event.ctrlKey, event.shiftKey);'
                + (this.cellselect || this.namevalue ? 'o.selectCell(event, this, isSelected);' : ''));
            
            oRow.setAttribute("onmouseup", 'if (!this.hasPassedDown) return;\
                var o = apf.lookup(' + this.$uniqueId + ');\
                 var xmlNode = apf.xmldb.findXmlNode(this);\
                 var isSelected = o.isSelected(xmlNode);\
                 if (o.hasFeature(apf.__DRAGDROP__))\
                     o.select(this, event.ctrlKey, event.shiftKey);');
        } //@todo add DRAGDROP ifdefs
        else {
            oRow.setAttribute("onmousedown", 'var o = apf.lookup(' + this.$uniqueId + ');\
                var wasSelected = o.$selected == this;\
                o.select(this, event.ctrlKey, event.shiftKey);'
                + (this.cellselect || this.namevalue ? 'o.selectCell(event, this, wasSelected);' : ''));
        }
        
        //Build the Cells
        for (var cell, h, i = 0; i < this.$headings.length; i++) {
            h = this.$headings[i];
            
            this.$getNewContext("cell");
            cell = this.$getLayoutNode("cell");
            
            apf.setStyleClass(cell, h.$className);
            
            if (h.css)
                apf.setStyleClass(cell, (apf.lm.compile(h.css))(xmlNode));

            if (h.type == "icon"){
                var node = this.$getLayoutNode("cell", "caption", oRow.appendChild(cell));
                if (apf.isIE) {
                    apf.setNodeValue(node, "&nbsp;");
                }
                (node.nodeType == 1 && node || node.parentNode)
                    .setAttribute("style", "background-image:url(" 
                        + apf.getAbsolutePath(this.iconPath, 
                            ((h.cvalue2 || h.$compile("value", {nostring: true}))(xmlNode) || ""))
                        + ")");
            }
            else {
                apf.setNodeValue(this.$getLayoutNode("cell", "caption", oRow.appendChild(cell)),
                    (h.cvalue2 || h.$compile("value", {nostring: true}))(xmlNode) || "");
                    //(this.$applyBindRule([h.xml], xmlNode) || "").trim() || ""); //@todo for IE but seems not a good idea
            }
        }
        
        if (this.$bindings && this.$bindings.color) {
            var colorRule = this.$getDataNode("color", xmlNode);
            this.$setStyleClass(oRow, colorRule ? "highlight" : null, colorRule ? ["highlight"] : null);
        }
        
        
        var cssClass = this.$applyBindRule("css", xmlNode);
        if (cssClass) {
            this.$setStyleClass(oRow, cssClass);
            if (cssClass)
                this.dynCssClasses.push(cssClass);
        }
        

        //return apf.insertHtmlNode(oRow, htmlParentNode || this.$int, beforeNode);
        if (htmlParentNode)
            apf.insertHtmlNode(oRow, htmlParentNode, beforeNode);
        else
            this.$nodes.push(oRow);
        
        if (this.$withContainer) {
            var desc = this.$applyBindRule("description", xmlNode);
            this.$getNewContext("container");
            var oDesc = this.$getLayoutNode("container");
            apf.setNodeValue(this.$getLayoutNode("container", "container",
                oDesc), desc);
            oDesc.setAttribute("class", (oDesc.getAttribute("class") || "")
                + " row" + this.$uniqueId);
            
            if (htmlParentNode)
                apf.insertHtmlNode(oDesc, htmlParentNode, beforeNode);
            else 
                this.$nodes.push(oDesc);
        }
    };
    
    this.$fill = function(nodes){
        if (this.$useiframe)
            this.$pHtmlDoc = this.oDoc;

        if (this.$useTable) {
            apf.insertHtmlNodes(this.$nodes, this.$int, null,
                 "<table class='records' cellpadding='0' cellspacing='0'><tbody>", 
                 "</tbody></table>");
        }
        else
            apf.insertHtmlNodes(this.$nodes, this.$int);

        this.$nodes.length = 0;
    };

    this.$deInitNode = function(xmlNode, htmlNode){
        if (this.$withContainer)
            htmlNode.parentNode.removeChild(htmlNode.nextSibling);
        
        //Remove htmlNodes from tree
        htmlNode.parentNode.removeChild(htmlNode);
    };
    
    this.$updateNode = function(xmlNode, htmlNode){
        if (!htmlNode) return;
        
        var nodes     = this.$head.childNodes,
            htmlNodes = htmlNode.childNodes,
            node, p;
        
        if (!this.namevalue && this.$curBtn)
            p = this.$curBtn.parentNode;

        for (var nodeIter, h, i = this.namevalue ? 1 : 0, l = nodes.length; i < l; i++) {
            h = apf.all[nodes[i].getAttribute("hid")];
            
            nodeIter = htmlNodes[i];
            while (nodeIter && nodeIter.nodeType != 1)
                nodeIter = nodeIter.nextSibling;
            
            //@todo fake optimization
            node = this.$getLayoutNode("cell", "caption", nodeIter) || nodeIter;//htmlNodes[i].firstChild || 
            
            if (h.type == "icon") {
                (node.nodeType == 1 && node || node.parentNode)
                    .style.backgroundImage = "url(" 
                        + apf.getAbsolutePath(this.iconPath, 
                            ((h.cvalue2 || h.$compile("value", {nostring: true}))(xmlNode) || ""))
                        + ")";
            }
            else {
                node.innerHTML = (h.cvalue2 || h.$compile("value", {nostring: true}))(xmlNode) || ""
            }
        }
        
        if (!this.namevalue && p)
            p.appendChild(this.$curBtn);
        
        //return; //@todo fake optimization
        
        if (this.$bindings && this.$bindings.color) {
            var colorRule = this.$getDataNode("color", xmlNode);
            this.$setStyleClass(htmlNode, colorRule ? "highlight" : null,
                colorRule ? ["highlight"] : null);
        }
        
        
        var cssClass = this.$applyBindRule("css", xmlNode);
        if (cssClass || this.dynCssClasses.length) {
            this.$setStyleClass(htmlNode, cssClass, this.dynCssClasses);
            if (cssClass && !this.dynCssClasses.contains(cssClass))
                this.dynCssClasses.push(cssClass);
        }
        
        
        if (this.$withContainer) {
            htmlNode.nextSibling.innerHTML 
                = this.$applyBindRule("description", xmlNode) || "";
        }
    };
    
    this.$moveNode = function(xmlNode, htmlNode){
        if (!htmlNode) return;
        var oPHtmlNode = htmlNode.parentNode;
        var beforeNode = xmlNode.nextSibling 
            ? apf.xmldb.findHtmlNode(this.getNextTraverse(xmlNode), this)
            : null;

        oPHtmlNode.insertBefore(htmlNode, beforeNode);
        
        //if(this.emptyMessage && !oPHtmlNode.childNodes.length) this.setEmpty(oPHtmlNode);
    };
    
    this.$selectDefault = function(XMLRoot){
        this.select(XMLRoot.selectSingleNode(this.each), null, null, null, true);
    };
    
    /**** Column management ****/

    /**
     * Returns a column definition object based on the column number.
     * @param {Number} hid the heading number; this number is based on the sequence of the column elements.
     */
    this.getColumn = function(nr){
        return this.$headings[nr || this.$lastcol || 0];
    };
    
    /** 
     * Resizes a column.
     * @param {Number} hid      the heading number; this number is based on the sequence of the column elements. 
     * @param {Number} newsize  the new size of the column.
     * @todo optimize but bringing down the string concats
     */
    this.resizeColumn = function(nr, newsize){
        var h = this.$headings[nr];
        h.resize(newsize);
    };

    /**
     * Hides a column.
     * @param {Number} hid      the heading number; this number is based on the sequence of the column elements. 
     */
    this.hideColumn = function(nr){
        var h = this.$headings[nr];
        h.hide();
    };
    
    /**
     * Shows a hidden column.
     * @param {Number} hid      the heading number; this number is based on the sequence of the column elements. 
     */
    this.showColumn = function(nr){
        var h = this.$headings[nr];
        h.show();
    };
    
    /**
     * Sorts a column.
     * @param {Number} hid the heading number; this number is based on the sequence of the column elements.
     */
    this.sortColumn = function(hid){
        var h = this.$headings[nr];
        h.sort();
    };
    
    /**
     * Moves a column to another position.
     * @param {Number} fromHid the heading number of the column to move; this number is based on the sequence of the column elements.
     * @param {Number} toHid   the position the column is moved to;
     */
    this.moveColumn = function(from, to){
        var h = this.$headings[nr];
        h.move(to);
    }
    
    /**** Init ****/

    this.$draw = function(){
        //Build Main Skin
        this.$ext     = this.$getExternal();
        this.$int     = this.$getLayoutNode("main", "body", this.$ext);
        this.$head    = this.$getLayoutNode("main", "head", this.$ext);
        this.$pointer = this.$getLayoutNode("main", "pointer", this.$ext);

        if (this.$head.firstChild)
            this.$head.removeChild(this.$head.firstChild);
        if (this.$int.firstChild)
            this.$int.removeChild(this.$int.firstChild);

        var widthdiff = this.$widthdiff = this.$getOption("main", "widthdiff") || 0;
        this.$defaultwidth = this.$getOption("main", "defaultwidth") || "100";
        this.$useiframe    = apf.isIE && (apf.isTrue(this.$getOption("main", "iframe")) || this.iframe);

        var _self = this;
        
        //Initialize Iframe 
        if (this.$useiframe && !this.oIframe) {
            //this.$int.style.overflow = "hidden";
            //var sInt = this.$int.outerHTML 
            var sClass   = this.$int.className;
            //this.$int.parentNode.removeChild(this.$int);
            this.oIframe = this.$int.appendChild(document.createElement(apf.isIE 
                ? "<iframe frameborder='0'></iframe>"
                : "iframe"));
            this.oIframe.frameBorder = 0;
            this.oWin = this.oIframe.contentWindow;
            this.oDoc = this.oWin.document;
            this.oDoc.write('<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">\
                <html xmlns="http://www.w3.org/1999/xhtml">\
                    <head><script>\
                        apf = {\
                            lookup : function(uid){\
                                return window.parent.apf.lookup(uid);\
                            },\
                            Init : {add:function(){},run:function(){}}\
                        };</script>\
                    </head>\
                    <body></body>\
                </html>');
            //Import CSS
            //this.oDoc.body.innerHTML = sInt;
            this.$int = this.oDoc.body;//.firstChild;
            this.$int.className = sClass;//this.oIframe.parentNode.className;
            this.oDoc.documentElement.className = this.$ext.className;
            //this.oDoc.body.className = this.$ext.className;

            apf.skins.loadCssInWindow(this.skinName, this.oWin, this.mediaPath, this.iconPath);
            
            if (apf.isIE) //@todo this can be removed when focussing is fixed for this component
                this.$setStyleClass(this.oDoc.documentElement, this.$baseCSSname + "Focus");
            
            apf.convertIframe(this.oIframe, true);

            
            this.oDoc.body.insertAdjacentHTML("beforeend", this.oTxt.outerHTML);

            var t     = this.oTxt;
            t.refCount--;
            this.oTxt = this.oDoc.body.lastChild;
            this.oTxt.parentNode.removeChild(this.oTxt);
            this.oTxt.select = t.select;

            this.oTxt.ondblclick    = 
            this.oTxt.onselectstart = 
            this.oTxt.onmouseover   = 
            this.oTxt.onmouseout    = 
            this.oTxt.oncontextmenu = 
            this.oTxt.onmousedown   = function(e){ 
                (e || (_self.oWin || window).event).cancelBubble = true; 
            };

            this.oTxt.onfocus   = t.onfocus;
            this.oTxt.onblur    = t.onblur;
            this.oTxt.onkeyup   = t.onkeyup;
            this.oTxt.refCount  = 1;
            
            
            if (apf.getStyle(this.oDoc.documentElement, apf.isIE 
              ? "overflowY" : "overflow-y") == "auto") {
                //@todo ie only
                this.oIframe.onresize = function(){
                    _self.$head.style.marginRight = 
                      _self.oDoc.documentElement.scrollHeight > _self.oDoc.documentElement.offsetHeight 
                        ? "16px" : "0";
                }
                
                this.addEventListener("afterload", this.oIframe.onresize);
                this.addEventListener("xmlupdate", this.oIframe.onresize);
            }
            
            this.oDoc.documentElement.onmousedown = function(e){
                if (!e) e = _self.oWin.event;
                if ((e.srcElement || e.target).tagName == "HTML")
                    apf.popup.forceHide();
            }
                        
            this.oDoc.documentElement.onscroll = 
                function(){
                    if (_self.$isFixedGrid)
                        _self.$head.scrollLeft = _self.oDoc.documentElement.scrollLeft;
                };
        }
        else {
            if (apf.getStyle(this.$int, apf.isIE 
              ? "overflowY" : "overflow-y") == "auto") {
                this.$resize = function(){
                    _self.$head.style.marginRight = 
                      _self.$int.scrollHeight > _self.$int.offsetHeight 
                        ? "16px" : "0";
                }
                
                
                apf.layout.setRules(this.$ext, this.$uniqueId + "_datagrid",
                    "var o = apf.all[" + this.$uniqueId + "];\
                     if (o) o.$resize()");
                apf.layout.queue(this.$ext);
                
                
                this.addEventListener("afterload", this.$resize);
                this.addEventListener("xmlupdate", this.$resize);
            }
            
            this.$int.onmousedown = function(e){
                if (!e) e = event;
                if ((e.srcElement || e.target) == this)
                    apf.popup.forceHide();
            }
            
            this.$int.onscroll = 
                function(){
                    if (_self.$isFixedGrid)
                        _self.$head.scrollLeft = _self.$int.scrollLeft;
                };
        }
    };
    
    this.$destroy = function(){
        apf.popup.removeContent(this.$uniqueId);
        
        //@todo destroy this.oTxt here

        this.$ext.onclick = this.$int.onresize = null;
        
        
        apf.layout.removeRule(this.$int, "dg" + this.$uniqueId);
        apf.layout.activateRules(this.$int);
        
    };

}).call(apf.datagrid.prototype = new apf.MultiSelect());


apf.spreadsheet.prototype = apf.datagrid.prototype;

apf.aml.setElement("spreadsheet", apf.spreadsheet);
apf.aml.setElement("datagrid",    apf.datagrid);
//apf.aml.setElement("column",      apf.BindingRule);
apf.aml.setElement("description", apf.BindingRule);
apf.aml.setElement("color",       apf.BindingRule);
apf.aml.setElement("contents",    apf.BindingRule);





/*FILEHEAD(/var/lib/platform/source/trunk/elements/skin.js)SIZE(9256)TIME(1264809662)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * element specifying the skin of an application.
 * Example:
 * <code>
 *  <a:skin src="perspex.xml"
 *    name       = "perspex"
 *    media-path = "http://example.com/images"
 *    icon-path  = "http://icons.example.com" />
 * </code>
 * @attribute {String} name       the name of the skinset.
 * @attribute {String} src        the location of the skin definition.
 * @attribute {String} media-path the basepath for the images of the skin.
 * @attribute {String} icon-path  the basepath for the icons used in the elements using this skinset.
 * @addnode global, anyaml
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.skin = function(struct, tagName){
    this.$init(tagName || "skin", apf.NODE_HIDDEN, struct);
};
apf.aml.setElement("skin", apf.skin);

(function(){
    this.$parsePrio = "002";
    
    this.$propHandlers["src"] = function(value){
        this.$path = apf.getAbsolutePath(apf.hostPath, value)
        getSkin.call(this, this.$path);
    }
    
    this.$propHandlers["name"] = function(value){
        if (!this.attributes.getNamedItem("src")) {
            this.$path = apf.getAbsolutePath(apf.hostPath, value) + "/index.xml";
            getSkin.call(this, this.$path);
        }
    }
    
    /**
     * @private
     */
    function checkForAmlNamespace(xmlNode){
        if (!xmlNode.ownerDocument.documentElement)
            return false;

        var nodes = xmlNode.ownerDocument.documentElement.attributes;
        for (var found = false, i=0; i<nodes.length; i++) {
            if (nodes[i].nodeValue == apf.ns.aml) {
                found = true;
                break;
            }
        }

        
        if (!found) {
            throw new Error(apf.formatErrorString(0, null,
                "Checking for the aml namespace",
                "The Ajax.org Platform xml namespace was not found in "
                + (xmlNode.getAttribute("filename")
                    ? "in '" + xmlNode.getAttribute("filename") + "'"
                    : "")));
        }
        

        return found;
    }
    
    function getSkin(path){
        var domParser = this.ownerDocument.$domParser;
        
        if (!apf.skins.$first)
            apf.skins.$first = this;
        
        var defer = this.attributes.getNamedItem("defer");
        if (!defer || !apf.isTrue(defer.nodeValue)) {
            domParser.$shouldWait++;
            this.$parseContext = domParser.$parseContext || [this.ownerDocument.documentElement];
        }
        
        //var basePath = apf.hostPath;//only for recursion: apf.getDirname(xmlNode.getAttribute("filename")) || 
        loadSkinFile.call(this, path);
        
    }
    
    function finish(xmlNode){
        if (xmlNode)
            apf.skins.Init(xmlNode, this, this.$path);

        if (!this.defer) {// && this.$parseContext
            var domParser = this.ownerDocument.$domParser;
            domParser.$continueParsing.apply(domParser, this.$parseContext);
        }
    }
    
    
    function loadSkinInclude(includeNode, xmlNode, path) {
        var _self = this;

        
        apf.getData(
        
          apf.getAbsolutePath(path, includeNode.getAttribute("src")), {
          callback: function(xmlString, state, extra){
            if (state != apf.SUCCESS) {
                throw new Error("Could not load skin include");//@todo apf3.0 make this into a proper error
            }
            
            var newPart = apf.getXml('<a:skin xmlns:a="http://ajax.org/2005/aml">' + xmlString + '</a:skin>');
            apf.mergeXml(newPart, xmlNode, {beforeNode: includeNode});
            includeNode.parentNode.removeChild(includeNode);
            
            var includeNodes = $xmlns(newPart, "include", apf.ns.aml);
            if (includeNodes.length) {
                var path = apf.getDirname(extra.url);
                for (var i = 0; i < includeNodes.length; i++) {
                    loadSkinInclude.call(_self, includeNodes[i], xmlNode, path);
                }
            }
            else if (!$xmlns(xmlNode, "include", apf.ns.aml).length) {
                
                apf.console.info("Loading of " + xmlNode[apf.TAGNAME].toLowerCase() + " skin done from file: " + extra.url);
                
                
                finish.call(_self, xmlNode);
            }
          }
        });
    }
    
    
    function loadSkinFile(path){
        
        apf.console.info("Loading include file: " + path);
        

        var _self = this;
        
        apf.getData(
        
          path, {
          callback: function(xmlString, state, extra){
             if (state != apf.SUCCESS) {
                var oError = new Error(apf.formatErrorString(1007,
                    _self, "Loading skin file", "Could not load skin file '"
                    + (path || _self.src)
                    + "'\nReason: " + extra.message));

                if (extra.tpModule.retryTimeout(extra, state, null, oError) === true)
                    return true;

                
                if (this.autoload) {
                    apf.console.warn("Could not autload skin.");
                    return finish.call(_self);
                }
                

                throw oError;
            }

            //if (!apf.supportNamespaces)
            xmlString = xmlString.replace(/\<\!DOCTYPE[^>]*>/, "")
                .replace(/&nbsp;/g, " ").replace(/^[\r\n\s]*/, "")
                .replace(/xmlns\=\"[^"]*\"/g, "");
            
            if (!xmlString) {
                throw new Error(apf.formatErrorString(0, _self,
                    "Loading skin",
                    "Empty skin file. Maybe the file does not exist?", _self));
            }
            
            var xmlNode = apf.getXml(xmlString);//apf.getAmlDocFromString(xmlString);
            
            
            checkForAmlNamespace(xmlNode);
            
            
            if (!xmlNode) {
                throw new Error(apf.formatErrorString(0, _self,
                    "Loading skin",
                    "Could not parse skin. Maybe the file does not exist?", _self));
            }
            
            xmlNode.setAttribute("filename", extra.url);
            
            
            var includeNodes = $xmlns(xmlNode, "include", apf.ns.aml);
            if (includeNodes.length) {
                var path = apf.getDirname(extra.url);
                for (var i = 0; i < includeNodes.length; i++) {
                    loadSkinInclude.call(_self, includeNodes[i], xmlNode, path);
                }
                return;
            }
            else 
            
            {
                
                apf.console.info("Loading of " + xmlNode[apf.TAGNAME].toLowerCase() + " skin done from file: " + extra.url);
                
                
                finish.call(_self, xmlNode);
            }
          }, 
          async         : true,
          ignoreOffline : true
        });
    }
    
    //@todo use mutation events to update
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (this.src || this.name)
            return;
        
        apf.skins.Init(this);
        
        //@todo implied skin
        /*if (this.parentNode && this.parentNode.parentNode) {
            var name = "skin" + Math.round(Math.random() * 100000);
            q.parentNode.setAttribute("skin", name);
            apf.skins.skins[name] = {name: name, templates: {}};
            apf.skins.skins[name].templates[q.parentNode[apf.TAGNAME]] = q;
        }*/
    });
}).call(apf.skin.prototype = new apf.AmlElement());



/*FILEHEAD(/var/lib/platform/source/trunk/elements/video.js)SIZE(20320)TIME(1259091146)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element that is able to play a video file or remote stream
 * Example:
 * Plays a video at 340x180
 * <code>
 *  <a:video id="myVideo"
 *   src      = ""
 *   controls = "false"
 *   autoplay = "true"
 *   volume   = "20"
 *   width    = "340"
 *   height   = "180">
 *    Video Codec not supported.
 *  </a:video>
 * </code>
 * Example:
 * <code>
 *  <a:video id="myVideo2"
 *   autoplay = "true"
 *   controls = "false"
 *   volume   = "90">
 *    <a:source src="http://my-mediaserver.com/demo_video.flv" />
 *    <a:source src="http://my-mediaserver.com/demo_video.mov" />
 *    <a:source src="http://my-mediaserver.com/demo_video.wmv" />
 *    <a:source src="http://my-mediaserver.com/video.wmv" type="video/silverlight" />
 *    <a:source src="http://my-mediaserver.com/demo_video.ogg" />
 *    <a:nomedia>Video Codec not supported.</a:nomedia>
 *  </a:video>
 * </code>
 *
 * @return {Video} Returns a new video
 * @type {Video}
 * @inherits apf.Presentation
 * @inherits apf.Media
 * @constructor
 * @allowchild text, source, nomedia
 * @addnode elements:video
 * @link http://www.whatwg.org/specs/web-apps/current-work/#video
 *
 * @author      Mike de Boer
 * @version     %I%, %G%
 * @since       1.0
 */

apf.video = function(struct, tagName){
    this.$init(tagName || "video", apf.NODE_VISIBLE, struct);
};

(function(){
    this.implement(
        
        apf.DataAction
        
    );

    this.$booleanProperties["fullscreen"] = true;

    var oldStyle = null; //will hold old style of the media elements' parentNode on fullscreen
    //var placeHolder = null;
    this.$propHandlers["fullscreen"] = function(value) {
        if (!this.player) return;
        // only go fullscreen when the feature is supported by the active player
        if (typeof this.player.setFullscreen == "function")
            this.player.setFullscreen(value);
        else if (this.parentNode && this.parentNode.tagName != "application"
          && this.parentNode.setWidth) {
            // we're going into fullscreen mode...
            var i, node, oParent = this.parentNode.$ext;
            if (value) {
                oldStyle = {
                    width    : this.parentNode.getWidth(),
                    height   : this.parentNode.getHeight(),
                    top      : this.parentNode.getTop(),
                    left     : this.parentNode.getLeft(),
                    position : apf.getStyle(oParent, 'position'),
                    zIndex   : apf.getStyle(oParent, 'z-index'),
                    resizable: this.parentNode.resizable,
                    nodes    : []
                }

                if (oParent != document.body) {
                    while (oParent.parentNode != document.body) {
                        var node = oParent.parentNode;
                        i = oldStyle.nodes.push({
                            pos:  apf.getSyle(node, 'position') || "",
                            top:  apf.getSyle(node, 'top')  || node.offsetTop + "px",
                            left: apf.getSyle(node, 'left') || node.offsetLeft + "px",
                            node: node
                        }) - 1;
                        node.style.position = "absolute";
                        node.style.top      = "0";
                        node.style.left     = "0";
                        /*window.console.log('still reparenting!');
                        window.console.dir(oParent.parentNode);
                        placeHolder = document.createElement('div');
                        placeHolder.setAttribute('id', 'apf.__apf_video_placeholder__');
                        placeHolder.style.display = "none";
                        oParent.parentNode.insertBefore(placeHolder, oParent);

                        document.body.appendChild(oParent);*/
                    }
                }

                this.parentNode.$ext.style.position = "absolute";
                this.parentNode.$ext.style.zIndex = "1000000";
                this.parentNode.setWidth('100%');
                this.parentNode.setHeight('100%');
                this.parentNode.setTop('0');
                this.parentNode.setLeft('0');

                if (this.parentNode.resizable)
                    this.parentNode.setAttribute("resizable", false);
            }
            // we're going back to normal mode...
            else if (oldStyle) {
                var coll;
                if (oldStyle.nodes.length) {
                    for (i = oldStyle.nodes.length - 1; i >= 0; i--) {
                        coll = oldStyle.nodes[i];
                        node = coll.node;
                        node.style.position = coll.pos;
                        node.style.top      = coll.top;
                        node.style.left     = coll.left;
                    }
                }
                /*if (placeHolder) {
                    window.console.log('still reparenting!');
                    placeHolder.parentNode.insertBefore(oParent, placeHolder);
                    placeHolder.parentNode.removeChild(placeHolder);
                    placeHolder = null;
                }*/

                this.parentNode.$ext.style.zIndex = oldStyle.zIndex;
                this.parentNode.$ext.style.position = oldStyle.position;
                this.parentNode.setWidth(oldStyle.width);
                this.parentNode.setHeight(oldStyle.height);
                this.parentNode.setTop(oldStyle.top);
                this.parentNode.setLeft(oldStyle.left);

                if (oldStyle.resizable)
                    this.parentNode.setAttribute("resizable", true);

                oldStyle = null;
                delete oldStyle;
            }

            if (this.player.onAfterFullscreen)
                this.player.onAfterFullscreen(value);

            var _self = this;
            
            window.setTimeout(function() {
                apf.layout.forceResize(_self.parentNode.$ext);
            }, 100);
            
        }
    };

    /**** Event listeners ****/

    
    this.addEventListener("keydown", function(e){
        switch (e.keyCode) {
            case 13 && (e.ctrlKey || e.altKey): //(CTRL | ALT) + RETURN
            case 70: //f
                this.setPropery("fullscreen", true);
                return false;
                break;
            case 80:
                this.setProperty("paused", !this.paused);
                return false;
                break;
            case 27: //ESC
                this.setProperty("fullscreen", false);
                return false;
                break;
            default:
                break;
        };
    }, true);
    

    this.$mainBind = "src";

    /**
     * Load a video by setting the URL pointer to a different video file
     *
     * @param {String} sVideo
     * @type {Object}
     */
    this.loadMedia = function() {
        if (this.player) {
            this.setProperty('currentSrc',   this.src);
            this.setProperty('networkState', apf.Media.NETWORK_LOADING);
            this.player.load(this.src);
        }

        return this;
    };

    /**
     * Seek the video to a specific position.
     *
     * @param {Number} iTo The number of seconds to seek the playhead to.
     * @type {Object}
     */
    this.seek = function(iTo) {
        if (this.player && iTo >= 0 && iTo <= this.duration)
            this.player.seek(iTo);
    };

    /**
     * Set the volume of the video to a specific range (0 - 100)
     *
     * @param {Number} iVolume
     * @type {Object}
     */
    this.setVolume = function(iVolume) {
        if (this.player) {
            this.player.setVolume(iVolume);
        }
    };

    var typesQT = "mov",
        typesFLV = "flv",
        typesWMP = "asf|asx|avi|wmv",
        typesNtv = "ogg",
        typesVLC = "3gp|3gpp|3g2|3gpp2|divx|mp4|mpg4|mpg|mpeg|mpe|ogg|vob";

    /**
     * Guess the mime-type of a video file, based on its filename/ extension.
     *
     * @param {String} path
     * @type {String}
     */
    this.$guessType = function(path) {
        // make a best-guess, based on the extension of the src attribute (file name)
        var ext  = path.substr(path.lastIndexOf('.') + 1),
            type = "";
        if (typesQT.indexOf(ext) != -1)
            type = "video/quicktime";
        else if (typesFLV.indexOf(ext) != -1)
            type = "video/flv";
        else if (typesWMP.indexOf(ext) != -1)
            type = "video/wmv";
        else if (typesNtv.indexOf(ext) != -1 && apf.hasVideo)
            type = "video/ogg";
        else if (typesVLC.indexOf(ext) != -1)
            type = "video/vlc";
        // mpeg video is better to be played by native players
        if (ext == "mpg" || ext == "mpeg" || ext == "mpe")
            type = apf.isMac ? "video/quicktime" : "video/wmv";
        // default to VLC on *NIX machines
        if (!apf.isWin && !apf.isMac && type == "video/wmv")
            type = "video/vlc";

        return type;
    };

    /**
     * Find the correct video player type that will be able to playback the video
     * file with a specific mime-type provided.
     *
     * @param {String} mimeType
     * @type {String}
     */
    this.$getPlayerType = function(mimeType) {
        if (!mimeType) return null;

        var playerType = null;

        var aMimeTypes = mimeType.splitSafe(',');
        if (aMimeTypes.length == 1)
            aMimeTypes = aMimeTypes[0].splitSafe(';');
        for (var i = 0; i < aMimeTypes.length; i++) {
            mimeType = aMimeTypes[i];

            if (mimeType.indexOf('ogg') > -1)
                playerType = "TypeNative";
            else if (mimeType.indexOf('flv') > -1)
                playerType = "TypeFlv";
            else if (mimeType.indexOf('quicktime') > -1)
                playerType = "TypeQT";
            else if (mimeType.indexOf('wmv') > -1)
                playerType = "TypeWmp";
            else if (mimeType.indexOf('silverlight') > -1)
                playerType = "TypeSilverlight";
            else if (mimeType.indexOf('vlc') > -1)
                playerType = "TypeVlc";

            if (playerType == "TypeWmp") {
                if (!apf.isIE && typeof apf.video.TypeVlc != "undefined"
                  && apf.video.TypeVlc.isSupported())
                    playerType = "TypeVlc";
                else if (apf.isMac)
                    playerType = "TypeQT";
            }

            if (playerType && apf.video[playerType] &&
              apf.video[playerType].isSupported()) {
                this.$lastMimeType = i;
                return playerType;
            }
        }

        this.$lastMimeType = -1;
        return null;//playerType;
    };

    /**
     * Checks if a specified playerType is supported by APF or not...
     *
     * @type {Boolean}
     */
    this.$isSupported = function(sType) {
        sType = sType || this.playerType;
        return (apf.video[sType] && apf.video[sType].isSupported());
    };

    /**
     * Initialize and instantiate the video player provided by getPlayerType()
     *
     * @type {Object}
     */
    this.$initPlayer = function() {
        this.player = new apf.video[this.playerType](this, this.$ext, {
            src         : this.src.splitSafe(",")[this.$lastMimeType] || this.src,
            width       : this.width,
            height      : this.height,
            autoLoad    : true,
            autoPlay    : this.autoplay,
            showControls: this.controls,
            volume      : this.volume,
            mimeType    : this.type
        });
        return this;
    };

    /**
     * The 'init' event hook is called when the player control has been initialized;
     * usually that means that the active control (flash, QT or WMP) has been loaded
     * and is ready to load a file.
     *
     * @ignore
     * @type {void}
     */
    this.$initHook = function() {
        this.loadMedia();
    };

    /**
     * The 'cuePoint' event hook is called when the player has set a cue point in
     * the video file.
     *
     * @ignore
     * @type {void}
     */
    this.$cuePointHook = function() {}; //ignored

    /**
     * The 'playheadUpdate' event hook is called when the position of the playhead
     * that is currently active (or 'playing') is updated.
     * This feature is currently handled by {@link element.video.method.$changeHook}
     *
     * @ignore
     * @type {void}
     */
    this.$playheadUpdateHook = function() {}; //ignored

    /**
     * The 'error' event hook is called when an error occurs within the internals
     * of the player control.
     *
     * @param {Object} e Event data, specific to this hook, containing player data.
     * @type {void}
     */
    this.$errorHook = function(e) {
        apf.console.error(e.error);
    };

    /**
     * The 'progress' event hook is called when the progress of the loading sequence
     * of an video file is updated. The control signals us on how many bytes are
     * loaded and how many still remain.
     *
     * @param {Object} e Event data, specific to this hook, containing player data.
     * @type {void}
     */
    this.$progressHook = function(e) {
        this.setProperty('bufferedBytes', {start: 0, end: e.bytesLoaded});
        this.setProperty('totalBytes', e.totalBytes);
        var iDiff = Math.abs(e.bytesLoaded - e.totalBytes);
        if (iDiff <= 20)
            this.setProperty('readyState', apf.Media.HAVE_ENOUGH_DATA);
    };

    /**
     * The 'stateChange' event hook is called when the internal state of a control
     * changes. The state of internal properties of an video control may be
     * propagated through this function.
     *
     * @param {Object} e Event data, specific to this hook, containing player data.
     * @type {void}
     */
    this.$stateChangeHook = function(e) {
        //loading, playing, seeking, paused, stopped, connectionError
        if (e.state == "loading") {
            this.setProperty('networkState', this.networkState = apf.Media.NETWORK_LOADING);
        }
        else if (e.state == "connectionError") {
            this.$propHandlers["readyState"].call(this, this.networkState = apf.Media.HAVE_NOTHING);
        }
        else if (e.state == "playing" || e.state == "paused") {
            if (e.state == "playing")
                this.$readyHook({type: 'ready'});
            this.paused = Boolean(e.state == "paused");
            this.setProperty('paused', this.paused);
        }
        else if (e.state == "seeking") {
            this.seeking = true;
            this.setProperty('seeking', true);
        }
    };

    /**
     * The 'change' event hook is called when a) the volume level changes or
     * b) when the playhead position changes.
     *
     * @param {Object} e Event data, specific to this hook, containing player data.
     * @type {void}
     */
    this.$changeHook = function(e) {
        if (typeof e.volume != "undefined") {
            this.volume = e.volume;
            if (!this.muted)
                this.setProperty("volume", this.volume);
        }
        else {
            this.duration = this.player.getTotalTime();
            this.position = e.playheadTime / this.duration;
            if (isNaN(this.position)) return;
            this.setProperty('position', this.position);
            this.currentTime = e.playheadTime;
            this.setProperty('currentTime', this.currentTime);
        }
    };

    /**
     * The 'complete' event hook is called when a control has finished playing
     * an video file completely, i.e. the progress is at 100%.
     *
     * @param {Object} e Event data, specific to this hook, containing player data.
     * @type {void}
     */
    this.$completeHook = function(e) {
        this.paused = true;
        this.setProperty('paused', true);
    };

    /**
     * When a video player signals that is has initialized properly and is ready
     * to play, this function sets all the flags and behaviors properly.
     *
     * @type {Object}
     */
    this.$readyHook = function(e) {
        this.setProperty('networkState', apf.Media.NETWORK_LOADED);
        this.setProperty('readyState',   apf.Media.HAVE_FUTURE_DATA);
        this.setProperty('duration', this.player.getTotalTime());
        this.seeking  = false;
        this.seekable = true;
        this.setProperty('seeking', false);
        return this;
    };

    /**
     * The 'metadata' event hook is called when a control receives metadata of an
     * video file.
     *
     * @ignore
     * @type {void}
     */
    this.$metadataHook = function(e) {
        this.oVideo.setProperty('readyState', apf.Media.HAVE_METADATA);
    };

    /**
     * Unsubscribe from all the events that we have subscribed to with
     * startListening()
     *
     * @type {Object}
     */
    this.stopListening = function() {
        if (!this.player) return this;

        return this;
    };

    /**
     * Build Main Skin
     *
     * @type {void}
     */
    this.$draw = function(){
        this.$ext = this.$getExternal();
    };

    /**
     * Parse the block of AML that constructs the HTML5 compatible <VIDEO> tag
     * for arguments like URL of the video, width, height, etc.
     *
     * @param {XMLRootElement} x
     * @type {void}
     */
    this.addEventListener("DOMNodeInsertedIntoDocument", function(){
        this.$int   = this.$getLayoutNode("main", "container", this.$ext);

        this.width  = parseInt(this.width)  || null;
        this.height = parseInt(this.height) || null;
    });

    this.addEventListener("AMLMediaReady", function() {
        if (this.setSource())
            this.$propHandlers["type"].call(this, this.type);
    });

    this.$destroy = function(bRuntime) {
        if (this.player && this.player.$destroy)
            this.player.$destroy();
        delete this.player;
        this.player = null;

        if (bRuntime)
            this.$ext.innerHTML = "";
    };
}).call(apf.video.prototype = new apf.Media());

apf.aml.setElement("video", apf.video);

apf.video.TypeInterface = {
    properties: ["src", "width", "height", "volume", "showControls",
        "autoPlay", "totalTime", "mimeType"],

    /**
     * Set and/or override the properties of this object to the values
     * specified in the opions argument.
     *
     * @param {Object} options
     * @type {Object}
     */
    setOptions: function(options) {
        if (options == null) return this;
        // Create a hash of acceptable properties
        var hash = this.properties;
        for (var i = 0; i < hash.length; i++) {
            var prop = hash[i];
            if (options[prop] == null) continue;
            this[prop] = options[prop];
        }
        return this;
    },

    /**
     * Utility method; get an element from the browser's document object, by ID.
     *
     * @param {Object} id
     * @type {HTMLDomElement}
     */
    getElement: function(id) {
        var elem;

        if (typeof id == "object")
            return id;
        if (apf.isIE)
            return window[id];
        else {
            elem = document[id] ? document[id] : document.getElementById(id);
            if (!elem)
                elem = apf.lookup(id);
            return elem;
        }
    }
};




/*FILEHEAD(/var/lib/platform/source/trunk/elements/model.js)SIZE(38333)TIME(1264690337)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element functioning as the central access point for xml data. Data can be
 * retrieved from any data source using data instructions. Data can be
 * submitted using data instructions in a similar way to html form posts. The
 * modal can be reset to it's original state. It has support for offline use and
 * {@link element.remove synchronization between multiple clients}.
 * Example:
 * <code>
 *  <a:model src="products.xml" />
 * </code>
 * Example:
 * A small form where the bound data is submitted to a server using a model.
 * <code>
 *  <a:model id="mdlForm" submission="save_form.asp">
 *      <data name="Lukasz" address="Poland"></data>
 *  </a:model>
 * 
 *  <a:frame model="mdlForm">
 *      <a:label>Name</a:label>
 *      <a:textbox value="[@name]" />
 *      <a:label>Address</a:label>
 *      <a:textarea 
 *        value  = "[@address]" 
 *        width  = "100" 
 *        height = "50" />
 *      <a:button 
 *        default = "true" 
 *        action  = "submit">Submit</a:button>
 *  </a:frame>
 * </code>
 *
 * @event beforeretrieve    Fires before a request is made to retrieve data.
 *   cancelable: Prevents the data from being retrieved.
 * @event afterretrieve     Fires when the request to retrieve data returns both on success and failure.
 * @event receive           Fires when data is successfully retrieved
 *   object:
 *   {String} data  the retrieved data
 * @event beforeload        Fires before data is loaded into the model.
 *   cancelable:
 * @event afterload         Fires after data is loaded into the model.
 * @event beforesubmit      Fires before data is submitted.
 *   cancelable: Prevents the submit.
 *   object:
 *   {String} instruction The data instruction used to store the data.
 * @event submiterror       Fires when submitting data has failed.
 * @event submitsuccess     Fires when submitting data was successfull.
 * @event aftersubmit       Fires after submitting data.
 * @event error             Fires when a communication error has occured while making a request for this element.
 *   cancelable: Prevents the error from being thrown.
 *   bubbles:
 *   object:
 *   {Error}          error     the error object that is thrown when the event callback doesn't return false.
 *   {Number}         state     the state of the call
 *     Possible values:
 *     apf.SUCCESS  the request was successfull
 *     apf.TIMEOUT  the request has timed out.
 *     apf.ERROR    an error has occurred while making the request.
 *     apf.OFFLINE  the request was made while the application was offline.
 *   {mixed}          userdata  data that the caller wanted to be available in the callback of the http request.
 *   {XMLHttpRequest} http      the object that executed the actual http request.
 *   {String}         url       the url that was requested.
 *   {Http}           tpModule  the teleport module that is making the request.
 *   {Number}         id        the id of the request.
 *   {String}         message   the error message.
 *
 * @constructor
 * @define model
 * @allowchild [cdata], instance, load, submission
 * @addnode smartbinding, global
 * @attribute  {String}  src          the data instruction on how to load data from the data source into this model.
 * @attribute  {String}  submission   the data instruction on how to record the data from the data source from this model.
 * @attribute  {String}  session      the data instruction on how to store the session data from this model.
 * @attribute  {Boolean} autoinit     whether to initialize the model immediately. If set to false you are expected to call init() when needed. This is useful when the system has to log in first.
 * @attribute  {Boolean} save-original whether to save the original state of the data. This enables the use of the reset() call.
 * @attribute  {String}  remote       the id of the {@link element.remote} element to use for data synchronization between multiple clients.
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 */
apf.model = function(struct, tagName){
    this.$init(tagName || "model", apf.NODE_HIDDEN, struct);
    
    this.$amlNodes = {};
    this.$propBinds = {};
    
    this.$listeners = {};
    this.$proplisteners = {};

    if (!apf.globalModel) {
        apf.globalModel = this;
        apf.nameserver.register("model", "@default", this);
    }
};

(function(){
    this.$parsePrio = "020";
    this.$isModel   = true;
    
    this.canHaveChildren  = false;
    this["save-original"] = true;

    this.$state = 0;//1 = loading

    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        submission : 1,
        src        : 1,
        session    : 1
    }, this.$attrExcludePropBind);

    this.$booleanProperties["autoinit"] = true;
    this.$supportedProperties = ["submission", "src", "session", "autoinit", 
        "save-original", "remote"];
    
    this.$propHandlers["src"] = 
    this.$propHandlers["get"] = function(value, prop){
        if (this.$amlLoaded)
            this.$loadFrom(value);
    };

    this.$propHandlers["validation"] = function(value, prop){
        apf.nameserver.get("validation", value).register(this); //@todo error handling
    };
    
    
    //Connect to a remote smartbinding
    this.$propHandlers["remote"] = function(value, prop){
        if (this.rsb) {
            this.rsb.models.remove(this);
            this.rsb = null;
        }
        
        if (value) {
            this.rsb = apf.nameserver.get("remote", this.remote);

            
            if (!this.rsb || !this.rsb.models) {
                throw new Error(apf.formatErrorString(0, null,
                    "Loading AML into model",
                    "Could not find reference to remote smartbinding: '"
                    + this.getAttribute("remote") + "'", this))
            }
            

            this.rsb.models.push(this);
        }
    };
    

    
    this.validate = function(xmlNode, checkRequired, validityState, amlNode){
        if (!this.$validation) //@todo warn
            return;

        if (!xmlNode) {
            //Validate entire model.. not implemented yet...
        }
        else {
            validityState = this.$validation.validate(xmlNode, checkRequired, validityState);
            if (validityState.valid) {
                amlNode.clearError();
                return true;
            }
            else {
                amlNode.setError();
                return false;
            }
            
            //@todo detect amlNode based xmlNode this.$listeners
        }
    }
    //@todo add xmlupdate hook here
    
    

    /**
     * Registers a aml element to this model in order for the aml element to
     * receive data loaded in this model.
     *
     * @param  {AMLElement}  amlNode  The aml element to be registered.
     * @param  {String}      [xpath]  the xpath query which is executed on the
     *                                data of the model to select the node to be
     *                                loaded in the <code>amlNode</code>.
     * @return  {Model}  this model
     * @private
     */
    this.register = function(amlNode, xpath){
        if (!amlNode || !amlNode.load) //hasFeature(apf.__DATABINDING__))
            return this;

        //Remove previous model
        if (amlNode.$model && amlNode.$model != this)
            amlNode.$model.unregister(amlNode);

        //Register the aml node
        var item = this.$amlNodes[amlNode.$uniqueId] = {
            amlNode : amlNode, 
            xpath   : xpath
        };
        amlNode.$model = this;

        var p, node, list = amlNode.$propsUsingMainModel;
        for (var prop in list) {
            p = this.$bindXmlProperty(amlNode, prop, 
                    list[prop].xpath, list[prop].optimize);
            
            if (this.data) {
                if (node = p.root || p.listen ? this.data.selectSingleNode(p.root || p.listen) : this.data) {
                    amlNode.$execProperty(prop, node);
                }
                else
                    this.$waitForXml(amlNode, prop);
            }
        }

        if (typeof amlNode.noloading == "undefined"
          && amlNode.$setInheritedAttribute 
          && !amlNode.$setInheritedAttribute("noloading"))
            amlNode.noloading = false;

        //amlNode.$model = this;
        if (this.$state == 1) {
            if (amlNode.clear && !amlNode.noloading)
                amlNode.clear("loading");//@todo apf3.0
        }
        else if (this.data) {
            this.$loadInAmlNode(item);
            //this.$loadInAmlProp(amlNode);
        }
        else { //@experimental
            if (amlNode.clear)
                amlNode.clear("empty");
        }

        return this;
    };

    this.$register = function(amlNode, xpath){
        //@todo apf3.0 update this.$propBinds;
        
        this.$amlNodes[amlNode.$uniqueId].xpath = xpath;
    };

    /**
     * Removes a aml element from the group of registered aml elements.
     * The aml element will not receive any updates from this model, however
     * the data loaded in the aml element is not unloaded.
     *
     * @param  {AMLElement}  amlNode  The aml element to be unregistered.
     * @private
     */
    this.unregister = function(amlNode){
        delete this.$amlNodes[amlNode.$uniqueId];
        
        var list = amlNode.$propsUsingMainModel;
        for (var prop in list)
            this.$unbindXmlProperty(amlNode, prop);
    };

    /**
     * @private
     */
    this.getXpathByAmlNode = function(amlNode){
        var n = this.$amlNodes[amlNode.$uniqueId];
        if (!n)
            return false;

        return n.xpath;
    };
    
    /**
     * @private
     */
    this.$loadInAmlNode = function(item){
        var xmlNode;
        var xpath   = item.xpath;
        var amlNode = item.amlNode;
        
        if (this.data && xpath) {
            xmlNode = this.data.selectSingleNode(xpath);
        }
        else
            xmlNode = this.data || null;
        
        if (xmlNode) {
            delete this.$listeners[amlNode.$uniqueId];
            amlNode.load(xmlNode);
        }
        else 
            this.$waitForXml(amlNode);
    };
    
    this.$loadInAmlProp = function(id, xmlNode){
        var prop, node, p = this.$propBinds[id], amlNode = apf.all[id];
        
        for (prop in p) {
            if (node = p[prop].root ? xmlNode.selectSingleNode(p[prop].root) : xmlNode) {
                apf.xmldb.addNodeListener(xmlNode, amlNode, 
                  "p|" + id + "|" + prop + "|" + this.$uniqueId);
                
                delete this.$proplisteners[id];
                amlNode.$execProperty(prop, node);
            }
            else
                this.$waitForXml(amlNode, prop);
        }            
    };
    
    /*
        We don't want to connect to the root, that would create a rush
        of unnecessary update messages, so we'll find the element that's
        closest to the node that is going to feed us the value
        
        mdlBlah::bli/persons
        mdlBlah::bli/persons/person
        
        $attrBindings
        //split / join, pop, indexOf
        
        <j:textbox value="{persons/person/@blah}" width="{persons/blah/@width}" height="[@height]" model="mdlBlah::bli"/>
    */
    this.$bindXmlProperty = function(amlNode, prop, xpath, optimize, listenRoot) {
        var q ,p, id = amlNode.$uniqueId;
        if (!this.$propBinds[id]) 
            this.$propBinds[id] = {};

        /*
            Store
            0 - Original xpath
            1 - Store point of change listener
            2 - Xpath to determine data node passed into load
        */
        p = this.$propBinds[id][prop] = {
            bind: xpath
        };

        //@todo apf3.0
        //Optimize root point, doesnt work right now because it doesnt change the original rule
        if (optimize) {
            //Find xpath for bind on this model of the amlNode
            if ((q = this.$amlNodes[id]) && q.xpath)
                xpath = (p.root = q.xpath) + "/" + xpath;
            
            var l = xpath.split("/"), z = l.pop();
            if (z.indexOf("@") == 0 
              || z.indexOf("text()") > -1 
              || z.indexOf("node()") > -1) {
                p.listen = l.join("/");
            }
            else p.listen = xpath;
        }
        else {
            if ((q = this.$amlNodes[id]) && q.xpath)
                p.listen = q.xpath;
        }
        
        if (listenRoot)
            p.listen = ".";

        if (this.data) {
            var xmlNode = p.listen ? this.data.selectSingleNode(p.listen) : this.data;
            if (xmlNode) {
                apf.xmldb.addNodeListener(xmlNode, amlNode, 
                  "p|" + amlNode.$uniqueId + "|" + prop + "|" + this.$uniqueId);
                
                return p;
            }
        }
        
        this.$waitForXml(amlNode, prop);
        
        return p;
    };
    
    this.$unbindXmlProperty = function(amlNode, prop){
        var id = amlNode.$uniqueId;

        //@todo apf3.0
        var p = this.$propBinds[id] && this.$propBinds[id][prop];
        if (!p) return;
        
        if (this.data) {
            var xmlNode = p.listen ? this.data.selectSingleNode(p.listen) : this.data;
            if (xmlNode) {
                apf.xmldb.removeNodeListener(xmlNode, amlNode, 
                  "p|" + id + "|" + prop + "|" + this.$uniqueId);
            }
        }
        
        delete this.$proplisteners[id + prop];
        delete this.$propBinds[id][prop];
        return p;
    };

    /**
     * Gets a copy of current state of the xml of this model.
     *
     * @return  {XMLNode}  context of this model
     */
    this.getXml = function(){
        return this.data
            ? apf.xmldb.cleanNode(this.data.cloneNode(true))
            : false;
    };

    /**
     * Sets a value of an XMLNode based on an xpath statement executed on the data of this model.
     *
     * @param  {String}  xpath  the xpath used to select a XMLNode.
     * @param  {String}  value  the value to set.
     * @return  {XMLNode}  the changed XMLNode
     */
    this.setQueryValue = function(xpath, value){
        if (!this.data)
            return false;
        
        var node = apf.createNodeFromXpath(this.data, xpath);
        if (!node)
            return null;

        apf.setNodeValue(node, value, true);
        //apf.xmldb.setTextNode(node, value);
        return node;
    };

    /**
     * Gets the value of an XMLNode based on a xpath statement executed on the data of this model.
     *
     * @param  {String}  xpath  the xpath used to select a XMLNode.
     * @return  {String}  value of the XMLNode
     */
    this.queryValue = function(xpath){
        if (!this.data)
            return false;
        
        return apf.queryValue(this.data, xpath);
    };
	
    /**
     * Gets the value of an XMLNode based on a xpath statement executed on the data of this model.
     *
     * @param  {String}  xpath  the xpath used to select a XMLNode.
     * @return  {String}  value of the XMLNode
     */	
    this.queryValues = function(xpath){
        if (!this.data)
            return false;
        
        return apf.queryValue(this.data, xpath);
    };
	
    /**
     * Executes an xpath statement on the data of this model
     *
     * @param  {String}   xpath    the xpath used to select the XMLNode(s).
     * @return  {variant}  XMLNode or NodeList with the result of the selection
     */
    this.queryNode = function(xpath){
        if (!this.data)
            return null;
        
        return this.data.selectSingleNode(xpath)
    };

    /**
     * Executes an xpath statement on the data of this model
     *
     * @param  {String}   xpath    the xpath used to select the XMLNode(s).
     * @return  {variant}  XMLNode or NodeList with the result of the selection
     */
    this.queryNodes = function(xpath){
        if (!this.data)
            return null;
        
        return this.data.selectNodes(xpath);
    };

    /**
     * Appends a copy of the xmlNode or model to this model as a child
     * of it's root node
     */
    this.appendXml = function(xmlNode, xpath){
        var insertNode = xpath
          ? apf.createNodeFromXpath(this.data, xpath)
          : this.data;
        if (!insertNode)
            return null;
        
        if (typeof xmlNode == "string")
            xmlNode = apf.getXml(xmlNode);
        else {
            xmlNode = !xmlNode.nodeType //Check if a model was passed
                ? xmlNode.getXml()
                : apf.xmldb.getCleanCopy(xmlNode);
        }
        
        if (!xmlNode) return;

        apf.xmldb.appendChild(insertNode, xmlNode);
    };

    /**
     * Removes xmlNode from this model 
     */
    this.removeXml = function(xmlNode){
        if (typeof xmlNode == "string")
            xmlNode = this.data.selectNodes(xmlNode);
        else if (!xmlNode.length)
            xmlNode = [xmlNode];
        
        if (xmlNode)
            apf.xmldb.removeNodeList(xmlNode);
    };

    /**
     * Clears the loaded data from this model.
     */
    this.clear = function(){
        this.load(null);
        doc = null; //Fix for safari refcount issue;
    };

    /**
     * Resets data in this model to the last saved point.
     *
     */
    this.reset = function(){
        this.load(this.copy);
    };

    /**
     * Sets a new saved point based on the current state of the data in this
     * model. The reset() method returns the model to this point.
     */
    this.savePoint = function(){
        this.copy = apf.xmldb.getCleanCopy(this.data);
    };

    /**
     * @private
     */
    this.reloadAmlNode = function(uniqueId){
        if (!this.data)
            return;

        var item = this.$amlNodes[uniqueId];
        var xmlNode = item.xpath 
            ? this.data.selectSingleNode(item.xpath) 
            : this.data;
        item.amlNode.load(xmlNode);
    };

    /**
     * @private
     */
    //@todo refactor this to use .blah instead of getAttribute
    //@todo move this to propHandlers
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var x = this.$aml;
        
        if (this.parentNode.hasFeature(apf.__DATABINDING__)) {
            if (!this.name)
                this.setProperty("id", "model" + this.parentNode.$uniqueId);
            //this.parentNode.$aml.setAttribute("model", this.name); //@todo don't think this is necesary anymore...
            this.register(this.parentNode);
        }

        //Load literal model
        if (!this.src) {
            var strXml, xmlNode = x;
            if (xmlNode.childNodes.length) {
                if (apf.getNode(xmlNode, [0])) {
                    if ((strXml = xmlNode.xml || xmlNode.serialize()).match(/^[\s\S]*?>([\s\S]*)<[\s\S]*?$/)) {
                        strXml = RegExp.$1; //@todo apf3.0 test this with json
                        if (!apf.supportNamespaces)
                            strXml = strXml.replace(/xmlns=\"[^"]*\"/g, "");
                    }
                    
                    return this.load(apf.getXmlDom(strXml).documentElement);
                }
                // we also support JSON data loading in a model CDATA section
                else if (apf.isJson(xmlNode.childNodes[0].nodeValue)) {
                    return this.load(apf.getXmlDom(xmlNode.childNodes[0].nodeValue).documentElement);
                }
            }
            
            //Default data for XForms models without an instance but with a submission node
            if (this.submission)
                this.load("<data />");
        }

        //Load data into model if allowed
        if (!apf.isFalse(this.autoinit))
            this.init();

        //@todo actions apf3.0

        return this;
    });

    /**
     * Loads the initial data into this model.
     * @see element.model.attribute.init
     */
    //callback here is private
    this.init = function(callback){
        if (this.session) {
            this.$loadFrom(this.session, {isSession: true});
        }
        else {
            
            if (typeof apf.offline != "undefined" && apf.offline.models.enabled) {
                //Check if there's stored data
                if (apf.offline.models.loadModel(this)) {
                    return;
                }

                //Hmm we're offline, lets wait until we're online again
                //@todo this will ruin getting data from offline resources
                if (this.src && !apf.offline.onLine) {
                    apf.offline.models.addToInitQueue(this);
                    return;
                }
            }
            

            if (this.src)
                this.$loadFrom(this.src, {callback: callback});
        }
    };

    /* *********** LOADING ****************/

    /**
     * Loads data into this model using a data instruction.
     * @param {String}     instruction  the data instrution how to retrieve the data.
     * @param {Object}     options
     *   Properties:
     *   {XMLElement} xmlNode   the {@link term.datanode data node} that provides context to the data instruction.
     *   {Function}   callback  the code executed when the data request returns.
     *   {mixed}      []        Custom properties available in the data instruction.
     */
    this.$loadFrom = function(instruction, options){
        var data      = instruction.split(":");

        if (!options)
            options = {};

        if (!options.isSession) {
            this.src   = instruction;
            this.$srcOptions = [instruction, options];
        }

        //Loading data in non-literal model
        this.dispatchEvent("beforeretrieve");
        
        //Set all components on loading...        
        var uniqueId, item;
        for (uniqueId in this.$amlNodes) {
            if (!(item = this.$amlNodes[uniqueId]) || !item.amlNode)
                continue;

            //@todo apf3.0
            if (!item.amlNode.noloading)
                item.amlNode.clear("loading");
        }

        this.$state = 1;
        if (!this.$callCount)
            this.$callCount = 1;
        else
            this.$callCount++;

        var _self     = this,
            callCount = this.$callCount,
            callback  = options.callback;
        options.callback = function(data, state, extra){
            if (callCount != _self.$callCount)
                return; //another call has invalidated this one
            
            _self.dispatchEvent("afterretrieve");

            
            if (state == apf.OFFLINE) {
                apf.offline.models.addToInitQueue(this);
                return false;
            }
            

            if (state != apf.SUCCESS) {
                var oError;

                oError = new Error(apf.formatErrorString(1032,
                    _self, "Inserting xml data", "Could not load data "
                  + "Instruction:" + instruction + "\n"
                  + "Url: " + extra.url + "\n"
                  + "Info: " + extra.message + "\n\n" + data));

                if (callback && callback.apply(this, arguments) === true)
                    return true;

                if (extra.tpModule && extra.tpModule.retryTimeout(extra, state, _self, oError) === true)
                    return true;

                _self.$state = 0;

                throw oError;
            }

            if (options && options.isSession && !data) {
                if (this.src)
                    return _self.$loadFrom(this.src);
            }
            else {
                if (options && options.cancel)
                    return;

                _self.load(data);
                _self.dispatchEvent("receive", {
                    data: data
                });

                if (callback)
                    callback.apply(this, arguments);
            }
        };

        return apf.getData(instruction, options);
    };
    
    /**
     * Loads the data from the datasource specified for init.
     */
    this.reload = function(){
        if (!this.data)
            return;
        
        if (this.$srcOptions)
            this.$loadFrom.apply(this, this.$srcOptions);
        else if (this.src)
            this.$loadFrom(this.src);
    };

    /**
     * Loads data in this model
     *
     * @param  {XMLElement} [xmlNode]  the data to load in this model. null will clear the data from this model.
     * @param  {Boolean}    [nocopy]   Whether the data loaded will not overwrite the reset point.
     */
    this.load = function(xmlNode, options){
        if (typeof xmlNode == "string") {
            if (xmlNode.charAt(0) == "<") {
                if (xmlNode.substr(0, 5).toUpperCase() == "<!DOC")
                    xmlNode = xmlNode.substr(xmlNode.indexOf(">")+1);
                xmlNode = apf.getXmlDom(xmlNode, null, true).documentElement; //@todo apf3.0 whitespace issue
            }
            else
                return this.$loadFrom(xmlNode, options);
        }

        if (this.ownerDocument && this.ownerDocument.$domParser.$shouldWait) {
            var _self = this;
            apf.queue.add("modelload" + this.$uniqueId, function(){
                _self.load(xmlNode, options);
            });
            return;
        }
        
        this.$state = 0;

        if (this.dispatchEvent("beforeload", {xmlNode: xmlNode}) === false)
            return false;

        var doc = xmlNode ? xmlNode.ownerDocument : null; //Fix for safari refcount issue;

        //if (apf.isIE && this.$aml && this.getAttribute("ns"))
            //doc.setProperty("SelectionNamespaces", this.getAttribute("ns"));
        
        if (xmlNode) {
            if (!apf.supportNamespaces && (xmlNode.prefix || xmlNode.scopeName))
                doc.setProperty("SelectionNamespaces", "xmlns:"
                     + (xmlNode.prefix || xmlNode.scopeName) + "='"
                     + xmlNode.namespaceURI + "'");
            
            apf.xmldb.addNodeListener(xmlNode, this); //@todo this one can be added for this.$listeners and when there are none removed
            apf.xmldb.nodeConnect(
                apf.xmldb.getXmlDocId(xmlNode, this), xmlNode, null, this);

            if ((!options || !options.nocopy) && this["save-original"])
                this.copy = apf.xmldb.getCleanCopy(xmlNode);
        }

        this.data = xmlNode;
        
        for (var id in this.$amlNodes)
            this.$loadInAmlNode(this.$amlNodes[id]);

        for (id in this.$propBinds)
            this.$loadInAmlProp(id, xmlNode);

        this.dispatchEvent("afterload", {xmlNode: xmlNode});

        return this;
    };
    
    //Listening nodes should be removed in unregister
    this.$waitForXml = function(amlNode, prop){
        if (prop)
            this.$proplisteners[amlNode.$uniqueId + prop] = {
                id      : amlNode.$uniqueId, 
                amlNode : amlNode, 
                prop    : prop
            };
        else 
            this.$listeners[amlNode.$uniqueId] = amlNode;
        
        //@todo apf3.0 this was useful for something, i'm sure it was
        //node.xmlRoot = null; //.load(null)
        //if (amlNode.xmlRoot)
            //amlNode.clear();
    };
    
    this.$xmlUpdate = function(action, xmlNode, listenNode, UndoObj){
        //@todo optimize by only doing this for add, sync etc actions
        
        
        
        var p, b;
        for (var id in this.$listeners) {
            if (xmlNode = this.data.selectSingleNode(this.$amlNodes[id].xpath || ".")) {
                this.$listeners[id].load(xmlNode);
                delete this.$listeners[id];
            }
        }

        for (id in this.$proplisteners) {
            p = this.$proplisteners[id];
            b = this.$propBinds[p.id][p.prop];
            if (xmlNode = b.listen ? this.data.selectSingleNode(b.listen) : this.data) {
                apf.xmldb.addNodeListener(xmlNode, p.amlNode, 
                  "p|" + p.id + "|" + p.prop + "|" + this.$uniqueId);
                
                delete this.$proplisteners[id];
                p.amlNode.$execProperty(p.prop, b.root 
                  ? this.data.selectSingleNode(b.root) 
                  : this.data);
            }
        }
    };

    /**** INSERT ****/

    /**
     * Inserts data into the data of this model using a data instruction.
     * @param {String}     instruction  the data instrution how to retrieve the data.
     * @param {XMLElement} xmlContext   the {@link term.datanode data node} that provides context to the data instruction.
     * @param {Object}     options
     *   Properties:
     *   {XMLElement} insertPoint  the parent element for the inserted data.
     *   {mixed}      <>           Custom properties available in the data instruction.
     * @param {Function} callback       the code executed when the data request returns.
     */
    this.$insertFrom = function(instruction, options){
        if (!instruction) return false;

        this.dispatchEvent("beforeretrieve");

        
        var amlNode = options.amlNode;
        

        var callback = options.callback, _self = this;
        options.callback = function(data, state, extra){
            _self.dispatchEvent("afterretrieve");

            if (!extra)
                extra = {};

            if (state != apf.SUCCESS) {
                var oError;

                
                oError = new Error(apf.formatErrorString(1032,
                    _self, "Inserting xml data", "Could not insert data for "
                  + "Instruction:" + instruction + "\n"
                  + "Url: " + extra.url + "\n"
                  + "Info: " + extra.message + "\n\n" + data));
                

                if (extra.tpModule.retryTimeout(extra, state, 
                  options.amlNode || _self, oError) === true)
                    return true;

                throw oError;
            }

            
            if (!options.insertPoint) {
                throw new Error(apf.formatErrorString(0, amlNode || _self,
                    "Inserting data", "Could not determine insertion point for "
                  + "instruction: " + instruction));
            }
            

            //Checking for xpath
            if (typeof options.insertPoint == "string")
                options.insertPoint = _self.data.selectSingleNode(options.insertPoint);

            if (typeof options.clearContents == "undefined" && extra.userdata) 
                options.clearContents = apf.isTrue(extra.userdata[1]); //@todo is this still used?

            //Call insert function
            (options.amlNode || _self).insert(data, options);

            if (callback)
                callback.call(this, extra.data);
        };

        apf.getData(instruction, options);
    };

    /**
     * Inserts data in this model as a child of the currently loaded data.
     *
     * @param  {XMLElement} XMLRoot         the {@link term.datanode data node} to insert into this model.
     * @param {Object}     options
     *   Properties:
     *   {XMLElement} insertPoint  the parent element for the inserted data.
     *   {Boolean}    copyAttribute  wether the attributes of the merged element are copied.
     *   {mixed}      <>           Custom properties available in the data instruction.
     */
    this.insert = function(xmlNode, options){
        if (typeof xmlNode == "string") {
            if (xmlNode.charAt(0) == "<")
                xmlNode = apf.getXmlDom(xmlNode).documentElement;
            else
                return this.$insertFrom(xmlNode, options);
        }
        
        if (!options.insertPoint)
            options.insertPoint = this.data;

        //if(this.dispatchEvent("beforeinsert", parentXMLNode) === false) return false;

        //Integrate XMLTree with parentNode
        if (typeof options.copyAttributes == "undefined")
            options.copyAttributes = true;
        
        var newNode = apf.mergeXml(xmlNode, options.insertPoint, options);

        //Call __XMLUpdate on all this.$listeners
        apf.xmldb.applyChanges("insert", options.insertPoint);//parentXMLNode);

        //this.dispatchEvent("afterinsert");

        return xmlNode;
    };

    /* *********** SUBMISSION ****************/

    /**
     * Serialize the full XML DOM to a format specified by 'type'
     * 
     * @param {String} type  how to serialize the data
     */
    this.convertXml = function(type) {
        if (!type)
            return this.data.xml;

        return apf.convertXml(this.data, type);
    };

    /**
     * Submit the data of the model to a data source.
     * @param {String} type         how to serialize the data.
     *   Possible values:
     *   xml, application/xml
     *   form, application/x-www-form-urlencoded
     *   json, application/json
     * @param {String} instruction  the instruction for sending the data, or the url to send the data to.
     * @param {XMLElement} xmlNode  the data node to send to the server.
     */
     //@todo rewrite this for apf3.0
    this.submit = function(instruction, type, xmlNode, type, useComponents, xSelectSubTree){
        if (!instruction)
            instruction = this.submission;
        
        if (!xmlNode)
            xmlNode = this.data;

        
        if (!xmlNode) {
            throw new Error(apf.formatErrorString(0, this, 
                "Submitting model",
                "Could not submit data, because no data was passed and the "
              + "model does not have data loaded."));
        }
        

        if (!type)
            type = "form";

        if (this.dispatchEvent("beforesubmit", {
            instruction: instruction
        }) === false)
            return false;

        var model = this;
        function cbFunc(data, state, extra){
            if ((state == apf.TIMEOUT 
              || (model.retryOnError && state == apf.ERROR))
              && extra.retries < apf.maxHttpRetries) {
                return extra.tpModule.retry(extra.id);
            }
            else {
                if (state != apf.SUCCESS) {
                    model.dispatchEvent("submiterror", extra);
                }
                else {
                    model.dispatchEvent("submitsuccess", apf.extend({
                        data: data
                    }, extra));
                }
            }
        }
        
        var data;
        if (type.indexOf("xml") > -1)
            data = apf.getXmlString(xmlNode);
        else if (type.indexOf("form") > -1)
            data = apf.convertXml(apf.xmldb.getCleanCopy(xmlNode), "cgiobjects");
        else if (type.indexOf("json") > -1)
            data = apf.convertXml(xmlNode, "json");

        apf.saveData(instruction, {
            xmlNode  : xmlNode,
            data     : data,
            callback : cbFunc
        });

        this.dispatchEvent("aftersubmit");
    };

    this.$destroy = function(){
        if (this.session && this.data)
            apf.saveData(this.session, {xmlNode: this.getXml()});
    };
}).call(apf.model.prototype = new apf.AmlElement());

apf.aml.setElement("model", apf.model);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/list.js)SIZE(14293)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element displaying a skinnable list of options which can be selected.
 * Selection of multiple items can be allowed. Items can be renamed
 * and removed. The list can be used as a collection of checkboxes or 
 * radiobuttons. This is especially useful for use in forms.
 * This element is one of the most often used elements. It can display lists
 * of items in a cms style interface or display a list of search results in 
 * a more website like interface.
 * Example:
 * A simple list with inline items.
 * <code>
 *  <a:list multiselect="false">
 *      <a:item>The Netherlands</a:item>
 *      <a:item>United States of America</a:item>
 *      <a:item>United Kingdom</a:item>
 *      ...
 *  </a:list>
 * </code>
 * Example:
 * A databound list with items loaded from an xml file.
 * <code>
 *  <a:list model="friends.xml" each="[friend]" caption="[@name]" />
 * </code>
 * Example:
 * A databound list using the bindings element
 * <code>
 *  <a:model id="mdlList">
 *      <data>
 *          <item date="2009-11-12" deleted="0"></item>
 *          <item date="2009-11-11" deleted="0"></item>
 *          <item date="2009-11-10" deleted="0"></item>
 *          <item date="2009-11-09" deleted="1"></item>
 *          <item date="2009-11-08" deleted="1"></item>
 *      </data>
 *  </a:model>
 *  <a:list id="list" width="200" height="200" model="mdlList">
 *      <a:bindings>
 *          <a:caption match="[@date]" />
 *          <a:each match="[item[not(@deleted='1')]]" />
 *      </a:bindings>
 *  </a:list>
 * </code>
 *
 * @event click Fires when a user presses a mouse button while over this element.
 *
 * @constructor
 * @define list, select, select1, thumbnail
 * @allowchild {smartbinding}
 * @addnode elements
 *
 * @inherits apf.BaseList
 * @inherits apf.Rename
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.list      = function(struct, tagName){
    this.$init(tagName || "list", apf.NODE_VISIBLE, struct);
};

/**
 * Example:
 * A small product search application using a list to display results.
 * <code>
 *  <a:bar>
 *      <h1>Search for a product</h1>
 *      <a:textbox id="txtSearch" selectfocus="true" />
 *      <a:button onclick="search()" default="true">Search</a:button>
 *  </a:bar>
 * 
 *  <a:model id="mdlSearch">
 *      <data>
 *          <item title="Title 1" src="siteimg/slideshow_img/img1_small.jpg" descr="Descr 1"></item>
 *          <item title="Title 2" src="siteimg/slideshow_img/img2_small.jpg" descr="Descr 2"></item>
 *      </data>
 *  </a:model>
 * 
 *  <a:thumbnail 
 *    model         = "mdlSearch"
 *    autoselect    = "false" 
 *    width         = "400"
 *    height        = "400"
 *    caching       = "false" 
 *    empty-message = "No products found">
 *      <a:bindings>
 *          <a:caption match="[@title]" />
 *          <a:image match="[@src]" />
 *          <a:each match="[item]" />
 *      </a:bindings>
 *  </a:thumbnail>
 * 
 *  <a:script>
 *      function search(){
 *          mdlSearch.$loadFrom("http://localhost/search.php?keyword=" + txtSearch.getValue());
 *      }
 *  </a:script>
 * </code>
 */
apf.thumbnail = function(struct, tagName){
    this.$init(tagName || "thumbnail", apf.NODE_VISIBLE, struct);
};

apf.select    = function(struct, tagName){
    this.$init(tagName || "select", apf.NODE_VISIBLE, struct);
};

apf.select1   = function(struct, tagName){
    this.$init(tagName || "selectl", apf.NODE_VISIBLE, struct);
};

(function(){
    
    if (!apf.isIphone)
        this.implement(apf.Rename);
    
    
    
    this.$getCaptionElement = function(){
        if (!(this.$caret || this.$selected))
            return;
        
        var x = this.$getLayoutNode("item", "caption", this.$caret || this.$selected);
        if (!x) 
            return;
        return x.nodeType == 1 ? x : x.parentNode;
    };
    
    
    
    this.addEventListener("afterselect", function(e){
        if (this.hasFeature(apf.__VALIDATION__)) 
            this.validate(true);
    });
    
    
    /**** Properties and Attributes ****/
    
    this.$supportedProperties.push("appearance", "mode", "more", "thumbsize");
    
    this.$propHandlers["thumbsize"] = function(value){
        var className = this.thumbclass;
        
        if (apf.isIE) { //@todo detection??
            className = className.splitSafe(",");
            for (var i = 0; i < className.length; i++) {
                apf.setStyleRule(className[i], "width", value + "px");
                apf.setStyleRule(className[i], "height",  value + "px");
            }
            return;
        }
        
        apf.setStyleRule(className, "width", value + "px");
        apf.setStyleRule(className, "height",  value + "px");
    };
    
    
    /**
     * @attribute {String} appearance the type of select this element is. 
     * This is an xforms property and only available if apf is compiled 
     * with __WITH_XFORMS set to 1.
     *   Possible values:
     *   full     depending on the tagName this element is either a list of radio options or of checked options.
     *   compact  this elements functions like a list with multiselect off.
     *   minimal  this element functions as a dropdown element.
     */
    this.$propHandlers["appearance"] = function(value){
        
    };
    
    /**
     * @attribute {String} mode Sets the way this element interacts with the user.
     *   Possible values:
     *   check  the user can select a single item from the list. The selected item is indicated.
     *   radio  the user can select multiple items from a list. Each selected item is indicated.
     */
    this.mode = "normal";
    this.$propHandlers["mode"] = function(value){
        this.mode = value || "normal";
        
        if ("check|radio".indexOf(this.mode) > -1) {
            this.allowdeselect = false;
            
            this.addEventListener("afterrename", $afterRenameMode);
            
            if (this.mode == "check") {
                this.autoselect = false;
                this.ctrlselect    = true;
            }
            else if (this.mode == "radio")
                this.multiselect = false;
            
            //if (!this.actionRules) //default disabled
                //this.actionRules = {}
        }
        else {
            //@todo undo actionRules setting
            this.ctrlselect = false;
            this.removeEventListener("afterrename", $afterRenameMode);
        }
    };
    
    //@todo apf3.0 retest this completely
    function $afterRenameMode(){
    }
    
    
    /**
     * @attribute {String} more Adds a new item to the list and lets the users 
     * type in the new name. This is especially useful in the interface when 
     * {@link element.list.attribute.mode} is set to check or radio. For instance in a form.
     * Example:
     * This example shows a list in form offering the user several options. The
     * user can add a new option. A server script could remember the addition
     * and present it to all new users of the form.
     * <code>
     *  <a:model id="mdlSuggestions">
     *      <suggestions>
     *          <question key="krant">
     *              <answer>Suggestion 1</answer>
     *              <answer>Suggestion 2</answer>
     *          </question>
     *      </suggestions>
     * </a:model>
     * <a:label>Which newspapers do you read?</a:label>
     * <a:list value="[krant]" 
     *   more  = "caption:Add new suggestion" 
     *   model = "[mdlSuggestions::question[@key='krant']]">
     *     <a:bindings>
     *         <a:caption match="[text()]" />
     *         <a:value match="[text()]" />
     *         <a:each match="[answer]" />
     *     </a:bindings>
     *     <a:actions>
     *         <a:rename match="[node()[@custom='1']]" />
     *         <a:remove match="[node()[@custom='1']]" />
     *         <a:add>
     *             <answer custom="1">New Answer</answer>
     *         </a:add>
     *     </a:actions>
     *  </a:list>
     * </code>
     */
    this.$propHandlers["more"] = function(value){
        if (value) {
            this.delayedselect = false;
            this.addEventListener("xmlupdate", $xmlUpdate);
            this.addEventListener("afterload", $xmlUpdate);
            //this.addEventListener("afterrename", $afterRenameMore);
            //this.addEventListener("beforeselect", $beforeSelect);
            
            this.$setClearMessage    = function(msg){
                if (!this.moreItem)
                    this.$fill();
                this.$int.appendChild(this.moreItem);
            };
            this.$updateClearMessage = function(){}
            this.$removeClearMessage = function(){};
        }
        else {
            this.removeEventListener("xmlupdate", $xmlUpdate);
            this.removeEventListener("afterload", $xmlUpdate);
            //this.removeEventListener("afterrename", $afterRenameMore);
            //this.removeEventListener("beforeselect", $beforeSelect);
        }
    };
    
    function $xmlUpdate(e){
        if ((!e.action || "insert|add|synchronize|move".indexOf(e.action) > -1) && this.moreItem)
            this.$int.appendChild(this.moreItem);
    }
    
    /*function $afterRenameMore(){
        var caption = this.$applyBindRule("caption", this.caret)
        var xmlNode = this.findXmlNodeByValue(caption);

        var curNode = this.caret;
        if (xmlNode != curNode || !caption) {
            if (xmlNode && !this.isSelected(xmlNode)) 
                this.select(xmlNode);
            this.remove(curNode);
        }
        else 
            if (!this.isSelected(curNode)) 
                this.select(curNode);
    }
    
    function $beforeSelect(e){
        //This is a hack
        if (e.xmlNode && this.isSelected(e.xmlNode) 
          && e.xmlNode.getAttribute('custom') == '1') {
            this.setCaret(e.xmlNode);
            this.selected = e.xmlNode;
            debugger;
            $setTimeout(function(){
                _self.startRename()
            });
            return false;
        }
    }*/
    
    
    /**** Keyboard support ****/
    
    
    this.addEventListener("keydown", this.$keyHandler, true);
    
    
    /**** Init ****/
    
    this.$draw = function(){
        this.appearance = this.getAttribute("appearance") || "compact";
        var mode = this.getAttribute("mode");

        //@todo apf3.0 checkmode, radiomode
        /*if (this.localName == "select" && (this.appearance == "full" 
          || this.appearance == "minimal") || mode == "check") {
            this.$aml.setAttribute("mode", "check");
            if (!this.getAttribute("skin")) {
                this.skinName = null;
                this.skin = "checklist"
                this.$loadSkin();
            }
        }
        else if (this.localName == "select1" && this.appearance == "full"
          || mode == "radio") {
            this.$aml.setAttribute("mode", "radio");
            if (!this.getAttribute("skin")) {
                this.skinName = null;
                this.skin = "radiolist";
                this.$loadSkin();
            }
        }
        else if (this.localName == "select1" && this.appearance == "compact") 
            this.multiselect = false;*/
        
        //Build Main Skin
        this.$ext = this.$getExternal();
        this.$int = this.$getLayoutNode("main", "container", this.$ext);
        
        if (apf.hasCssUpdateScrollbarBug && !this.mode)
            this.$fixScrollBug();
        
        var _self = this;
        this.$ext.onclick = function(e){
            _self.dispatchEvent("click", {
                htmlEvent: e || event
            });
        }
        
        //Get Options form skin
        //Types: 1=One dimensional List, 2=Two dimensional List
        this.listtype  = parseInt(this.$getOption("main", "type")) || 1;
        //Types: 1=Check on click, 2=Check independent
        this.behaviour = parseInt(this.$getOption("main", "behaviour")) || 1; 
        
        this.thumbsize  = this.$getOption("main", "thumbsize");
        this.thumbclass = this.$getOption("main", "thumbclass");
    };
    
    this.$loadAml = function(x){
    };
    
    this.$destroy = function(){
        if (this.$ext)
            this.$ext.onclick = null;
        apf.destroyHtmlNode(this.oDrag);
        this.oDrag = null;
    };
}).call(apf.list.prototype = new apf.BaseList());

apf.thumbnail.prototype =
apf.select.prototype    =
apf.select1.prototype   = apf.list.prototype;

apf.aml.setElement("thumbnail", apf.thumbnail);
apf.aml.setElement("select",    apf.select);
apf.aml.setElement("select1",   apf.select1);
apf.aml.setElement("list",      apf.list);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/errorbox.js)SIZE(5968)TIME(1259091146)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Element showing an error message when the attached element 
 * is in erroneous state and has the invalidmsg="" attribute specified.
 * In most cases the errorbox element is implicit and will be created 
 * automatically. 
 * Example:
 * <code>
 *  <a:errorbox>
 *      Invalid e-mail address entered.
 *  </a:errorbox>
 * </code>
 * Remarks:
 * In most cases the errorbox element is not created directly but implicitly
 * by a validationgroup. An element that goes into an error state will
 * show the errorbox.
 * <code>
 *  <a:bar validgroup="vgForm">
 *      <a:label>Phone number</a:label>
 *      <a:textbox id="txtPhone"
 *          required   = "true" 
 *          pattern    = "(\d{3}) \d{4} \d{4}" 
 *          invalidmsg = "Incorrect phone number entered" />
 *
 *      <a:label>Password</a:label>
 *      <a:textbox 
 *          required   = "true" 
 *          mask       = "password"
 *          minlength  = "4"
 *          invalidmsg = "Please enter a password of at least four characters" />
 *  </a:bar>
 * </code>
 *
 * To check if the element has valid information entered, leaving the textbox
 * (focussing another element) will trigger a check. Programmatically a check
 * can be done using the following code:
 * <code>
 *  txtPhone.validate();
 * 
 *  //Or use the html5 syntax
 *  txtPhone.checkValidity();
 * </code>
 *
 * To check for the entire group of elements use the validation group. For only 
 * the first non-valid element the errorbox is shown. That element also receives
 * focus.
 * <code>
 *  vgForm.validate();
 * </code>
 *
 * @constructor
 * @define errorbox
 * 
 * @allowchild {anyxhtml}
 * @addnode elements
 *
 * @inherits apf.Presentation
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.errorbox = function(struct, tagName){
    this.$init(tagName || "errorbox", apf.NODE_VISIBLE, struct);
};

(function(){
    this.$positioning = "basic";
    this.display = function(host){
        this.host = host;
        
        var refHtml = 
            
            host.validityState.$errorHtml || 
            
            host.$ext;

        document.body.appendChild(this.$ext);
        /*var pos = apf.getAbsolutePosition(refHtml, document.body);

        if (document != refHtml.ownerDocument) {
            var pos2 = apf.getAbsolutePosition(refHtml.ownerDocument.parentWindow.frameElement, document.body);
            pos[0] += pos2[0];
            pos[1] += pos2[1];
        }*/

        var x = (parseFloat(host.$getOption && host.$getOption("main", "erroffsetx") || 0)),
            y = (parseFloat(host.$getOption && host.$getOption("main", "erroffsety") || 0));
        //this.$ext.style.left = x + "px"
        //this.$ext.style.top  = y + "px"

        this.show();
        apf.popup.show(this.$uniqueId, {
            x       : x,
            y       : y,
            animate : false,
            ref     : refHtml
        });

        this.$setStyleClass(this.$ext,
            x + this.$ext.offsetWidth > this.$ext.offsetParent.offsetWidth
                ? "rightbox"
                : "leftbox", ["leftbox", "rightbox"]);
    };
    
    /**
     * Sets the message of the errorbox.
     * @param {String} value 
     */
    this.setMessage = function(value){
        if (value && value.indexOf(";") > -1) {
            value = value.split(";");
            value = "<strong>" + value[0] + "</strong>" + value[1];
        }
        this.$int.innerHTML = value || "";
    };
    
    this.$draw = function(){
        //Build Main Skin
        this.$ext   = this.$getExternal(); 
        this.$int   = this.$getLayoutNode("main", "container", this.$ext);
        this.oClose = this.$getLayoutNode("main", "close", this.$ext);
        
        if (this.oClose) {
            var _self = this;
            this.oClose.onclick = function(){
                _self.hide();

                if (apf.document.activeElement)
                    apf.document.activeElement.focus(true, {mouse:true});
            };
        }
        
        this.$ext.onmousedown = function(e){
            (e || event).cancelBubble = true;
            
            
            if (apf.hasFocusBug)
                apf.window.$focusfix();
            
        }

        this.hide();
        
        apf.popup.setContent(this.$uniqueId, this.$ext, "", null, null);
    };
    
    this.$loadAml = function(x){
    };
    
    this.$destroy = function(){
        if (this.oClose)
            this.oClose.onclick = null;
        
        this.$ext.onmousedown = null;
        
        apf.popup.removeContent(this.$uniqueId);
    };
}).call(apf.errorbox.prototype = new apf.Presentation());

apf.aml.setElement("errorbox", apf.errorbox);


/*FILEHEAD(/var/lib/platform/source/trunk/elements/services.js)SIZE(1492)TIME(1257329183)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.services = function(struct, tagName){
    this.$init(tagName || "services", apf.NODE_VISIBLE, struct);
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(aml){
        var pNode = this.parentNode;
        if (pNode.register)
            pNode.register(this);
    });
};

apf.services.prototype = new apf.AmlElement();
apf.aml.setElement("services", apf.services);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/validation.js)SIZE(3779)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @define validation 
 *
 * @constructor
 * @apfclass
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 *
 * @default_private
 */
apf.validation = function(struct, tagName){
    this.$init(tagName || "validation", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$rules = [];
    
    var amlNodes = {};
    this.register = function(amlNode){
        if (amlNode.tagName != "model")
            return;
        
        amlNodes[amlNode.$uniqueId] = amlNode;
        
        amlNode.$validation = this;
        
        //each child should register
    }

    this.unregister = function(){
        //unregister element
        amlNodes[amlNode.$uniqueId] = null;
        delete amlNodes[amlNode.$uniqueId];
        
        amlNode.$validation = null;
    };
    
    this.getRule = function(xmlNode){
        /*var rules = this.$rules[name];
        //@todo Shouldn't allow async calls..., should always give a function
        for (var rule, i = 0, l = rules.length; i < l; i++) {
            var rule = rules[i];
            if ((rule[1] || (rule[1] = (rule[5] = apf.lm.compileMatch(rule[0]))[0] ||apf.K))(xmlNode)) 
                return rule;
        }*/

        var id = apf.xmldb.nodeConnect(apf.xmldb.getXmlDocId(xmlNode), xmlNode.nodeType == 1 ? xmlNode : xmlNode.parentNode);
        for (var i = 0, l = this.$rules.length; i < l; i++) {
            if (xmlNode.ownerDocument.selectSingleNode("(.//" + this.$rules[i][0].split("|").join("|.//") + ")[@" + apf.xmldb.xmlIdTag + "='" + id + "']"))
                return this.$rules[i][1];
        }
    }
    
    this.validate = function(xmlNode, checkRequired, validityState){
        var rule = this.getRule(xmlNode);
        if (!rule) return validityState;
        
        return (rule.isValid || (rule.isValid 
          = apf.validator.compile(rule)))(apf.queryValue(xmlNode), checkRequired, validityState);
    }
    
    //@todo add DOM handlers
    
    /**
     * @private
     */
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var x = this.$aml;
        
        var rule, attr, node, nodes = x.childNodes;
        for (var i = 0, l = nodes.length; i < l; i++) {
            if ((node = nodes[i]).nodeType != 1)
                continue;
            this.$rules.push([node.getAttribute("match"), (rule = {})]);
            attr = node.attributes;
            for (var j = 0; j < attr.length; j++)
                rule[attr[j].nodeName] = attr[j].nodeValue;
            rule.node = node;
        }
        
        this.register(this.parentNode);
    });
}).call(apf.validation.prototype = new apf.AmlElement());

apf.aml.setElement("validation", apf.validation);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/splitter.js)SIZE(18374)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @constructor
 * @private
 */
apf.splitter = function(struct, tagName){
    this.$init(tagName || "splitter", apf.NODE_VISIBLE, struct);
    
    
    apf.plane.init();
    
};

(function() {
    this.$focussable = true; // This object can get the focus
    
    /* ********************************************************************
                                        PUBLIC METHODS
    *********************************************************************/
    
    this.update = function(){
        //Optimize this to not recalc for certain cases
        var b = (this.type == "vertical")
            ? {
                fsize      : "fwidth",
                size       : "width",
                offsetPos  : "offsetLeft",
                offsetSize : "offsetWidth",
                pos        : "left"
              }
            : {
                fsize      : "fheight",
                size       : "height",
                offsetPos  : "offsetTop",
                offsetSize : "offsetHeight", 
                pos        : "top"
              };
        
        this.$ext.offsetTop; //@weird somehow this will fix a problem in IE8
        
        this.$amlNode = this.refNode;
        var htmlNode  = this.refHtml;

        var v          = apf.layout.vars;
        var oItem      = this.oItem;
        var needRecalc = false;
        
        var itemStart = htmlNode 
            ? htmlNode[b.offsetPos] 
            : v[b.pos + "_" + oItem.id];
        var itemSize  = htmlNode 
            ? htmlNode[b.offsetSize] 
            : v[b.size + "_" + oItem.id];

        var row = oItem.parent.children;
        for (var z = 0, i = 0; i < row.length; i++)
            if (!row[i][b.fsize])
                z++;

        if (!oItem[b.fsize] && z > 1) {
            for (var rTotal = 0, rSize = 0, i = oItem.stackId + 1; i < row.length; i++) {
                if (!row[i][b.fsize]) {
                    rTotal += row[i].weight || 1;
                    rSize  += (row[i].node 
                        ? row[i].oHtml[b.offsetSize] 
                        : v[b.size + "_" + row[i].id]);
                }
            }
            
            var diff  = this.$ext[b.offsetPos] - itemStart - itemSize;
            var rEach = (rSize - diff)/rTotal;
            
            for (var i = 0; i < oItem.stackId; i++) {
                if (!row[i][b.fsize])
                    row[i].original.weight = (row[i].node 
                        ? row[i].oHtml[b.offsetSize] 
                        : v[b.size + "_" + row[i].id]) / rEach;
            }

            oItem.original.weight = (itemSize + diff) / rEach
            needRecalc = true;
        }
        else {
            var isNumber     = oItem[b.fsize] ? oItem[b.fsize].match(/^\d+$/) : false;
            var isPercentage = oItem[b.fsize] ? oItem[b.fsize].match(/^([\d\.]+)\%$/) : false;
            if (isNumber || isPercentage || !oItem[b.fsize]) {
                var diff      = this.$ext[b.offsetPos] - itemStart - itemSize;
                var newHeight = this.$ext[b.offsetPos] - itemStart;
                
                for (var total = 0, size = 0, i = oItem.stackId + 1; i < row.length; i++) {
                    if (!row[i][b.fsize]) {
                        total += row[i].weight || 1;
                        size  += (row[i].node 
                            ? row[i].oHtml[b.offsetSize] 
                            : v[b.size + "_" + row[i].id]);
                    }
                }
                
                if (total > 0) {
                    var ratio = ((size-diff)/total)/(size/total);
                    for (var i = oItem.stackId + 1; i < row.length; i++)
                        row[i].original.weight = ratio * (row[i].weight || 1);
                }
                else {
                    for (var i = oItem.stackId + 1; i < row.length; i++) {
                        if (row[i][b.fsize].match(/^\d+$/)) {
                            //should check for max here as well
                            var nHeight = (row[i].node 
                                ? row[i].oHtml[b.offsetSize] 
                                : v[b.size + "_" + row[i].id]) - diff;
                            row[i].original[b.fsize] = "" + Math.max(0, nHeight, row[i].minheight || 0);
                            if (row[i][b.fsize] - nHeight != 0) 
                                diff = row[i][b.fsize] - nHeight;
                            else
                                break;
                        }
                        else
                            if (row[i][b.fsize].match(/^([\d\.]+)\%$/)) {
                                var nHeight = (row[i].node 
                                    ? row[i].oHtml[b.offsetSize] 
                                    : v[b.size + "_" + row[i].id]) - diff;
                                row[i].original[b.fsize] = Math.max(0,
                                    ((parseFloat(RegExp.$1) / (row[i].node 
                                    ? row[i].oHtml[b.offsetSize] 
                                    : v[b.size + "_" + row[i].id])) * nHeight)) + "%";
                                //check fheight
                                break;
                            }
                    }
                }
                
                if (oItem.original[b.fsize]) {
                    oItem.original[b.fsize] = isPercentage 
                        ? ((parseFloat(isPercentage[1])/itemSize) * newHeight) + "%" 
                        : "" + newHeight;
                }
                
                //if(total > 0  || isPercentage) needRecalc = true;
                needRecalc = true;
            }
        }

        if (needRecalc) {
            /*
            var l = apf.layout.layouts[this.$ext.parentNode.getAttribute("id")];
            apf.layout.compileAlignment(l.root);
            apf.layout.activateRules(this.$ext.parentNode);

            */
            
            apf.layout.compile(this.$ext.parentNode);
            apf.layout.activateRules(this.$ext.parentNode);
            
            if (apf.hasSingleRszEvent)
                apf.layout.forceResize();

            return;
        }

        apf.layout.forceResize(this.$ext.parentNode);
    };
    
    /* *********
        INIT
    **********/
    //this.implement(apf.GuiElement); /** @inherits apf.GuiElement */
    
    this.init = function(size, refNode, oItem){
        /*var li = size + min + max + (refNode.$uniqueId || refNode);
        if(li == this.$lastinit) return;
        this.$lastinit = li;*/
        this.min     = 0;
        this.max     = 1000000;
        this.size    = parseInt(size) || 3;
        this.refNode = null;
        this.refHtml = null;
        
        var pNode;
        if (refNode) {
            if (typeof refNode != "object")
                refNode = apf.lookup(refNode);
            this.refNode = refNode;
            this.refHtml = this.refNode.$ext;
            pNode        = this.refHtml.parentNode;

            oItem        = refNode.aData.calcData;
        }
        else
            pNode = oItem.pHtml;
        
        this.oItem = oItem;
        if (pNode && pNode != this.$ext.parentNode)
            pNode.appendChild(this.$ext);
        
        var diff = apf.getDiff(this.$ext);
        this.$verdiff  = diff[0];
        this.$hordiff  = diff[1];
        this.$sizeArr  = [];
        
        this.type = oItem.parent.vbox ? "horizontal" : "vertical";
        
        var layout = apf.layout.get(this.$ext.parentNode).layout;
        var name   = "splitter" + this.$uniqueId;
        layout.addRule("var " + name + " = apf.lookup(" + this.$uniqueId + ").$ext");
        
        var vleft   = [name + ".style.left = "];
        var vtop    = [name + ".style.top = "];
        var vwidth  = [name + ".style.width = -" + this.$hordiff + " + "];
        var vheight = [name + ".style.height = -" + this.$verdiff + " + "];
        var oNext   = oItem.parent.children[oItem.stackId+1];
        
        if (this.type == "horizontal") {
            vwidth.push("Math.max(");
            if (oItem.node) {
                vleft.push(oItem.id  + ".offsetLeft");
                vtop.push(oItem.id   + ".offsetTop + " + oItem.id + ".offsetHeight");
                vwidth.push(oItem.id + ".offsetWidth");
            }
            else {
                vleft.push("v.left_"   + oItem.id);
                vtop.push("v.top_"     + oItem.id + " + v.height_" + oItem.id);
                vwidth.push("v.width_" + oItem.id);
            }
            vwidth.push(",", oNext
                ? (oNext.node 
                    ? oNext.id + ".offsetWidth" 
                    : "v.width_" + oNext.id)
                :  0, ")");
            
            layout.addRule(vwidth.join(""));
            this.$ext.style.height = (oItem.splitter - this.$hordiff) + "px";
        }
        else {
            vheight.push("Math.max(");
            if (oItem.node) {
                vleft.push(oItem.id   + ".offsetLeft + " + oItem.id + ".offsetWidth");
                vtop.push(oItem.id    + ".offsetTop");
                vheight.push(oItem.id + ".offsetHeight");
            }
            else {
                vleft.push("v.left_"     + oItem.id + " + v.width_" + oItem.id);
                vtop.push("v.top_"       + oItem.id);
                vheight.push("v.height_" + oItem.id);
            }
            vheight.push(",", oNext 
                ? (oNext.node 
                    ? oNext.id + ".offsetHeight" 
                    : "v.height_" + oNext.id)
                : 0, ")");
            
            layout.addRule(vheight.join(""));
            this.$ext.style.width = (oItem.splitter - this.$hordiff) + "px";
        }
        
        layout.addRule(vleft.join(""));
        layout.addRule(vtop.join(""));

        //if(!apf.p) apf.p = new apf.ProfilerClass();
        //apf.p.start();
        
        //Determine min and max
        var row = oItem.parent.children;
        if (this.type == "vertical") {
            layout.addRule(name + ".host.min = " + (oItem.node 
                ? "document.getElementById('" + oItem.id + "').offsetLeft" 
                : "v.left_" + oItem.id) + " + "
                    + parseInt(oItem.minwidth || oItem.childminwidth || 10));

            var max = [], extra = [];
            for (var hasRest = false, i = oItem.stackId + 1; i < row.length; i++) {
                if (!row[i].fwidth)
                    hasRest = true;
            }
            
            for (var d, i = oItem.stackId + 1; i < row.length; i++) {
                d = row[i];
                
                //should take care here of minwidth due to html padding and html borders
                if (d.minwidth || d.childminheight)
                    max.push(parseInt(d.minwidth || d.childminheight));
                else
                    if (d.fwidth) {
                        if (!hasRest && i == oItem.stackId+1)
                            max.push(10);
                        else
                            if(d.fwidth.indexOf("%") != -1)
                                max.push("(" + d.parent.innerspace + ") * " 
                                    + (parseFloat(d.fwidth)/100));
                        else 
                            max.push(d.fwidth);
                    }
                else 
                    max.push(10);
                
                max.push(d.edgeMargin);
            }
            
            layout.addRule(name + ".host.max = v.left_" + oItem.parent.id 
                + " + v.width_" + oItem.parent.id + " - (" 
                + (max.join("+")||0) + ")");
        }
        else {
            layout.addRule(name + ".host.min = " + (oItem.node 
                ? "document.getElementById('" + oItem.id + "').offsetTop" 
                : "v.top_" + oItem.id) + " + " 
                    + parseInt(oItem.minheight || oItem.childminheight || 10));

            var max = [], extra = [];
            for (var hasRest = false, i = oItem.stackId + 1; i < row.length; i++) {
                if (!row[i].fheight) 
                    hasRest = true;
            }
            
            //This line prevents splitters from sizing minimized items without a rest
            if (!hasRest && oNext && oNext.state > 0)
                return this.$ext.parentNode.removeChild(this.$ext);
            
            for (var d, i = oItem.stackId + 1; i < row.length; i++) {
                d = row[i];
                
                //should take care here of minwidth due to html padding and html borders
                if (d.minheight || d.childminheight)
                    max.push(parseInt(d.minheight || d.childminheight));
                else if (d.fheight) {
                    if (!hasRest && i == oItem.stackId+1)
                        max.push(10);
                    else if(d.fheight.indexOf("%") != -1)
                        max.push("(" + d.parent.innerspace + ") * " 
                            + (parseFloat(d.fheight)/100));
                    else 
                        max.push(d.fheight);
                }
                else
                    max.push(10);
                
                if (d.edgeMargin)
                    max.push(d.edgeMargin);
            }

            layout.addRule(name + ".host.max = v.top_" + oItem.parent.id 
                + " + v.height_" + oItem.parent.id + " - (" 
                + (max.join("+")||0) + ")");
        }

        //apf.p.stop();
        //document.title = apf.p.totalTime;	
        
        this.$setStyleClass(this.$ext, this.type,
            [this.type == "horizontal" ? "vertical" : "horizontal"]);
        
        if (this.type == "vertical")
            this.$setStyleClass(this.$ext, "w-resize", ["n-resize"]);
        else
            this.$setStyleClass(this.$ext, "n-resize", ["w-resize"]);

        return this;
    };
    
    this.$draw = function(){
        //Build Main Skin
        this.$ext = this.$getExternal();

        var _self = this;
        this.$ext.onmousedown = function(e){
            if (!e)
                e = event;
            
            var amlNode = _self;//.$amlNode;
            var pos = apf.getAbsolutePosition(this);
            if (amlNode.type == "vertical")
                amlNode.tx = e.clientX - pos[0];
            else
                amlNode.ty = e.clientY - pos[1];
            amlNode.startPos = amlNode.type == "vertical" 
                ? this.offsetLeft 
                : this.offsetTop;
            
            e.returnValue  = false;
            e.cancelBubble = true;
            
            
            apf.plane.show(this);
            

            amlNode.$setStyleClass(this, "moving");
            
            amlNode.$setStyleClass(document.body,
                amlNode.type == "vertical" ? "w-resize" : "n-resize",
                [amlNode.type == "vertical" ? "n-resize" : "w-resize"]);
            
            //@todo convert to proper way
            document.onmouseup = function(){
                amlNode.$setStyleClass(amlNode.$ext, "", ["moving"]);
        
                
                apf.plane.hide();
                
        
                amlNode.update();
                amlNode.$setStyleClass(document.body, "", ["n-resize", "w-resize"]);
                
                document.onmouseup   = 
                document.onmousemove = null;
            };
            
            //@todo convert to proper way
            document.onmousemove = function(e){
                if(!e) e = event;
        
                if (amlNode.type == "vertical") {
                    if (e.clientX >= 0) {
                        var pos = apf.getAbsolutePosition(amlNode.$ext.offsetParent);
                        amlNode.$ext.style.left = (Math.min(amlNode.max,
                            Math.max(amlNode.min, (e.clientX - pos[0]) - amlNode.tx))) + "px";
                    }
                }
                else {
                    if (e.clientY >= 0) {
                        var pos = apf.getAbsolutePosition(amlNode.$ext.offsetParent);
                        amlNode.$ext.style.top = (Math.min(amlNode.max,
                            Math.max(amlNode.min, (e.clientY - pos[1]) - amlNode.ty))) + "px";
                    }
                }
                
                e.returnValue  = false;
                e.cancelBubble = true;
            };
        }
    };
        
    this.$loadAml = function(x){
        if (this.left || this.top) {
            var O1 = this.left || this.top;
            var O2 = this.right || this.bottom;
            O1 = O1.split(/\s*,\s*/);
            O2 = O2.split(/\s*,\s*/);
            
            for (var i = 0; i < O1.length; i++)
                O1[i] = O1[i];
            for (var i = 0; i < O2.length; i++)
                O2[i] = O2[i];
                
            //Not a perfect hack, but ok, for now
            var _self = this;
            $setTimeout(function(){
                this.$amlNode.init(_self.type,
                    _self.size, 
                    _self.min, 
                    _self.max, 
                    _self.change, O1, O2);
            });
        }
    };
}).call(apf.splitter.prototype = new apf.Presentation());

apf.aml.setElement("splitter", apf.splitter);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/pager.js)SIZE(8375)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * This elements displays buttons which can be used to navigate between some
 * parts of data, for example between parts of article
 * 
 * @define pager
 * @attribute {String} range      determines how much page buttons is displayed 
 * @attribute {String} previous   determines the caption of "go to previous page" button
 * @attribute {String} next       determines the caption of "go to next page" button
 * 
 * @inherits apf.Presentation
 * @inherits apf.StandardBinding
 * @inherits apf.DataAction
 * 
 * @author      
 * @version     %I%, %G% 
 * 
 * @define bindings
 * @allowchild current, total
 *
 * @binding current      Determines which page is currently selected
 * @binding total        Determines the number of pages.
 * 
 */
apf.pager = function(struct, tagName){
    this.$init(tagName || "pager", apf.NODE_VISIBLE, struct);
};

(function() {
    this.previous   = "Previous";
    this.next       = "Next";
    this.range      = 5;
    this.curpage    = 1;
    this.totalpages = 0;
    this.autohide   = false;
    this.oEmpty     = null;
    
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        pageload : 1
    }, this.$attrExcludePropBind);
    
    this.$supportedProperties.push("range", "curpage", "totalpages", 
        "previous", "next", "autohide", "pageload");
        
    this.$booleanProperties["autohide"] = true;
    
    this.$propHandlers["curpage"] = function(value){
        this.gotoPage(value);
    };

    /**
     * Selects page depends on its number or jump length
     * 
     * @param {Number} pageNr      number of choosen page
     * @param {Number} pageDelta   length of jump which should be done between
     *                             current page and new selected page
     */
    this.gotoPage = function(pageNr, pageDelta) {
        var lastCurpage = this.curpage;
        this.curpage    = pageNr || this.curpage + pageDelta;
        if (lastCurpage != this.curpage)
            this.setProperty("curpage", this.curpage);

        //Sanity checks
        if (this.curpage < 1) 
            this.curpage = 1;
        else if (this.totalpages && this.curpage > this.totalpages) 
            this.curpage = this.totalpages;
        
        if (this.dispatchEvent("beforepagechange", {page:this.curpage}) === false)
            return false;
        
        var model = this.getModel(true),
            _self = this;
        if (model) {
            model.$loadFrom(this.pageload, {
                xmlNode  : this.xmlRoot,
                page     : this.curpage,
                callback : function(){
                    _self.dispatchEvent("afterpagechange", {page:_self.curpage});
                }
            });
        }
        else {
            //@todo is this the best way to detect a model?
            $setTimeout(function(){
                var model = _self.getModel(true);
                if (model) {
                    model.$loadFrom(_self.pageload, {
                        xmlNode  : _self.xmlRoot,
                        page     : _self.curpage,
                        callback : function(){
                            _self.dispatchEvent("afterpagechange", {page:_self.curpage});
                        }
                    });
                }
                
                _self.removeEventListener("afterload", arguments.callee);
            });
        }
    };
    
    this.addEventListener("$clear", function(e){
        return false;
    });
    
    this.$setClearMessage = function(msg, type){
        if (!this.$empty) {
            this.$empty = this.$int.ownerDocument.createElement("span");
            this.$setStyleClass(this.$empty, "loader");
        }
        
        if (type == "loading") {
            this.$setStyleClass(this.$ext, this.$baseCSSname + "Loading");
            this.$int.appendChild(this.$empty);
        }
    }
    
    this.$removeClearMessage = function(){
        if (this.$empty && this.$empty.parentNode) {
            this.$empty.parentNode.removeChild(this.$empty);
            this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Loading"]);
        }
    }
    
    this.$draw  = function() {
        this.$ext = this.$getExternal("main");
        this.$int = this.$getLayoutNode("main", "container",  this.$ext);
    };
    
    this.$load = function(xmlRoot) {
        this.setProperty("curpage",    parseInt(this.$applyBindRule("current", xmlRoot)));
        this.setProperty("totalpages", parseInt(this.$applyBindRule("total", xmlRoot)));
        
        var curpage    = this.curpage,
            totalpages = this.totalpages,
            nodes      = [],
            btn;
        
        this.$int.innerHTML = "";
        
        if (!totalpages)
            return;

        if (curpage != 1 || !this.autohide) {
            this.$getNewContext("button");
            btn = this.$getLayoutNode("button");
            this.$getLayoutNode("button", "caption").nodeValue = this.previous;
            this.$setStyleClass(btn, "previous");
            
            if (curpage != 1) {
                btn.setAttribute("onclick", "apf.lookup(" + this.$uniqueId
                    + ").gotoPage(null, -1)");
            }
            else {
                this.$setStyleClass(btn, "disabled");
            }

            nodes.push(btn);
        }
        
        var rlow  = Math.floor(this.range / 2),
        //    rhigh = Math.ceil(this.range / 2);
            start = Math.max(1, curpage - rlow),
            end   = Math.min(totalpages + 1, start + this.range),
            i;
        if (end - start < this.range && start != 1)
            start = Math.max(end - this.range, 1);
        
        for (i = start; i < end; i++) {
            this.$getNewContext("button");
            btn = this.$getLayoutNode("button");
            this.$getLayoutNode("button", "caption").nodeValue = i;
            btn.setAttribute("onclick", "apf.lookup(" + this.$uniqueId
                + ").gotoPage(" + i + ")");
            nodes.push(btn);
            
            if (i == curpage)
                this.$setStyleClass(btn, "current");
        }
        
        if (curpage != totalpages  || !this.autohide) {
            this.$getNewContext("button");
            btn = this.$getLayoutNode("button");
            this.$getLayoutNode("button", "caption").nodeValue = this.next;
            this.$setStyleClass(btn, "next");
            
            if (curpage != totalpages) {
                btn.setAttribute("onclick", "apf.lookup(" + this.$uniqueId
                    + ").gotoPage(null, 1)");
            }
            else {
                this.$setStyleClass(btn, "disabled");
            }

            nodes.push(btn);
        }
        
        apf.insertHtmlNodes(nodes, this.$int);
        
        if (this.$empty)
            this.$int.appendChild(this.$empty);
    }
    

}).call(apf.pager.prototype = new apf.StandardBinding());


apf.aml.setElement("pager",   apf.pager);
apf.aml.setElement("total",   apf.BindingRule);
apf.aml.setElement("current", apf.BindingRule);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/calendar.js)SIZE(30177)TIME(1263340865)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Element displaying a calendar, ordered by week. It allows the user to choose 
 * the month and year for which to display the days. Calendar returns a date 
 * in chosen date format. Minimal size of calendar is 150px.
 * 
 * Example:
 * Calendar component with date set on "Saint Nicholas Day" in iso date format
 * <code>
 *  <a:calendar
 *    top           = "200"
 *    left          = "400"
 *    output-format = "yyyy-mm-dd"
 *    value         = "2008-12-06" />
 * </code>
 * 
 * Example:
 * Sets the date based on data loaded into this component.
 * <code>
 *  <a:model id="mdlCalDD">
 *      <data date="2009-11-25" />
 *  </a:model>
 *  <a:calendar 
 *    output-format = "yyyy-mm-dd" 
 *    model         = "mdlCalDD" 
 *    value         = "[@date]" />
 * </code>
 * 
 * @constructor
 * @define calendar
 * @addnode elements
 *
 * @attribute {String}   output-format    the format of the returned value. See {@link term.dateformat more about the date format}.
 * @attribute {String}   default          the default date set when the calendar is opened.
 *     Possible values:
 *     today   calendar is set on today's date
 * @attribute {String}   value            the date returned by calendar; should be in the format specified by the output-format attribute.
 * 
 * @binding value  Determines the way the value for the element is retrieved 
 * from the bound data.
 *
 * @inherits apf.DataAction
 * 
 * @author      Lukasz Lipinski
 * @version     %I%, %G%
 * @since       1.0
 *
 */
apf.calendar = function(struct, tagName){
    this.$init(tagName || "calendar", apf.NODE_VISIBLE, struct);
    
    /**** Properties and Attributes ****/
    this.$calVars = {
        days         : ["Sunday", "Monday", "Tuesday", "Wednesday",
                        "Thursday", "Friday", "Saturday"],
        months       : [{name : "January",   number : 31},
                        {name : "February",  number : 28},
                        {name : "March",     number : 31},
                        {name : "April",     number : 30},
                        {name : "May",       number : 31},
                        {name : "June",      number : 30},
                        {name : "July",      number : 31},
                        {name : "August",    number : 31},
                        {name : "September", number : 30},
                        {name : "October",   number : 31},
                        {name : "November",  number : 30},
                        {name : "December",  number : 31}],

        day          : null,
        month        : null,
        year         : null,

        hours        : 1,
        minutes      : 0,
        seconds      : 0,

        currentMonth : null,
        currentYear  : null,
        numberOfDays : null,
        dayNumber    : null,

        temp         : null,

        inited       : false,
        startDiffs   : [],
        prevWidth    : 0,

        rRows        : [],
        rCells       : [[], [], [], [], [], []],
        rDoW         : []
    };
};

(function() {
    this.implement(
        
        apf.DataAction
        
        
    );

    this.$supportedProperties.push("output-format", "default");

    /**
     * @attribute {String} output-format is a style of returned date
     * 
     * Possible values:
     *     d      day of the month as digits, no leading zero for single-digit days
     *     dd     day of the month as digits, leading zero for single-digit days
     *     ddd    day of the week as a three-letter abbreviation
     *     dddd   day of the week as its full name
     *     m      month as digits, no leading zero for single-digit months
     *     mm     month as digits, leading zero for single-digit months
     *     mmm    month as a three-letter abbreviation
     *     mmmm   month as its full name
     *     yy     year as last two digits, leading zero for years less than 2010
     *     yyyy   year represented by four digits
     *     h      hours, no leading zero for single-digit hours (12-hour clock)
     *     hh     hours, leading zero for single-digit hours (12-hour clock)
     *     H      hours, no leading zero for single-digit hours (24-hour clock)
     *     HH     hours, leading zero for single-digit hours (24-hour clock)
     *     M      minutes, no leading zero for single-digit minutes
     *     MM     minutes, leading zero for single-digit minutes
     *     s      seconds, no leading zero for single-digit seconds
     *     ss     seconds, leading zero for single-digit seconds
     */
    this.$propHandlers["output-format"] = function(value) {
        if (this.value) {
            var c = this.$calVars;
            this.setProperty("value", 
                new Date(
                    c.year, c.month, c.day, c.hours, c.minutes, c.seconds
                ).format(this.outputFormat = value)
            );
        }
        else
            this.outputFormat = value;
    };

    this.$propHandlers["value"] = function(value) {
        var c = this.$calVars;
        
        if (!this.outputFormat) {
            c.temp = value;
            return;
        }

        var date = Date.parse(value, this.outputFormat);

        
        if (!date || isNaN(date)) {
            return;
            /*throw new Error(apf.formErrorString(this, "Parsing date",
                "Invalid date: " + value));*/
        }
        

        c.day     = date.getDate();
        c.month   = date.getMonth();
        c.year    = date.getFullYear();
        c.hours   = date.getHours();
        c.minutes = date.getMinutes();
        c.seconds = date.getSeconds();

        this.value = value;
        this.redraw(c.month, c.year);
    };

    /**** Public methods ****/

    

    /**
     * @method  Sets calendar date
     */
    this.setValue = function(value) {
        this.setProperty("value", value, false, true);
    };
    
    /**
     * @method  
     * 
     * @return {String} date indicated by calendar
     */
    this.getValue = function() {
        return this.value;
    };
    
    

    /**** Keyboard Support ****/

    
    this.addEventListener("keydown", function(e) {
        e = e || event;

        var key      = e.keyCode,
            ctrlKey  = e.ctrlKey,
            shiftKey = e.shiftKey,
            c        = this.$calVars;

        switch (key) {
            case 13: /* enter */
                this.selectDay(c.day);
                break;

            case 33: /* page up */
                this.nextMonth();
                break;

            case 34: /* page down */
                this.prevMonth();
                break;

            case 37: /* left arrow */
                if (ctrlKey)
                    this.prevMonth();
                else if (shiftKey)
                    this.prevYear();
                else {
                    if (c.day - 1 < 1) {
                        this.prevMonth();
                        this.selectDay(c.months[c.currentMonth].number);
                    }
                    else {
                        this.selectDay(c.day - 1);
                    }
                }
                break;

            case 38: /* up arrow */
                if (c.day - 7 < 1) {
                    this.prevMonth();
                    this.selectDay(c.months[c.currentMonth].number + c.day - 7);
                }
                else {
                    this.selectDay(c.day - 7);
                }
                break;

            case 39: /* right arrow */
                if (ctrlKey)
                    this.nextMonth();
                else if (shiftKey)
                    this.nextYear();
                else
                    this.selectDay(c.day + 1);
                break;

            case 40: /* down arrow */
                    this.selectDay(c.day + 7);
                break;

            case 84:
                if (ctrlKey)
                    this.today();
                    return false;
                break;
        }
    }, true);
    


    this.$blur = function() {
        this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Focus"]);
    };

    this.$focus = function() {
        this.$setStyleClass(this.oFocus || this.$ext, this.$baseCSSname + "Focus");
    }

    var isLeapYear = function(year) {
        return ((year % 4 == 0) && (year % 100 !== 0)) || (year % 400 == 0)
            ? true
            : false;
    };
    
    this.$getMargin = function(oHtml) {
        if (apf.isIE) {
            return [
                (parseInt(apf.getStyle(oHtml, "marginLeft")) || 0)
                + (parseInt(apf.getStyle(oHtml, "marginLeft")) || 0),
                (parseInt(apf.getStyle(oHtml, "marginTop")) || 0)
                + (parseInt(apf.getStyle(oHtml, "marginBottom")) || 0)
            ];
        }
        else {
            return [
                parseInt(apf.getStyle(oHtml, "margin-right") || 0)
                + parseInt(apf.getStyle(oHtml, "margin-left") || 0),
                parseInt(apf.getStyle(oHtml, "margin-top") || 0)
                + parseInt(apf.getStyle(oHtml, "margin-bottom") || 0)
            ];
        }
    };
    
    this.$getFontSize = function(oHtml) {
        return apf.isIE
            ? parseInt(apf.getStyle(oHtml, "fontSize"))
            : parseInt(apf.getStyle(oHtml, "font-size"));
    }
    
    this.$getPadding = function(oHtml) {
        return apf.isIE
            ? [parseInt(apf.getStyle(oHtml, "paddingLeft"))
               + parseInt(apf.getStyle(oHtml, "paddingRight")),
              parseInt(apf.getStyle(oHtml, "paddingTop"))
               + parseInt(apf.getStyle(oHtml, "paddingBottom"))]
            : [parseInt(apf.getStyle(oHtml, "padding-left"))
               + parseInt(apf.getStyle(oHtml, "padding-right")),
              parseInt(apf.getStyle(oHtml, "padding-top")) 
               + parseInt(apf.getStyle(oHtml, "padding-bottom"))];
    }

    this.$resize = function() {
        var width = parseInt(this.$ext.style.width || 0),
            c     = this.$calVars,
            i, j, l, l2;

        if (c.rRows.length == 0) {
            rows = this.oContent.childNodes;

            for (i = 0, l = rows.length; i < l; i++) {
                if ((rows[i].className || "").indexOf("row") > -1) {
                    c.rRows.push(rows[i]);

                    cells = rows[i].childNodes;
                    for (j = 0, l2 = cells.length; j < l2; j++) {
                        if ((cells[j].className || "").indexOf("cell") > -1)
                            c.rCells[c.rRows.length - 1].push(cells[j]);
                    }
                }
            }
        }

        if (c.rDoW.length == 0) {
            var daysofweek = this.oDow.childNodes;

            for (i = 0, l = daysofweek.length; i < l; i++) {
                if ((daysofweek[i].className || "").indexOf("dayofweek") > -1)
                    c.rDoW.push(daysofweek[i]);
            }
        }

        if (width > 0 && c.prevWidth !== width) {
            c.prevWidth = width;

            var ctDiff = apf.getDiff(this.$ext),
                _width = parseInt(this.$ext.offsetWidth
                    || this.$ext.style.width
                    || apf.getStyle(this.$ext, "width")) - ctDiff[0],

                rDiff = c.startDiffs[0], rDiff2 = c.startDiffs[1],
                cDiff = c.startDiffs[2], cDiff2 = c.startDiffs[3],
                eDiff = c.startDiffs[4],

                rWidth = _width - rDiff[0] - rDiff2[0],
                cWidthf = Math.floor(rWidth * 0.125) - cDiff[0] - cDiff2[0],
            
                height = cWidthf
                    + (cDiff[1] > cDiff[0] ? cDiff[0] - cDiff[1] : 0)
                    + (cDiff2[1] > cDiff2[0] ? cDiff2[0] - cDiff2[1] : 0),
                paddingBT,
                pl = Math.floor((rWidth - rDiff[0] - rDiff2[0]
                - (cWidthf + cDiff[0] + cDiff2[0]) * 8) * 0.5);

            for (i = 0, l = c.rRows.length; i < l; i++) {
                var row = c.rRows[i];

                for (j = 0, l2 = c.rCells[i].length; j < l2; j++) {
                    var cell = c.rCells[i][j];

                    paddingBT = Math.ceil((height - this.$getFontSize(cell))*0.5);
                    
                    cell.style.width         = (Math.max(cWidthf, 0) - (apf.isIE || apf.isChrome ? 1 : 0)) + "px";
                    cell.style.height        = (height - (2 * paddingBT - cDiff[1]))+ "px";
                    cell.style.paddingTop    = (paddingBT > 0 ? paddingBT + 1 : 0) + "px";
                    cell.style.paddingBottom = (paddingBT > 0 ? paddingBT - 1 : 0) + "px";
                    if (apf.isIE || apf.isChrome) {
                        cell.style.paddingLeft = (parseInt(cell.style.paddingLeft || 0) + 1) + "px";
                    }
                    
                }

                row.style.paddingLeft = pl + "px";

                this.$ext.style.paddingBottom = (Math.floor(eDiff[1] * 0.5) + pl) + "px";
            }

            this.oDow.style.paddingLeft = pl + "px";
    
            for (i = 0, l = c.rDoW.length; i < l; i++) {
                var dof = c.rDoW[i];
                dof.style.width  = cWidthf + "px";

                if (cWidthf < 16)
                    dof.style.fontSize = "9px";
            }
        }
    }

    this.redraw = function(month, year) {
        var w_firstYearDay = new Date(year, 0, 1),
            w_dayInWeek    = w_firstYearDay.getDay(),
            w_days         = w_dayInWeek,
            c              = this.$calVars;

        c.currentMonth = month;
        c.currentYear  = year;
        
        for (i = 0; i <= month; i++) {
            if (isLeapYear(year) && i == 1) {
                w_days++;
            }
            w_days += c.months[i].number;
        }

        var w_weeks  = Math.ceil(w_days / 7),
            date     = new Date(year, month);

        c.numberOfDays = c.months[date.getMonth()].number;
        if (isLeapYear(year) && date.getMonth() == 1) 
            c.numberOfDays++;

        c.dayNumber = new Date(year, month, 1).getDay();
        var prevMonth     = month == 0 ? 11 : month - 1,
            prevMonthDays = c.months[prevMonth].number - c.dayNumber + 1,

            nextMonthDays = 1,

            ctDiff        = apf.getDiff(this.$ext),
            _width        = parseInt(this.$ext.offsetWidth || this.$ext.style.width
                            || apf.getStyle(this.$ext, "width")) - ctDiff[0],
            /* Navigation buttons */
            navi          = this.oNavigation.childNodes;

        //@todo fix this!! 
        if (!_width) return;

        for (i = 0; i < navi.length; i++) {
            if ((navi[i].className || "").indexOf("today") != -1) {
                navi[i].innerHTML = "T";
            }
            else if ((navi[i].className || "").indexOf("status") != -1) {
                if (_width >= 300) {
                    navi[i].innerHTML = c.months[c.currentMonth].name
                        + " " + c.currentYear;
                    navi[i].style.width = "100px";
                    navi[i].style.marginLeft = "-50px";
                }
                else {
                    navi[i].innerHTML = (c.currentMonth + 1)
                        + "/" + c.currentYear;
                    navi[i].style.width = "40px";
                    navi[i].style.marginLeft = "-20px";
                }
            }
        }

        //Rows
        var rows = this.oContent.childNodes,
            cWidthf, pl;
        for (var i = 0, z = 0, y = 0; i < rows.length; i++) {
            if ((rows[i].className || "").indexOf("row") > -1) {
                var rDiff = !c.inited ? apf.getDiff(rows[i]) : c.startDiffs[0];
                var rDiff2 = !c.inited ? this.$getMargin(rows[i]) : c.startDiffs[1];
                var rWidth = _width - rDiff[0] - rDiff2[0];
                
                if (!c.inited) {
                    c.startDiffs[0] = rDiff
                    c.startDiffs[1] = rDiff2;
                }

                //Cells
                var cells = rows[i].childNodes;
                for (var j = 0, disabledRow = 0; j < cells.length; j++) {
                    if ((cells[j].className || "").indexOf("cell") > -1) {
                        var cDiff = !c.inited ? apf.getDiff(cells[j]) : c.startDiffs[2],
                            cDiff2 = !c.inited ? this.$getMargin(cells[j]) : c.startDiffs[3];

                        if (!c.inited) {
                            c.startDiffs[2] = cDiff
                            c.startDiffs[3] = cDiff2;
                            
                        }
                        cWidthf = Math.floor(rWidth / 8)
                            - cDiff[0] - cDiff2[0];
                        var width = cWidthf,
                            height = cWidthf
                            + (cDiff[1] > cDiff[0]
                                ? cDiff[0] - cDiff[1]
                                : 0) 
                            + (cDiff2[1] > cDiff2[0]
                                ? cDiff2[0] - cDiff2[1]
                                : 0),
                        paddingTop;

                        var paddingBottom = 
                            paddingTop = Math.ceil((height
                                - this.$getFontSize(cells[j])) / 2);

                        height -= (paddingTop + paddingBottom - cDiff[1]);
                        
                        cells[j].style.width         = (width > 0 ? width : 0) + "px";
                        cells[j].style.height        = (height > 0 ? height : 0) + "px";
                        cells[j].style.paddingTop    = (paddingTop > 0 ? paddingTop + 1 : 0) + "px";
                        cells[j].style.paddingBottom = (paddingBottom > 0 ? paddingBottom - 1 : 0) + "px";

                        // Drawing day numbers
                        this.$setStyleClass(cells[j], "", ["weekend",
                            "disabled", "active", "prev", "next", "weeknumber"]);
                        
                        z++;
                        if ((z - 1) % 8 == 0) {
                            cells[j].innerHTML = w_weeks 
                                - Math.ceil((c.months[c.month].number + c.dayNumber) / 7)
                                + 1 + (z - 1) / 8;
                            this.$setStyleClass(cells[j], "weeknumber");
                        }
                        else {
                            y++;

                            if (y <= c.dayNumber) {
                                cells[j].innerHTML = prevMonthDays++;
                                this.$setStyleClass(cells[j], "disabled prev");
                                
                            }
                            else if (y > c.dayNumber
                              && y <= c.numberOfDays + c.dayNumber) {
                                cells[j].innerHTML = y - c.dayNumber;
        
                                var dayNrWeek = new Date(year, month,
                                    y - c.dayNumber).getDay();
        
                                if (dayNrWeek == 0 || dayNrWeek == 6)
                                    this.$setStyleClass(cells[j], "weekend");
        
                                if (month == c.month && year == c.year
                                  && y - c.dayNumber == c.day)
                                    this.$setStyleClass(cells[j], "active");
                            }
                            else if (y > c.numberOfDays + c.dayNumber) {
                                cells[j].innerHTML = nextMonthDays++;
                                this.$setStyleClass(cells[j], "disabled next");
                                disabledRow++;
                            }
                        }
                    }
                }

                pl = Math.floor((rWidth - rDiff[0] - rDiff2[0] 
                    - (cWidthf + cDiff[0] + cDiff2[0])*8)/2);
                rows[i].style.paddingLeft = pl + "px";
                
                var eDiff = !c.inited ? this.$getPadding(this.$ext) : c.startDiffs[4];
                
                if (!c.inited)
                    c.startDiffs[4] = eDiff
                
                this.$ext.style.paddingBottom = 
                    (Math.floor(eDiff[1]/2) + pl) + "px";
                
                
                if (!this.height) {
                    rows[i].style.display = disabledRow == 7
                        ? "none"
                        : "block";
                }
                else {
                    rows[i].style.visibility = disabledRow == 7
                        ? "hidden"
                        : "visible";
                }
            }
        }
        
        /* Days of the week */
        var daysofweek = this.oDow.childNodes;
        this.oDow.style.paddingLeft = pl + "px";

        for (var z = 0, i = 0; i < daysofweek.length; i++) {
            if ((daysofweek[i].className || "").indexOf("dayofweek") > -1) {
                daysofweek[i].style.width  = (cWidthf > 0 ? cWidthf : 0) + "px";

                if (cWidthf < 16) {
                    daysofweek[i].style.fontSize = "9px";
                }

                if (z > 0) {
                    daysofweek[i].innerHTML = 
                        c.days[z - 1].substr(0, cWidthf < 12
                            ? 1 : (cWidthf < 16 ? 2
                            : 3));
                }
                else {
                    daysofweek[i].innerHTML = "&nbsp;";
                }
                z++;
            }
        }
        
        
        c.inited = true;
    };

    /**
     * Selects date and highlights its cell in calendar component
     *
     * @param {Number}   nr     day number
     * @param {String}   type   class name of html representation of selected cell
     */
    this.selectDay = function(nr, type) {
        var c        = this.$calVars,
            newMonth = type == "prev"
                ? c.currentMonth
                : (type == "next"
                    ? c.currentMonth + 2
                    : c.currentMonth + 1),

            newYear = c.currentYear;

        if (newMonth < 1) {
            newMonth = 12;
            newYear--;
        }
        else if (newMonth > 12) {
            newMonth = 1;
            newYear++;
        }

        this.change(new Date(newYear, (newMonth - 1), nr, c.hours, c.minutes,
            c.seconds).format(this.outputFormat));
    };

    /**
     * Change displayed year to next one
     */
    this.nextYear = function() {
        this.redraw(this.$calVars.currentMonth, this.$calVars.currentYear + 1);
    };

    /**
     * Change displayed year to previous one
     */
    this.prevYear = function() {
        this.redraw(this.$calVars.currentMonth, this.$calVars.currentYear - 1);
    };

    /**
     * Change displayed month to next one. If actual month is December, function
     * change current displayed year to next one
     */
    this.nextMonth = function() {
        var c = this.$calVars;
        this.redraw(
            c.currentMonth > 10 ? 0 : c.currentMonth + 1,
            c.currentMonth > 10 ? c.currentYear + 1 : c.currentYear
        );
    };

    /**
     * Change displayed month to previous one. If actual month is January, function
     * change current displayed year to previous one
     */
    this.prevMonth = function() {
        var c = this.$calVars;
        this.redraw(
            c.currentMonth < 1 ? 11 : c.currentMonth - 1,
            c.currentMonth < 1 ? c.currentYear - 1 : c.currentYear
        );
    };

    /**
     * Select today's date in calendar component
     */
    this.today = function() {
        this.setProperty("value", new Date().format(this.outputFormat));
    };

    /**** Init ****/

    this.$draw = function() {
        //Build Main Skin
        this.$ext = this.$getExternal("main", null, function(oExt) {
            var oContent = this.$getLayoutNode("main", "content", oExt);

            for (var i = 0; i < 6; i++) {
                this.$getNewContext("row");
                var oRow = oContent.appendChild(this.$getLayoutNode("row"));

                for (var j = 0; j < 8; j++) {
                    this.$getNewContext("cell");
                    var oCell = this.$getLayoutNode("cell");
                    if (j > 0) {
                        oCell.setAttribute("onmouseover",
                            "if (this.className.indexOf('disabled') > -1 "
                            + "|| this.className.indexOf('active') > -1) "
                            + "return; apf.lookup(" + this.$uniqueId 
                            + ").$setStyleClass(this, 'hover');");
                        oCell.setAttribute("onmouseout", 
                            "var o = apf.lookup(" + this.$uniqueId 
                            + ").$setStyleClass(this, '', ['hover']);");
                        oCell.setAttribute("onmousedown", 
                            "var o = apf.lookup(" + this.$uniqueId + ");"
                            + " if (this.className.indexOf('prev') > -1) { "
                            + "o.selectDay(this.innerHTML, 'prev');}"
                            + " else if (this.className.indexOf('next') > -1) {"
                            + "o.selectDay(this.innerHTML, 'next');}"
                            + " else {o.selectDay(this.innerHTML);}");
                    }
                    oRow.appendChild(oCell);
                }
            }

            var oNavigation = this.$getLayoutNode("main", "navigation", oExt);

            if (oNavigation) {
                var buttons = ["prevYear", "prevMonth", "nextYear", "nextMonth",
                               "today", "status"];
                for (var i = 0; i < buttons.length; i++) {
                    this.$getNewContext("button");
                    var btn = oNavigation.appendChild(this.$getLayoutNode("button"));
                    this.$setStyleClass(btn, buttons[i]);
                    if (buttons[i] !== "status")
                        btn.setAttribute("onmousedown", 'apf.lookup('
                                         + this.$uniqueId + ').'
                                         + buttons[i] + '()');
                }
            }

            var oDaysOfWeek = this.$getLayoutNode("main", "daysofweek", oExt);

            for (var i = 0; i < this.$calVars.days.length + 1; i++) {
                this.$getNewContext("day");
                oDaysOfWeek.appendChild(this.$getLayoutNode("day"));
            }
        });

        this.oNavigation = this.$getLayoutNode("main", "navigation",  this.$ext);
        this.oDow        = this.$getLayoutNode("main", "daysofweek",  this.$ext);
        this.oContent    = this.$getLayoutNode("main", "content",  this.$ext);
        
        
        
        apf.layout.setRules(this.$ext, "resize", "var o = apf.all[" + this.$uniqueId + "];\
        if (o) o.$resize()", true);
        apf.layout.queue(this.$ext);
        
    };

    this.$loadAml = function(x) {
        if (typeof this.value == "undefined") {
            switch(this["default"]) {
                case "today":
                    this.setProperty("value", new Date().format(this.outputFormat));
                    break;
                default :
                    this.setProperty("value", new Date().format(this.outputFormat));
                    break;
            }
        }
        else {
            var c    = this.$calVars,
                date = Date.parse(c.temp || this.value, this.outputFormat);
            c.day   = date.getDate();
            c.month = date.getMonth();
            c.year  = date.getFullYear();

            if (c.day && c.month && c.year) {
                this.setProperty("value", new Date(c.year, c.month, c.day, c.hours,
                    c.minutes, c.seconds).format(this.outputFormat));
            }
            
        }
    };
    
    this.$destroy = function() {
        apf.popup.removeContent(this.$uniqueId);
        apf.destroyHtmlNode(this.$ext);
        this.oCalendar = null;
    };
}).call(apf.calendar.prototype = new apf.StandardBinding());

apf.aml.setElement("calendar", apf.calendar);


/*FILEHEAD(/var/lib/platform/source/trunk/elements/comment.js)SIZE(1283)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * all elements within the comment tag are ignored by the parser.
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.comment = function(){
    this.$init("comment", apf.NODE_HIDDEN);
};

apf.comment.prototype = new apf.AmlComment();




/*FILEHEAD(/var/lib/platform/source/trunk/elements/lineselect.js)SIZE(4781)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Element displaying text with each line being selectable. This is especially
 * useful for log messages.
 * 
 * @experimental
 * @todo test this
 */
apf.lineselect = function(struct, tagName){
    this.$init(tagName || "lineselect", apf.NODE_VISIBLE, struct);
};

(function(){
    this.deselect = function(){
        this.value = this.selected = null;
    }
    
    this.select = function(node){
        if(this.selected) this.selected.className = this.skin.clsItem;
        
        node.className = this.skin.clsSelected;
        this.selected = node;

        this.dispatchEvent("afterselect", node.innerHTML);
    }
    
    this.$focus = function(){
        if(this.selected) this.selected.className = this.skin.clsSelected;
    }
    
    this.$blur = function(){
        if(this.selected) this.selected.className = this.skin.clsBlur;
    }
    
    this.$focussable = true;
    
    this.getHTML = function(t){
        t = t.replace(/</g, "&lt;");
        t = t.replace(/>/g, "&gt;");
        t = t.replace(/(^|\n)[^\(]*\(/g, "\n(");
        return t;
    }
    
    this.loadText = function(text){
        //this.parentNode.style.width = this.parentNode.offsetWidth;
        
        var ar = this.getHTML(text).split("\n");
        
        for(var i=0;i<ar.length;i++){
            if(ar[i].match(/error \E/)) var clr = "red";
            else if(ar[i].match(/warning \P/)) var clr = "yellow";
            else var clr = "white";
            
            ar[i] = "<div style='color:" + clr + "' onmousedown='" + 'apf.lookup(' + this.$uniqueId + ').select(this)' + "' ondblclick=\"" + 'apf.lookup(' + this.$uniqueId + ').dispatchEvent(\'onchoose\', this.innerHTML)' + "\" class='" + this.skin.clsItem + "'>" + ar[i] + "</div>";
        }
                
        this.$ext.innerHTML = "<div style='color:white' class='" + this.skin.clsItem + "'>APF Packager</div><div nowrap style='color:white' class='" + this.skin.clsItem + "'>(c) 2001-2003 All Rights Reserved.</div><br>" + ar.join("");
        //this.parentNode.style.width = "100%";
    }
    
    
    this.addEventListener("keydown", function(e){
        var key      = e.keyCode;

        if(this.renaming){
            if(key == 27 || key == 13){
                this.stopRename();
                if(key == 13) this.stopRename();
            }
            
            return;
        }
        
        if(!this.selected) return;

        switch(key){
            case 13:
                this.dispatchEvent("choose");
            break;
            case 38:
            //UP
                if(!this.value) return;
                var node = this.value;

                if(node.previousSibling) node = node.previousSibling;
                if(node && node.nodeType == 1) this.select(document.getElementById(node.getAttribute("id")));
                
                //this.selected.scrollIntoView();
                return false;
            break;
            case 40:
            //DOWN
                if(!this.value) return;
                var node = this.value;

                if(node.nextSibling) node = node.nextSibling;
                if(node && node.nodeType == 1) this.select(document.getElementById(node.getAttribute("id")));
                
                //this.selected.scrollIntoView();
                return false;
            break;
        }
    }, true);
    
    
    /**** Init ****/
    
    this.$draw = function(clear, parentNode){
        this.$ext = this.$getExternal();
        this.$int = this.$ext;
    }
}).call(apf.lineselect.prototype = new apf.GuiElement());

apf.aml.setElement("lineselect", apf.lineselect);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/upload.js)SIZE(31696)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element allowing the user to upload a file to a server. This element does 
 * not have a visual representation. By adding buttons, a progressbar and other
 * elements you can fully customize your upload component. Use
 * {@link term.propertybinding property binding} to update those elements with
 * the state of the upload element.
 * 
 * Example:
 * This example shows an upload element that pushes an image to the server. The
 * asp script returns an xml string which is added to the list of images on a
 * successfull upload.
 * <code>
 *  <a:list id="lstImages" smartbinding="..." model="..." />
 *
 *  <a:upload id="uplMain"
 *    target    = "../api/UploadPicture.asp"
 *    ontimeout = "alert('It seems the server went away')"
 *    oncancel  = "alert('Could not upload logo')"
 *    onuploaded = "lstImages.add(arguments[0])" />
 *
 *  <a:button caption="Browse file..." onclick="uplMain.browse()" 
 *    disabled="{uplMain.uploading}" />
 *  <a:button caption="{uplMain.uploading ? 'Cancel' : 'Send'}" 
 *    disabled="{!uplMain.value}" onclick="
 *      if (uplMain.uploading)
 *          uplMain.cancel();
 *      else
 *          uplMain.upload();
 *    " />
 * </code>
 *
 * @event afterbrowse Fires after the user has made a selection.
 *   object:
 *   {String} value the path of the file selected
 *
 * @constructor
 * @alias upload
 * @addnode elements
 *
 * @inherits apf.StandardBinding
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @binding value  Determines the way the value for the element is retrieved 
 * from the bound data.
 * Example:
 * Sets the value based on data loaded into this component.
 * <code>
 *  <a:upload>
 *      <a:bindings>
 *          <a:value match="[@filename]" />
 *      </a:bindings>
 *  </a:upload>
 * </code>
 * Example:
 * A shorter way to write this is:
 * <code>
 *  <a:upload value="[@filename]" />
 * </code>
 *
 * @todo get server side information to update the progressbar.
 */

apf.upload = function(struct, tagName){
    this.$init(tagName || "upload", apf.NODE_VISIBLE, struct);
    
    this.DEFAULT_SWF_PATH = (apf.config.resourcePath || apf.basePath)
        + "resources/Swiff.Uploader.swf?noCache=".appendRandomNumber(5);
    

    this.$playerId     = apf.flash.addPlayer(this);
    this.$useFlash     = apf.flash.isAvailable("9.0.0");
    // might be overridden later by the 'model' prophandler:
    this.$files        = new apf.upload.files();
};

(function(){
    this.implement(
        
        apf.DataAction
        
    );

    this.width               = 300;
    this.height              = 20;
    this.method              = "post";
    this.progress            = 0;
    this.uploading           = false;
    this["type-filter"]      = null;
    this.multiple            = true;
    this.queued              = 1;
    this.policyfile          = null;
    this.data                = null;
    this["merge-data"]       = true;
    this.fieldname           = "Filedata";
    this["filesize-min"]     = 1;
    this["filesize-max"]     = 0;
    this["allow-duplicates"] = false;
    this["time-limit"]       = apf.isLinux ? 0 : 30;
    this.noflash             = false;
    this.timeout             = 100000;
    this.$player             = null;
    this.$playerInited       = false;
    this.$focussable         = false;

    /**** Properties and attributes ****/

    this.$booleanProperties["uploading"]        = true;
    this.$booleanProperties["multiple"]         = true;
    this.$booleanProperties["merge-data"]       = true;
    this.$booleanProperties["allow-duplicates"] = true;
    this.$booleanProperties["noflash"]          = true;

    /**
     * @attribute {String}  value              the path of the file to uploaded,
     *                                         or the online path after upload.
     * @attribute {String}  target             URL to the server-side script
     *                                         (relative URLs are changed automatically
     *                                         to absolute paths).
     * @attribute {String}  [method]           if the method is ‘get’, data is
     *                                         appended as query-string to the URL.
     *                                         The upload will always be a POST request.
     *                                         Defaults to 'post'.
     * @attribute {Number}  !progress          the position of the progressbar
     *                                         indicating the position in the
     *                                         upload process, i.e. the realtive
     *                                         overall loaded size of running and
     *                                         completed files in the list in
     *                                         % / 100 (0..1).
     * @attribute {Boolean} !uploading         whether this upload element is
     *                                         uploading.
     * @attribute {Number}  !size              the overall size of all files in
     *                                         the list in byte.
     * @attribute {Number}  !bytes-loaded      the overall loaded size of running
     *                                         and completed files in the list in bytes.
     * @attribute {Number}  !bytes-total       the total size of files in the
     *                                         uploader queue in bytes.
     * @attribute {Number}  !rate              the overall rate of running files
     *                                         in the list in bytes/second.
     * @attribute {String}  [rel]              the AML element the file input should
     *                                         retrieve its dimensions from
     * @attribute {String}  [type-filter]      key/value pairs are used as filters
     *                                         for the dialog.
     *                                         Defaults to NULL.
     * Example:
     * <code>
     *  <a:upload type-filter="'Images (*.jpg, *.jpeg, *.gif, *.png)': '*.jpg; *.jpeg; *.gif; *.png'" />
     * </code>
     * @attribute {Boolean} [multiple]         If true, the browse-dialog allows
     *                                         multiple-file selection.
     *                                         Defaults to TRUE.
     * @attribute {Number}  [queued]           maximum of currently running files.
     *                                         If this is false, all files are uploaded
     *                                         at once. Defaults to '1'.
     * @attribute {String}  [policyfile]       location the cross-domain policy file.
     * {@link http://livedocs.adobe.com/flash/9.0/ActionScriptLangRefV3/flash/system/Security.html#loadPolicyFile%28%29 Flash Security.loadPolicyFile}
     * @attribute {String}  [data]             key/data values that are sent with
     *                                         the upload requests.
     * @attribute {Boolean} [merge-data]       If true, the data option from uploader
     *                                         and file is merged (prioritised file
     *                                         data). Defaults to TRUE.
     * @attribute {String}  [fieldname]        the key of the uploaded file on your
     *                                         server, similar to name in a file-input.
     *                                         Linux Flash ignores it, better avoid it.
     *                                         Defaults to 'Filedata'.
     * @attribute {Number}  [filesize-min]     validates the minimal size of a
     *                                         selected file byte.
     *                                         Defaults to '1'.
     * @attribute {Number}  [filesize-max]     validates the maximal size of a
     *                                         selected file
     *                                         (official limit is 100 MB for
     *                                         FileReference, I tested up to 2 GB)
     *                                         Defaults to '0'.
     * @attribute {Boolean} [allow-duplicates] validates that no duplicate files
     *                                         are added.
     *                                         Defaults to FALSE.
     * @attribute {Number}  [time-limit]       timeout in seconds. If the upload
     *                                         is without progress, it is cancelled
     *                                         and event complete gets fired (with
     *                                         error string timeout).
     *                                         Occurs usually when the server sends
     *                                         an empty response (also on redirects).
     *                                         Defaults to '30', '0' for linux.
     * @attribute {Boolean} [noflash]          whether to use flash, or fallback
     *                                         immediately to the 'old-fashioned'
     *                                         HTML uploader.
     *
     * Example:
     * When the skin doesn't have a progressbar you can use property binding to
     * update a seperate or central progressbar.
     * <code>
     *  <a:upload id="upExample" />
     *  <a:progressbar value="{upExample.progress}" />
     * </code>
     */
    this.$supportedProperties.push("value", "target", "method", "progress", "uploading",
        "rel", "bgswitch", "file-type", "multiple", "queued", "policyfile",
        "data", "merge-data", "fieldname", "filesize-min", "filesize-max",
        "allow-duplicates", "time-limit", "model");

    this.$propHandlers["value"] = function(value){
        if (!this.value)
            this.old_value = value;
        this.value = value;
    };

    this.$propHandlers["target"] = function(value){
        this.target = value = this.$qualifyPath(value);
        if (this.form)
            this.form.setAttribute("action", value);
    };

    this.$propHandlers["bgswitch"] = function(value) {
        if (!value) return;
        
        this.$getLayoutNode("main", "background", this.$ext)
            .style.backgroundImage = "url(" + this.mediaPath + value + ")";
        this.$getLayoutNode("main", "background", this.$ext)
            .style.backgroundRepeat = "no-repeat";
    };

    this.$propHandlers["rel"] = function(value) {
        var _self = this;
        window.setTimeout(function() {
            _self.rel = eval(value);
            if (_self.rel)
                _self.$reposition();
        });
    };


    var propModelHandler = this.$propHandlers["model"];
    this.$propHandlers["model"] = function(value) {
        if (!value) return;
        this.$files = new apf.upload.files(value);
        propModelHandler.call(this, value);
    };

    this.$propHandlers["noflash"] = function(value) {
        this.$useFlash = !value;
    };

    /**** Public methods ****/

    

    /**
     * Sets the icon of the button
     * @param {String} url the location of the image to be used as an icon
     */
    this.setIcon = function(url){
        this.setProperty("icon", url, false, true);
    };

    /**
     * Sets the caption of the button
     * @param {String} value the text displayed on the button
     */
    this.setCaption = function(value){
        this.setProperty("caption", value, false, true);
    };

    

    /**
     * Returns the current value of this element.
     * @return {String}
     */
    this.getValue = function(){
        return this.value;
    };

    /**
     * Sets the value of this element. This should be one of the values
     * specified in the values attribute.
     * @param {String} value the new value of this element
     */
    this.setValue = function(value){
        this.setProperty("value", value, false, true);
    };

    /**
     * Opens the browse window which allows the user to choose a file to upload.
     */
    this.browse = function(){
        // 'browse' action not available when the control is disabled, or when
        // using Flash Uploader:
        if (this.disabled || this.$useFlash || !this.$ext.parentNode.offsetHeight) //@todo apf3.0
            return;

        this.inpFile.click();
        
        if (this.inpFile.value != this.value) {
            this.setProperty("value", this.inpFile.value, false, true);
            this.dispatchEvent("afterbrowse", {value: this.value});
        }
    };

    /**
     * Starts uploading the selected file.
     */
    this.upload = function(){
        if (!this.$useFlash) {
            if (this.value != this.inpFile.value || !this.inpFile.value)
                return;

            this.old_value = this.value;
            this.value = this.inpFile.value;
            this.setValue(this.value);
        }

        this.$upload();
    };

    /**
     * Cancels the upload process
     * @param {String} msg the reason why the process was cancelled.
     */
    this.cancel = function(msg){
        return this.$cancel(msg);
    }

    /**
     * Sets the target frame to which the form is posted
     * @param {String} target the name of the frame receiving the form post.
     */
    this.setTarget = function(target){
        if (this.$useFlash) return;

        this.target = target;
        this.$initForm();
    };

    this.event = function(eventName, eventObj) {
        switch (eventName) {
            case "load":
                this.$initUploader();
                break;
            case "fail":
                /*
                 * flash   - Flash is not installed or the Flash version did not
                 *           meet the requirements.
                 * blocked - The user has to enable the movie manually because
                 *           of Flashblock, no refresh required.
                 * empty   - The Flash movie failed to load, check if the file
                 *           exists and the path is correct.
                 * hidden  - Adblock Plus blocks hides the movie, the user has
                 *           enable it and refresh.
                 */
                break;
            case "queue":
                //Function to execute when the queue statistics are updated.
                this.setProperty("bytes-loaded", eventObj.bytesLoaded);
                this.setProperty("bytes-total",  eventObj.size);
                this.setProperty("progress",     eventObj.percentLoaded / 100);
                this.setProperty("rate",         eventObj.rate);
                break;
            case "complete":
                //Function to execute when all files are uploaded (or stopped).
                this.setProperty("uploading", false);
                break;
            case "buttonEnter":
            case "buttonLeave":
            case "buttonDown":
            case "buttonDisable":
                this.$setState(eventName);
                break;
            case "browse":
                //Function to execute when the browse-dialog opens.
            case "disabledBrowse":
                //Function to execute when the user tries to open the browse-dialog,
                //but the uploader is disabled.
                if (this.rel && !this.rel.disabled)
                    this.rel.setProperty("disabled", true);
                break;
            case "cancel":
                //Function to execute when the user closes the browse-dialog without a selection.
                this.setProperty("uploading", false);
                break;
            //case "select": <-- deprecated
            case "selectSuccess":
                //Function to execute when files were selected and validated successfully.
                //param: successFiles
                this.$files.createMany(eventObj);
                break;
            case "selectFail":
                //Function to execute when files were selected and failed validation.
                //param: failFiles
                //validation error values: duplicate, sizeLimitMin, sizeLimitMax
                this.$files.removeMany(eventObj);
                break;
            case "fileStart":
                //Function to execute when flash initialised the upload for a file.
            case "fileStop":
                //Function to execute when a file got stopped manually.
            case "fileRequeue":
                //Function to execute when a file got added back to the queue after
                //being stopped or completed.
            case "fileOpen":
                //Function to execute when the file is accessed before for upload.
            case "fileProgress":
                //Function to execute when the upload reports progress.
            case "fileComplete":
                //Function to execute when a file is uploaded or failed with an error.
            case "fileRemove":
                //Function to execute when a file got removed.
                this.$files.update(eventObj);
                break;
            default:
                break;
        }

        this.setAttribute("value", this.$files.getValue());
    };

    /**** Private state handling methods ****/

    this.$initUploader = function() {
        this.$playerInited = true;
        apf.flash.remote(this.$player, "initialize", {
            width          : this.width,
            height         : this.height,
            typeFilter     : this["type-filter"],
            multiple       : this.multiple,
            queued         : this.queued,
            url            : this.target,
            method         : this.method,
            data           : this.data,
            mergeData      : this["merge-data"],
            fieldName      : this["fieldname"],
            
            verbose        : true,
            
            fileSizeMin    : this["filesize-min"],
            fileSizeMax    : this["filesize-max"],
            allowDuplicates: this["allow-duplicates"],
            timeLimit      : this["time-limit"],
            policyFile     : this["policyfile"]
        });
    };

    var states = {
        "buttonEnter": "Over",
        "buttonLeave": "Out",
        "buttonDown":  "Down"
    };

    this.$setState = function(state) {
        if (!this.rel) return null; // @todo this will go when this class inherits from button

        if (state == "buttonDisabled")
            return this.rel.setProperty("disabled", true);
        else if (this.rel.disabled)
            this.rel.setProperty("disabled", false);

        return this.rel.$setState(states[state]);
    };

    this.$reposition = function() {
        if (!this.rel) return; // @todo this will go when this class inherits from button

        var o   = this.rel.$ext,
            pos = apf.getAbsolutePosition(o);
        this.$ext.style.top    = pos[1] + "px";
        this.$ext.style.left   = pos[0] + "px";
        this.$ext.style.width  = o.offsetWidth + "px";
        this.$ext.style.height = o.offsetHeight + "px";
    };

    var anchor;
    this.$qualifyPath = function(path) {
        (anchor || (anchor = document.createElement("a"))).href = path;
        return anchor.href;
    };

    this.$updateProgress = function(){
        this.setProperty("progress", Math.min(1, (this.progress || 0) + (1/800)));
    };

    this.$upload = function(){
        this.$uploading = true;

        this.setProperty("uploading", true);

        if (this.$useFlash) {
            apf.flash.remote(this.$player, "start");
        }
        else {
            this.timer = setInterval('apf.lookup(' + this.$uniqueId + ').$updateProgress()', 800);
            this.timeout_timer = $setTimeout('apf.lookup(' + this.$uniqueId + ').$timeout()', this.timeout);
            this.form.submit();
        }
    };

    /**
     * @event uploaded Fires when the upload succeeded, was cancelled or failed.
     *   object:
     *   {String} data the data that was returned by the upload post.
     */
    this.$done = function(data){
        window.clearInterval(this.timer);
        window.clearInterval(this.timeout_timer);
        window.setTimeout('apf.lookup(' + this.$uniqueId + ').$clearProgress()', 300);

        //if (value)
        //    this.setValue(value);
        this.old_value = null;

        //if(caption)
        //this.setCaption(this.lastCaption);

        this.data = data;

        this.dispatchEvent("uploaded", {
            data: data
        });

        this.$initForm();
        this.$uploading = false;
    };

    this.$cancel = function(value){
        if (this.$useFlash) {
            apf.flash.remote(this.$player, "stop");
        }
        else {
            window.clearInterval(this.timer);
            window.clearInterval(this.timeout_timer);

            if (this.old_value)
                this.setValue(this.old_value);
            this.old_value = null;

            this.$initForm();
        }

        this.dispatchEvent("cancel", {
            returnValue: value
        });
        this.$uploading = false;

        this.$clearProgress();
    };

    /**
     * @event timeout Fires when the upload timed out.
     */
    this.$timeout = function(){
        clearInterval(this.timer);
        clearInterval(this.timeout_timer);

        /*this.oCaption.nodeValue = this.$aml.firstChild
            ? this.$aml.firstChild.nodeValue
            : "";*/
        this.$clearProgress();

        if (this.old_value)
            this.setValue(this.old_value);
        this.old_value = null;

        this.dispatchEvent("timeout");

        this.$initForm();
        this.$uploading = false;
    };

    this.$clearProgress = function(){
        this.setProperty("progress", 0);
        this.setProperty("uploading", false);
    };

    /**** Event handling ****/

    this.$initForm = function(){
        if (apf.isIE) {
            this.oFrame.contentWindow.document.write("<body></body>");
            this.form = apf.insertHtmlNode(this.$getLayoutNode("form"),
                this.oFrame.contentWindow.document.body);
        }

        //this.form = this.$getLayoutNode("main", "form", this.$ext);
        this.form.setAttribute("action", this.target);
        this.form.setAttribute("target", "upload" + this.$uniqueId);
        this.$getLayoutNode("form", "inp_uid", this.form)
            .setAttribute("value", this.$uniqueId);
        this.inpFile = this.$getLayoutNode("form", "inp_file", this.form);

        var _self = this;
        if (!apf.isIE) {
            this.inpFile.setAttribute("size", "0");
            this.inpFile.onchange = function(){
                //amlNode.$startUpload();
                _self.setProperty("value", this.value);
            }
        }

        if (apf.debug == 2) {
            this.oFrame.style.visibility = "visible";
            this.oFrame.style.width      = "100px";
            this.oFrame.style.height     = "100px";
        }

        if (apf.isIE) return;
        
        var timer = setInterval(function() {
            var oNode = _self.rel ? _self.rel : null;

            _self.inpFile.onchange = function() {_self.browse();};

            if (oNode && oNode.$ext && oNode.$ext.offsetHeight) {
                if (oNode.$ext.offsetWidth == 0 || oNode.$ext.offsetHeight == 0)
                    return;
                var z = parseInt(oNode.$ext.style.zIndex) || 1;
                oNode.$ext.style.zIndex      = z;
                _self.inpFile.style.zIndex   = ++z;
                _self.inpFile.style.margin   = "0";
                _self.inpFile.style.position = oNode.$ext.style.position;
                _self.inpFile.style.width    = oNode.$ext.offsetWidth  + "px";
                _self.inpFile.style.height   = oNode.$ext.offsetHeight + "px";
                _self.inpFile.style.top      = (oNode.$ext.offsetTop - 20)    + "px";
                _self.inpFile.style.left     = (oNode.$ext.offsetLeft - 8)   + "px";
                // @todo: resize/ move on browser resize
                
                clearInterval(timer);
            }
        }, 500);
    };

    /**
     * @event beforeuploaded Fires before data is uploaded.
     *   cancelable: Prevents the data from being uploaded.
     *   object:
     *   {String} data the data that was returned by the upload post.
     *   {HTMLFrameElement} frame the iframe serving as the target to the form post.
     */
    this.$draw = function(){
        this.$name = "upload" + this.$uniqueId;
        var _self = this;
        // first we try the Flash method:
        this.$useFlash = !this.getAttribute("noflash");
        if (this.$useFlash && !this["noflash"]) {
            this.$ext = this.$getExternal("main");//, null, function(oExt) {
            //console.dir(oExt);
            this.$ext.style.position = "absolute";
            this.$ext.style.zIndex   = "9999";
            this.$ext.style.width    = this.width;
            this.$ext.style.height   = this.height;
            apf.flash.embed({
                // apf.flash#embed properties
                context          : this,
                htmlNode         : this.$ext,
                // movie properties
                src              : this.DEFAULT_SWF_PATH,
                width            : "100%",
                height           : "100%",
                id               : this.$name,
                quality          : "high",
                //bgcolor          : "#000000",
                //allowFullScreen  : "true",
                name             : this.$name,
                flashvars        : "playerID=" + this.$playerId,
                allowScriptAccess: "always",
                wMode            : "transparent",
                swLiveConnect    : "true",
                type             : "application/x-shockwave-flash",
                pluginspage      : "http://www.adobe.com/go/getflashplayer",
                menu             : "false"
            });
        }
        else {
            this.width  = 'auto';
            this.height = 'auto';
            //Build Main Skin
            this.$ext = this.$getExternal("main", null, function(oExt){
                oExt.appendChild(oExt.ownerDocument.createElement("iframe"))
                    .setAttribute("name", "upload" + this.$uniqueId);
            });

            if (!apf.isIE)
                this.form = apf.insertHtmlNode(this.$getLayoutNode("form"), this.$ext);

            this.oFrame = this.$ext.getElementsByTagName("iframe")[0];
            apf.AbstractEvent.addListener(this.oFrame, "load", function(){
                if (!_self.uploading)
                    return;

                var data = "";
                try {
                    data = apf.html_entity_decode(_self.oFrame.contentWindow
                        .document.body.innerHTML.replace(/<PRE>|<\/PRE>/ig, ""));
                }
                catch(e){}

                var hasFailed = _self.dispatchEvent("beforeuploaded", {
                    data  : data,
                    frame : _self.oFrame
                }) === false;

                if (hasFailed)
                    _self.$cancel();
                else
                    _self.$done(data);
            });

            apf.AbstractEvent.addListener(this.oFrame, "error", function(){
                if (!_self.uploading)
                    return;

                _self.$cancel();
            });

            this.$initForm();
        }
    };

    this.addEventListener("DOMNodeRemovedFromDocument", function() {
        if (this.oFrame)
            this.oFrame.onload = null;
    });

}).call(apf.upload.prototype = new apf.StandardBinding());


apf.upload.files = function(model) {
    if (typeof model == "string")
        model = apf.nameserver.get("model", model);

    if (model)
        model.load("<files/>");

    var files = {},
        userProps = {"addDate":1, "creationDate":1, "extension":1, "id":1,
                     "modificationDate":1, "name":1, "size":1, "status":1,
                     "validationError":1
        };

    this.create = function(file) {
        if (!file || !file.id || files[file.id]) return null;

        files[file.id] = file;
        if (model) {
            file.xml = model.data.ownerDocument.createElement("file");
            apf.xmldb.appendChild(model.data, file.xml);
        }

        return this.update(file);
    };

    this.createMany = function(arr) {
        if (!arr || !arr.length) return;

        for (var i = 0, l = arr.length; i < l; i++) {
            if (arr[i])
                this.create(arr[i]);
        }
    };

    this.read = function(filename) {

    };

    this.update = function(file) {
        if (!file || !file.id) return null;

        var i;
        if (!file.xml) {
            var t = file;
            file = files[file.id];
            for (i in userProps)
                file[i] = t[i];
        }
        if (!model || !file.xml) return null;

        for (i in userProps) {
            if (typeof file[i] == "undefined") continue;
            if (i.indexOf("Date") != -1 && typeof file[i] == "number")
                file[i] = new Date(file[i]);

            file.xml.setAttribute(i, (i == "status")
                ? apf.upload.STATUS_MAP[file[i]]
                : file[i]);
        }

        apf.xmldb.applyChanges("synchronize", file.xml);

        return file;
    };

    this.remove = function(file) {
        if (!file || !file.id || !files[file.id]) return;

        file = files[file.id];
        if (model && file.xml)
            apf.xmldb.removeChild(model.data, file.xml);
        delete files[file.id];
    };

    this.removeMany = function(arr) {
        if (!arr || !arr.length) return;

        for (var i = 0, l = arr.length; i < l; i++) {
            if (arr[i])
                this.remove(arr[i]);
        }
    };

    this.getValue = function() {
        var i,
            a = [];
        for (i in files)
            a.push(files[i].name);
        return a.join("|");
    };
};

apf.upload.STATUS_QUEUED   = 0;
apf.upload.STATUS_RUNNING  = 1;
apf.upload.STATUS_ERROR    = 2;
apf.upload.STATUS_COMPLETE = 3;
apf.upload.STATUS_STOPPED  = 4;
apf.upload.STATUS_MAP = ["queued", "running", "error", "complete", "stopped"];


apf.aml.setElement("upload", apf.upload);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/dropdown.js)SIZE(14540)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */





/**
 * Element allowing a user to select a value from a list, which is 
 * displayed when the user clicks a button.
 * Example:
 * A simple dropdown with inline items.
 * <code>
 *  <a:dropdown>
 *      <a:item>The Netherlands</a:item>
 *      <a:item>United States of America</a:item>
 *      <a:item>United Kingdom</a:item>
 *      ...
 *  </a:dropdown>
 * </code>
 * Example:
 * A databound dropdown with items loaded from an xml file.
 * <code>
 *  <a:dropdown model="friends.xml" each="[friend]" caption="[@name]" />
 * </code>
 * Example:
 * A databound dropdown using the bindings element
 * <code>
 *  <a:dropdown model="friends.xml">
 *      <a:bindings>
 *          <a:caption  match = "[@name]" />
 *          <a:css      match = "[self::node()[@type='best']]" value="bestfriend" />
 *          <a:each     match = "[friend]" />
 *      </a:bindings>
 *  </a:dropdown>
 * </code>
 * Example:
 * A small form.
 * <code>
 *  <a:model id="mdlForm" submission="save_form.asp">
 *      <data>
 *          <name>Mike</name>
 *          <city>amsterdam</city>
 *      </data>
 *  </a:model>
 * 
 *  <a:bar model="mdlForm">
 *      <a:label>Name</a:label>
 *      <a:textbox value="[name]" />
 *    
 *      <a:label>City</a:label>
 *      <a:dropdown value="[mdlForm::city]" model="cities.xml">
 *          <a:bindings>
 *              <a:caption match="[text()]" />
 *              <a:value match="[@value]" />
 *              <a:each match="[city]" />
 *          </a:bindings>
 *      </a:dropdown>
 *    
 *      <a:button default="true" action="submit">Submit</a:button>
 *  </a:bar>
 * </code>
 *
 * @event slidedown Fires when the calendar slides open.
 *   cancelable: Prevents the calendar from sliding open
 * @event slideup   Fires when the calendar slides up.
 *   cancelable: Prevents the calendar from sliding up
 *
 * @constructor
 * @define dropdown
 * @allowchild item, {smartbinding}
 * @addnode elements
 *
 * @inherits apf.BaseList
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.dropdown = function(struct, tagName){
    this.$init(tagName || "dropdown", apf.NODE_VISIBLE, struct);
};

(function(){
    this.$animType        = 1;
    this.$animSteps       = 5;
    this.$animSpeed       = 20;
    this.$itemSelectEvent = "onmouseup";
    
    /**** Properties and Attributes ****/
    
    this.dragdrop      = false;
    this.reselectable  = true;
    this.$focussable   = true;
    this.autoselect    = false;
    this.multiselect   = false;
    this.disableremove = true;
    this.delayedselect = false;
    this.maxitems      = 5;
    
    this.$booleanProperties["disableremove"] = true;
    this.$supportedProperties.push("maxitems", "disableremove", 
        "initial-message", "fill");
    
    /**
     * @attribute {String} initial-message the message displayed by this element
     * when it doesn't have a value set. This property is inherited from parent 
     * nodes. When none is found it is looked for on the appsettings element. 
     *
     * @attribute {Number} maxitems the number of items that are shown at the 
     * same time in the container.
     */
    this.$propHandlers["maxitems"] = function(value){
        this.sliderHeight    = value 
            ? (Math.min(this.maxitems || 100, value) * this.itemHeight)
            : 10;
        this.containerHeight = value
            ? (Math.min(this.maxitems || 100, value) * this.itemHeight)
            : 10;
        if (this.containerHeight > 20)
            this.containerHeight = Math.ceil(this.containerHeight * 0.9);
    };
    
    /**** Public methods ****/
    
    /**
     * Toggles the visibility of the container with the list elements. It opens
     * or closes it using a slide effect.
     * @private
     */
    this.slideToggle = function(e){
        if (!e) e = event;

        if (this.isOpen)
            this.slideUp();
        else
            this.slideDown(e);
    };

    /**
     * Shows the container with the list elements using a slide effect.
     * @private
     */
    this.slideDown = function(e){
        if (this.dispatchEvent("slidedown") === false)
            return false;
        
        this.isOpen = true;

        this.$propHandlers["maxitems"].call(this, this.xmlRoot && this.each 
            ? this.getTraverseNodes().length : this.childNodes.length); //@todo apf3.0 count element nodes
        
        this.oSlider.style.display = "block";
        if (!this.ignoreOverflow) {
            this.oSlider.style[apf.supportOverflowComponent
                ? "overflowY"
                : "overflow"] = "hidden";
        }
        
        this.oSlider.style.display = "";

        this.$setStyleClass(this.$ext, this.$baseCSSname + "Down");
        
        //var pos = apf.getAbsolutePosition(this.$ext);
        this.oSlider.style.height = (this.sliderHeight - 1)     + "px";
        this.oSlider.style.width  = (this.$ext.offsetWidth - 2 - this.widthdiff) + "px";

        var _self = this;

        apf.popup.show(this.$uniqueId, {
            x       : 0,
            y       : this.$ext.offsetHeight,
            animate : true,
            ref     : this.$ext,
            width   : this.$ext.offsetWidth - this.widthdiff,
            height  : this.containerHeight,
            callback: function(container){
                if (!_self.ignoreOverflow) {
                    container.style[apf.supportOverflowComponent
                        ? "overflowY"
                        : "overflow"] = "auto";
                }
            }
        });
    };
    
    /**
     * Hides the container with the list elements using a slide effect.
     * @private
     */
    this.slideUp = function(){
        if (this.isOpen == 2) return false;
        if (this.dispatchEvent("slideup") === false) return false;
        
        this.isOpen = false;
        if (this.selected) {
            var htmlNode = apf.xmldb.findHtmlNode(this.selected, this);
            if(htmlNode) this.$setStyleClass(htmlNode, '', ["hover"]);
        }
        
        this.$setStyleClass(this.$ext, '', [this.$baseCSSname + "Down"]);
        apf.popup.hide();
        return false;
    };
    
    /**** Private methods and event handlers ****/

    //@todo apf3.0 why is this function called 6 times on init.
    this.$setLabel = function(value){
        
        this.oLabel.innerHTML = value || this["initial-message"] || "";
        
        
        this.$setStyleClass(this.$ext, value ? "" : this.$baseCSSname + "Initial",
            !value ? [] : [this.$baseCSSname + "Initial"]);
    };

    this.addEventListener("afterselect", function(e){
        if (!e) e = event;
        
        this.slideUp();
        if (!this.isOpen)
            this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Over"]);
        
        this.$setLabel(e.selection.length
         ? this.$applyBindRule("caption", this.selected)
         : "");
    });
    
    function setMaxCount() {
        if (this.isOpen == 2)
            this.slideDown();
    }

    this.addEventListener("afterload", setMaxCount);
    this.addEventListener("xmlupdate", function(){
        setMaxCount.call(this);
        this.$setLabel(this.$applyBindRule("caption", this.selected));
    });
    
    // Private functions
    this.$blur = function(){
        this.slideUp();
        //this.$ext.dispatchEvent("mouseout")
        if (!this.isOpen)
            this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Over"])
        
        this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Focus"]);
    };
    
    /*this.$focus = function(){
        apf.popup.forceHide();
        this.$setStyleClass(this.oFocus || this.$ext, this.$baseCSSname + "Focus");
    }*/
    
    this.$setClearMessage = function(msg){
        this.$setLabel(msg);
    };
    
    this.$removeClearMessage = function(){
        this.$setLabel("");
    };

    this.addEventListener("popuphide", this.slideUp);
    
    /**** Keyboard Support ****/
    
    
    this.addEventListener("keydown", function(e){
        var key      = e.keyCode;
        //var ctrlKey  = e.ctrlKey; << unused
        //var shiftKey = e.shiftKey;
        
        if (!this.xmlRoot) return;
        
        var node;
        
        switch (key) {
            case 38:
                //UP
                if (e.altKey) {
                    this.slideToggle(e.htmlEvent);
                    return;
                }
                
                if (!this.selected) 
                    return;
                    
                node = this.getNextTraverseSelected(this.caret
                    || this.selected, false);

                if (node)
                    this.select(node);
                break;
            case 40:
                //DOWN
                if (e.altKey) {
                    this.slideToggle(e.htmlEvent);
                    return;
                }
                
                if (!this.selected) {
                    node = this.getFirstTraverseNode();
                    if (!node) 
                        return;
                } 
                else
                    node = this.getNextTraverseSelected(this.selected, true);
                
                if (node)
                    this.select(node);
                
                break;
            default:
                if (key == 9 || !this.xmlRoot) return;	
            
                //if(key > 64 && key < 
                if (!this.lookup || new Date().getTime() - this.lookup.date.getTime() > 1000)
                    this.lookup = {
                        str  : "",
                        date : new Date()
                    };

                this.lookup.str += String.fromCharCode(key);
                
                var caption, nodes = this.getTraverseNodes();
                for (var i = 0; i < nodes.length; i++) {
                    caption = this.$applyBindRule("caption", nodes[i]);
                    if (caption && caption.indexOf(this.lookup.str) > -1) {
                        this.select(nodes[i]);
                        return;
                    }
                }
            return;
        }

        return false;
    }, true);
    
    
    /**** Init ****/
    
    this.$draw = function(){
        this.$getNewContext("main");
        this.$getNewContext("container");
        
        this.$animType = this.$getOption("main", "animtype") || 1;
        this.clickOpen = this.$getOption("main", "clickopen") || "button";

        //Build Main Skin
        this.$ext = this.$getExternal(null, null, function(oExt){
            oExt.setAttribute("onmouseover", 'var o = apf.lookup(' + this.$uniqueId
                + ');o.$setStyleClass(o.$ext, o.$baseCSSname + "Over");');
            oExt.setAttribute("onmouseout", 'var o = apf.lookup(' + this.$uniqueId
                + ');if(o.isOpen) return;o.$setStyleClass(o.$ext, "", [o.$baseCSSname + "Over"]);');
            
            //Button
            var oButton = this.$getLayoutNode("main", "button", oExt);
            if (oButton) {
                oButton.setAttribute("onmousedown", 'apf.lookup('
                    + this.$uniqueId + ').slideToggle(event);');
            }
            
            //Label
            var oLabel = this.$getLayoutNode("main", "label", oExt);
            if (this.clickOpen == "both") {
                oLabel.parentNode.setAttribute("onmousedown", 'apf.lookup('
                    + this.$uniqueId + ').slideToggle(event);');
            }
        });
        this.oLabel = this.$getLayoutNode("main", "label", this.$ext);
        
        
        if (this.oLabel.nodeType == 3)
            this.oLabel = this.oLabel.parentNode;
        
        
        this.oIcon = this.$getLayoutNode("main", "icon", this.$ext);
        if (this.$button)
            this.$button = this.$getLayoutNode("main", "button", this.$ext);
        
        this.oSlider = apf.insertHtmlNode(this.$getLayoutNode("container"),
            document.body);
        this.$int = this.$getLayoutNode("container", "contents", this.oSlider);
        
        //Set up the popup
        this.$pHtmlDoc = apf.popup.setContent(this.$uniqueId, this.oSlider,
            apf.skins.getCssString(this.skinName));
        
        //Get Options form skin
        //Types: 1=One dimensional List, 2=Two dimensional List
        this.listtype = parseInt(this.$getLayoutNode("main", "type")) || 1;
        
        this.itemHeight     = this.$getOption("main", "item-height") || 18.5;
        this.widthdiff      = this.$getOption("main", "width-diff") || 0;
        this.ignoreOverflow = apf.isTrue(this.$getOption("main", "ignore-overflow")) || false;
    };
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(){
        if (typeof this["initial-message"] == "undefined")
            this.$setInheritedAttribute("initial-message");
        
        if (!this.selected && this["initial-message"])
            this.$setLabel();
    });
    
    this.$destroy = function(){
        apf.popup.removeContent(this.$uniqueId);
        apf.destroyHtmlNode(this.oSlider);
        this.oSlider = null;
    };
}).call(apf.dropdown.prototype = new apf.BaseList());

apf.config.$inheritProperties["initial-message"] = 1;

apf.aml.setElement("dropdown", apf.dropdown);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/contextmenu.js)SIZE(2560)TIME(1263686463)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * element specifying which menu is shown when a
 * contextmenu is requested by a user for a aml node.
 * Example:
 * This example shows a list that shows the mnuRoot menu when the user
 * right clicks on the root {@link term.datanode data node}. Otherwise the mnuItem menu is
 * shown.
 * <code>
 *  <a:list>
 *      <a:contextmenu menu="mnuRoot" select="root" />
 *      <a:contextmenu menu="mnuItem" />
 *  </a:list>
 * </code>
 * @attribute {String} menu   the id of the menu element.
 * @attribute {String} select the xpath executed on the selected element of the databound element which determines whether this contextmenu is shown.
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.contextmenu = function(){
    this.$init("contextmenu", apf.NODE_HIDDEN);
};

(function(){
    this.$amlNodes = [];
    
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        "match" : 1
    }, this.$attrExcludePropBind);
    
    this.register = function(amlParent){
        if (!amlParent.contextmenus)
            amlParent.contextmenus = [];
        amlParent.contextmenus.push(this);
    };
    
    this.unregister = function(amlParent){
        amlParent.contextmenus.remove(this);
    };
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        this.register(this.parentNode);
    });
}).call(apf.contextmenu.prototype = new apf.AmlElement());

apf.aml.setElement("contextmenu", apf.contextmenu);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/vectorflow.js)SIZE(65716)TIME(1265021706)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/menu.js)SIZE(16478)TIME(1263686463)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element displaying a skinnable menu of items which can be choosen.
 * Based on the context of the menu, items can be shown and hidden. That's
 * why this element is often called a contextmenu.
 * Example:
 * <code>
 *  <a:iconmap 
 *    id     = "tbicons" 
 *    src    = "toolbar.icons.gif"
 *    type   = "horizontal" 
 *    size   = "20" 
 *    offset = "2,2"></a:iconmap>
 * 
 *  <a:menu id="msub">
 *      <a:item icon="tbicons:12">test</a:item>
 *      <a:item icon="tbicons:14">test2</a:item>
 *  </a:menu>
 * 
 *  <a:menu id="mmain">
 *      <a:item icon="tbicons:1">table_wizard</a:item>
 *      <a:item icon="tbicons:2" hotkey="Ctrl+M">table_wizard</a:item>
 *      <a:divider></a:divider>
 *      <a:radio>item 1</a:radio>
 *      <a:radio>item 2</a:radio>
 *      <a:radio>item 3</a:radio>
 *      <a:radio>item 4</a:radio>
 *      <a:divider></a:divider>
 *      <a:check hotkey="Ctrl+T">item check 1</a:check>
 *      <a:check hotkey="F3">item check 2</a:check>
 *      <a:divider></a:divider>
 *      <a:item icon="tbicons:11" submenu="msub">table_wizard</a:item>
 *      <a:item icon="tbicons:10">table_wizard</a:item>
 *  </a:menu>
 * 
 *  <a:window 
 *    visible     = "true" 
 *    width       = "200"
 *    height      = "190"
 *    contextmenu = "mmain"
 *    center      = "true">
 *  </a:window>
 * </code>
 * @see baseclass.guielement.event.contextmenu
 *
 * @event display   Fires when the contextmenu is shown.
 * @event itemclick Fires when a user presses the mouse button while over a child of this element.
 *   object:
 *   {String} value the value of the clicked element.
 *
 * @constructor
 * @define menu
 * @allowchild item, divider, check, radio
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @inherits apf.Presentation
 */
apf.menu = function(struct, tagName){
    this.$init(tagName || "menu", apf.NODE_VISIBLE, struct);
};

(function(){
    this.$focussable  = apf.KEYBOARD;
    this.$positioning = "basic"
    //var _self         = this;
    //var blurring      = false;

    /**** Properties and Attributes ****/
    
    this.anim   = true;
    this.zindex = 10000000;

    this.$booleanProperties["anim"] = true;
    this.$propHandlers["visible"] = function(value, prop, force, nofocus, hideOpener){
        if (value) {
            this.$ext.style.display = "block";
            if(this.opener.localName.indexOf('item') > -1)
                this.opener.parentNode.$showingSubMenu = this;
        }
        else {
            this.$ext.style.display = "none";

            var lastFocus = apf.menu.lastFocus;

            //@todo test this with a list being the opener of the menu
            if (lastFocus != this.opener && this.opener && this.opener.$blur)
                this.opener.$blur();

            if (this.opener && this.opener.parentNode.localName == "menu") {
                if (!this.$hideTree)
                    this.$hideTree = -1
                this.opener.parentNode.focus();
            }
            
            
            else if (lastFocus) {
                //We're being hidden because some other object gets focus
                if (apf.window.$settingFocus) {
                    if (apf.window.$settingFocus != lastFocus && lastFocus.$blur)
                        lastFocus.$blur();
                    this.$blur();

                    if (apf.window.$settingFocus.localName != "menu") //not menu walking
                        apf.menu.lastFocus = null;
                }
                //We're being hidden because window looses focus
                else if (!apf.window.hasFocus()) {
                    if (lastFocus.$blur)
                        lastFocus.$blur();
                    this.$blur();

                    apf.document.activeElement = lastFocus;
                    if (lastFocus.$focusParent)
                        lastFocus.$focusParent.$lastFocussed = lastFocus;

                    apf.menu.lastFocus = null;
                }
                //We're just being hidden
                else if (this.$hideTree) {
                    if (!this.$hideTree)
                        this.$hideTree = -1

                    var visTest = (lastFocus.disabled || !lastFocus.visible)
                        && lastFocus != apf.document.documentElement;

                    if (nofocus || visTest) {
                        if (lastFocus.$blur)
                            lastFocus.$blur();
                        this.$blur();
                        apf.document.activeElement = null;

                        if (visTest && apf.window.moveNext() === false)
                            apf.window.$focusRoot();
                    }
                    else {
                        lastFocus.focus(null, null, true);
                    }

                    apf.menu.lastFocus = null;
                }
            }
            

            if (this.$showingSubMenu) {
                this.$showingSubMenu.hide();
                this.$showingSubMenu = null;
            }

            if (this.opener && this.opener.$submenu) {
                this.opener.$submenu(true, true);

                //@todo problem with loosing focus when window looses focus
                if (this.$hideTree === true && this.opener.parentNode.localName == "menu") {
                    this.opener.parentNode.$hideTree = true
                    this.opener.parentNode.hide();
                }
                
                this.opener = null;
            }
            this.$hideTree = null;

            if (this.$selected) {
                apf.setStyleClass(this.$selected.$ext, "", ["hover"]);
                this.$selected = null;
            }
        }
    };

    /**** Public Methods ****/

    var lastFocus;

    /**
     * Shows the menu, optionally within a certain context.
     * @param {Number}     x        the left position of the menu.
     * @param {Number}     y        the top position of the menu.
     * @param {Boolean}    noanim   whether to animate the showing of this menu.
     * @param {AMLElement} opener   the element that is the context of this menu.
     * @param {XMLElement} xmlNode  the {@link term.datanode data node} that provides data context to the menu child nodes.
     * @see baseclass.guielement.event.contextmenu
     */
    this.display = function(x, y, noanim, opener, xmlNode, openMenuId, btnWidth){
        this.opener = opener;
        this.dispatchEvent("display");

        //Show / hide Child Nodes Based on XML
        var last, i, node,
            nodes = this.childNodes,
            c     = 0,
            l     = nodes.length, result;
        for (i = 0; i < l; i++) {
            node = nodes[i];
            if (node.nodeType != 1) continue;

            result = !xmlNode || !node.match || (node.cmatch || (node.cmatch = apf.lm.compile(node.match, {
                xpathmode  : 3,
                injectself : true
            })))(xmlNode)

            if (result) {
                node.show();

                if (node.localName == "divider") {
                    last = node;
                    if (c == 0)
                        node.hide();
                    c = 0;
                }
                else c++;
            }
            else {
                node.hide();

                if (!node.nextSibling && c == 0)
                    last.hide();
            }
        }

        if (this.oOverlay) {
            if (btnWidth) {
                this.oOverlay.style.display = "block";
                this.oOverlay.style.width   = btnWidth + "px";
            }
            else
                this.oOverlay.style.display = "none";
        }

        this.visible = false;
        this.show();

        var bodyPos = apf.getAbsolutePosition(document.body);
        apf.popup.show(this.$uniqueId, {
            x            : x - bodyPos[0], 
            y            : y - bodyPos[1] - (apf.isIE && apf.isIE < 8 ? 1 : 0), 
            animate      : noanim || !this.anim ? false : "fade",
            ref          : this.$ext.offsetParent,
            allowTogether: openMenuId,
            autoCorrect  : false
        });

        var lastFocus      =
        apf.menu.lastFocus = opener && opener.$focussable === true
            ? opener
            : apf.menu.lastFocus || apf.document.activeElement;
        
        apf.popup.last = null;
        this.focus();

        //Make the component that provides context appear to have focus

        if (lastFocus && lastFocus != this && lastFocus.$focus)
            lastFocus.$focus();

        this.xmlReference = xmlNode;
    };

    /**
     * Returns the current value of this element.
     * @return {String}
     */
    this.getValue = function(group){
        return this.getSelected(group).value || "";
    };

    /**
     * Retrieves the selected element from a group of radio elements.
     * @param {String} group the name of the group.
     * @return {radio} the selected radio element.
     */
    this.getSelected = function(group){
        var nodes = this.childNodes;
        var i, l = nodes.length;
        for (i = 0; i < l; i++) {
            if (nodes[i].group != group)
                continue;

            if (nodes[i].selected)
                return nodes[i];
        }

        return false;
    }

    /**
     * Selects an element within a radio group.
     * @param {String} group  the name of the group.
     * @param {String} value  the value of the item to select.
     */
    this.select = function(group, value){
        var nodes = this.childNodes;
        var i, l = nodes.length;
        for (i = 0; i < l; i++) {
            if (nodes[i].group != group)
                continue;

            if (nodes[i].value == value || !nodes[i].value && nodes[i].caption == value)
                nodes[i].$handlePropSet("selected", true);
            else if (nodes[i].selected)
                nodes[i].$handlePropSet("selected", false);
        }
    };

    /**** Events ****/

    
    this.addEventListener("keydown", function(e){
        var node, key = e.keyCode;
        //var ctrlKey  = e.ctrlKey;
        //var shiftKey = e.shiftKey;

        switch (key) {
            case 13:
                if (!this.$selected)
                    return;

                node = this.$selected;
                node.$down();
                node.$up();
                node.$click();
                break;
            case 38:
                //UP
                node = this.$selected && this.$selected.previousSibling
                  || this.lastChild;

                if (node && node.localName == "divider")
                    node = node.previousSibling;

                if (!node)
                    return;

                if (this.$selected)
                    apf.setStyleClass(this.$selected.$ext, "", ["hover"]);

                apf.setStyleClass(node.$ext, "hover");
                this.$selected = node;
                break;
            case 40:
                //DOWN
                node = this.$selected && this.$selected.nextSibling
                  || this.firstChild;

                if (node && node.localName == "divider")
                    node = node.nextSibling;

                if (!node)
                    return;

                if (this.$selected)
                    apf.setStyleClass(this.$selected.$ext, "", ["hover"]);

                apf.setStyleClass(node.$ext, "hover");
                this.$selected = node;
                break;
            case 37:
                //LEFT
                //if (this.$selected && this.$selected.submenu)
                    //this.$selected.$submenu(true, true);

                if (!this.opener)
                    return;

                if (this.opener.localName == "button") {
                    node = this.opener.previousSibling;
                    while(node && !node.submenu)
                        node = node.previousSibling;

                    if (node) {
                        node.dispatchEvent("mouseover");

                        var btnMenu = node.parentNode.menuIsPressed;
                        if (btnMenu) {
                            self[btnMenu.submenu].dispatchEvent("keydown", {
                                keyCode : 40
                            });
                        }
                    }
                }
                else if (this.opener.parentNode.localName == "menu") {
                    //@todo Ahum bad abstraction boundary
                    var op = this.opener;
                    this.hide();
                    apf.setStyleClass(op.$ext, "hover");
                    op.parentNode.$showingSubMenu = null;
                }

                break;
            case 39:
                //RIGHT
                if (this.$selected && this.$selected.submenu) {
                    this.$selected.$submenu(null, true);
                    this.$showingSubMenu.dispatchEvent("keydown", {
                       keyCode : 40
                    });

                    return;
                }

                if (this.opener) {
                    var op = this.opener;
                    while (op && op.parentNode && op.parentNode.localName == "menu")
                        op = op.parentNode.opener;

                    if (op && op.localName == "button") {
                        node = op.nextSibling;
                        while(node && !node.submenu)
                            node = node.nextSibling;

                        if (node) {
                            node.dispatchEvent("mouseover");

                            var btnMenu = node.parentNode.menuIsPressed;
                            if (btnMenu) {
                                self[btnMenu.submenu].dispatchEvent("keydown", {
                                    keyCode : 40
                                });
                            }

                            return;
                        }
                    }
                }

                if (!this.$selected) {
                    arguments.callee.call(this, {
                       keyCode : 40
                    });
                }

                break;
            default:
                return;
        }

        return false;
    }, true);
    

    //Hide menu when it looses focus or when the popup hides itself
    function forceHide(){
        if (this.$showingSubMenu)
            return;

        if (this.$hideTree != -1) {
            this.$hideTree = true;
            this.hide();
        }

        return false;
    }

    this.addEventListener("focus", function(){
        apf.popup.last = this.$uniqueId;
    });

    this.addEventListener("blur", forceHide);
    this.addEventListener("popuphide", forceHide);

    /**** Init ****/

    this.$draw = function(){
        this.$pHtmlNode = document.body;

        //Build Main Skin
        this.$ext = this.$getExternal();
        this.oOverlay = this.$getLayoutNode("main", "overlay", this.$ext);

        apf.popup.setContent(this.$uniqueId, this.$ext, "", null, null);
    };

    this.$loadAml = function(x){
        this.$int = this.$getLayoutNode("main", "container", this.$ext);
    };

    this.$destroy = function(){
        apf.popup.removeContent(this.$uniqueId);
    };
}).call(apf.menu.prototype = new apf.Presentation());

apf.aml.setElement("menu", apf.menu);


/*FILEHEAD(/var/lib/platform/source/trunk/elements/palette.js)SIZE(5882)TIME(1260316863)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element displaying a set of choices to the user which allows
 * him/her to pick a specific color. This element also gives the
 * user a choice to add a custom color.
 *
 * @constructor
 * @define palette
 * @allowchild {smartbinding}
 * @addnode elements
 *
 * @inherits apf.XForms
 * @inherits apf.StandardBinding
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @binding value  Determines the way the value for the element is retrieved 
 * from the bound data.
 * Example:
 * Sets the color based on data loaded into this component.
 * <code>
 *  <a:model id="mdlColor">
 *      <data color="#000099"></data>
 *  </a:model>
 *  <a:palette model="mdlColor" value="[@color]" />
 * </code>
 * Example:
 * A shorter way to write this is:
 * <code>
 *  <a:model id="mdlColor">
 *      <data color="#000099"></data>
 *  </a:model>
 *  <a:palette value="[mdlColor::@color]" />
 * </code>
 */
apf.palette = function(struct, tagName){
    this.$init(tagName || "palette", apf.NODE_VISIBLE, struct);
};

(function(){
    this.implement(
        
        apf.DataAction
        
        
    );
    /**** Properties and Attributes ****/
    
    this.$focussable = true; // This object can get the focus
    this.value       = "ff0000";
    this.direction   = "down";
    
    this.$supportedProperties.push("value");
    /**
     * The selected color of the palette
     */
    this.$propHandlers["value"] = function(value){
        this.oViewer.style.backgroundColor = value;
    };
    
    /**** Public methods ****/
    
    
    
    /**
     * Sets the value of this element. This should be one of the values
     * specified in the values attribute.
     * @param {String} value the new value of this element
     */
    this.setValue = function(value){
        this.setProperty("value", value, false, true);
    };
    
    /**
     * Returns the current value of this element.
     * @return {String}
     */
    this.getValue = function(){
        return this.value ? this.value : "";
    };
    
    
    
    /**** Private state handling methods ****/
    
    this.$addColor = function(clr, oContainer){
        if (!oContainer) 
            oContainer = this.oCustom;
        
        var oItem = this.$getLayoutNode("item");
        
        if (oContainer == this.oCustom) {
            oItem.setAttribute("onmousedown", "apf.lookup(" 
                + this.$uniqueId + ").$doCustom(this)");
            oItem.setAttribute("ondblclick", "apf.lookup(" 
                + this.$uniqueId + ").$doCustom(this, true)");
        }
        else 
            oItem.setAttribute("onmousedown", "apf.lookup(" + this.$uniqueId 
                + ").change(this.style.backgroundColor.replace(/^#/, ''))");

        oItem = apf.insertHtmlNode(oItem, oContainer);
        this.$getLayoutNode("item", "background", oItem).style.backgroundColor = "#"+clr;
    };
    
    this.$setCustom = function(oItem, clr){
        oItem.style.backgroundColor = clr;
        this.change(clr);
    };
    
    /**
     * @event createcustom Fires when a custom color is choosen. This event allows the developer to display a color picker to fill the palette's color.
     *   object:
     *   {HTMLElement} htmlNode the rectangle in the palette to be filled.
     */
    this.$doCustom = function(oItem, force_create){
        if (force_create || oItem.style.backgroundColor == "#ffffff") {
            this.dispatchEvent("createcustom", {
                htmlNode: oItem
            });
        }
        else 
            this.change(oItem.style.backgroundColor.replace(/^#/, ""));
    };
    
    this.defaultValue = "ff0000";
    
    this.colors = ["fc0025", "ffd800", "7dff00", "32ffe0", "0026ff",
        "cd00ff", "ffffff", "e5e5e5", "d9d9d9", "de003a",
        "ffc600", "009022", "00bee1", "003e83", "dc0098", 
        "737373", "666666", "000000"];
    
    this.$draw = function(){
        //Build Main Skin
        this.$ext      = this.$getExternal();
        this.oViewer   = this.$getLayoutNode("main", "viewer", this.$ext);
        this.oStandard = this.$getLayoutNode("main", "standard", this.$ext);
        this.oCustom   = this.$getLayoutNode("main", "custom", this.$ext);

        var i;
        for (i = 0; i < this.colors.length; i++) 
            this.$addColor(this.colors[i], this.oStandard);
        for (i = 0; i < 9; i++) 
            this.$addColor("ffffff");
        
        //this.oViewer.setAttribute("ondblclick", "apf.lookup(" + this.$uniqueId + ").openColorPicker()");
    };

}).call(apf.palette.prototype = new apf.StandardBinding());


apf.aml.setElement("palette", apf.palette);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/textbox.js)SIZE(23735)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




//@todo DOCUMENT the modules too

/**
 * Element displaying a rectangular area wich allows a
 * user to type information. The information typed can be
 * restricted by using this.$masking. The information can also
 * be hidden from view when used in password mode. By adding an 
 * {@link element.autocomplete autocomplete element} as a child the 
 * value for the textbox can be looked up as you type. By setting the 
 * {@link element.textbox.attribute.mask mask atribute}, complex data input 
 * validation is done while the users types.
 * 
 * @constructor
 * @define input, secret, textarea, textbox
 * @allowchild autocomplete, {smartbinding}
 * @addnode elements
 *
 * @inherits apf.StandardBinding
 * @inherits apf.XForms
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.1
 *
 * @binding value  Determines the way the value for the element is retrieved 
 * from the bound data.
 * Example:
 * Sets the value based on data loaded into this component.
 * <code>
 *  <a:model id="mdlTextbox">
 *      <data name="Lukasz"></data>
 *  </a:model>
 *  <a:textbox model="mdlTextbox" value="[@name]" />
 * </code>
 * Example:
 * A shorter way to write this is:
 * <code>
 *  <a:model id="mdlTextbox">
 *      <data name="Lukasz"></data>
 *  </a:model>
 *  <a:textbox value="[mdlTextbox::@name]" />
 * </code>
 *
 * @event click     Fires when the user presses a mousebutton while over this element and then let's the mousebutton go. 
 * @event mouseup   Fires when the user lets go of a mousebutton while over this element. 
 * @event mousedown Fires when the user presses a mousebutton while over this element. 
 * @event keyup     Fires when the user lets go of a keyboard button while this element is focussed. 
 *   object:
 *   {Number}  keyCode   which key was pressed. This is an ascii number.
 * @event clear     Fires when the content of this element is cleared. 
 */
apf.input    = function(struct, tagName){
    this.$init(tagName || "input", apf.NODE_VISIBLE, struct);
};

apf.secret   = function(struct, tagName){
    this.$init(tagName || "secret", apf.NODE_VISIBLE, struct);
};

apf.password = function(struct, tagName){
    this.$init(tagName || "password", apf.NODE_VISIBLE, struct);
};

apf.textarea = function(struct, tagName){
    this.$init(tagName || "textarea", apf.NODE_VISIBLE, struct);
    
    this.multiline = true;
};

// HTML5 email element
apf.email    = function(struct, tagName){
    this.$init(tagName || "email", apf.NODE_VISIBLE, struct);
};

apf.textbox  = function(struct, tagName){
    this.$init(tagName || "textbox", apf.NODE_VISIBLE, struct);
};

(function(){
    this.implement(
        
        apf.DataAction
        
        
    );

    this.$focussable       = true; // This object can get the focus
    this.$masking          = false;

    this.$childProperty    = "value";

    //this.realtime          = false;
    this.value             = "";
    this.isContentEditable = true;
    this.multiline         = false;

    /**
     * @attribute {Boolean} realtime whether the value of the bound data is
     * updated as the user types it, or only when this element looses focus or
     * the user presses enter.
     */
    this.$booleanProperties["focusselect"] = true;
    this.$booleanProperties["realtime"]    = true;
    this.$supportedProperties.push("value", "mask", "initial-message",
        "focusselect", "realtime", "type");

    /**
     * @attribute {String} value the text of this element
     * @todo apf3.0 check use of this.$propHandlers["value"].call
     */
    this.$propHandlers["value"] = function(value, prop, initial){
        if (!this.$int || !initial && this.getValue() == value)
            return;

        // Set Value
        if (!initial && !value) //@todo apf3.x research the use of clear
            this.clear();
        else if (this.isHTMLBox) {
            if (this.$int.innerHTML != value)
                this.$int.innerHTML = value;
        }
        else if (this.$int.value != value)
            this.$int.value = value;
        
        if (this.$button)
            this.$button.style.display = value && !initial ? "block" : "none";
    };

    //See validation
    //var oldPropHandler = this.$propHandlers["maxlength"];
    this.addEventListener("prop.maxlength", function(e){

        //Special validation support using nativate max-length browser support
        if (this.$int.tagName.toLowerCase().match(/input|textarea/))
            this.$int.maxLength = parseInt(e.value) || null;
    });

    /**
     * @attribute {String} mask a complex input pattern that the user should
     * adhere to. This is a string which is a combination of special and normal
     * characters. Then comma seperated it has two options. The first option
     * specifies whether the non input characters (the chars not typed by the
     * user) are in the value of this element. The second option specifies the
     * character that is displayed when the user hasn't yet filled in a
     * character.
     *   Possible values:
     *   0  Any digit
     *   1  The number 1 or 2.
     *   9  Any digit or a space.
     *   #  User can enter a digit, space, plus or minus sign.
     *   L  Any alpha character, case insensitive.
     *   ?  Any alpha character, case insensitive or space.
     *   A  Any alphanumeric character.
     *   a  Any alphanumeric character or space.
     *   X  Hexadecimal character, case insensitive.
     *   x  Hexadecimal character, case insensitive or space.
     *   &  Any whitespace.
     *   C  Any character.
     *   !  Causes the input mask to fill from left to right instead of from right to left.
     *   '  The start or end of a literal part.
     *   "  The start or end of a literal part.
     *   >  Converts all characters that follow to uppercase.
     *   <  Converts all characters that follow to lowercase.
     *   \  Cancel the special meaning of a character.
     * Example:
     * An american style phone number.
     * <code>
     *  <a:textbox mask="(000)0000-0000;;_" />
     * </code>
     * Example:
     * A dutch postal code
     * <code>
     *  <a:textbox mask="0000 AA;;_" />
     * </code>
     * Example:
     * A date
     * <code>
     *  <a:textbox mask="00-00-0000;;_" datatype="xsd:date" />
     * </code>
     * Example:
     * A serial number
     * <code>
     *  <a:textbox mask="'WCS74'0000-00000;1;_" />
     * </code>
     * Example:
     * A MAC address
     * <code>
     *  <a:textbox mask="XX-XX-XX-XX-XX-XX;;_" />
     * </code>
     */
    this.$propHandlers["mask"] = function(value){
        if (this.mask.toLowerCase() == "password")// || !apf.hasMsRangeObject)
            return;

        if (!value) {
            throw new Error("Not Implemented");
        }

        if (!this.$masking) {
            this.$masking = true;
            this.implement(apf.textbox.masking);
            this.focusselect = false;
            //this.realtime    = false;
        }

        this.setMask(this.mask);
    };

    //this.$propHandlers["ref"] = function(value) {
    //    this.$int.setAttribute("name",  value.split("/").pop().split("::").pop()
    //        .replace(/[\@\.\(\)]*/g, ""));
    //};

    /**
     * @attribute {String} initial-message the message displayed by this element
     * when it doesn't have a value set. This property is inherited from parent
     * nodes. When none is found it is looked for on the appsettings element.
     */
    this.$propHandlers["initial-message"] = function(value){
        if (value) {
            
            if (apf.hasFocusBug)
                this.$int.onblur();
            
            
            //this.$propHandlers["value"].call(this, value, null, true);
        }
        
        if (!this.value)
            this.clear();
    };

    /**
     * @attribute {Boolean} focusselect whether the text in this element is
     * selected when this element receives focus.
     */
    this.$propHandlers["focusselect"] = function(value){
        var _self = this;
        this.$int.onmousedown = function(){
            _self.focusselect = false;
        };

        this.$int.onmouseup  =
        this.$int.onmouseout = function(){
            _self.focusselect = value;
        };
    };

    /**
     * @attribute {String} type the type or function this element represents.
     * This can be any arbitrary name. Although there are some special values.
     *   Possible values:
     *   username   this element is used to type in the name part of login credentials.
     *   password   this element is used to type in the password part of login credentials.
     */
    this.$propHandlers["type"] = function(value){
        if (value && "password|username".indexOf(value) > -1
          && typeof this.focusselect == "undefined") {
            this.focusselect = true;
            this.$propHandlers["focusselect"].call(this, true);
        }
    };

    /**** Public Methods ****/

    

    /**
     * Sets the value of this element. This should be one of the values
     * specified in the values attribute.
     * @param {String} value the new value of this element
     */
    this.setValue = function(value){
        return this.setProperty("value", value, false, true);
    };
    
    //@todo cleanup and put initial-message behaviour in one location
    this.clear = function(){
        if (this["initial-message"]) {
            this.$propHandlers["value"].call(this, this["initial-message"], null, true);
            apf.setStyleClass(this.$ext, this.$baseCSSname + "Initial");
        }
        else {
            this.$propHandlers["value"].call(this, "", null, true);
        }
        
        this.dispatchEvent("clear");//@todo this should work via value change
    }

    /**
     * Returns the current value of this element.
     * @return {String}
     */
    this.getValue = function(){
        var v = this.isHTMLBox ? this.$int.innerHTML : this.$int.value;
        return v == this["initial-message"] ? "" : v.replace(/\r/g, "");
    };
    
    

    /**
     * Selects the text in this element.
     */
    this.select   = function(){ 
        try {
            this.$int.select(); 
        }
        catch(e){}
    };

    /**
     * Deselects the text in this element.
     */
    this.deselect = function(){ this.$int.deselect(); };

    /**** Private Methods *****/

    this.$enable  = function(){ this.$int.disabled = false; };
    this.$disable = function(){ this.$int.disabled = true; };

    this.$insertData = function(str){
        return this.setValue(str);
    };

    /**
     * @private
     */
    this.insert = function(text){
        if (apf.hasMsRangeObject) {
            try {
                this.$int.focus();
            }
            catch(e) {}
            var range = document.selection.createRange();
            if (this.oninsert)
                text = this.oninsert(text);
            range.pasteHTML(text);
            range.collapse(true);
            range.select();
        }
        else {
            this.$int.value += text;
        }
    };

    this.addEventListener("$clear", function(){
        this.value = "";//@todo what about property binding?
        
        if (this["initial-message"] && apf.document.activeElement != this) {
            this.$propHandlers["value"].call(this, this["initial-message"], null, true);
            apf.setStyleClass(this.$ext, this.$baseCSSname + "Initial");
        }
        else {
            this.$propHandlers["value"].call(this, "");
        }
        
        if (!this.$int.tagName.toLowerCase().match(/input|textarea/i)) {
            if (apf.hasMsRangeObject) {
                try {
                    var range = document.selection.createRange();
                    range.moveStart("sentence", -1);
                    //range.text = "";
                    range.select();
                }
                catch(e) {}
            }
        }
        
        this.dispatchEvent("clear"); //@todo apf3.0
    });

    this.$keyHandler = function(key, ctrlKey, shiftKey, altKey, e){
        if (this.$button && key == 27) {
            this.clear();
            this.blur();
        }
        
        if (this.dispatchEvent("keydown", {
            keyCode   : key,
            ctrlKey   : ctrlKey,
            shiftKey  : shiftKey,
            altKey    : altKey,
            htmlEvent : e}) === false)
                return false;

        // @todo: revisit this IF statement - dead code?
        if (false && apf.isIE && (key == 86 && ctrlKey || key == 45 && shiftKey)) {
            var text = window.clipboardData.getData("Text");
            if ((text = this.dispatchEvent("keydown", {
                text : this.onpaste(text)}) === false))
                    return false;
            if (!text)
                text = window.clipboardData.getData("Text");

            this.$int.focus();
            var range = document.selection.createRange();
            range.text = "";
            range.collapse();
            range.pasteHTML(text.replace(/\n/g, "<br />").replace(/\t/g, "&nbsp;&nbsp;&nbsp;"));

            return false;
        }
    };

    var fTimer;
    this.$focus = function(e){
        if (!this.$ext || this.$ext.disabled)
            return;

        this.$setStyleClass(this.$ext, this.$baseCSSname + "Focus");

        if (this["initial-message"] && this.$int.value == this["initial-message"]) {
            this.$propHandlers["value"].call(this, "", null, true);
            apf.setStyleClass(this.$ext, "", [this.$baseCSSname + "Initial"]);
        }
        
        var _self = this;
        function delay(){
            try {
                if (!fTimer || document.activeElement != _self.$int) {
                    _self.$int.focus();
                }
                else {
                    clearInterval(fTimer);
                    return;
                }
            }
            catch(e) {}

            if (_self.$masking)
                _self.setPosition();

            if (_self.focusselect)
                _self.select();
        };

        if ((!e || e.mouse) && apf.isIE) {
            clearInterval(fTimer);
            fTimer = setInterval(delay, 1);
        }
        else
            delay();
    };

    this.$blur = function(e){
        if (!this.$ext)
            return;
        
        if (!this.realtime)
            this.change(this.getValue());

        this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Focus"]);

        if (this["initial-message"] && this.$int.value == "") {
            this.$propHandlers["value"].call(this, this["initial-message"], null, true);
            apf.setStyleClass(this.$ext, this.$baseCSSname + "Initial");
        }

        /*if (apf.hasMsRangeObject) {
            var r = this.$int.createTextRange();
            r.collapse();
            r.select();
        }*/

        try {
            if (apf.isIE || !e || e.srcElement != apf.window)
                this.$int.blur();
        }
        catch(e) {}

        // check if we clicked on the oContainer. ifso dont hide it
        if (this.oContainer) {
            $setTimeout("var o = apf.lookup(" + this.$uniqueId + ");\
                o.oContainer.style.display = 'none'", 100);
        }
        
        clearInterval(fTimer);
    };

    /**** Init ****/

    this.$draw = function(){
        var _self = this;
        
        //Build Main Skin
        this.$ext = this.$getExternal(null, null, function(oExt){
            var mask = this.getAttribute("mask");

            if ((typeof mask == "string" && mask.toLowerCase() == "password")
              || "secret|password".indexOf(this.localName) > -1) {
                this.type == "password";
                this.$getLayoutNode("main", "input").setAttribute("type", "password");
            }
            
            
            else if (this.localName == "email") {
                this.datatype = (this.prefix ? this.prefix + ":" : "") + "email";
                this.$propHandlers["datatype"].call(this, this.datatype, "datatype");
            }
            else if (this.localName == "url") {
                this.datatype = (this.prefix ? this.prefix + ":" : "") + "url";
                this.$propHandlers["datatype"].call(this, this.datatype, "datatype");
            }
            

            oExt.setAttribute("onmousedown", "this.host.dispatchEvent('mousedown', {htmlEvent : event});");
            oExt.setAttribute("onmouseup",   "this.host.dispatchEvent('mouseup', {htmlEvent : event});");
            oExt.setAttribute("onclick",     "this.host.dispatchEvent('click', {htmlEvent : event});");
        });
        this.$int    = this.$getLayoutNode("main", "input", this.$ext);
        this.$button = this.$getLayoutNode("main", "button", this.$ext);
        
        if (this.type == "password")
            this.$propHandlers["type"].call(this, "password");

        if (!apf.hasContentEditable && "input|textarea".indexOf(this.$int.tagName.toLowerCase()) == -1) {
            var node  = this.$int;
            this.$int = node.parentNode.insertBefore(document.createElement("textarea"), node);
            node.parentNode.removeChild(node);
            this.$int.className = node.className;
            if (this.$ext == node)
                this.$ext = this.$int;
        }
        
        if (this.$button) {
            this.$button.onmousedown = function(){
                _self.clear();
                _self.focus({mouse:true});
            }
        }

        //@todo for skin switching this should be removed
        if (this.$int.tagName.toLowerCase() == "textarea") {
            this.addEventListener("focus", function(e){
                //if (this.multiline != "optional")
                    //e.returnValue = false
            });
        }

        this.$int.onselectstart = function(e){
            if (!e) e = event;
            e.cancelBubble = true;
        }
        this.$int.host = this;

        this.$int.onkeydown = function(e){
            e = e || window.event;
            
            if (this.disabled) {
                e.returnValue = false;
                return false;
            }

            //Change
            if (!_self.realtime) {
                var value = _self.getValue();
                if (e.keyCode == 13 && value != this.value)
                    _self.change(value);
            }
            else if (apf.isWebkit && _self.xmlRoot && _self.getValue() != this.value) //safari issue (only old??)
                $setTimeout("var o = apf.lookup(" + _self.$uniqueId + ");\
                    o.change(o.getValue())");

            if (_self.multiline == "optional" && e.keyCode == 13 && !e.shiftKey
              || e.ctrlKey && (e.keyCode == 66 || e.keyCode == 73
              || e.keyCode == 85)) {
                e.returnValue = false;
                return false;
            }

            //Autocomplete
            if (_self.oContainer) {
                var oTxt    = _self;
                var keyCode = e.keyCode;
                $setTimeout(function(){
                    oTxt.fillAutocomplete(keyCode);
                });
            }

            //Non this.$masking
            if (!_self.mask) {
                return _self.$keyHandler(e.keyCode, e.ctrlKey,
                    e.shiftKey, e.altKey, e);
            }
        };

        this.$int.onkeyup = function(e){
            if (!e)
                e = event;

            var keyCode = e.keyCode;
            
            if (_self.$button)
                _self.$button.style.display = this.value ? "block" : "none";

            if (_self.realtime) {
                $setTimeout(function(){
                    var v;
                    if (!_self.mask && (v = _self.getValue()) != _self.value)
                        _self.change(v); 
                    _self.dispatchEvent("keyup", {keyCode : keyCode});//@todo
                });
            }
            else {
                _self.dispatchEvent("keyup", {keyCode : keyCode});//@todo
            }

            
            if (_self.isValid && _self.isValid() && e.keyCode != 13 && e.keyCode != 17)
                _self.clearError();
            
        };

        
        if (apf.hasFocusBug)
            apf.sanitizeTextbox(this.$int);
        

        if (apf.hasAutocompleteXulBug)
            this.$int.setAttribute("autocomplete", "off");

        if (!this.$int.tagName.toLowerCase().match(/input|textarea/)) {
            this.isHTMLBox = true;

            this.$int.unselectable    = "Off";
            this.$int.contentEditable = true;
            this.$int.style.width     = "1px";

            this.$int.select = function(){
                var r = document.selection.createRange();
                r.moveToElementText(this);
                r.select();
            }
        };

        this.$int.deselect = function(){
            if (!document.selection) return;

            var r = document.selection.createRange();
            r.collapse();
            r.select();
        };
    };

    this.$loadAml = function() {
        if (typeof this["initial-message"] == "undefined")
            this.$setInheritedAttribute("initial-message");

        if (typeof this.realtime == "undefined")
            this.$setInheritedAttribute("realtime");
    }

    this.addEventListener("DOMNodeRemovedFromDocument", function(){
        if (this.$button)
            this.$button.onmousedown = null;
        
        if (this.$int) {
            this.$int.onkeypress     =
            this.$int.onmouseup      =
            this.$int.onmouseout     =
            this.$int.onmousedown    =
            this.$int.onkeydown      =
            this.$int.onkeyup        =
            this.$int.onselectstart  = null;
        }
    });

}).call(apf.textbox.prototype = new apf.StandardBinding());


apf.config.$inheritProperties["initial-message"] = 1;
apf.config.$inheritProperties["realtime"]        = 1;

apf.input.prototype    =
apf.secret.prototype   =
apf.password.prototype =
apf.textarea.prototype =
apf.email.prototype    = apf.textbox.prototype;

apf.aml.setElement("input",    apf.input);
apf.aml.setElement("secret",   apf.secret);
apf.aml.setElement("password", apf.password);
apf.aml.setElement("textarea", apf.textarea);
apf.aml.setElement("textbox",  apf.textbox);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/script.js)SIZE(3276)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * element that loads javascript into the application
 * either from it's first child or from a file.
 * Example:
 * <code>
 *  <a:script src="code.js" />
 * </code>
 * Example:
 * <code>
 *  <a:script>//<!-- 
 *      for (var i = 0; i < 2; i++) {
 *          alert(i);
 *      }
 *  //--></a:script>
 * </code>
 * @attribute {String} src the location of the script file.
 * @addnode global, anyaml
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.script = function(){
    this.$init("script", apf.NODE_HIDDEN);
};

(function(){
    this.$propHandlers["src"] = function(value){
        if (apf.isOpera) {
            $setTimeout(function(){
                apf.window.loadCodeFile(apf.hostPath
                    + value);
            }, 1000);
        }
        else {
            apf.window.loadCodeFile(apf.getAbsolutePath(apf.hostPath,
                value));
        }
    }
    
    this.addEventListener("DOMNodeInserted", function(e){
        if (e.currentTarget.nodeType != 1) {
            var code = e.currentTarget.nodeValue;
            
            if (!this.type || this.type == "text/javascript") {
                apf.exec(code);
            }
            else if (this.type == "application/livemarkup"
              || this.type == "application/lm") { //@todo this is wrong, it should start in code mode
                this.$setDynamicProperty("$data", code);
            }
        }
    });
    
    //@todo this should use text node insertion
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var nodes = this.childNodes, s = [];
        for (var i = 0, l = nodes.length; i < l; i++) {
            s[s.length] = nodes[i].nodeValue;
        }
        
        var code = s.join("\n");
        
        if (!this.type || this.type == "text/javascript") {
            apf.exec(code);
        }
        else if (this.type == "application/livemarkup"
          || this.type == "application/lm") { //@todo this is wrong, it should start in code mode
            this.$setDynamicProperty("$data", code);
        }
    });
}).call(apf.script.prototype = new apf.AmlElement());

apf.aml.setElement("script", apf.script);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/tree.js)SIZE(53744)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */








/**
 * Element displaying data in a list where each item in the list can contain
 * such a list. This element gives the user the ability to walk through this
 * tree of data by clicking open elements to show more elements. The tree
 * can grow by fetching more data when the user requests it.
 * Example:
 * A tree with inline items.
 * <code>
 *  <a:tree id="tree" align="right">
 *      <a:item caption="root" icon="icoUsers.gif">
 *          <a:item icon="icoUsers.gif" caption="test">
 *              <a:item icon="icoUsers.gif" caption="test" />
 *              <a:item icon="icoUsers.gif" caption="test" />
 *              <a:item icon="icoUsers.gif" caption="test" />
 *          </a:item>
 *          <a:item icon="icoUsers.gif" caption="test" />
 *          <a:item icon="icoUsers.gif" caption="test" />
 *          <a:item icon="icoUsers.gif" caption="test" />
 *      </a:item>
 *  </a:tree>
 * </code>
 * Example:
 * <code>
 *  <a:tree model="filesystem.xml">
 *      <a:bindings>
 *          <a:caption match="[@caption|@filename]" />
 *          <a:icon match="[@icon]" />
 *          <a:each match="[drive|file|folder]" />
 *      </a:bindings>
 *  </a:tree>
 * </code>
 *
 * @constructor
 * @define tree
 * @allowchild {smartbinding}
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @inherits apf.XForms
 * @inherits apf.MultiSelect
 * @inherits apf.Cache
 * @inherits apf.DataAction
 * @inherits apf.Rename
 *
 * @binding insert Determines how new data is loaded when the user expands 
 * an item. For instance by clicking on the + button. This way only the root nodes
 * need to be loaded at the start of the application. All other children are
 * received on demand when the user requests it by navigating throught the tree.
 * Example:
 * This example shows an insert rule that only works on folder elements. It will
 * read the directory contents using webdav and insert it under the selected 
 * tree node.
 * <code>
 *  <a:tree model="filesystem.xml">
 *      <a:bindings>
 *          <a:caption match="[@caption]" />
 *          <a:insert match="[folder]" get="{myWebdav.readdir([@id])}" />
 *          <a:each match="[folder]" />
 *      </a:bindings>
 *  </a:tree>
 * </code>
 * @attribute {String} get the {@link term.datainstruction data instruction} that is used to load the new data.
 * @binding caption  Determines the caption of a tree node.
 * @binding icon     Determines the icon of a tree node.
 * @binding css      Determines a css class for a tree node.
 * Example:
 * In this example a node is bold when the folder contains unread messages:
 * <code>
 *  <a:tree model="messages.xml">
 *      <a:bindings>
 *          <a:caption match="[@caption]" />
 *          <a:css match="[folder/message[@unread]]" value="highlighUnread" />
 *          <a:icon match="[@icon]" />
 *          <a:icon match="[folder]" value="icoDir.png" />
 *          <a:each match="[folder|message]" />
 *      </a:bindings>
 *  </a:tree>
 * </code>
 * @binding tooltip  Determines the tooltip of a tree node.
 * @binding empty    Determines the empty message of a node.
 * Example:
 * This example shows a gouped contact list, that displays a message under 
 * empty groups.
 * <code>
 *  <a:tree>
 *      <a:bindings>
 *          <a:caption select="@caption" />
 *          <a:icon select="self::contact" value="icoContact.png" />
 *          <a:icon select="self::group" value="icoFolder.png" />
 *          <a:empty select="self::group" value="Drag a contact to this group." />
 *          <a:each select="group|contact" />
 *      </a:bindings>
 *  </a:tree>
 * </code>
 */
apf.tree = function(struct, tagName){
    this.$init(tagName || "tree", apf.NODE_VISIBLE, struct);
    
    this.nodes = [];
    
    
    this.dynCssClasses = [];
    
};

(function(){
    this.implement(
        
        
        apf.Rename,
        
        
        apf.DataAction,
        
        
        apf.Cache
        
    );
    
    //Options
    this.$isTreeArch   = true; // This element has a tree architecture.
    this.$focussable   = true; // This object can get the focus.
    this.multiselect   = false; // Initially multiselect is disabled.
    this.bufferselect  = true;
    
    this.startcollapsed  = true;
    this.animType        = apf.tween.NORMAL;
    this.animOpenStep    = 3;
    this.animCloseStep   = 1;
    this.animSpeed       = 10;
    
    var HAS_CHILD = 1 << 1,
        IS_CLOSED = 1 << 2,
        IS_LAST   = 1 << 3,
        IS_ROOT   = 1 << 4,
    
        treeState = {};
    
    treeState[0]                               = "";
    treeState[HAS_CHILD]                       = "min";
    treeState[HAS_CHILD | IS_CLOSED]           = "plus";
    treeState[IS_LAST]                         = "last";
    treeState[IS_LAST | HAS_CHILD]             = "minlast";
    treeState[IS_LAST | HAS_CHILD | IS_CLOSED] = "pluslast";
    treeState[IS_ROOT]                         = "root";
    
    /**** Properties and Attributes ****/

    /**
     * @attribute {Boolean} openadd         whether the tree expands the parent to which a node is added. Defaults to true.
     * @attribute {Boolean} startcollapsed  whether the tree collapses all nodes that contain children on load. Defaults to true.
     * @attribute {Boolean} nocollapse      whether the user cannot collapse a node. Defaults to false.
     * @attribute {Boolean} singleopen      whether the tree will expand a node by a single click. Defaults to false.
     * @attribute {Boolean} prerender       whether the tree will render all the nodes at load. Defaults to true.
     */
    this.$booleanProperties["openadd"]        = true;
    this.$booleanProperties["startcollapsed"] = true;
    this.$booleanProperties["nocollapse"]     = true;
    this.$booleanProperties["singleopen"]     = true;
    this.$booleanProperties["prerender"]      = true;
    this.$booleanProperties["removecontainer"] = true;
    
    this.openadd        = true;
    this.startcollapsed = 1;
    this.prerender      = true;
    
    /**
     * @attribute {String} mode Sets the way this element interacts with the user.
     *   Possible values:
     *   check  the user can select a single item from this element. The selected item is indicated.
     *   radio  the user can select multiple items from this element. Each selected item is indicated.
     */
    this.$mode = 0;
    this.$propHandlers["mode"] = function(value){
        if ("check|radio".indexOf(value) > -1) {
            this.implement(apf.MultiCheck);
            
            this.addEventListener("afterrename", $afterRenameMode); //what does this do?
            
            this.multicheck = value == "check"; //radio is single
            this.$mode = this.multicheck ? 1 : 2;
        }
        else {
            //@todo undo actionRules setting
            this.removeEventListener("afterrename", $afterRenameMode);
            //@todo unimplement??
            this.$mode = 0;
        }
    };
    
    //@todo apf3.0 retest this completely
    function $afterRenameMode(){
    }
    
    /**** Public Methods ****/
    
    /**
     * Expands all items in the tree
     */
    this.expandAll    = function(){
        var xpath = this.each.split('|')
                        .join('[' + this.each.replace(/\|/g, " or ") + ']|.//'),
            _self = this;
        (function(node){
            var nodes = node.selectNodes(xpath);
            //for (var i = nodes.length - 1; i >= 0; i--) {
            for (var i = 0; i < nodes.length; i++) {
                _self.slideToggle(apf.xmldb.getHtmlNode(nodes[i], _self), 1, true);
                arguments.callee(nodes[i]);
            }
        })(this.xmlRoot);
    };
    
    /**
     * Collapses all items in the tree
     */
    this.collapseAll   = function(){
        var pNodes = this.xmlRoot.selectNodes(".//" + this.each
          .split('|').join('[' + this.each.replace(/\|/g, " or ") + ']|.//'));
        
        for (var i = pNodes.length - 1; i >=0; i--)
            this.slideToggle(apf.xmldb.getHtmlNode(pNodes[i], this), 2, true);
    };
    
    /**
     * @notimplemented
     * @todo who's volunteering?
     * @private
     */
    this.selectPath = function(path){};
    
    /**** Sliding functions ****/
    
    /**
     * @private
     */
    this.slideToggle = function(htmlNode, force, immediate){
        if (this.nocollapse)
            return;
        
        if (!htmlNode)
            htmlNode = this.$selected;
        
        var id = htmlNode.getAttribute(apf.xmldb.htmlIdTag);
        while (!id && htmlNode.parentNode)
            id = (htmlNode = htmlNode.parentNode)
                .getAttribute(apf.xmldb.htmlIdTag);

        var container = this.$getLayoutNode("item", "container", htmlNode);
        if (!container) return;
        
        if (apf.getStyle(container, "display") == "block") {
            if (force == 1) return;
            htmlNode.className = htmlNode.className.replace(/min/, "plus");
            this.slideClose(container, apf.xmldb.getNode(htmlNode), immediate);
        }
        else {
            if (force == 2) return;
            htmlNode.className = htmlNode.className.replace(/plus/, "min");
            this.slideOpen(container, apf.xmldb.getNode(htmlNode), immediate);
        }
    };
    
    this.isCollapsed = function(xmlNode){
        return (apf.getStyle(this.$getLayoutNode("item", "container",
            apf.xmldb.getHtmlNode(xmlNode, this)), "display") == "none");
    }
    
    var lastOpened = {};
    /**
     * @private
     */
    this.slideOpen = function(container, xmlNode, immediate){
        if (!xmlNode)
            xmlNode = this.selected;
        
        var htmlNode = apf.xmldb.findHtmlNode(xmlNode, this);
        if (!container)
            container = this.$findContainer(htmlNode);
        
        //We don't slide open elements without children.
        if (!container.innerHTML && !this.getTraverseNodes(xmlNode).length)
            return; 

        if (this.singleopen) {
            var pNode = this.getTraverseParent(xmlNode),
                p     = (pNode || this.xmlRoot).getAttribute(apf.xmldb.xmlIdTag);
            if (lastOpened[p] && lastOpened[p][1] != xmlNode 
              && this.getTraverseParent(lastOpened[p][1]) == pNode)
                this.slideToggle(lastOpened[p][0], 2);//lastOpened[p][1]);
            lastOpened[p] = [htmlNode, xmlNode];
        }
        
        container.style.display = "block";
        
        if (!this.prerender && this.$hasLoadStatus(xmlNode, "potential") 
          && !container.innerHTML) {
            this.$extend(xmlNode, container, immediate);
            return;
        }
        
        if (immediate) {
            container.style.height = "auto";
            return;
        }

        var _self = this;
        apf.tween.single(container, {
            type    : 'scrollheight', 
            from    : 0, 
            to      : container.scrollHeight, 
            anim    : this.animType, 
            steps   : this.animOpenStep,
            interval: this.animSpeed,
            onfinish: function(container){
                if (xmlNode && _self.$hasLoadStatus(xmlNode, "potential")) {
                    $setTimeout(function(){
                        _self.$extend(xmlNode, container);
                    });
                    container.style.height = "auto";
                }
                else {
                    //container.style.overflow = "visible";
                    container.style.height = "auto";
                }
            }
        });
    };

    /**
     * @private
     */
    this.slideClose = function(container, xmlNode, immediate){
        if (this.nocollapse) 
            return;
        
        if (!xmlNode)
            xmlNode = this.selected;
        
        if (this.singleopen) {
            var p = (this.getTraverseParent(xmlNode) || this.xmlRoot)
                .getAttribute(apf.xmldb.xmlIdTag);
            lastOpened[p] = null;
        }
        
        if (!container) {
            var htmlNode = apf.xmldb.findHtmlNode(xmlNode, this);
            container = this.$findContainer(htmlNode);
        }
        
        container.style.height   = container.offsetHeight;
        container.style.overflow = "hidden";
        
        if (immediate) {
            container.style.height = 0;
            container.style.display = "none";
            return;
        }

        apf.tween.single(container, {
            type    : 'scrollheight', 
            from    : container.scrollHeight, 
            to      : 0, 
            anim    : this.animType, 
            steps   : this.animCloseStep,
            interval: this.animSpeed,
            onfinish: function(container, data){
               container.style.display = "none";
            }
        });
    };
    
    /**** Databinding Support ****/

    //@todo apf3.x refactor
    this.$add = function(xmlNode, Lid, xmlParentNode, htmlParentNode, beforeNode, isLast){
        var loadChildren     = this.$getBindRule("insert", xmlNode) ? true : false,
            traverseNodes    = this.getTraverseNodes(xmlNode),
            hasTraverseNodes = traverseNodes.length ? true : false,
            hasChildren      = loadChildren || hasTraverseNodes,
            startcollapsed   = this.$hasBindRule("collapsed")
                ? (this.$getDataNode("collapsed", xmlNode) ? true : false)
                : this.startcollapsed,
            state            = (hasChildren ? HAS_CHILD : 0) | (startcollapsed && hasChildren
                || loadChildren ? IS_CLOSED : 0) | (isLast ? IS_LAST : 0),

            htmlNode         = this.$initNode(xmlNode, state, Lid),
            container        = this.$getLayoutNode("item", "container"),
            eachLength;
        if (!startcollapsed && !this.nocollapse)
            container.setAttribute("style", "overflow:visible;height:auto;display:block;");
        
        var msg, removeContainer = (!this.removecontainer || hasChildren);
        
        //TEMP on for dynamic subloading
        if (!hasChildren || loadChildren)
            container.setAttribute("style", "display:none;");
        
        //Dynamic SubLoading (Insertion) of SubTree
        if (!this.prerender)
            eachLength = traverseNodes.length;

        if (hasChildren && !this.prerender && eachLength > 2 && startcollapsed
          || loadChildren && (!this.$hasLoadStatus(xmlNode) 
          || this.$hasLoadStatus(xmlNode, "potential")))
            this.$setLoading(xmlNode, container);
        else if (!hasTraverseNodes && (msg = this.$applyBindRule("empty", xmlNode))) {
            this.$setEmptyMessage(container, msg);
        }

        if ((!htmlParentNode || htmlParentNode == this.$int) 
          && xmlParentNode == this.xmlRoot && !beforeNode) {
            this.nodes.push(htmlNode);
            if (!apf.isChildOf(htmlNode, container, true) && removeContainer)
                this.nodes.push(container);
            
            this.$setStyleClass(htmlNode,  "root");
            this.$setStyleClass(container, "root");
        }
        else {
            if (!htmlParentNode) {
                htmlParentNode = apf.xmldb.findHtmlNode(xmlNode.parentNode, this);
                htmlParentNode = htmlParentNode 
                    ? this.$getLayoutNode("item", "container", htmlParentNode) 
                    : this.$int;
            }
            
            if (htmlParentNode == this.$int) {
                this.$setStyleClass(htmlNode,  "root");
                this.$setStyleClass(container, "root");
            }
            
            if (!beforeNode && this.getNextTraverse(xmlNode))
                beforeNode = apf.xmldb.findHtmlNode(this.getNextTraverse(xmlNode), this);
            if (beforeNode && beforeNode.parentNode != htmlParentNode)
                beforeNode = null;
        
            if (htmlParentNode.style 
              && this.getTraverseNodes(xmlNode.parentNode).length == 1) 
                this.$removeEmptyMessage(htmlParentNode);
        
            //alert("|" + htmlNode.nodeType + "-" + htmlParentNode.nodeType + "-" + beforeNode + ":" + container.nodeType);
            //Insert Node into Tree
            if (htmlParentNode.style) {
                apf.insertHtmlNode(htmlNode, htmlParentNode, beforeNode);
                if (!apf.isChildOf(htmlNode, container, true) && removeContainer) 
                    var container = apf.insertHtmlNode(container, 
                        htmlParentNode, beforeNode);
            }
            else {
                htmlParentNode.insertBefore(htmlNode, beforeNode);
                if (!apf.isChildOf(htmlParentNode, container, true) && removeContainer) 
                    htmlParentNode.insertBefore(container, beforeNode);
            }

            //Fix parent if child is added to drawn parentNode
            if (htmlParentNode.style) {
                if (!startcollapsed && this.openadd && htmlParentNode != this.$int 
                  && htmlParentNode.style.display != "block") 
                    this.slideOpen(htmlParentNode, xmlParentNode, true);
                
                //this.$fixItem(xmlNode, htmlNode); this one shouldn't be called, because it should be set right at init
                this.$fixItem(xmlParentNode, apf.xmldb.findHtmlNode(xmlParentNode, this));
                if (this.getNextTraverse(xmlNode, true)) { //should use each here
                    this.$fixItem(this.getNextTraverse(xmlNode, true), 
                        apf.xmldb.findHtmlNode(this.getNextTraverse(xmlNode, true),
                        this));
                }
            }
        }

        if ((this.prerender || eachLength < 3 || !startcollapsed) && (xmlNode.namespaceURI != apf.ns.apf || xmlNode.localName != "item")) {
            this.$addNodes(xmlNode, container, false); //checkChildren ???
        }
        /*else {
            this.$setLoadStatus(xmlNode, "potential");
        }*/

        return container;
    };
    
    this.$fill = function(){
        //if(!this.nodes.length) return;
        //this.$int.innerHTML = "";
        apf.insertHtmlNodes(this.nodes, this.$int);
        this.nodes.length = 0;

        //for(var i=0;i<this.nodes.length;i++)
            //apf.insertHtmlNodes(this.nodes[i], this.$int);
        //this.nodes.length = 0;
    };
    
    this.$getParentNode = function(htmlNode){
        return htmlNode 
            ? this.$getLayoutNode("item", "container", htmlNode) 
            : this.$int;
    };

    this.$fixItem = function(xmlNode, htmlNode, isDeleting, oneLeft, noChildren){
        if (!htmlNode) return;

        if (isDeleting) {
            //if isLast fix previousSibling
            var prevSib;
            if (prevSib = this.getNextTraverse(xmlNode, true))
                this.$fixItem(prevSib, this.$findHtmlNode(prevSib
                    .getAttribute(apf.xmldb.xmlIdTag) + "|" 
                    + this.$uniqueId), null, true);

            //if no sibling fix parent
            if (!this.emptyMessage && xmlNode.parentNode.selectNodes(this.each).length == 1)
                this.$fixItem(xmlNode.parentNode, this.$findHtmlNode(
                    xmlNode.parentNode.getAttribute(apf.xmldb.xmlIdTag) 
                    + "|" + this.$uniqueId), null, false, true); 
        }
        else {
            var container   = this.$getLayoutNode("item", "container", htmlNode),
                hasChildren = false;
            if (noChildren) 
                hasChildren = false;
            else if (this.getTraverseNodes(xmlNode).length > 0)
                hasChildren = true;
            else if (this.$hasLoadStatus(xmlNode, "potential"))
                hasChildren = true;
            else
                hasChildren = false;
            
            var isClosed = hasChildren && container.style.display != "block",
                isLast   = this.getNextTraverse(xmlNode, null, oneLeft ? 2 : 1)
                    ? false
                    : true,
                state = (hasChildren ? HAS_CHILD : 0)
                    | (isClosed ? IS_CLOSED : 0) | (isLast ? IS_LAST : 0);
            this.$setStyleClass(this.$getLayoutNode("item", "class", htmlNode),
                treeState[state], ["min", "plus", "last", "minlast", "pluslast"]);
            this.$setStyleClass(this.$getLayoutNode("item", "container", htmlNode),
                treeState[state], ["min", "plus", "last", "minlast", "pluslast"]);

            if(this.$getLayoutNode("item", "openclose", htmlNode))
                this.$getLayoutNode("item", "openclose", htmlNode)
                    .setAttribute("children", hasChildren);
            
            if (!hasChildren && container)
                container.style.display = "none";
        }
    };

    //@todo please upgrade all the event calls to the 21st century, it hurts my eyes.
    this.$initNode = function(xmlNode, state, Lid){
        //Setup Nodes Interaction
        this.$getNewContext("item");
        
        var hasChildren = state & HAS_CHILD || this.emptyMessage 
            && this.$applyBindRule("empty", xmlNode),
            //should be restructured and combined events set per element
            oItem = this.$getLayoutNode("item");
        //@todo this should use dispatchEvent, and be moved to oExt
        oItem.setAttribute("onmouseover",
            "var o = apf.lookup(" + this.$uniqueId + ");\
            if (o.onmouseover) o.onmouseover(event, this);\
            apf.setStyleClass(this, 'hover');");
        oItem.setAttribute("onmouseout",
            "var o = apf.lookup(" + this.$uniqueId + ");\
            if (o.onmouseout) o.onmouseout(event, this);\
            apf.setStyleClass(this, '', ['hover']);");
        oItem.setAttribute("onmousedown",
            "var o = apf.lookup(" + this.$uniqueId + ");\
            if (o.onmousedown) o.onmousedown(event, this);");
        
        //Set open/close skin class & interaction
        this.$setStyleClass(this.$getLayoutNode("item", "class"), treeState[state]).setAttribute(apf.xmldb.htmlIdTag, Lid);
        this.$setStyleClass(this.$getLayoutNode("item", "container"), treeState[state])
        //this.$setStyleClass(oItem, xmlNode.tagName)
        var elOpenClose = this.$getLayoutNode("item", "openclose");
        if (elOpenClose) { //hasChildren && 
            elOpenClose.setAttribute("children", hasChildren);
            elOpenClose.setAttribute("onmousedown",
                "if (this.getAttribute('children') == false) return;\
                var o = apf.lookup(" + this.$uniqueId + ");\
                o.slideToggle(this);\
                if (o.onmousedown) o.onmousedown(event, this);\
                apf.cancelBubble(event, o);");
            
            elOpenClose.setAttribute("ondblclick", "event.cancelBubble = true");
        }
        
        if (this.$mode) {
            var elCheck = this.$getLayoutNode("item", "check");
            if (elCheck) {
                elCheck.setAttribute("onmousedown",
                    "var o = apf.lookup(" + this.$uniqueId + ");\
                    o.checkToggle(this);\o.$skipSelect = true;");

                if (this.isChecked(xmlNode))
                    this.$setStyleClass(oItem, "checked");
            }
            else {
                
                throw new Error(apf.formatErrorString(0, this,
                        "Could not find check attribute",
                        'Maybe the attribute check is missing from your skin file:\
                            <a:item\
                              class        = "."\
                              caption      = "label/u/text()"\
                              icon         = "label"\
                              openclose    = "span"\
                              select       = "label"\
                              check        = "label/b"\
                              container    = "following-sibling::blockquote"\
                            >\
                                <div><span> </span><label><b> </b><u>-</u></label></div>\
                                <blockquote> </blockquote>\
                            </a:item>\
                        '));
                
                return false;
            }
        }
        
        var ocAction = this.opencloseaction || "ondblclick";
        
        //Icon interaction
        var elIcon = this.$getLayoutNode("item", "icon");
        if (elIcon && elIcon != elOpenClose) {
            if (ocAction != "ondblclick") {
                elIcon.setAttribute(ocAction, 
                  "var o = apf.lookup(" + this.$uniqueId + ");" +
                   (ocAction == "onmousedown" ? "o.select(this, event.ctrlKey, event.shiftKey);" : "") +
                   (true ? "o.slideToggle(this);" : ""));
            }
            if (ocAction != "onmousedown") {
                elIcon.setAttribute("onmousedown", 
                  "apf.lookup(" + this.$uniqueId + ").select(this, event.ctrlKey, event.shiftKey);");
            }
            
            elIcon.setAttribute("ondblclick", 
              "var o = apf.lookup(" + this.$uniqueId + ");\
              o.choose();" + 
              
              "o.stopRename();" + 
              
              (true && !ocAction == "ondblclick" ? "o.slideToggle(this);" : "") +
              "apf.cancelBubble(event,o);");
        }

        //Select interaction
        var elSelect = this.$getLayoutNode("item", "select"),
            strMouseDown;
        
        
        if (this.hasFeature(apf.__RENAME__) || this.hasFeature(apf.__DRAGDROP__)) {
            strMouseDown =
                'var o = apf.lookup(' + this.$uniqueId + ');\
                 var xmlNode = apf.xmldb.findXmlNode(this);\
                 var isSelected = o.isSelected(xmlNode);\
                 this.hasPassedDown = true;\
                 if (!o.renaming && o.hasFocus() && isSelected == 1) \
                    this.dorename = true;\
                 if (!o.hasFeature(apf.__DRAGDROP__) || !isSelected && !event.ctrlKey)\
                     o.select(this, event.ctrlKey, event.shiftKey);';
            
            elSelect.setAttribute("onmouseout", 'this.hasPassedDown = false;' + (elSelect.getAttribute("onmouseout") || ""));
            elSelect.setAttribute("onmouseup", 'if (!this.hasPassedDown) return;\
                var o = apf.lookup(' + this.$uniqueId + ');'
                
                + 'if (this.dorename && !o.mode)\
                    o.startDelayedRename(event);' +
                
                'this.dorename = false;\
                 var xmlNode = apf.xmldb.findXmlNode(this);\
                 var isSelected = o.isSelected(xmlNode);\
                 if (o.hasFeature(apf.__DRAGDROP__))\
                     o.select(this, event.ctrlKey, event.shiftKey);');
        }
        else 
        
        {
            strMouseDown = "o.select(this, event.ctrlKey, event.shiftKey);";
        }
        
        if (ocAction != "ondblclick") {
            elSelect.setAttribute(ocAction, 
              "var o = apf.lookup(" + this.$uniqueId + ");" +
               (ocAction == "onmousedown" ? strMouseDown : "") +
               (true ? "o.slideToggle(this);" : ""));
        }
        if (ocAction != "onmousedown") {
            elSelect.setAttribute("onmousedown", 
              "var o = apf.lookup(" + this.$uniqueId + ");" + strMouseDown);
        }

        elSelect.setAttribute("ondblclick", 
          "var o = apf.lookup(" + this.$uniqueId + ");\
          o.choose();" + 
          
          "o.stopRename();this.dorename=false;" + 
          
          (ocAction == "ondblclick" ? "o.slideToggle(this);" : "") +
          "apf.cancelBubble(event,o);");
        
        //Setup Nodes Identity (Look)
        if (elIcon) {
            var iconURL = this.$applyBindRule("icon", xmlNode);
            if (iconURL) {
                if (elIcon.tagName.match(/^img$/i))
                    elIcon.setAttribute("src", this.iconPath + iconURL);
                else
                    elIcon.setAttribute("style", "background-image:url(" + this.iconPath + iconURL + ")");
            }
        }

        var elCaption = this.$getLayoutNode("item", "caption");
        if (elCaption) {
            apf.setNodeValue(elCaption,
                this.$applyBindRule("caption", xmlNode));
        }
        
        var strTooltip = this.$applyBindRule("tooltip", xmlNode)
        if (strTooltip)
            oItem.setAttribute("title", strTooltip);
        
        
        var cssClass = this.$applyBindRule("css", xmlNode);
        if (cssClass) {
            this.$setStyleClass(this.$getLayoutNode("item", null, oItem), cssClass);
            this.$setStyleClass(this.$getLayoutNode("item", "container", oItem), cssClass);
            this.dynCssClasses.push(cssClass);
        }
        

        return oItem;
    };
    
    this.$deInitNode = function(xmlNode, htmlNode){
        //Lookup container
        var containerNode = this.$getLayoutNode("item", "container", htmlNode),
            pContainer    = htmlNode.parentNode;
        
        //Remove htmlNodes from tree
        containerNode.parentNode.removeChild(containerNode);
        pContainer.removeChild(htmlNode);
        
        //Fix Images (+, - and lines)
        if (xmlNode.parentNode != this.xmlRoot)
            this.$fixItem(xmlNode, htmlNode, true);
        
        var msg;
        if (!pContainer.childNodes.length && (msg = this.$applyBindRule("empty", xmlNode)))
            this.$setEmptyMessage(pContainer, msg);
        
        //Fix look (tree thing)
        this.$fixItem(xmlNode, htmlNode, true);
        //this.$fixItem(xmlNode.parentNode, apf.xmldb.findHtmlNode(xmlNode.parentNode, this));
        /*throw new Error();
        if(xmlNode.previousSibling) //should use each here
            this.$fixItem(xmlNode.previousSibling, apf.xmldb.findHtmlNode(xmlNode.previousSibling, this));*/
    };
    
    this.$moveNode = function(xmlNode, htmlNode){
        if (!self.apf.debug && !htmlNode) 
            return;
            
        var container;
        if (this.$hasLoadStatus(xmlNode.parentNode, "potential")) {
            container = this.$getLayoutNode("item", "container", htmlNode);
            htmlNode.parentNode.removeChild(htmlNode);
            container.parentNode.removeChild(container);
            this.$extend(xmlNode.parentNode);
            return;
        }
        
        var oPHtmlNode = htmlNode.parentNode,
            pHtmlNode  = apf.xmldb.findHtmlNode(xmlNode.parentNode, this),
        //if(!pHtmlNode) return;
        
            nSibling = this.getNextTraverse(xmlNode),
            beforeNode = nSibling
                ? apf.xmldb.findHtmlNode(nSibling, this)
                : null,
            pContainer = pHtmlNode
                ? this.$getLayoutNode("item", "container", pHtmlNode)
                : this.$int;
        container  = this.$getLayoutNode("item", "container", htmlNode);

        if (pContainer != oPHtmlNode && this.getTraverseNodes(xmlNode.parentNode).length == 1)
            this.$removeEmptyMessage(pContainer);

        pContainer.insertBefore(htmlNode, beforeNode);
        if (container)
            pContainer.insertBefore(container, beforeNode);
        
        /*if (!this.startcollapsed) {
            pContainer.style.display = "block";
            pContainer.style.height = "auto";
        }*/
        
        var msg;
        if (!oPHtmlNode.childNodes.length && (msg = this.$applyBindRule("empty", xmlNode)))
            this.$setEmptyMessage(oPHtmlNode, msg);
        
        if (this.openadd && pHtmlNode != this.$int && pContainer.style.display != "block") 
            this.slideOpen(pContainer, pHtmlNode, true);
        
        //Fix look (tree thing)
        this.$fixItem(xmlNode, htmlNode);
        
        var tParent = this.getTraverseParent(xmlNode);
        this.$fixItem(tParent, apf.xmldb.findHtmlNode(tParent, this));
        if (this.getNextTraverse(xmlNode, true)) { //should use each here
            this.$fixItem(this.getNextTraverse(xmlNode, true),
                apf.xmldb.findHtmlNode(this.getNextTraverse(xmlNode, true),
                this));
        }
    };
    
    this.$updateNode = function(xmlNode, htmlNode){
        var elIcon  = this.$getLayoutNode("item", "icon", htmlNode),
            iconURL = this.$applyBindRule("icon", xmlNode);
        if (elIcon && iconURL) {
            if (elIcon.tagName && elIcon.tagName.match(/^img$/i))
                elIcon.src = this.iconPath + iconURL;
            else
                elIcon.style.backgroundImage = "url(" + this.iconPath + iconURL + ")";
        }

        var elCaption = this.$getLayoutNode("item", "caption", htmlNode);
        if (elCaption) {
            /*if (elCaption.nodeType == 1)
                elCaption.innerHTML = this.$applyBindRule("caption", xmlNode);
            else
                elCaption.nodeValue = this.$applyBindRule("caption", xmlNode);*/
            
            if (elCaption.nodeType != 1)
                elCaption = elCaption.parentNode;

            elCaption.innerHTML = this.$applyBindRule("caption", xmlNode);
        }
        
        var strTooltip = this.$applyBindRule("tooltip", xmlNode);
        if (strTooltip) 
            htmlNode.setAttribute("title", strTooltip);

        
        var cssClass = this.$applyBindRule("css", xmlNode);
        if (cssClass || this.dynCssClasses.length) {
            this.$setStyleClass(htmlNode, cssClass, this.dynCssClasses);
            if (cssClass && !this.dynCssClasses.contains(cssClass))
                this.dynCssClasses.push(cssClass);
        }
        
    };
    
    this.$setLoading = function(xmlNode, container){
        this.$setLoadStatus(xmlNode, "potential");
        
        if (!this.getTraverseNodes(xmlNode).length) {
            this.$getNewContext("loading");
            apf.insertHtmlNode(this.$getLayoutNode("loading"), container);
        }
    };
    
    this.$removeLoading = function(htmlNode){
        if (!htmlNode) return;
        this.$getLayoutNode("item", "container", htmlNode).innerHTML = "";
    };
    
    //check databinding for how this is normally implemented
    this.$extend = function(xmlNode, container, immediate){
        var rule       = this.$getBindRule("insert", xmlNode),
            xmlContext = rule && rule.match
                ? (rule.cmatch || rule.compile("match"))(xmlNode)
                : xmlNode;

        if (rule && xmlContext) {
            this.$setLoadStatus(xmlNode, "loading");
            
            if (rule.get) {
                
                if (!apf.offline.onLine) {
                    apf.offline.transactions.actionNotAllowed();
                    this.slideClose(container, xmlNode);
                    return;
                }
                
                
                this.getModel().$insertFrom(rule.getAttribute("get"), {
                    xmlNode     : xmlContext,
                    insertPoint : xmlContext, 
                    amlNode     : this
                });
            }
            else {
                if (this.$applyBindRule("insert", xmlNode))
                    this.insert(data, {insertPoint: xmlContext});
            }
        }
        else if (!this.prerender) {
            this.$setLoadStatus(xmlNode, "loading");
            this.$removeLoading(apf.xmldb.findHtmlNode(xmlNode, this));
            xmlUpdateHandler.call(this, {
                action  : "insert", 
                xmlNode : xmlNode, 
                result  : this.$addNodes(xmlNode, container, true), //checkChildren ???
                anim    : !immediate
            });
        }
    };
    
    function xmlUpdateHandler(e){
        /*
            Display the animation if the item added is 
            * Not in the cache
            - Being insterted using xmlUpdate
            - there is at least 1 child inserted
        */
        
        if (e.action == "move-away")
            this.$fixItem(e.xmlNode, apf.xmldb.findHtmlNode(e.xmlNode, this), true);

        if (e.action != "insert") return;
        
        var htmlNode = this.$findHtmlNode(e.xmlNode.getAttribute(
            apf.xmldb.xmlIdTag) + "|" + this.$uniqueId);
        if (!htmlNode) return;
        
        if (this.$hasLoadStatus(e.xmlNode, "loading") && e.result.length > 0) {
            var container = this.$getLayoutNode("item", "container", htmlNode);
            this.slideOpen(container, e.xmlNode, e.anim ? false : true);
        }
        else
            this.$fixItem(e.xmlNode, htmlNode);
        
        //Can this be removed?? (because it was added in the insert function)
        if (this.$hasLoadStatus(e.xmlNode, "loading"))
            this.$setLoadStatus(e.xmlNode, "loaded");
    }
    
    this.addEventListener("xmlupdate", xmlUpdateHandler);
    
    /**** Keyboard Support ****/
    
    
    this.addEventListener("beforerename", function(){
        if (this.$tempsel) {
            clearTimeout(this.timer);
            this.select(this.$tempsel);

            this.$tempsel = null;
            this.timer   = null;
        }
    });
    
    
    
    this.addEventListener("keydown", function(e){
        var key      = e.keyCode,
            ctrlKey  = e.ctrlKey,
            shiftKey = e.shiftKey,
            selHtml  = this.$caret || this.$selected,
            pos, top, el, node, nodes, sNode, pNode, container;

        if (!selHtml || this.renaming) 
            return;

        var selXml = this.caret || this.selected,
            oExt   = this.$ext;

        switch (key) {
            case 13:
                if (this.$tempsel)
                    this.$selectTemp();
            
                if (this.ctrlselect == "enter")
                    this.select(this.caret, true);
            
                this.choose(selHtml);
                break;
            case 32:
                if (this.$tempsel)
                    this.$selectTemp();

                if (this.$mode && !ctrlKey) {
                    var sel = this.getSelection();
                    if (!sel.length || !this.multiselect)
                        this.checkToggle(this.caret);
                    else
                        this.checkList(sel, this.isChecked(this.selected), true);
                }
                else if (ctrlKey || !this.isSelected(this.caret))
                    this.select(this.caret, true);
                return false;
            case 46:
                if (this.$tempsel)
                    this.$selectTemp();
            
                //DELETE
                //this.remove();
                this.remove(this.caret); //this.mode != "check"
                break;
            case 36:
                //HOME
                this.$setTempSelected(this.getFirstTraverseNode(), false, shiftKey);
                oExt.scrollTop = 0;
                return false;
            case 35:
                //END
                var lastNode = this.getLastTraverseNode();
                while (!this.isCollapsed(lastNode))
                    lastNode = this.getLastTraverseNode(lastNode);
                
                this.$setTempSelected(lastNode, false, shiftKey, true);
                oExt.scrollTop = oExt.scrollHeight;
                return false;
            case 37:
                //LEFT
                if (this.$tempsel)
                    this.$selectTemp();
                    
                if (this.caret.selectSingleNode(this.each) 
                  && !this.isCollapsed(this.caret))
                    this.slideToggle(this.$caret || this.$selected, 2)
                else if (pNode = this.getTraverseParent(this.caret))
                    this.select(pNode)
                return false;
            case 107: //+
            case 187: //+
            case 39:
                //RIGHT
                if (this.$tempsel)
                    this.$selectTemp();
            
                if (this.$hasLoadStatus(this.caret, "potential") 
                  || this.getFirstTraverseNode(this.caret))
                    this.slideToggle(this.$caret || this.$selected, 1)
                break;
            case 109:
            case 189:
                //-
                if (this.getFirstTraverseNode(this.caret))
                    this.slideToggle(this.$caret || this.$selected, 2)
                break;
            case 38:
                //UP
                if (!selXml && !this.$tempsel) 
                    return;
                
                node = this.$tempsel 
                    ? apf.xmldb.getNode(this.$tempsel) 
                    : selXml;
                
                sNode = this.getNextTraverse(node, true);
                if (sNode) {
                    nodes = this.getTraverseNodes(sNode);
                    
                    do {
                        container = this.$getLayoutNode("item", "container",
                            this.$findHtmlNode(apf.xmldb.getID(sNode, this)));
                        if (container && apf.getStyle(container, "display") == "block" 
                          && nodes.length) {
                                sNode = nodes[nodes.length-1];
                        }
                        else {
                            break;
                        }
                    }
                    while (sNode && (nodes = this.getTraverseNodes(sNode)).length);
                }
                else if (this.getTraverseParent(node) == this.xmlRoot) {
                    this.dispatchEvent("selecttop");
                    return;
                }
                else
                    sNode = this.getTraverseParent(node);

                if (sNode && sNode.nodeType == 1)
                   this.$setTempSelected(sNode, ctrlKey, shiftKey, true);
                else
                    return false;
                
                selHtml = apf.xmldb.findHtmlNode(sNode, this);
                top     = apf.getAbsolutePosition(selHtml, this.$int)[1]
                     - (selHtml.offsetHeight/2);
                if (top <= oExt.scrollTop)
                    oExt.scrollTop = top;
                
                return false;
            case 40:
                //DOWN
                if (!selXml && !this.$tempsel) 
                    return;

                node = this.$tempsel 
                    ? apf.xmldb.getNode(this.$tempsel)
                    : selXml;
                
                sNode = this.getFirstTraverseNode(node);
                if (sNode) {
                    container = this.$getLayoutNode("item", "container",
                        this.$findHtmlNode(apf.xmldb.getID(node, this)));
                    if (container && apf.getStyle(container, "display") != "block")
                        sNode = null;
                }
                
                while (!sNode) {
                    pNode = this.getTraverseParent(node);
                    if (!pNode) break;
                    
                    var i = 0;
                    nodes = this.getTraverseNodes(pNode);
                    while (nodes[i] && nodes[i] != node)
                        i++;
                    sNode = nodes[i+1];
                    node  = pNode;
                }

                if (sNode && sNode.nodeType == 1)
                   this.$setTempSelected(sNode, ctrlKey, shiftKey);
                else
                    return false;
                    
                selHtml = apf.xmldb.findHtmlNode(sNode, this);
                top     = apf.getAbsolutePosition(selHtml, this.$int)[1]
                    + (selHtml.offsetHeight/2);
                if (top > oExt.scrollTop + oExt.offsetHeight)
                    oExt.scrollTop = top - oExt.offsetHeight;
                
                return false;
            case 33: //@todo
                //PGUP
                pos   = apf.getAbsolutePosition(this.$int);
                el    = document.elementFromPoint(pos[0] + this.$int.offsetWidth
                      - 2, pos[1] + 2);
                sNode = apf.xmldb.findXmlNode(el);
                if (sNode == this.selected) {
                    oExt.scrollTop -= oExt.offsetHeight - apf.getHeightDiff(oExt);
                    el    = document.elementFromPoint(pos[0] + this.$int.offsetWidth
                          - 2, pos[1] + 2);
                    sNode = apf.xmldb.findXmlNode(el);
                }
                this.select(sNode);
                
                selHtml = apf.xmldb.findHtmlNode(sNode, this);
                top     = apf.getAbsolutePosition(selHtml, this.$int)[1]
                     - (selHtml.offsetHeight / 2);
                if (top <= oExt.scrollTop)
                    oExt.scrollTop = top;
                break;
            case 34: //@todo
                //PGDN
                pos   = apf.getAbsolutePosition(this.$int);
                el    = document.elementFromPoint(pos[0] + this.$int.offsetWidth
                      - 2, pos[1] + this.$ext.offsetHeight - 4);
                sNode = apf.xmldb.findXmlNode(el);
                if (sNode == this.selected) {
                    oExt.scrollTop += oExt.offsetHeight - apf.getHeightDiff(oExt);
                    el    = document.elementFromPoint(pos[0] + this.$int.offsetWidth
                          - 2, pos[1] + this.$ext.offsetHeight - 4);
                    sNode = apf.xmldb.findXmlNode(el);
                }
                this.select(sNode);
                
                selHtml = apf.xmldb.findHtmlNode(sNode, this);
                top     = apf.getAbsolutePosition(selHtml, this.$int)[1]
                    + (selHtml.offsetHeight/2);
                if (top > oExt.scrollTop + oExt.offsetHeight)
                    oExt.scrollTop = top - oExt.offsetHeight;
                break;
            default:
                if (key == 65 && ctrlKey)
                    this.selectAll();
                break;
        }
    }, true);
    
    
    /**** Rename Support ****/
    
    
    this.$getCaptionElement = function(){
        if (!this.$selected) return false;
        var x = this.$getLayoutNode("item", "caption", this.$selected);
        return x.nodeType == 1 ? x : x.parentNode;
    };
    
    
    /**** Selection Support ****/
    
    this.$calcSelectRange = function(xmlStartNode, xmlEndNode){
        var r     = [],
            f     = false,
            i     = 0,
            nodes = this.xmlRoot.selectNodes(".//" + this.each
                .split('|').join('|.//'));

        for (; i < nodes.length; i++) {
            if (nodes[i] == xmlStartNode)
                f = true;
            if (f)
                r.push(nodes[i]);
            if (nodes[i] == xmlEndNode)
                f = false;
        }
        
        if (!r.length || f) {
            r = [];
            for (f = false, i = nodes.length - 1; i >= 0; i--) {
                if (nodes[i] == xmlStartNode)
                    f = true;
                if (f)
                    r.push(nodes[i]);
                if (nodes[i] == xmlEndNode)
                    f = false;
            }
        }
        
        return r;
    };
    
    this.$findContainer = function(htmlNode){
        return this.$getLayoutNode("item", "container", htmlNode);
    };
    
    this.$selectDefault = function(xmlNode){
        if (this.select(this.getFirstTraverseNode(xmlNode), null, null, null, true)) {
            return true;
        }
        else {
            var nodes = this.getTraverseNodes(xmlNode);
            for (var i = 0; i < nodes.length; i++) {
                if (this.$selectDefault(nodes[i]))
                    return true;
            }
        }
    };
    
    this.$setEmptyMessage = function(htmlNode, msg){
        this.$getNewContext("empty");
        var xmlEmpty = this.$getLayoutNode("empty");
        if (!xmlEmpty) return;

        var empty = apf.insertHtmlNode(xmlEmpty, htmlNode);
        var caption = this.$getLayoutNode("empty", "caption", empty);

        if (caption)
            apf.setNodeValue(caption, msg || "");
        
        if (htmlNode.style)
            this.slideOpen(htmlNode, null, true);
        else
            htmlNode.setAttribute("style", "overflow:visible;height:auto;display:block;");
    }
    
    this.$removeEmptyMessage = function(htmlNode){
        var cNode = htmlNode.firstChild;
        if (!cNode)
            return;

        do {
            if (cNode.className == "message") { //@todo hack
                htmlNode.removeChild(cNode);
                return;
            }
            cNode = cNode.nextSibling;
        }
        while(cNode);
    }
    
    /**** Init ****/
    
    /**
     * @event click Fires when the user presses a mousebutton while over this
     *              element and then let's the mousebutton go.
     * @see baseclass.multiselect.event.beforeselect
     * @see baseclass.multiselect.event.afterselect
     * @see baseclass.multiselect.event.beforechoose
     * @see baseclass.multiselect.event.afterchoose
     */
    this.$draw = function(){
        //@todo apf3.0 checkmode, radiomode
        /*if (!this.getAttribute("skin")) {
            var mode = this.getAttribute("mode");
            this.skinName = null;
            this.skin = mode + "tree";
            this.$loadSkin();
        }*/
        
        //Build Main Skin
        this.$ext = this.$getExternal(); 
        this.$int = this.$getLayoutNode("main", "container", this.$ext);
        this.opencloseaction = this.$getOption("main", "openclose");
        
        //Need fix...
        //this.$ext.style.MozUserSelect = "none";

        if (apf.hasCssUpdateScrollbarBug && !this.mode)
            this.$fixScrollBug();
        
        var _self = this;
        this.$ext.onclick = function(e){
            _self.dispatchEvent("click", {htmlEvent : e || event});
        };
    };
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(){
        if (this.nocollapse)
            this.startcollapsed = false;
        else if (this.startcollapsed === 1)
            this.startcollapsed = !apf.isFalse(this.$getOption("main", "startcollapsed"));
    });
    
    this.$destroy = function(){
        this.$ext.onclick = null;
        
        apf.destroyHtmlNode(this.oDrag);
        this.oDrag = null;
    };

}).call(apf.tree.prototype = new apf.MultiSelect());


apf.aml.setElement("tree", apf.tree);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/bar.js)SIZE(4243)TIME(1259091146)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Element displaying a skinnable rectangle which can contain other 
 * aml elements. This element is used by other elements such as the 
 * toolbar and statusbar element to specify sections within those elements
 * which in turn can contain other aml elements.
 * Remarks:
 * This component is used in the accordion element to create its sections. In
 * the statusbar the panel element is an alias of bar.
 *
 * @constructor
 *
 * @define bar, panel, menubar
 * @attribute {String} icon the url pointing to the icon image.
 * @attribute {Boolean} collapsed   collapse panel on load, default is false
 * Possible values:
 *     true    panel is collapsed
 *     false   panel is not collapsed
 * @attribute {String} title   describes content in panel
 * @allowchild button
 * @allowchild {elements}, {anyaml}
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.section = function(struct, tagName){
    this.$init(tagName || "section", apf.NODE_VISIBLE, struct);
};

apf.menubar = function(struct, tagName){
    this.$init(tagName || "menubar", apf.NODE_VISIBLE, struct);
};

apf.bar     = function(struct, tagName){
    this.$init(tagName || "bar", apf.NODE_VISIBLE, struct);
};

(function(){
    this.$focussable     = false;
    this.$canLeechSkin   = true;
    this.$isLeechingSkin = false;
    
    this.$propHandlers["caption"] = function(value) {
        this.$int.innerHTML = value;
    }
    
    //@todo apf3.0 refactor
    this.addEventListener("AMLReparent", 
        function(beforeNode, pNode, withinParent){
            if (!this.$amlLoaded)
                return;

            if (this.$isLeechingSkin && !withinParent
              && this.skinName != pNode.skinName
              || !this.$isLeechingSkin
              && this.parentNode.$hasLayoutNode 
              && this.parentNode.$hasLayoutNode(this.localName)) {
                this.$isLeechingSkin = true;
                this.$forceSkinChange(this.parentNode.skinName.split(":")[0] + ":" + skinName);
            }
        });

    this.$draw = function(){
        //Build Main Skin
        this.$ext = this.$getExternal(this.$isLeechingSkin
            ? this.localName 
            : "main");

        //Draggable area support, mostly for a:toolbar
        if (this.oDrag) //Remove if already exist (skin change)
            this.oDrag.parentNode.removeChild(this.oDrag);
        
        this.oDrag = this.$getLayoutNode(this.$isLeechingSkin
            ? this.localName 
            : "main", "dragger", this.$ext);
            
        this.$int = this.$getLayoutNode(this.$isLeechingSkin
            ? this.localName 
            : "main", "container", this.$ext);
    };

    this.$loadAml = function(x){
        
    };
    
    
    this.$skinchange = function(){
        
    }
    
}).call(apf.bar.prototype = new apf.Presentation());

apf.menubar.prototype = 
apf.section.prototype = apf.bar.prototype;

apf.aml.setElement("bar", apf.bar);
apf.aml.setElement("menubar", apf.menubar);
apf.aml.setElement("section", apf.section);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/actions.js)SIZE(3181)TIME(1259091146)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
* @define actions  element containing all the action rules for the data 
 * bound elements referencing this element.
 * Example:
 * <code>
 *  <a:actions id="actPerson" >
 *      <a:add set="{comm.addPerson([.])}">
 *          <person name="New person" />
 *      </a:add
 *      <a:rename set="{comm.renamePerson([@id], [@name])}" />
 *      <a:remove match="[@new]" set="{comm.removePerson([@id])}"/>
 *  </a:actions>
 *
 *  <a:tree actions="actPerson" />
 * </code>
 * @allowchild {actions}
 * @addnode smartbinding, global
 *
 * @constructor
 * @apfclass
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 *
 * @default_private
 */
apf.actions = function(struct, tagName){
    this.$init(tagName || "actions", apf.NODE_HIDDEN, struct);
    
    this.$actions      = new apf.ruleList();
    this.$amlNodes     = {};
};

(function(){
    this.$smartbinding = null;

    this.register = function(amlNode){
        if (amlNode.localName == "smartbinding") {
            this.$smartbinding = amlNode;
            this.$smartbinding.add(this); //Assuming only at init
            return;
        }
        
        this.$amlNodes[amlNode.$uniqueId] = amlNode;
        amlNode.$actions = this.$actions;
        amlNode.dispatchEvent("actionsload", {bindings: this});
    }

    this.unregister = function(amlNode){
        //unregister element
        this.$amlNodes[amlNode.$uniqueId] = null;
        delete this.$amlNodes[amlNode.$uniqueId];
        
        delete amlNode.$actions;
        amlNode.dispatchEvent("actionsunload", {bindings: this});
    };
    
    /**** DOM Handlers ****/
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var nodes = this.childNodes;
        for (var node, i = 0, l = nodes.length; i < l; i++) {
            if ((node = nodes[i]).nodeType != 1)
                continue;
                
            node.dispatchEvent("DOMNodeInsertedIntoDocument");
        }
        
        this.register(this.parentNode);
    });
}).call(apf.actions.prototype = new apf.AmlElement());

apf.aml.setElement("actions", apf.actions);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/caldropdown.js)SIZE(34958)TIME(1263427263)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Element displaying a calendar, ordered by week. It allows the user to choose 
 * the month and year for which to display the days. Calendar returns a date 
 * in chosen date format. Minimal size of calendar is 150px.
 * 
 * Remarks:
 * The language variables possible to use of this component:
 * <groups>
 *     <english id="sub">
 *         <group id="caldropdown">
 *             <key id="shortToday">T</key>
 *             <key id="today">Today</key>
 *         </group>
 *     </english>
 * </groups>
 * 
 * @constructor
 * @define caldropdown
 * @addnode elements
 * 
 * @author      Lukasz Lipinski
 * @version     %I%, %G%
 * @since       1.0
 * 
 * @inherits apf.DataAction
 *
 * @binding value  Determines the way the value for the element is retrieved 
 * from the bound data.
 * 
 * @attribute {String}   output-format    the format of the returned date; See {@link term.dateformat more about the date format}.
 * @attribute {String}   caption-format   the format of the displayed date. Default is yyyy-mm-dd. See {@link term.dateformat more about the date format}. 
 * @attribute {String}   default          the default date set when the calendar is opened.
 *     Possible values:
 *     today   calendar is set on today's date
 * @attribute {String}   value            the date returned by calendar; should be in the format specified by the output-format attribute.
 *
 * @event slidedown Fires when the calendar slides open.
 *   cancelable: Prevents the calendar from sliding open
 * @event slideup   Fires when the calendar slides up.
 *   cancelable: Prevents the calendar from sliding up
 *
 * Example:
 * Calendar component with date set on "Saint Nicholas Day" in iso date format
 * <code>
 *  <a:caldropdown 
 *    top           = "200" 
 *    left          = "400" 
 *    output-format = "yyyy-mm-dd" 
 *    value         = "2008-12-06" />
 * </code>
 * 
 * Example:
 * Sets the date based on data loaded into this component.
 * <code>
 *  <a:model id="mdlCalDD">
 *       <data date="2009-11-25" />
 *  </a:model>
 *  <a:caldropdown 
 *    output-format = "yyyy-mm-dd" 
 *    model         = "mdlCalDD" 
 *    value         = "[@date]" />
 * </code>
 */

apf.caldropdown = function(struct, tagName){
    this.$animType        = 1;
    this.$animSteps       = 5;
    this.$animSpeed       = 20;
    this.$itemSelectEvent = "onmouseup";

    /**** Properties and Attributes ****/

    this.dragdrop      = false;
    this.reselectable  = true;
    this.$focussable   = true;
    this.autoselect    = false;
    this.multiselect   = false;

    this.outputFormat  = "yyyy-mm-dd";
    this.captionFormat = "yyyy-mm-dd";

    this.$sliderHeight = 0;

    this.$calVars      = {
        day          : null,
        month        : null,
        year         : null,
        hours        : 1,
        minutes      : 0,
        seconds      : 0,
        currentMonth : null,
        currentYear  : null,
        numberOfDays : null,
        dayNumber    : null,
        
        days         : ["Sunday", "Monday", "Tuesday", "Wednesday",
                        "Thursday", "Friday", "Saturday"],
        months       : [{name : "January",   number : 31},
                        {name : "February",  number : 28},
                        {name : "March",     number : 31},
                        {name : "April",     number : 30},
                        {name : "May",       number : 31},
                        {name : "June",      number : 30},
                        {name : "July",      number : 31},
                        {name : "August",    number : 31},
                        {name : "September", number : 30},
                        {name : "October",   number : 31},
                        {name : "November",  number : 30},
                        {name : "December",  number : 31}]
    };
    
    this.$init(tagName || "caldropdown", apf.NODE_VISIBLE, struct);
};

(function() {
    this.implement(
        
        apf.DataAction
        
        
        //,apf.StandardBinding
        
        
    );

    this.$supportedProperties.push("initial-message", "output-format",
                                   "default", "caption-format", "value");

    /**
     * @attribute {String} initial-message the message displayed by this element
     * when it doesn't have a value set. This property is inherited from parent
     * nodes. When none is found it is looked for on the appsettings element.
     *
     * @attribute {String} output-format style of returned date
     * 
     * Possible values:
     *     d      day of the month as digits, no leading zero for single-digit days
     *     dd     day of the month as digits, leading zero for single-digit days
     *     ddd    day of the week as a three-letter abbreviation
     *     dddd   day of the week as its full name
     *     m      month as digits, no leading zero for single-digit months
     *     mm     month as digits, leading zero for single-digit months
     *     mmm    month as a three-letter abbreviation
     *     mmmm   month as its full name
     *     yy     year as last two digits, leading zero for years less than 2010
     *     yyyy   year represented by four digits
     *     h      hours, no leading zero for single-digit hours (12-hour clock)
     *     hh     hours, leading zero for single-digit hours (12-hour clock)
     *     H      hours, no leading zero for single-digit hours (24-hour clock)
     *     HH     hours, leading zero for single-digit hours (24-hour clock)
     *     M      minutes, no leading zero for single-digit minutes
     *     MM     minutes, leading zero for single-digit minutes
     *     s      seconds, no leading zero for single-digit seconds
     *     ss     seconds, leading zero for single-digit seconds
     */
    this.$propHandlers["output-format"] = function(value) {
        this.outputFormat = value;
    }

    /**
     * @attribute {String} caption-format style of returned date
     * 
     * Possible values
     *     d      day of the month as digits, no leading zero for single-digit days
     *     dd     day of the month as digits, leading zero for single-digit days
     *     ddd    day of the week as a three-letter abbreviation
     *     dddd   day of the week as its full name
     *     m      month as digits, no leading zero for single-digit months
     *     mm     month as digits, leading zero for single-digit months
     *     mmm    month as a three-letter abbreviation
     *     mmmm   month as its full name
     *     yy     year as last two digits, leading zero for years less than 2010
     *     yyyy   year represented by four digits
     *     h      hours, no leading zero for single-digit hours (12-hour clock)
     *     hh     hours, leading zero for single-digit hours (12-hour clock)
     *     H      hours, no leading zero for single-digit hours (24-hour clock)
     *     HH     hours, leading zero for single-digit hours (24-hour clock)
     *     M      minutes, no leading zero for single-digit minutes
     *     MM     minutes, leading zero for single-digit minutes
     *     s      seconds, no leading zero for single-digit seconds
     *     ss     seconds, leading zero for single-digit seconds
     */
    this.$propHandlers["caption-format"] = function(value) {
        if (this.value) {
            var c = this.$calVars;
            this.$setLabel(new Date(c.year, c.month, c.day, c.hours,
                c.minutes, c.seconds).format(this.captionFormat = value));
        }
        else
            this.captionFormat = value;
    }

    this.$propHandlers["value"] = function(value) {
        var c = this.$calVars;
        var outputFormat = this.getAttribute("output-format");
        
        if (outputFormat !== null && outputFormat != this.outputFormat) {
            this.outputFormat = outputFormat;
        }

        if (!value) {
            this.$setLabel();
            return;
        }

        var date = Date.parse(value, this.outputFormat);

        
        if (!date || isNaN(date)) {
            return;
            /*throw new Error(apf.formErrorString(this, "Parsing date",
                "Invalid date: " + value));*/
        }
        

        c.day     = date.getDate();
        c.month   = date.getMonth();
        c.year    = date.getFullYear();
        c.hours   = date.getHours();
        c.minutes = date.getMinutes();
        c.seconds = date.getSeconds();

        this.value = value;
        this.$setLabel(new Date(c.year, c.month, c.day, c.hours,
            c.minutes, c.seconds).format(this.captionFormat));
        this.redraw(c.month, c.year);
    }
    
    
    /**
     * @method  
     * 
     * @return {String} date indicated by calendar
     */
    this.getValue = function(){
        return this.value;
    }
    
    /**
     * @method  Sets calendar date
     */
    this.setValue = function(value){
        this.setProperty("value", value, false, true);
    }
    
    
    /**** Keyboard Handling ****/

    
    this.addEventListener("keydown", function(e) {
        e = e || event;

        var key      = e.keyCode,
            ctrlKey  = e.ctrlKey,
            shiftKey = e.shiftKey,
            c        = this.$calVars;

        switch (key) {
            case 13: /* enter */
                this.selectDay(c.day);
                this.slideUp();
                break;

            case 33: /* page up */
                this.nextMonth();
                break;

            case 34: /* page down */
                this.prevMonth();
                break;

            case 37: /* left arrow */
                if (ctrlKey)
                    this.prevMonth();
                else if (shiftKey)
                    this.prevYear();
                else {
                    if (c.day - 1 < 1) {
                        this.prevMonth();
                        this.selectDay(c.months[c.currentMonth].number);
                    }
                    else {
                        this.selectDay(c.day - 1);
                    }
                }
                break;

            case 38: /* up arrow */
                if (ctrlKey)
                    this.slideUp();
                else {
                    if (c.day - 7 < 1) {
                        this.prevMonth();
                        this.selectDay(c.months[c.currentMonth].number + c.day - 7);
                    }
                    else {
                        this.selectDay(c.day - 7);
                    }
                }
                break;

            case 39: /* right arrow */
                if (ctrlKey)
                    this.nextMonth();
                else if (shiftKey)
                    this.nextYear();
                else
                    this.selectDay(c.day + 1);
                break;

            case 40: /* down arrow */
                if (ctrlKey)
                    this.slideDown(e);
                else
                    this.selectDay(c.day + 7);
                break;

            case 84:
                if (ctrlKey)
                    this.today();
                    return false;
                break;
        }
    }, true);
    

    /**** Public methods ****/

    /**
     * Toggles the visibility of the container with the calendar. It opens
     * or closes container using a slide effect.
     */
    this.slideToggle = function(e) {
        if (!e) e = event;

        if (this.isOpen)
            this.slideUp();
        else
            this.slideDown(e);
    };

    /**
     * Shows the container with the list elements using a slide effect.
     */
    this.slideDown = function(e) {

        if (this.dispatchEvent("slidedown") === false)
            return false;

        this.isOpen = true;

        this.oSlider.style.display = "block";
        this.oSlider.style[apf.supportOverflowComponent
            ? "overflowY"
            : "overflow"] = "hidden";

        this.oSlider.style.display = "";
        this.$setStyleClass(this.$ext, this.$baseCSSname + "Down");

        this.oSlider.style.height = (this.$sliderHeight > 0
            ? this.$sliderHeight - 1
            : 0) + "px";

        this.oSlider.style.width  = (this.$ext.offsetWidth > 0
            ? this.$ext.offsetWidth - 1
            : 0) + "px";

        apf.caldropdown.cache["oSlider"].host = this;

        this.redraw(this.$calVars.month, this.$calVars.year);

        apf.popup.show(this.$uniqueId, {
            x       : 0,
            y       : this.$ext.offsetHeight,
            animate : true,
            ref     : this.$ext,
            width   : this.$ext.offsetWidth + 1,
            height  : this.$sliderHeight,
            callback: function(container) {
                container.style[apf.supportOverflowComponent
                    ? "overflowY"
                    : "overflow"] = "hidden";
            }
        });
    };
    
    this.$getPageScroll = function() {
        return [
            document.documentElement.scrollLeft || document.body.scrollLeft,
            document.documentElement.scrollTop || document.body.scrollTop
        ];
    }

    /**
     * Hides the container with the calendar using a slide effect.
     */
    this.slideUp = function() {
        if (this.isOpen == 2) return false;
        if (this.dispatchEvent("slideup") === false) return false;

        this.isOpen = false;
        if (this.selected) {
            var htmlNode = apf.xmldb.findHtmlNode(this.selected, this);
            if (htmlNode) this.$setStyleClass(htmlNode, '', ["hover"]);
        }

        this.$setStyleClass(this.$ext, '', [this.$baseCSSname + "Down"]);
        apf.popup.hide();
        return false;
    };

    /**** Private methods and event handlers ****/

    this.$setLabel = function(value) {
        this.oLabel.innerHTML = value || this["initial-message"] || "";

        this.$setStyleClass(this.$ext, value ? "" : this.$baseCSSname + "Initial",
            [!value ? "" : this.$baseCSSname + "Initial"]);
    };

    this.addEventListener("afterselect", function(e) {
        if (!e) e = event;

        this.slideUp();
        if (!this.isOpen)
            this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Over"]);

        this.$setLabel(e.selection.length
            ? this.$applyBindRule("value", this.selected)
            : "")

        
        if (this.hasFeature(apf.__VALIDATION__) && this.form) {
            this.validate(true);
        }
        
    });

    function setMaxCount() {
        if (this.isOpen == 2)
            this.slideDown();
    }

    // Private functions
    this.$blur = function() {
        this.slideUp();
        //this.$ext.dispatchEvent("mouseout")
        if (!this.isOpen)
            this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Over"])
        //if(this.$ext.onmouseout) this.$ext.onmouseout();

        this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Focus"]);
    };

    this.$focus = function(){
        apf.popup.forceHide();
        this.$setStyleClass(this.oFocus || this.$ext, this.$baseCSSname + "Focus");
    }

    this.$setClearMessage = function(msg) {
        if (msg)
            this.$setLabel(msg);
    };

    this.$removeClearMessage = function() {
        this.$setLabel("");
    };

    
    this.addEventListener("slidedown", function() {
        //THIS SHOULD BE UPDATED TO NEW SMARTBINDINGS
        if (!this.form || !this.form.xmlActions || this.xmlRoot)
            return;
        var loadlist = this.form.xmlActions
            .selectSingleNode("LoadList[@element='" + this.name + "']");
        if (!loadlist) return;

        this.isOpen = 2;
        this.form.processLoadRule(loadlist, true, [loadlist]);

        return false;
    });
    

    this.addEventListener("popuphide", this.slideUp);

    var isLeapYear = function(year) {
        return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0)
            ? true
            : false;
    };

    this.redraw = function(month, year) {
        var c = this.$calVars;
        c.currentMonth = month;
        c.currentYear  = year;

        var _width     = this.$ext.offsetWidth,
            temp       = Math.floor((_width - 36) / 8) * 8 + 32 
                         - apf.getDiff(this.oNavigation)[0],
            w_days     = new Date(year, 0, 1).getDay();

        if (temp >= 0)
            this.oNavigation.style.width = temp + "px";

        //var w_firstYearDay = new Date(year, 0, 1);
        //var w_dayInWeek    = w_firstYearDay.getDay();

        for (i = 0; i <= month; i++) {
            if (isLeapYear(year) && i == 1)
                w_days++;
            w_days += c.months[i].number;
        }

        var w_weeks = Math.ceil(w_days / 7),
            date    = new Date(year, month);

        c.numberOfDays = c.months[date.getMonth()].number;
        if (isLeapYear(year) && date.getMonth() == 1)
            c.numberOfDays++;

        c.dayNumber = new Date(year, month, 1).getDay();
        var prevMonth     = month == 0 ? 11 : month - 1,
            prevMonthDays = c.months[prevMonth].number - c.dayNumber + 1,
            nextMonthDays = 1,
            rows = this.oNavigation.childNodes,
            cells,
            y;

        for (i = 0; i < rows.length; i++) {
            if ((rows[i].className || "").indexOf("today") != -1) {
                if (_width < 300) {
                    var shortTodayText = apf.language.getWord("sub.calendar.shortToday") || "T";
                    rows[i].innerHTML   = shortTodayText;
                    rows[i].style.width = "8px";
                    rows[i].setAttribute("title", shortTodayText);
                }
                else {
                    var TodayText = apf.language.getWord("sub.calendar.today") || "Today";
                    rows[i].innerHTML   = TodayText;
                    rows[i].style.width = "32px";
                    rows[i].setAttribute("title", TodayText);
                }
            }
            else if ((rows[i].className || "").indexOf("status") != -1) {
                if (_width >= 300)
                    rows[i].innerHTML = c.months[c.currentMonth].name
                                      + " " + c.currentYear;
                else {
                    rows[i].innerHTML = (c.currentMonth + 1) + "/" + c.currentYear;
                }
            }
        }

        this.$sliderHeight = 22; //navigators bar height
        temp = Math.floor((_width - 37) / 8);
        var squareSize = temp > 0 ? temp : 0;

        var daysofweek   = this.oDow.childNodes,
            d_height     = Math.floor(squareSize / 4 + 6),
            d_paddingTop = Math.floor(squareSize / 4 - 8) > 0
                ? Math.floor(squareSize / 4 - 8)
                : 0,
            d_fontSize   = _width < 150 ? "6px" : (_width <= 220 ? "9px" : "11px"),
            d_width      = (squareSize * 8 + 32);

        this.oDow.style.width = d_width + "px";

        this.$sliderHeight += d_height + d_paddingTop;

        for (var z = 0, i = 0; i < daysofweek.length; i++) {
            if ((daysofweek[i].className || "").indexOf("dayofweek") > -1) {
                daysofweek[i].style.width      = squareSize   + "px";
                daysofweek[i].style.height     = d_height     + "px";
                daysofweek[i].style.paddingTop = d_paddingTop + "px";
                daysofweek[i].style.fontSize   = d_fontSize;

                if (z > 0) {
                    daysofweek[i].innerHTML = c.days[z - 1].substr(0, 3);
                }
                z++;
            }
        }

        var c_height     = Math.floor((squareSize + 12) / 2),
            c_paddingTop = squareSize - c_height > 0
                ? squareSize - c_height
                : 0;

        rows = this.oSlider.childNodes;
        for (z = 0, y = 0, i = 0; i < rows.length; i++) {
            if ((rows[i].className || "").indexOf("row") == -1)
                continue;

            rows[i].style.width = (d_width - apf.getDiff(rows[i])[0]) + "px";
            if (!apf.isGecko) {
                rows[i].style.paddingTop = "1px";
            }

            this.$sliderHeight += (squareSize + 5);

            cells = rows[i].childNodes;
            for (var j = 0, disabledRow = 0; j < cells.length; j++) {
                if ((cells[j].className || "").indexOf("cell") == -1)
                    continue;
                z++;
                cells[j].style.width      = squareSize   + "px";
                cells[j].style.height     = c_height     + "px";
                cells[j].style.paddingTop = c_paddingTop + "px";

                cells[j].style.margin = z%8 == 0 && z !== 1
                    ? "1px 0 1px 0"
                    : "1px 2px 1px 0";

                this.$setStyleClass(cells[j], "", ["weekend", "disabled",
                    "active", "prev", "next", "weeknumber"]);

                if ((z - 1) % 8 == 0) {
                    cells[j].innerHTML = w_weeks
                        - Math.ceil((c.months[c.month].number + c.dayNumber) / 7)
                        + 1 + (z - 1) / 8;
                    this.$setStyleClass(cells[j], "weeknumber");
                }
                else {
                    y++;
                    if (y <= c.dayNumber) {
                        cells[j].innerHTML = prevMonthDays++;
                        this.$setStyleClass(cells[j], "disabled prev");
                    }
                    else if (y > c.dayNumber && y <= c.numberOfDays + c.dayNumber) {
                        cells[j].innerHTML = y - c.dayNumber;

                        var dayNrWeek = new Date(year, month,
                                                 y - c.dayNumber).getDay();

                        if (dayNrWeek == 0 || dayNrWeek == 6) {
                            this.$setStyleClass(cells[j], "weekend");
                        }

                        if (month == c.month && year == c.year
                          && y - c.dayNumber == c.day) {
                            this.$setStyleClass(cells[j], "active");
                        }
                    }
                    else if (y > c.numberOfDays + c.dayNumber) {
                        cells[j].innerHTML = nextMonthDays++;
                        this.$setStyleClass(cells[j], "disabled next");
                        disabledRow++;
                    }
                }
            }

            rows[i].style.visibility = disabledRow == 7
                ? "hidden"
                : "visible";
        }
    };

    /**
     * Selects date and highlights its cell in calendar component
     *
     * @param {Number}   nr     day number
     * @param {String}   type   class name of html representation of selected cell
     */
    this.selectDay = function(nr, type) {
        var c = this.$calVars,
            newMonth = type == "prev"
                ? c.currentMonth
                : (type == "next"
                    ? c.currentMonth + 2
                    : c.currentMonth + 1),
            newYear = c.currentYear;

        if (newMonth < 1) {
            newMonth = 12;
            newYear--;
        }
        else if (newMonth > 12) {
            newMonth = 1;
            newYear++;
        }

        this.change(new Date(newYear, (newMonth - 1), nr, c.hours,
            c.minutes, c.seconds).format(this.outputFormat));
    };

    /**
     * Change displayed year to next one
     */
    this.nextYear = function() {
        this.redraw(this.$calVars.currentMonth, this.$calVars.currentYear + 1);
    };

    /**
     * Change displayed year to previous one
     */
    this.prevYear = function() {
        this.redraw(this.$calVars.currentMonth, this.$calVars.currentYear - 1);
    };

    /**
     * Change displayed month to next one. If actual month is December, function
     * change current displayed year to next one
     */
    this.nextMonth = function() {
        var newMonth, newYear,
            c = this.$calVars;
        if (c.currentMonth > 10) {
            newMonth = 0;
            newYear  = c.currentYear + 1;
        }
        else {
            newMonth = c.currentMonth + 1;
            newYear  = c.currentYear;
        }

        this.redraw(newMonth, newYear);
    };

    /**
     * Change displayed month to previous one. If actual month is January, 
     * function change current displayed year to previous one
     */
    this.prevMonth = function() {
        var newMonth, newYear,
            c = this.$calVars;
        if (c.currentMonth < 1) {
            newMonth = 11;
            newYear  = c.currentYear - 1;
        }
        else {
            newMonth = c.currentMonth - 1;
            newYear  = c.currentYear;
        }

        this.redraw(newMonth, newYear);
    };

    /**
     * Select today's date in calendar component
     */
    this.today = function() {
        this.change(new Date().format(this.outputFormat));
    };

    /**** Init ****/

    this.$draw = function() {
        this.$getNewContext("main");
        this.$getNewContext("container");

        this.$animType = this.$getOption("main", "animtype") || 1;
        this.clickOpen = this.$getOption("main", "clickopen") || "button";

        //Build Main Skin
        this.$ext = this.$getExternal(null, null, function(oExt) {
            oExt.setAttribute("onmouseover", 
                'var o = apf.lookup(' + this.$uniqueId + ');\
                 o.$setStyleClass(o.$ext, o.$baseCSSname + "Over");');
            oExt.setAttribute("onmouseout", 
                'var o = apf.lookup('+ this.$uniqueId + ');\
                 if (o.isOpen) return;\
                 o.$setStyleClass(o.$ext, "", [o.$baseCSSname + "Over"]);');

            //Button
            var oButton = this.$getLayoutNode("main", "button", oExt);
            if (oButton) {
                oButton.setAttribute("onmousedown",
                    'apf.lookup(' + this.$uniqueId + ').slideToggle(event);');
            }

            //Label
            var oLabel  = this.$getLayoutNode("main", "label", oExt);
            if (this.clickOpen == "both") {
                oLabel.parentNode.setAttribute("onmousedown", 'apf.lookup('
                    + this.$uniqueId + ').slideToggle(event);');
            }
        });
        this.oLabel     = this.$getLayoutNode("main", "label", this.$ext);
        
        if (this.oLabel.nodeType == 3)
            this.oLabel = this.oLabel.parentNode;

        this.oIcon      = this.$getLayoutNode("main", "icon", this.$ext);
        if (this.$button)
            this.$button = this.$getLayoutNode("main", "button", this.$ext);

        if (apf.caldropdown.cache) {
            var cal          = apf.caldropdown.cache;
            this.oSlider     = cal["oSlider"];
            this.oNavigation = cal["oNavigation"];
            this.oDow        = cal["oDow"];

            apf.caldropdown.cache.refcount++;

            //Set up the popup
            this.$pHtmlDoc = apf.popup.setContent(this.$uniqueId, this.oSlider,
            apf.skins.getCssString(this.skinName));
        }
        else {
            this.oSlider = this.$getExternal("container", null, function(oExt1) {
                var i, oSlider = this.$getLayoutNode("container", "contents", oExt1);
    
                for (i = 0; i < 6; i++) {
                    this.$getNewContext("row");
                    var oRow = oSlider.appendChild(this.$getLayoutNode("row"));
    
                    for (var j = 0; j < 8; j++) {
                        this.$getNewContext("cell");
                        var oCell = this.$getLayoutNode("cell");
                        if (j > 0) {
                            oCell.setAttribute("onmouseout",
                                "apf.setStyleClass(this, '', ['hover']);");
                            oCell.setAttribute("onmouseover",
                                "if (this.className.indexOf('disabled') > -1 \
                                   || this.className.indexOf('active') > -1) \
                                     return;\
                                 apf.setStyleClass(this, 'hover');");
                            oCell.setAttribute("onmousedown",
                                "var o = apf.findHost(this);\
                                 if (this.className.indexOf('prev') > -1) \
                                     o.selectDay(this.innerHTML, 'prev');\
                                 else if (this.className.indexOf('next') > -1) \
                                     o.selectDay(this.innerHTML, 'next');\
                                 else \
                                     o.selectDay(this.innerHTML);\
                                 o.slideUp();");
                        }
                        oRow.appendChild(oCell);
                    }
                }
    
                var oNavigation = this.$getLayoutNode("container", "navigation",
                                                      oExt1);
    
                if (oNavigation) {
                    var buttons = ["prevYear", "prevMonth", "nextYear", "nextMonth",
                                   "today", "status"];
                    for (i = 0; i < buttons.length; i++) {
                        this.$getNewContext("button");
                        var btn = oNavigation.appendChild(this.$getLayoutNode("button"));
                        this.$setStyleClass(btn, buttons[i]);
                        if (buttons[i] !== "status") {
                            btn.setAttribute("onmousedown", 'apf.findHost(this).' + buttons[i] + '()');
                            btn.setAttribute("onmouseover", 'apf.setStyleClass(this, "hover");');
                            btn.setAttribute("onmouseout",  'apf.setStyleClass(this, "", ["hover"]);');
                        }
                    }
                }
    
                var oDaysOfWeek = this.$getLayoutNode("container",
                                                      "daysofweek", oExt1);
    
                for (i = 0; i < this.$calVars.days.length + 1; i++) {
                    this.$getNewContext("day");
                    oDaysOfWeek.appendChild(this.$getLayoutNode("day"));
                }
            });
    
            this.oNavigation = this.$getLayoutNode("container", "navigation", this.oSlider);
            this.oDow        = this.$getLayoutNode("container", "daysofweek", this.oSlider);
        }

        

        //Set up the popup
        this.$pHtmlDoc    = apf.popup.setContent(this.$uniqueId, this.oSlider,
            apf.skins.getCssString(this.skinName));

        document.body.appendChild(this.oSlider);

        //Get Options form skin
        //Types: 1=One dimensional List, 2=Two dimensional List
        this.listtype    = parseInt(this.$getLayoutNode("main", "type")) || 1;

        if (!apf.caldropdown.cache) {
            apf.caldropdown.cache = {
                "oSlider"     : this.oSlider,
                "oNavigation" : this.oNavigation,
                "oDow"        : this.oDow
            };
            apf.caldropdown.cache.refcount = 0;
        }
    };

    this.$loadAml = function(x) {
        var date, c = this.$calVars;

        if (typeof this.value == "undefined") {
            switch(this["default"]) {
                case "today":
                    this.setProperty("value", new Date().format(this.outputFormat));
                    break;
                default :
                    date =  new Date();
                    c.day   = 0;
                    c.month = date.getMonth();
                    c.year  = date.getFullYear();

//                    if (!this.selected && this["initial-message"])
                        this.$setLabel();
                    break;
            }
        }
        else {
            date = Date.parse(this.value, this.outputFormat);
            c.day   = date.getDate();
            c.month = date.getMonth();
            c.year  = date.getFullYear();

            if (c.day && c.month && c.year) {
                this.setProperty("value", new Date(c.year, c.month, c.day, c.hours,
                    c.minutes, c.seconds).format(this.outputFormat));
            }
        }
    };

    this.$destroy = function() {
        apf.popup.removeContent(this.$uniqueId);
        apf.destroyHtmlNode(this.oSlider);
        this.oSlider = null;

        if (apf.caldropdown.cache && apf.caldropdown.cache.refcount) {
            if (apf.caldropdown.cache.refcount == 0)
                apf.caldropdown.cache = null;
            else
                apf.caldropdown.cache.refcount--;
        }
    };
}).call(apf.caldropdown.prototype = new apf.StandardBinding());

apf.config.$inheritProperties["initial-message"] = 1;

apf.aml.setElement("caldropdown", apf.caldropdown);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/radiobutton.js)SIZE(15672)TIME(1259091146)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element displaying a two state button which is one of a grouped set.
 * Only one of these buttons in the set can be checked at the same time.
 * Example:
 * <code>
 *  <a:frame title="Options">
 *      <a:radiobutton>Option 1</a:radiobutton>
 *      <a:radiobutton>Option 2</a:radiobutton>
 *      <a:radiobutton>Option 3</a:radiobutton>
 *      <a:radiobutton>Option 4</a:radiobutton>
 *  </a:frame>
 * </code>
 * Example:
 * This example shows radio buttons with an explicit group set:
 * <code>
 *  <a:label>Options</a:label>
 *  <a:radiobutton group="g1">Option 1</a:radiobutton>
 *  <a:radiobutton group="g1">Option 2</a:radiobutton>
 *
 *  <a:label>Choices</a:label>
 *  <a:radiobutton group="g2">Choice 1</a:radiobutton>
 *  <a:radiobutton group="g2">Choice 2</a:radiobutton>
 * </code>
 *
 * @constructor
 * @define radiobutton
 * @allowchild {smartbinding}
 * @addnode elements
 *
 * @inherits apf.Presentation
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @binding value  Determines the way the value for the element is retrieved 
 * from the bound data.
 * Example:
 * Sets the selection based on data loaded into this component.
 * <code>
 *  <a:radiobutton group="g2" bindings="bndExample" value="1">Choice 1</a:radiobutton>
 *  <a:radiobutton group="g2" value="2">Choice 2</a:radiobutton>
 *
 *  <a:bindings id="bndExample">
 *      <a:value match="[@value]" />
 *  </a:bindings>
 * </code>
 * Example:
 * A shorter way to write this is:
 * <code>
 *  <a:radiobutton group="g2" value="[@value]" value="1">Choice 1</a:radiobutton>
 *  <a:radiobutton group="g2" value="2">Choice 2</a:radiobutton>
 * </code>
 *
 * @event click Fires when the user presses a mousebutton while over this element and then let's the mousebutton go. 
 * @see baseclass.amlnode.event.afterchange
 */
apf.radiobutton = function(struct, tagName){
    this.$init(tagName || "radiobutton", apf.NODE_VISIBLE, struct);
    
    this.$constructor = apf.radiobutton;
    var fEl = apf.aml.setElement("radiobutton", function(){
        this.$init(tagName || "radiobutton", apf.NODE_VISIBLE, struct);
    });
    fEl.prototype = apf.radiobutton.prototype;
    apf.radiobutton = fEl;
};

(function(){
    this.implement(apf.ChildValue);
    this.$childProperty = "label";
    
    this.$focussable = true; // This object can get the focus
    
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        checked: 1
    }, this.$attrExcludePropBind);

    /**** Properties and Attributes ****/

    this.$supportedProperties.push("value", "background", "group",
        "label", "checked", "tooltip", "icon");

    /**
     * @attribute {String} group the name of the group to which this radio
     * button belongs. Only one item in the group can be checked at the same
     * time. When no group is specified the parent container functions as the
     * group; only one radiobutton within that parent can be checked.
     */
    this.$propHandlers["group"] = function(value){
        if (this.$group && this.$group.$removeRadio)
            this.$group.$removeRadio(this);
            
        if (!value) {
            this.$group = null;
            return;
        }
        
        var group = apf.nameserver.get("radiogroup", value);
        if (!group) {
            group = apf.nameserver.register("radiogroup", value, 
                new apf.$group());
            group.setAttribute("id", value);
            group.dispatchEvent("DOMNodeInsertedIntoDocument");
            group.parentNode = this;
        }
        this.$group = group;
        
        if (this.oInput)
            this.oInput.setAttribute("name", value);
        
        this.$group.$addRadio(this);
    };
    
    /**
     * @attribute {String} tooltip the tooltip of this radio button.
     */
    this.$propHandlers["tooltip"] = function(value){
        this.$ext.setAttribute("title", value);
    };

    /**
     * @attribute {String} icon the icon for this radiobutton
     */
    this.$propHandlers["icon"] = function(value){
        
        if (!this.oIcon)
            return apf.console.warn("No icon defined in the Button skin", "button");
        

        if (value)
            this.$setStyleClass(this.$ext, this.$baseCSSname + "Icon");
        else
            this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Icon"]);

        apf.skins.setIcon(this.oIcon, value, this.iconPath);
    };

    /**
     * @attribute {String} label the label for this radiobutton
     */
    this.$propHandlers["label"] = function(value){
        if (value)
            this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Empty"]);
        else
            this.$setStyleClass(this.$ext, this.$baseCSSname + "Empty");
        
        if (this.oLabel)
            this.oLabel.innerHTML = value;
    };

    /**
     * @attribute {String} checked whether this radiobutton is the checked one in the group it belongs to.
     */
    this.$propHandlers["checked"] = function(value){
        if (!this.$group)
            return;

        if (apf.isTrue(value)) {
            this.checked = true;
            this.$group.setProperty("value", this.value);
        }
        else if (apf.isFalse(value)) {
            this.checked = false;
            this.$group.setProperty("value", "");
        }
        else {
            this.$group.$setDynamicProperty("value", value);
        }
    };
    
    this.addEventListener("prop.model", function(e){
        this.$group.setProperty("model", e.value);
    });

    /**
     * @attribute {string} background sets a multistate background. The arguments
     * are seperated by pipes '|' and are in the order of:
     * 'imagefilename|mapdirection|nrofstates|imagesize'
     * The mapdirection argument may have the value of 'vertical' or 'horizontal'.
     * The nrofstates argument specifies the number of states the iconfile contains:
     * 1 - normal
     * 2 - normal, hover
     * 3 - normal, hover, down
     * 4 - normal, hover, down, disabled
     * The imagesize argument specifies how high or wide each icon is inside the
     * map, depending of the mapdirection argument.
     *
     * Example:
     * A 3 state picture where each state is 16px high, vertically spaced
     * <code>
     * background="threestates.gif|vertical|3|16"
     * </code>
     * @see baseclass.basebutton
     */
    this.$propHandlers["background"] = function(value){
        var oNode = this.$getLayoutNode("main", "background", this.$ext);
        if (value) {
            var b = value.split("|");
            this.$background = b.concat(["vertical", 2, 16].slice(b.length - 1));

            oNode.style.backgroundImage  = "url(" + this.mediaPath + b[0] + ")";
            oNode.style.backgroundRepeat = "no-repeat";
        }
        else {
            oNode.style.backgroundImage  = "";
            oNode.style.backgroundRepeat = "";
            this.$background = null;
        }
    }

    /**** Public methods ****/

    

    /**
     * Sets the value of this element. This should be one of the values
     * specified in the values attribute.
     * @param {String} value the new value of this element
     */
    this.setValue = function(value){
        this.setProperty("value", value, false, true);
    };

    /**
     * Returns the current value of this element.
     * @return {String}
     */
    this.getValue = function(){
        return this.value;
    };
    
    this.check = function(){
        this.setProperty("checked", true, false, true);
    }
    
    this.uncheck = function(){
        this.setProperty("checked", false, false, true);
    }
    
    this.getGroup = function(){
        return this.$group;
    }
    
    

    /**
     * Sets the checked state and related value
     */
    this.$check = function(visually){
        this.$setStyleClass(this.$ext, this.$baseCSSname + "Checked");
        this.checked = true;
        if (this.oInput)
            this.oInput.checked = true;
        this.doBgSwitch(2);
    };

    this.$uncheck = function(){
        this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Checked"]);
        this.checked = false;
        if (this.oInput)
            this.oInput.checked = false;
        this.doBgSwitch(1);
    };

    /**** Private methods ****/

    this.$enable = function(){
        if (this.oInput)
            this.oInput.disabled = false;

        var _self = this;
        this.$ext.onclick = function(e){
            if (!e) e = event;
            if ((e.srcElement || e.target) == this)
                return;

            _self.dispatchEvent("click", {
                htmlEvent: e
            });
            _self.$group.change(_self.value);
        }

        this.$ext.onmousedown = function(e){
            if (!e) e = event;
            if ((e.srcElement || e.target) == this)
                return;

            apf.setStyleClass(this, _self.$baseCSSname + "Down");
        }

        this.$ext.onmouseover = function(e){
            if (!e) e = event;
            if ((e.srcElement || e.target) == this)
                return;

            apf.setStyleClass(this, _self.$baseCSSname + "Over");
        }

        this.$ext.onmouseout =
        this.$ext.onmouseup  = function(){
            apf.setStyleClass(this, "", [_self.$baseCSSname + "Down", _self.$baseCSSname + "Over"]);
        }
    };

    this.$disable = function(){
        if (this.oInput)
            this.oInput.disabled = true;
        this.$ext.onclick = null
        this.$ext.onmousedown = null
    };

    /**
     * @private
     */
    this.doBgSwitch = function(nr){
        if (this.bgswitch && (this.bgoptions[1] >= nr || nr == 4)) {
            if (nr == 4)
                nr = this.bgoptions[1] + 1;

            var strBG = this.bgoptions[0] == "vertical"
                ? "0 -" + (parseInt(this.bgoptions[2]) * (nr - 1)) + "px"
                : "-"   + (parseInt(this.bgoptions[2]) * (nr - 1)) + "px 0";

            this.$getLayoutNode("main", "background", this.$ext)
                .style.backgroundPosition = strBG;
        }
    };

    this.$focus = function(){
        if (!this.$ext)
            return;
        if (this.oInput && this.oInput.disabled)
            return false;

        this.$setStyleClass(this.$ext, this.$baseCSSname + "Focus");
    };

    this.$blur = function(){
        if (!this.$ext)
            return;
        this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Focus"]);
    };

    /**** Keyboard support ****/

    
    this.addEventListener("keydown", function(e){
        var key = e.keyCode;

        if (key == 13 || key == 32) {
            //this.check();
            //this.$group.current = this;
            this.$group.change(this.value);
            return false;
        }
        //Up
        else if (key == 38) {
            var node = this;
            while (node && node.previousSibling) {
                node = node.previousSibling;
                if (node.localName == "radiobutton" && !node.disabled
                  && node.$group == this.$group) {
                    node.check();
                    node.focus();
                    return;
                }
            }
        }
        //Down
        else if (key == 40) {
            var node = this;
            while (node && node.nextSibling) {
                node = node.nextSibling;
                if (node.localName == "radiobutton" && !node.disabled
                  && node.$group == this.$group) {
                    node.check();
                    node.focus();
                    return;
                }
            }
        }
    }, true);
    

    /**** Init ****/

    this.$draw = function(){
        //Build Main Skin
        this.$ext = this.$getExternal();
        this.oInput = this.$getLayoutNode("main", "input", this.$ext);
        this.oLabel = this.$getLayoutNode("main", "label", this.$ext);
        this.oIcon  = this.$getLayoutNode("main", "icon", this.$ext);

        this.enable();
    };

    this.$childProperty = "label";
    this.$loadAml = function(x){
        if (!this.group) {
            this.$propHandlers["group"].call(this,
                "radiogroup" + this.parentNode.$uniqueId);
        }
    };
    
    this.$destroy = function(){
        if (this.$group)
            this.$group.$removeRadio(this);
    }
}).call(apf.radiobutton.prototype = new apf.Presentation());

apf.aml.setElement("radiobutton", apf.radiobutton);

apf.$group = function(struct, tagName){
    this.$init(tagName || "radiogroup", apf.NODE_VISIBLE, struct);
    
    this.implement(
        
        apf.DataAction
        
        
    );

    var radiobuttons = [];

    this.$supportedProperties.push("value", "selectedItem");
    this.$propHandlers["value"] = function(value){
        for (var i = 0; i < radiobuttons.length; i++) {
            if (radiobuttons[i].value == value) {
                return this.setProperty("selectedItem", radiobuttons[i]);
            }
        }
        return this.setProperty("selectedItem", null);
    };
    
    var lastSelected;
    this.$propHandlers["selectedItem"] = function(rb){
        if (lastSelected)
            lastSelected.$uncheck();
        if (!rb)
            return;
            
        rb.$check();
        lastSelected = rb;
        
        for (var i = 0; i < radiobuttons.length; i++)
            radiobuttons[i].setProperty("selectedItem", rb);
    };

    this.$addRadio = function(rb){
        var id = radiobuttons.push(rb) - 1;
        
        if (!rb.value)
            rb.setProperty("value", id);
        
        if (this.value && rb.value == this.value)
            this.setProperty("selectedItem", rb);
        else if (rb.checked)
            this.setProperty("value", rb.value);
    };

    this.$removeRadio = function(rb){
        radiobuttons.remove(rb);
        
        if (rb.value === rb.id)
            rb.setProperty("value", "");
        
        if (rb.selectedItem == rb)
            this.setProperty("value", null);
    }

    /**
     * Sets the current value of this element.
     */
    this.setValue = function(value){
        this.setProperty("value", value);
    };
    
    /**
     * Returns the current value of this element.
     * @return {String}
     */
    this.getValue = function(){
        return this.value;
    };
};
apf.$group.prototype = new apf.StandardBinding();




/*FILEHEAD(/var/lib/platform/source/trunk/elements/style.js)SIZE(1612)TIME(1264352083)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @todo description
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.style = function(struct, tagName){
    this.$init(tagName || "style", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$focussable = false;
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (this.type != "text/chartcss" && this.firstChild)
            apf.importCssString(this.firstChild.nodeValue);
    });
}).call(apf.style.prototype = new apf.AmlElement());

apf.aml.setElement("style", apf.style);
apf.xhtml.setElement("style",  apf.style);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/page.js)SIZE(14241)TIME(1263561659)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * A page in a pageable element. (i.e. a page in {@link element.tab})
 *
 * @constructor
 * @define  page
 * @allowchild  {elements}, {anyaml}
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 */
apf.page = function(struct, tagName){
    this.$init(tagName || "page", apf.NODE_VISIBLE, struct);
};

(function(){
    this.canHaveChildren = true;
    this.$focussable     = false;
    this.buttons         = false;
    this.closebtn        = false;

    
    /**
     * Sets the caption of the button of this element.
     * @param {String} caption the text displayed on the button of this element.
     */
    this.setCaption = function(caption){
        this.setProperty("caption", caption, false, true);
    };

    /**
     * Sets the icon of the button of this element.
     * @param {String} icon the icon displayed on the button of this element.
     */
    this.setIcon = function(icon) {
        this.setProperty("icon", icon, false, true);
    };
    

    /**** Delayed Render Support ****/

    
    //Hack
    this.addEventListener("beforerender", function(){
        this.parentNode.dispatchEvent("beforerender", {
            page : this
        });
    });

    this.addEventListener("afterrender",  function(){
        this.parentNode.dispatchEvent("afterrender", {
            page : this
        });
    });
     

    /**** Properties ****/

    this.$booleanProperties["visible"]  = true;
    this.$booleanProperties["fake"]     = true;
    this.$booleanProperties["closebtn"] = true;
    this.$supportedProperties.push("fake", "caption", "icon", 
        "type", "buttons", "closebtn");

    this.$propHandlers["buttons"] = function(value){
        this.buttons = value;
    };
    
    this.$propHandlers["closebtn"] = function(value){
        this.closebtn = value;
    };

    /**
     * @attribute {String} caption the text displayed on the button of this element.
     */
    this.$propHandlers["caption"] = function(value){
        if (!this.parentNode)
            return;

        var node = this.parentNode
            .$getLayoutNode("button", "caption", this.$button);

        if (node.nodeType == 1)
            node.innerHTML = value;
        else
            node.nodeValue = value;
    };

    this.$propHandlers["icon"] = function(value) {
        if (!this.parentNode)
            return;

        var node = this.parentNode
            .$getLayoutNode("button", "icon", this.$button);

        if (node && node.nodeType == 1)
            apf.skins.setIcon(node, value, this.parentNode.iconPath);
    };

    this.$propHandlers["visible"] = function(value){
        if (!this.parentNode)
            return;

        if (value) {
            this.$ext.style.display = "";
            if (this.parentNode.$hasButtons)
                this.$button.style.display = "block";

            if (!this.parentNode.$activepage) {
                this.parentNode.set(this);
            }
        }
        else {
            if (this.$active) {
                this.$deactivate();

                // Try to find a next page, if any.
                var nextPage = this.parentNode.activepagenr + 1;
                var pages = this.parentNode.getPages()
                var len = pages.length
                while (nextPage < len && !pages[nextPage].visible)
                    nextPage++;

                if (nextPage == len) {
                    // Try to find a previous page, if any.
                    nextPage = this.parentNode.activepagenr - 1;
                    while (nextPage >= 0 && len && !pages[nextPage].visible)
                        nextPage--;
                }

                if (nextPage >= 0)
                    this.parentNode.set(nextPage);
                else {
                    this.parentNode.activepage   =
                    this.parentNode.activepagenr =
                    this.parentNode.$activepage = null;
                }
            }

            this.$ext.style.display = "none";
            if (this.parentNode.$hasButtons)
                this.$button.style.display = "none";
        }
    };

    /**
     * @attribute {Boolean} fake whether this page actually contains elements or
     * only provides a button in the pageable parent element.
     */
    this.$propHandlers["fake"] = function(value){
        if (this.$ext) {
            apf.destroyHtmlNode(this.$ext);
            this.$int = this.$ext = null;
        }
    };

    this.$propHandlers["type"] = function(value) {
        this.setProperty("fake", true);
        this.relPage = this.parentNode.getPage(value);
        if (this.$active)
            this.$activate();
    };

    /**** DOM Hooks ****/

    this.addEventListener("DOMNodeRemoved", function(e){
        if (e && e.currentTarget != this)
            return;
        
        if (this.$button) {
            if (this.$position & 1)
                this.parentNode.$setStyleClass(this.$button, "", ["firstbtn", "firstcurbtn"]);
            if (this.$position & 2)
                this.parentNode.$setStyleClass(this.$button, "", ["lastbtn"]);
        }

        if (!e.$doOnlyAdmin) {
            if (this.$button)
                this.$button.parentNode.removeChild(this.$button);

            if (this.parentNode.$activepage == this) {
                if (this.$button)
                    this.parentNode.$setStyleClass(this.$button, "", ["curbtn"]);
                this.parentNode.$setStyleClass(this.$ext, "", ["curpage"]);
            }
        }
    });

    //beforeNode, pNode, withinParent
    this.addEventListener("DOMNodeInserted", function(e){
        if (e && e.currentTarget != this || !this.$amlLoaded 
          || !e.$oldParent)
            return;

        if (!e.$moveWithinParent 
          && this.skinName != this.parentNode.skinName) {
            this.$destroy(); //clean up button
        }
        else if (this.$button && e.$oldParent.$hasButtons)
            this.parentNode.$buttons.insertBefore(this.$button,
                e.$beforeNode && e.$beforeNode.$button || null);
    }, true);

    /**** Private state functions ****/

    this.$position = 0;
    this.$first = function(remove){
        if (remove) {
            this.$position -= 1;
            this.parentNode.$setStyleClass(this.$button, "",
                ["firstbtn", "firstcurbtn"]);
        }
        else {
            this.$position = this.$position | 1;
            this.parentNode.$setStyleClass(this.$button, "firstbtn"
                + (this.parentNode.$activepage == this ? " firstcurbtn" : ""));
        }
    };

    this.$last = function(remove){
        if (remove) {
            this.$position -= 2;
            this.parentNode.$setStyleClass(this.$button, "", ["lastbtn"]);
        }
        else {
            this.$position = this.$position | 2;
            this.parentNode.$setStyleClass(this.$button, "lastbtn");
        }
    };

    this.$deactivate = function(fakeOther){
        if (this.disabled)
            return false;

        this.$active = false

        if (this.parentNode.$hasButtons) {
            if (this.$position > 0)
                this.parentNode.$setStyleClass(this.$button, "", ["firstcurbtn"]);
            this.parentNode.$setStyleClass(this.$button, "", ["curbtn"]);
        }

        if ((!this.fake || this.relPage) && !fakeOther) {
            this.parentNode.$setStyleClass(this.fake
                ? this.relPage.$ext
                : this.$ext, "", ["curpage"]);
            
            
            this.dispatchEvent("prop.visible", {value:false});
            
        }
    };

    this.$activate = function(){
        if (this.disabled)
            return false;

        this.$active = true;

        if (!this.$drawn) {
            var f;
            this.addEventListener("DOMNodeInsertedIntoDocument", f = function(e){
                this.removeEventListener("DOMNodeInsertedIntoDocument", f);
                if (!this.$active)
                    return;
                    
                this.$activate();
            });
            return;
        }

        if (this.parentNode.$hasButtons) {
            if (this.$position > 0)
                this.parentNode.$setStyleClass(this.$button, "firstcurbtn");
            this.parentNode.$setStyleClass(this.$button, "curbtn");
        }

        if (!this.fake || this.relPage) {
            this.parentNode.$setStyleClass(this.fake
                ? this.relPage.$ext
                : this.$ext, "curpage");
            
            if (apf.layout)
                apf.layout.forceResize(this.fake ? this.relPage.$int : this.$int);
            
        }

        
        if (this.$render)
            this.$render();
        
        
        if (!this.fake) {
            if (apf.isIE) {
                var cls = this.$ext.className;
                this.$ext.className = "rnd" + Math.random();
                this.$ext.className = cls;
            }
            
            
            this.dispatchEvent("prop.visible", {value:true});
            
        }
    };

    this.addEventListener("$skinchange", function(){
        if (this.caption)
            this.$propHandlers["caption"].call(this, this.caption);

        if (this.icon)
            this.$propHandlers["icon"].call(this, this.icon);
    });

    /**** Init ****/

    this.$canLeechSkin = true;

    this.$draw = function(isSkinSwitch){
        this.skinName = this.parentNode.skinName;

        var sType = this.getAttribute("type")
        if (sType) {
            this.fake = true;
            this.relPage = this.parentNode.getPage(sType) || null;
        }

        if (this.parentNode.$hasButtons) {
            //this.parentNode.$removeEditable(); //@todo multilingual support is broken when using dom

            this.parentNode.$getNewContext("button");
            var elBtn = this.parentNode.$getLayoutNode("button");
            elBtn.setAttribute(this.parentNode.$getOption("main", "select") || "onmousedown",
                'var page = apf.lookup(' + this.$uniqueId + ');\
                 page.parentNode.set(page);\
                 page.canHaveChildren = 2;');
            elBtn.setAttribute("onmouseover", 'var o = apf.lookup('
                + this.parentNode.$uniqueId + ');if(apf.lookup(' + this.$uniqueId
                + ') != o.$activepage) o.$setStyleClass(this, "over");');
            elBtn.setAttribute("onmouseout", 'var o = apf.lookup('
                + this.parentNode.$uniqueId + ');\
                  o.$setStyleClass(this, "", ["over"]);\
                  var page = apf.lookup(' + this.$uniqueId + ');\
                  page.canHaveChildren = true;');

            var nameOrId = this.getAttribute("id") || this.getAttribute("name"),
                closebtn = this.getAttribute("closebtn");

            if ((closebtn == "true" || (this.parentNode.buttons == "close" && closebtn == null)) && nameOrId) {
                var btncontainer = this.parentNode.$getLayoutNode("button", "btncontainer");

                this.parentNode.$getNewContext("btnclose");
                var elBtnClose = this.parentNode.$getLayoutNode("btnclose");
                
                if (!elBtnClose)
                    return;
                    
                elBtnClose.setAttribute("onclick",
                    'var page = apf.lookup(' + this.$uniqueId + ');\
                     page.parentNode.remove(' + nameOrId + ');');
                     
                btncontainer.appendChild(elBtnClose);
            }
            
            this.$button = apf.insertHtmlNode(elBtn, this.parentNode.$buttons);

            if (!isSkinSwitch && this.nextSibling && this.nextSibling.$button)
                this.$button.parentNode.insertBefore(this.$button, this.nextSibling.$button);

            this.$button.host = this;
        }

        if (this.fake)
            return;

        if (this.$ext)
            this.$ext.parentNode.removeChild(this.$ext); //@todo mem leaks?

        this.$ext = this.parentNode.$getExternal("page",
            this.parentNode.oPages, null, this);
        this.$ext.host = this;
        
        this.$int = this.parentNode
            .$getLayoutNode("page", "container", this.$ext);
        //if (this.$int)
            //this.$int.setAttribute("id", this.$int.getAttribute("id"));
    };

    this.$loadAml = function(x){
        
    };

    this.$destroy = function(){
        if (this.$button) {
            this.$button.host = null;
            this.$button = null;
        }
    };
}).call(apf.page.prototype = new apf.Presentation());

apf.aml.setElement("page", apf.page);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/submitform.js)SIZE(30279)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */







/**
 * Element allowing special form functionality to a set of AML
 * elements. This element is an alias for xforms offering
 * xform compatible strategies with relation to submitting the form's data.
 * This element also offers form paging, including validation across pages.
 * Buttons placed inside this element can contain an action
 * attribute specifying whether they behave as next, previous or finish(submit)
 * buttons. This element is <u>not</u> necesary for simple forms, like the
 * normal html webforms (see {@link baseclass.validation}). This element should
 * be used when multi page forms are required, or a wizard style form.
 *
 * @constructor
 * @define submitform, xforms
 * @allowchild page, {elements}, {anyaml}
 * @addnode elements
 *
 * @inherits apf.StandardBinding
 * @inherits apf.BaseTab
 * @inherits apf.ValidationGroup
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.9
 *
 * @default_private
 *
 * @todo please refactor. This element should be cleared of most its 'features' its all bollocks.
 */

apf.xforms     = function(struct, tagName){
    this.$init(tagName || "xforms", apf.NODE_VISIBLE, struct);
};

apf.submitform = function(struct, tagName){
    this.$init(tagName || "submitform", apf.NODE_VISIBLE, struct);
};

(function(){
    this.implement(
        
        apf.DataAction,
        
        apf.BaseTab,
        apf.ValidationGroup
    );

    this.$focussable     = false;

    this.elements = {};
    var buttons = {
        "next"     : [],
        "previous" : [],
        "submit"   : [],
        "follow"   : []
    };

    this.$focussable = false;
    //this.allowMultipleErrors = true;

    this.inputs        = [];
    this.errorEl       = {};
    this.cq            = {};
    this.reqs          = [];
    this.conditionDeps = {};
    this.depends       = {};

    this.loadValueDeps = {};
    this.loadValues    = {};

    this.listsHeldBack = {};
    this.nextHeldBack  = {};

    this.activepagenr    = 0;
    this.zCount        = 1000000;

    this.clear = function(){};

    /* ********************************************************************
                                        PUBLIC METHODS
    *********************************************************************/

    this.showLoader = function(checked, nr){
        if (checked) {
            var page = nr ? this.getPage(nr) : this.getNextPage();
            if (!page || page.$rendered) return;
        }

        if (this.loadState) {
            this.loadState.style.display = "block";

            var message = this.getPage().getAttribute("loadmessage");
            if (message)
                (apf.queryNode("div[@class='msg']", this.loadState)
                  || this.loadState).innerHTML = message;
        }
    };

    this.hideLoader = function(){
        if (this.loadState)
            this.loadState.style.display = "none";
    };

    var nextpagenr;
    this.getNextPage = function(){
        var nextpage, pageNr = this.activepagenr;
        do {
            nextpage = this.getPage(++pageNr);
        }
        while(nextpage && !this.testCondition(nextpage.condition));

        nextpagenr = pageNr;
        return nextpage;
    };

    this.next = function(no_error){
        if (!this.testing && !this.isValid(null, null, this.getPage())) {
            this.hideLoader();
            return;//checkRequired
        }

        //var nextpage = nextpagenr ? this.getPage(nextpagenr) : this.getNextPage();
        //if(this.dispatchEvent("beforeswitch", nextpagenr) === false)return false;

        //this.getPage().hide();
        this.set(this.activepagenr + 1);//nextpagenr
        //this.activepagenr = nextpagenr;

        //if(!no_error && !nextpage) throw new Error(apf.formatErrorString(1006, this, "Form", "End of pages reached."));

        //nextpage.show();
        //if(nextpage.$rendered) this.hideLoader();
        //else nextpage.addEventListener("afterrender", function(){this.parentNode.hideLoader()});

        for (var prop in buttons) {
            if (!prop.match(/next|previous|submit/)) continue;
            this.updateButtons(prop);
        }

        nextpagenr = null;

        /*var amlNode = this;
        $setTimeout(function(){
            amlNode.dispatchEvent("afterswitch", amlNode.activepagenr, nextpage);
        }, 1);*/
    };

    this.previous = function(){
        //var active = this.activepagenr;
        //do{var prevpage = this.getPage(--active);}
        //while(prevpage && !this.testCondition(prevpage.condition));

        //if(this.dispatchEvent("beforeswitch", active) === false) return false;

        this.set(this.activepagenr - 1);
        //this.getPage().hide();
        //this.activepagenr = active;

        //if(!prevpage) throw new Error(apf.formatErrorString(1006, this, "Form", "End of pages reached."));

        //prevpage.show();

        //if(prevpage.$rendered) this.hideLoader();
        //else prevpage.addEventListener("afterrender", function(){this.parentNode.hideLoader()});

        for (var prop in buttons) {
            if (!prop.match(/next|previous|submit/)) continue;
            this.updateButtons(prop);
        }

        //this.dispatchEvent("afterswitch", this.activepagenr);
    };

    this.$enable = function(){
        forbuttons('enable');
    };

    this.$disable = function(){
        forbuttons('disable');
    };

    function forbuttons(feat){
        var arr = ["next", "previous", "submit", "follow"];
        for (var k = 0; k < arr.length; k++) {
            for (var i = 0; i < buttons[arr[k]].length; i++) {
                buttons[arr[k]][i][feat]();
            }
        }
    }

    this.processValueChange = function(oFormEl){
        if (this.conditionDeps[oFormEl.name]) {
            var c = this.conditionDeps[oFormEl.name];
            for (var i = 0; i < c.length; i++) {
                if (this.testCondition(c[i].condition))
                    c[i].setActive();
                else
                    c[i].setInactive();
            }
        }

        for (var prop in buttons) {
            if (!prop.match(/next|previous|submit/)) continue;
            this.updateButtons(prop);
        }

        this.setLoadValues(oFormEl.name);
    };

    /* ***********************
                Actions
    ************************/

    /* ********************************************************************
                                        PRIVATE METHODS
    *********************************************************************/
    this.addInput = function(objEl){
        var name = objEl.name;
        objEl.$validgroup = this;

        if (this.elements[name] && !this.elements[name].length) {
            this.elements[name] = [this.elements[name]];
            this.elements[name].getValue = new Function(
                "for (var i = 0; i < this.length; i++)\
                     if (this[i].$int.checked)\
                         return this[i].getValue();");
        }

        if (this.elements[name])
            this.elements[name].push(objEl);
        else
            this.elements[name] = objEl;

        if (this.cq[name]) {
            for (var i = 0; i < this.cq[name].length; i++) {
                this.cq[name][i][1].call(this.cq[name][i][0], objEl);
                objEl.labelEl = this.cq[name][i][0];
            }
        }

        if (objEl.getAttribute("dependson")) {
            var o = self[objEl.getAttribute("dependson")];
            if (!this.depends[o.name])
                this.depends[o.name] = [];
            this.depends[o.name].push(objEl);
            objEl.setInactive();
        }

        if (objEl.nodeFunc == apf.NODE_VISIBLE)
            objEl.setZIndex(--this.zCount);

        if (this.listsHeldBack[name]) {
            var ld = this.listsHeldBack[name];
            this.loadLists(ld[0], ld[1], ld[2]);
            this.listsHeldBack[name] = null;
        }

        if (this.nQuest && objEl.getAttribute("checknext") == "true") {
            if (this.lastEl) {
                this.lastEl.nextEl = objEl;
                objEl.prevEl = this.lastEl;
            }
            this.lastEl = objEl;

            if (objEl.prevEl && objEl.getAttribute("show") != "true"
              && !this.nextHeldBack[name] && !objHasValue(objEl))
                objEl.setInactive(true);
            else if (this.condActiveCheck[objEl.name])
                this.condActiveCheck[objEl.name].setActive();

            //terrible code, but what the heck
            if (this.condActiveCheck[objEl.name]) {
                objEl.container = this.condActiveCheck[objEl.name];

                function activateHandler(){
                    if (this.form.hasActiveElement(this.container))
                        this.container.setActive();
                    else
                        this.container.setInactive();
                }

                objEl.addEventListener("activate", activateHandler);
                objEl.addEventListener("deactivate", activateHandler);
            }
        }
    };

    this.hasActiveElement = function(objEl){
        var nodes = objEl.$aml.getElementsByTagName("*");
        for (var i = 0; i < nodes.length; i++) {
            if (!nodes[i].getAttribute("id")) continue;
            var comp = this.elements[nodes[i].getAttribute("id")];
            if (comp && comp.form == this && comp.isActive)
                return true;
        }

        return false;
    };

    this.condActiveCheck = {};

    this.getButtons      = function(action){
        return buttons[action];
    };

    this.registerButton = function(action, oBtn){
        buttons[action].push(oBtn);

        if (oBtn.condition)
            this.parseCondition(oBtn, oBtn.condition);
        this.updateButtons(action, oBtn);

        if (action == "follow") return;

        var amlNode = this;
        oBtn.onclick = function(){
            amlNode.showLoader(true);
            $setTimeout(function(){ amlNode[action](); }, 10);
        };

        /*
            new Function(
                "apf.lookup(" + this.$uniqueId + ").showLoader(true);setTimeout("apf.lookup(" + this.$uniqueId + ")." + action + "()", 10)"
            );

            action == "previous" ?
                "apf.lookup(" + this.$uniqueId + ")." + action + "()" :
                "apf.lookup(" + this.$uniqueId + ").showLoader();setTimeout("apf.lookup(" + this.$uniqueId + ")." + action + "()", 10)"
            );
        */
    };

    //refactor to give buttons classes, so they can decide what to do when inactive
    this.updateButtons = function(action, singleBtn){
        return false;//

        if (!buttons[action]) return false;

        var result = true;
        if (action == "previous" && this.activepagenr == 0)
            result = false;
        else if (!this.testing && action == "next" && !this.isValid())
            result = false;
        else if (action == "next") {
            var cp = this.activepagenr;
            do {
                var nextpage = this.getPage(++cp);
            }
            while(nextpage && !this.testCondition(nextpage.condition));

            if (!nextpage)
                result = false;
        }

        if (this.testing)
            return true;

        var buttons = singleBtn ? [singleBtn] : buttons[action];
        for (var i = 0; i < buttons.length; i++) {
            if (result && (!buttons[i].condition || this.testCondition(buttons[i].condition)))
                buttons[i].setActive();
            else
                buttons[i].setInactive();
        }

        return true;
    };

    this.setLoadValues = function(item, clearElements, noload){
        var lvDep = this.loadValueDeps[item];
        if (!lvDep) return;
        //alert(item);
        for (var i = 0; i < lvDep.length; i++) {
            try{
                if (!eval(lvDep[i][1]))
                    throw new Error();
            }
            catch (e) {
                if (clearElements) {
                    var oEl = self[lvDep[i][0].getAttribute("element")];
                    if (oEl)
                        this.clearNextQuestionDepencies(oEl, true);//might be less optimized...

                    if (lvDep[i][0].tagName == "LoadValue")
                        this.dispatchEvent("clearloadvalue", lvDep[i][0]);

                    /*else if(lvDep[i][0].getAttribute("lid")){
                        var lid = lvDep[i][0].getAttribute("lid");
                        var nodes = this.xmlRoot.selectSingleNode("node()[@lid='" + lid + "']");

                        for(var i=0;i<nodes.length;i++){
                            apf.xmldb.removeNode(nodes[i]);
                        }
                    }*/
                }
                continue;
            }

            if (noload) continue;

            if (lvDep[i][0].getAttribute("runonrequest") != "true") {
                this.processLoadRule(lvDep[i][0], lvDep[i][2], lvDep[i]);
            }
            else
                if (self[lvDep[i][0].getAttribute("element")]) {
                    //This should be different :'(
                    self[lvDep[i][0].getAttribute("element")].clear();
                }
        }
    };

    this.processLoadRule = function(xmlCommNode, isList, data){
        //Extend with Method etc
        if (!apf.teleport.hasLoadRule(xmlCommNode)) return;

        this.dispatchEvent(isList ? "beforeloadlist" : "beforeloadvalue");

        //Process basedon arguments
        var nodes = xmlCommNode.childNodes;//selectNodes("node()[@arg-type | @arg-nr]"); //Safari bugs on this XPath... hack!
        if (nodes.length) {
            var arr, arg = xmlCommNode.getAttribute(apf.teleport.lastRuleFound.args);
            arg = arg ? arg.split(";") : [];

            if (xmlCommNode.getAttribute("argarray"))
                arr = [];
            for (var j = 0; j < nodes.length; j++) {
                if (nodes[j].nodeType != 1) continue; //for safari
                if (nodes[j].getAttribute("argtype").match(/fixed|param|nocheck/)) { //Where does item come from??? || item == nodes[j].getAttribute("element")
                    var el    = self[nodes[j].getAttribute("element")];
                    var xpath = el.getMainBindXpath();
                    var xNode = apf.createNodeFromXpath(this.xmlRoot, xpath);
                    var nType = xNode.nodeType;
                    (arr || arg)[nodes[j].getAttribute("argnr") || j] =
                        "xpath:" + xpath + (nType == 1 ? "/text()" : "");
                }
                else
                    if(nodes[j].getAttribute("argtype") == "xpath") {
                        (arr || arg)[nodes[j].getAttribute("argnr") || j] =
                            "xpath:" + nodes[j].getAttribute("select");//apf.queryValue(this.xmlRoot, );
                    }
            }

            if (xmlCommNode.getAttribute("argarray")) {
                arg[xmlCommNode.getAttribute("argarray")] = "(" + arr.join(",") + ")";
            }

            xmlCommNode.setAttribute(apf.teleport.lastRuleFound.args, arg.join(";"));
        }

        //this.xmlRoot.firstChild
        //if(confirm("do you want to debug?")) throw new Error();

        var jNode = self[xmlCommNode.getAttribute("element")];
        if (jNode && jNode.nodeFunc == apf.NODE_VISIBLE)
            jNode.$setStyleClass(jNode.$ext, "loading", ["loaded"]);

        //if(!isList && !data[0].getAttribute("lid")) data[0].setAttribute("lid", apf.getUniqueId());
        apf.teleport.callMethodFromNode(xmlCommNode, this.xmlRoot,
            Function('data', 'state', 'extra', 'apf.lookup(' + this.$uniqueId
                + ').' + (isList ? 'loadLists' : 'loadValues')
                + '(data, state, extra)'), null, data);
    };

    this.registerCondition = function(objEl, strCondition, no_parse){
        if (!no_parse)
            this.parseCondition(objEl, strCondition);

        var forceActive = false;
        if (objEl.onlyWhenActive) {
            var nodes = objEl.$aml.getElementsByTagName("*");
            for (var i = 0; i < nodes.length; i++) {
                if (!nodes[i].getAttribute("id")) continue;

                if (this.nextHeldBack[nodes[i].getAttribute("id")])
                    forceActive = true;
                else
                    if (nodes[i].getAttribute("ref") && this.xmlRoot
                      && apf.queryValue(this.xmlRoot
                      .selectSingleNode(nodes[i].getAttribute("ref"))) != "") {
                        forceActive = true;
                        nodes[i].setAttribute("show", "true");
                    }

                this.condActiveCheck[nodes[i].getAttribute("id")] = objEl;
            }
        }

        if (forceActive || this.testCondition(objEl.condition)
          && (!objEl.onlyWhenActive || this.hasActiveElement(objEl, true)))
            objEl.setActive();
        else
            objEl.setInactive();

        var matches = !no_parse
            ? strCondition.match(/(\W|^)(\w+)(?:\=|\!\=)/g)
            : strCondition.match(/(\b|^)([\w\.]+)/g);
        if (!matches) return;

        for (var i = 0; i < matches.length; i++) {
            if (!no_parse) {
                var m = matches[i].replace(/(?:\=|\!\=)$/, "").replace(/(^\s+|\s+$)/g, "");
            }
            else {
                var m = matches[i].split(".");
                if (m.length < 2) continue;
                m = m[0];
            }

            if (!this.conditionDeps[m])
                this.conditionDeps[m] = Array();
            this.conditionDeps[m].push(objEl);
        }
    };

    this.testCondition = function(strCondition){
        //somename='somestr' and (sothername='que' or iets='niets') and test=15

        try {
            return eval(strCondition);
        }
        catch(e) {
            return false;
            //throw new Error(apf.formatErrorString(1009, this, "Form", "Invalid conditional statement [" + strCondition + "] : " + e.message));
        }
    };

    this.loadValues = function(data, state, extra){
        if (state != apf.SUCCESS) {
            if (extra.retries < apf.maxHttpRetries)
                return extra.tpModule.retry(extra.id);
            else
                throw new Error(apf.formatErrorString(1010, this, "LoadVaLue", "Could not load values with LoadValue query :\n\n" + extra.message));
        }

        if (extra.userdata[0].getAttribute("returntype") == "array") {
            //integrate array
            for (var i = 0; i < data.length; i++) {
                var pnode = this.xmlRoot.selectSingleNode("//" + data[i][0]);
                apf.xmldb.setTextNode(pnode, data[i][1] || "");
            }
        }
        else {
            //integrate xml
            if (typeof data != "object")
                data = apf.getXmlDom(data).documentElement;
            var nodes     = data.childNodes;
            var strUnique = extra.userdata[0].getAttribute("unique");

            for (var i = nodes.length - 1; i >= 0; i--) {
                var xmlNode = nodes[i];
                var unique  = strUnique ? xmlNode.selectSingleNode(strUnique) : false;

                var node = unique
                    ? this.xmlRoot.selectSingleNode("node()[" + strUnique
                        + " = '" + unique.nodeValue + "']")
                    : null;
                if (node) {
                    //Move all this into the xmldb
                    apf.xmldb.copyConnections(node, xmlNode);
                    apf.xmldb.notifyListeners(xmlNode);

                    //node.setAttribute("lid", data.getAttribute("lid"));

                    //hack!! - should be recursive
                    var valueNode = xmlNode.selectSingleNode("value");
                    if (valueNode) {
                        apf.xmldb.copyConnections(node
                            .selectSingleNode("value"), valueNode);
                        apf.xmldb.notifyListeners(valueNode);
                    }
                }

                this.xmlRoot.insertBefore(xmlNode, node); //consider using replaceChild here
                if (node)
                    this.xmlRoot.removeChild(node);
                apf.xmldb.applyChanges("attribute", xmlNode);
            }
        }

        this.dispatchEvent("afterloadvalue");
    };

    this.loadLists = function(data, state, extra){
        if (state != apf.SUCCESS){
            if (extra.retries < apf.maxHttpRetries)
                return extra.tpModule.retry(extra.id);
            else
                throw new Error(apf.formatErrorString(1011, this, "Load List", "Could not load data with LoadList query :\n\n" + extra.message));
        }

        if (!self[extra.userdata[0].getAttribute("element")])
            return this.listsHeldBack[extra.userdata[0].getAttribute("element")] =
                [data, state, extra];

        //set style
        var jNode = self[extra.userdata[0].getAttribute("element")];
        if (jNode && jNode.nodeFunc == apf.NODE_VISIBLE) {
            jNode.$setStyleClass(jNode.$ext, "loaded", ["loading"]);
            $setTimeout("var jNode = apf.lookup(" + jNode.$uniqueId + ");\
                jNode.$setStyleClass(jNode.$ext, '', ['loading', 'loaded']);", 500);
        }

        if (extra.userdata[0].getAttribute("clearonload") == "true") {
            jNode.clearSelection();
            //this.setLoadValues(jNode.name, true);
            this.clearNextQuestionDepencies(jNode, true);
        }

        //load xml in element
        jNode.load(data);
        //if(!jNode.value){
            //this.clearNextQuestionDepencies(jNode, true);
        //}

        this.dispatchEvent("afterloadlist");
    };

    /*this.isValid = function(checkReq, setError, page){
        if(!page) page = this.getPage() || this;
        var found = checkValidChildren(page, checkReq, setError);

        //Global Rules
        //

        return !found;
    }

    this.validate = function(){
        if(!this.isValid()){

        }
    }*/

    //HACK!
    this.reset = function(){
        //Clear all error states
        var name, el;
        for (name in this.elements) {
            el = this.elements[name];

            //Hack!!! maybe each
            if (el.length) {
                throw new Error(apf.formatErrorString(this, "clearing form",
                    "Found controls without a name or with a name that isn't unique. Please give all elements of your submitform an id: '" + name + "'"));
            }

            el.clearError();
            if (this.errorEl[name])
                this.errorEl[name].hide();

            el.clear();
        }
    };

    /* ***********************
            Databinding
    ************************/

    this.$xmlUpdate = function(action, xmlNode, listenNode, UndoObj){
        //this.setConnections(this.xmlRoot, "select");
        //if(confirm("debug? " + this.toString())) debugger;
        this.dispatchEvent("xmlupdate");
    };

    this.smartBinding = {};

    this.$load = function(XMLRoot, id){
        apf.xmldb.addNodeListener(XMLRoot, this);
        //this.setConnections(apf.xmldb.getElement(XMLRoot, 0), "select");
        //this.setConnections(XMLRoot, "select");
    };

    function objHasValue(objEl){
        var oCheck = objEl;
        if (!oCheck)
            return false;
        return oCheck.$applyBindRule(oCheck.$mainBind,
            oCheck.xmlRoot, null, true);
    }

    //Reset form
    function onafterload(){
        //Clear all error states
        for (var name in this.elements) {
            if (apf.isWebkit && (!this.elements[name]
              || !this.elements[name].$amlLoaders))
                continue;

            //Hack!!! maybe each
            if (this.elements[name].length) {
                throw new Error(apf.formatErrorString(1012, this, "clearing form",
                "Found controls without a name or with a name that isn't unique("
                + name + "). Please give all elements of your submitform an id: '"
                + name + "'"));
            }

            this.elements[name].clearError();
            if (this.errorEl[name])
                this.errorEl[name].hide();
        }

        if (this.nQuest) {
            //Show all controls and labels which are in the nquest stack
            for (name in this.elements) {

                var objEl = this.elements[name];

                if (objEl.getAttribute("checknext") == "true") {
                    if (objHasValue(objEl)) {//oCheck.value ||
                        objEl.setActive();
                        if (this.condActiveCheck[name])
                            this.condActiveCheck[name].setActive();
                    }
                    else {
                        objEl.setInactive(true);
                    }
                }
                else {
                    //que ???
                    if (objEl.tagName == "Radiogroup" && objEl.current)
                        objEl.current.uncheck();
                }
            }
        }

        if (this.nQuest && this.xmlRoot.childNodes.length > 0) {
            var element = this.nQuest.getAttribute("final"),
                amlNode = self[element].$aml;//apf.queryNode(".//node()[@id='" + element + "']", this.$aml);

            if (amlNode && !apf.getBoundValue(amlNode, this.xmlRoot)) {
                var fNextQNode = apf.xmldb
                    .selectSingleNode(".//node()[@checknext='true']", this.$aml);
                if (!fNextQNode) return;
                self[fNextQNode.getAttribute("id")].dispatchEvent("afterchange");
            }
        }
    }
    this.addEventListener("afterload", onafterload);
    this.addEventListener("afterinsert", onafterload);

    this.addEventListener("beforeload", function(){
        if (!this.smartBinding || !this.smartBinding.actions) return;
        var nodes = this.smartBinding.actions.LoadList;
        if (nodes) {
            for (var objEl, i = 0; i < nodes.length; i++) {
                if (!nodes[i].getAttribute("element")
                  || !(objEl = this.elements[nodes[i].getAttribute("element")]))
                    continue;
                objEl.clear();
            }
        }

        var nodes = this.smartBinding.actions.NextQuestion;
        if (nodes) {
            for (var objEl, i = 0; i < nodes.length; i++) {
                if (!nodes[i].getAttribute("final")
                  || !(objEl = this.elements[nodes[i].getAttribute("element")]))
                    continue;
                objEl.clear();
            }
        }
    });

    /* *********
        INIT
    **********/
    this.implement(apf.GuiElement); /** @inherits apf.GuiElement */

    this.addOther = function(tagName, oAml){
        if (tagName == "loadstate") {
            var htmlNode   = apf.getFirstElement(oAml);
            this.loadState = apf.insertHtmlNode(htmlNode, this.$int);
            this.loadState.style.display = "none";
        }
    };

    this.$draw = function(){
        //Build Main Skin
        this.oPages = this.$ext = this.$getExternal();
        this.$int   = this.$getLayoutNode("main", "container", this.$ext);
        this.$ext.host = this;
    };

    /**
     * Submit this form
     * Example:
     *  <a:submitform
     *    [action="url" method="get|post|urlencoded-post" [ref="/"] ]
     *    [submit="<save_data>"]
     *    [submittype="json|xml|native"]
     *    [useelements="boolean"]
     *    [model="id"]
     *  >
     *    <a:button action="submit" [submission="[@id]"] [model=""] />
     *  </a:submitform>
     */
    this.submit = function(submissionId){
        if(!this.isValid()) return;
        if(!this.$model)     return; //error?

        var type = this.method == "urlencoded-post"
            ? "native"
            : (this.type || "xml");
        var instruction = submissionId || this.action
            ? ((this.method.match(/post/) ? "url.post:" : "") + this.action)
            : "";

        this.$model.submit(instruction, type, this.useComponents, this.ref);
    };

    this.setModel = function(model, xpath){
        this.$model = model;
    };

    this.$loadAml = function(x){
        this.testing       = x.getAttribute("testing") == "true";

        this.action        = this.getAttribute("action");
        this.ref           = this.getAttribute("ref");
        this.type          = this.getAttribute("submittype") || "native";
        this.method        = (this.getAttribute("method") || "get").toLowerCase();
        this.useComponents = this.getAttribute("usecomponents") || true;

        apf.setModel(x.getAttribute("model"), this);

        this.$loadChildren(function(xmlPage) {
            this.validation = xmlPage.getAttribute("validation") || "true";
            this.invalidmsg = xmlPage.getAttribute("invalidmsg");
        });
    };

}).call(apf.submitform.prototype = new apf.StandardBinding());


apf.xforms.prototype = apf.submitform.prototype;

apf.aml.setElement("xforms", apf.xforms);
apf.aml.setElement("submitform", apf.submitform);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/notifier.js)SIZE(15283)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Notification element, which shows popups when events occur. Similar
 * to growl on the OSX platform.
 * Example:
 * <code>
 *  <a:notifier position="bottom-right" margin="10 10">
 *      <a:event 
 *        when    = "{offline.onLine}"
 *        message = "You are currently working offline"
 *        icon    = "icoOffline.gif" />
 *      <a:event 
 *        when    = "{!offline.onLine}"
 *        message = "You are online"
 *        icon    = "icoOnline.gif" />
 *      <a:event 
 *        when    = "{offline.syncing}" 
 *        message = "Your changes are being synced" 
 *        icon    = "icoSyncing.gif" />
 *      <a:event 
 *        when    = "{!offline.syncing}"
 *        message = "Syncing done"
 *        icon    = "icoDone.gif" />
 *  </a:notifier>
 * </code>
 * Example:
 * Notifier with 4 notifications which appears and stays over the 3 seconds
 * begins to the top right corner and goes to the left. First notification will
 * be displayed when value in textbox will be bigger than 4. In next two cases 
 * notification will be shown when notifier's position or arrange attribute will 
 * be changed. In the last case notification will be shown when date 2008-12-24 
 * will be selected on calendar.
 * <code>
 *  <a:notifier id="notiTest" position="top-right" margin="20" timeout="3" arrange="horizontal" columnsize="200">
 *      <a:event when="{txtNumber.value > 4}" message="Incorrect value, please enter a number not bigger than 4." icon="evil.png"></a:event>
 *      <a:event when="{notiTest.position}" message="Notifier display position has been changed"></a:event>
 *      <a:event when="{notiTest.arrange}" message="Notifier display arrange has been changed"></a:event>
 *      <a:event when="{txtDrop.value == '2008-12-24'}" message="Marry christmas !" icon="Reindeer.png" ></a:event>
 *  </a:notifier>
 * </code>
 * 
 * @define notifier
 * @attribute   {String}   position     Vertical and horizontal element's start
 *                                      position, it can be changed in any time,
 *                                      default is 'top-right'
 *     Possible values:
 *     top-right       element is placed in top-right corner of browser window
 *     top-left        element is placed in top-left corner of browser window
 *     bottom-right    element is placed in bottom-right corner of browser window
 *     bottom-left     element is placed in bottom-left corner of browser window
 *     center-center   element is placed in the middle of browser window
 *     right-top       element is placed in top-right corner of browser window
 *     left-top        element is placed in top-left corner of browser window
 *     right-bottom    element is placed in bottom-right corner of browser window
 *     left-bottom     element is placed in bottom-left corner of browser window
 *     center-center   element is placed in the middle of browser window
 * @attribute   {String}   margin       It's a free space around popup element,
 *                                      default is '10 10 10 10' pixels
 * @attribute   {String}   columnsize   Specify element width and col width where
 *                                      element will be displayed, default is 300 pixels
 * @attribute   {String}   arrange      popup elements can be displayed in rows
 *                                      or columns, default is 'vertical'
 *     Possible values:
 *     vertical     element will be displayed in rows
 *     horizontal   element will be displayed in columns
 * @attribute   {String}   timeout      After the timeout has passed the popup
 *                                      will dissapear automatically. When the
 *                                      mouse hovers over the popup it doesn't
 *                                      dissapear, default is 2 seconds
 * $attribute   {String}   onclick      It's an action executed after user click
 *                                      on notifier cloud
 * 
 * @constructor
 *
 * @inherits apf.Presentation
 * 
 * @author      
 * @version     %I%, %G% 
 * 
 * @allowchild event
 */
apf.notifier = function(struct, tagName){
    this.$init(tagName || "notifier", apf.NODE_VISIBLE, struct);
};

(function() {
    this.timeout    = 2000;
    this.position   = "top-right";
    this.columnsize = 300;
    this.arrange    = "vertical";
    this.margin     = "10 10 10 10";

    this.lastPos    = null;
    this.showing    = 0;
    this.sign       = 1;

    this.$supportedProperties.push("margin", "position", "timeout",
        "columnsize", "arrange");

    this.$propHandlers["position"] = function(value) {
        this.lastPos = null;
    };
    
    this.$propHandlers["margin"] = function(value) {
        this.margin = value;
    };
    
    this.$propHandlers["timeout"] = function(value) {
        this.timeout = parseInt(value) * 1000;
    };
    
    function getPageScroll() {
        return [
            document.documentElement.scrollTop || document.body.scrollTop,
            document.documentElement.scrollLeft || document.body.scrollLeft
        ];
    }

    function getStartPosition(x, wh, ww, nh, nw, margin) {
        var scrolled = getPageScroll();

        return [
             (x[0] == "top"
                 ? margin[0]
                 : (x[0] == "bottom"
                     ? wh - nh - margin[2]
                     : wh / 2 - nh / 2)) + scrolled[0],
             (x[1] == "left"
                 ? margin[3]
                 : (x[1] == "right"
                     ? ww - nw - margin[1]
                     : ww / 2 - nw / 2)) + scrolled[1]
        ];
    }

    /**
     * Function creates new notifie popup element
     * 
     * @param {String}  message  Message content displaing in popup element,
     *                           default is [No message]
     * @param {String}  icon     Path to icon file relative to "icon-path" which
     *                           is set in skin declaration
     * @param {Object}  ev       object representation of event
     * 
     */
    this.popup = function(message, icon, ev) {
        if (!this.$ext)
            return;

        this.$ext.style.width = this.columnsize + "px";

        var _self = this,
            oNoti = this.$pHtmlNode.appendChild(this.$ext.cloneNode(true)),
            ww    = apf.isIE
                ? document.documentElement.offsetWidth
                : window.innerWidth,
            wh    = apf.isIE
                ? document.documentElement.offsetHeight
                : window.innerHeight,
        
            removed = false,

            oIcon = this.$getLayoutNode("notification", "icon", oNoti),
            oBody = this.$getLayoutNode("notification", "body", oNoti);

        this.showing++;

        if (oIcon && icon) {
            if (oIcon.nodeType == 1) {
                oIcon.style.backgroundImage = "url("
                + this.iconPath + icon + ")";
            }
            else {
                oIcon.nodeValue = this.iconPath + icon;
            }

            this.$setStyleClass(oNoti, this.$baseCSSname + "ShowIcon");
        }

        oBody.insertAdjacentHTML("beforeend", message || "[No message]");
        oNoti.style.display = "block";

        var margin = apf.getBox(this.margin || "0"),
            nh     = oNoti.offsetHeight,
            nw     = oNoti.offsetWidth,
            /* It's possible to set for example: position: top-right or right-top */
            x      = this.position.split("-"),
            _reset = false;

        if (x[1] == "top" || x[1] == "bottom" || x[0] == "left" || x[0] == "right")
            x = [x[1], x[0]];
        /* center-X and X-center are disabled */
        if ((x[0] == "center" && x[1] !== "center") || (x[0] !== "center" && x[1] == "center"))
            x = ["top", "right"];

        /* start positions */
        if (!this.lastPos) {
            this.lastPos = getStartPosition(x, wh, ww, nh, nw, margin);
            this.sign = 1;
            _reset = true;
        }

        if ((!_reset && x[0] == "bottom" && this.sign == 1) ||
           (x[0] == "top" && this.sign == -1)) {
            if (this.arrange == "vertical") {
                this.lastPos[0] += x[1] == "center"
                    ? 0
                    : this.sign * (x[0] == "top"
                        ? margin[0] + nh
                        : (x[0] == "bottom"
                            ? - margin[2] - nh
                            : 0));
            }
            else {
                this.lastPos[1] += x[0] == "center"
                    ? 0
                    : this.sign * (x[1] == "left"
                        ? margin[3] + nw
                        : (x[1] == "right"
                            ? - margin[1] - nw
                            : 0));
            }
        }

        /* reset to next line, first for vertical, second horizontal */
        var scrolled = getPageScroll();
        
        if (this.lastPos[0] > wh + scrolled[0] - nh || this.lastPos[0] < scrolled[0]) {
            this.lastPos[1] += (x[1] == "left"
                ? nw + margin[3]
                : (x[1] == "right"
                    ? - nw - margin[3]
                    : 0));
            this.sign *= -1;
            this.lastPos[0] += this.sign*(x[0] == "top"
                ? margin[0] + nh
                : (x[0] == "bottom"
                    ? - margin[2] - nh
                    : 0));
        }
        else if (this.lastPos[1] > ww + scrolled[1] - nw || this.lastPos[1] < scrolled[1]) {
            this.lastPos[0] += (x[0] == "top"
                ? nh + margin[0]
                : (x[0] == "bottom"
                    ? - nh - margin[0]
                    : 0));
            this.sign *= -1;
            this.lastPos[1] += x[0] == "center"
                ? 0
                : this.sign * (x[1] == "left"
                    ? margin[3] + nw
                    : (x[1] == "right"
                        ? - margin[1] - nw
                        : 0));
        }

        /* Start from begining if entire screen is filled */
        if (this.lastPos) {
            if ((this.lastPos[0] > wh + scrolled[0] - nh || this.lastPos[0] < scrolled[1])
              && this.arrange == "horizontal") {
                this.lastPos = getStartPosition(x, wh, ww, nh, nw, margin);
                this.sign = 1;
            }
            if ((this.lastPos[1] > ww + scrolled[1] - nw || this.lastPos[1] < scrolled[1])
              && this.arrange == "vertical") {
                this.lastPos = getStartPosition(x, wh, ww, nh, nw, margin);
                this.sign = 1;
            }
        }  

        oNoti.style.left = this.lastPos[1] + "px";
        oNoti.style.top  = this.lastPos[0] + "px";

        if ((x[0] == "top" && this.sign == 1) || (x[0] == "bottom" && this.sign == -1)) {
            if (this.arrange == "vertical") {
                this.lastPos[0] += x[1] == "center"
                    ? 0
                    : this.sign * (x[0] == "top"
                        ? margin[0] + nh
                        : (x[0] == "bottom"
                            ? - margin[2] - nh
                            : 0));
            }
            else {
                this.lastPos[1] += x[0] == "center"
                    ? 0
                    : this.sign * (x[1] == "left"
                        ? margin[3] + nw
                        : (x[1] == "right"
                            ? - margin[1] - nw
                            : 0));
            }
        };

        var isMouseOver = false;

        apf.tween.css(oNoti, "fade", {
            anim     : apf.tween.NORMAL,
            steps    : 10,
            interval : 10,
            onfinish : function(container) {
                oNoti.style.filter = "";
                $setTimeout(hideWindow, _self.timeout)
            }
        });

        function hideWindow() {
            if (isMouseOver)
                return;

            apf.tween.css(oNoti, "notifier_hidden", {
                anim    : apf.tween.NORMAL,
                steps   : 10,
                interval: 20,
                onfinish: function(container) {
                    apf.setStyleClass(oNoti, "", ["notifier_hover"]);
                    if (isMouseOver)
                        return;

                    if (oNoti.parentNode) {
                        if (oNoti.parentNode.removeChild(oNoti) && !removed) {
                            _self.showing--;
                            removed = true;
                        }
                    }

                    if (_self.showing == 0)
                        this.lastPos = null;
                }
            });
        }

        /* Events */
        oNoti.onmouseover = function(e) {
            e = (e || event);
            var tEl = e.explicitOriginalTarget || e.toElement;
            if (isMouseOver)
                return;
            if (tEl == oNoti || apf.isChildOf(oNoti, tEl)) {
                apf.tween.css(oNoti, "notifier_hover", {
                    anim    : apf.tween.NORMAL,
                    steps   : 10,
                    interval: 20,
                    onfinish: function(container) {
                        apf.setStyleClass(oNoti, "", ["notifier_shown"]);
                    }
                });
                
                isMouseOver = true;
            }
        };

        oNoti.onmouseout = function(e) {
            e = (e || event);
            var tEl = e.explicitOriginalTarget || e.toElement;

            if (!isMouseOver)
                return;

            if (apf.isChildOf(tEl, oNoti) ||
               (!apf.isChildOf(oNoti, tEl) && oNoti !== tEl )) {
                isMouseOver = false;
                hideWindow();
            }
        };

        if (ev) {
            oNoti.onclick = function() {
                ev.dispatchEvent("click");
            };
        }
    };

    /**** Init ****/

    this.$draw = function() {
        //Build Main Skin
        this.$pHtmlNode = document.body;
        
        this.$ext = this.$getExternal("notification");
        this.$ext.style.display  = "none";
        this.$ext.style.position = "absolute";
        this.$ext.style.zIndex   = 100000;
    };
}).call(apf.notifier.prototype = new apf.Presentation());

apf.aml.setElement("notifier", apf.notifier);
apf.aml.setElement("event", apf.event);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/bindingdndrule.js)SIZE(3737)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @attribute {String} target 
 * @attribute {String} action
 * @attribute {Boolean} copy
 */
apf.BindingDndRule = function(struct, tagName){
    this.$init(tagName, apf.NODE_HIDDEN, struct);
};

(function(){
    this.compile = function(prop){
        if (!this[prop])
            return;
        
        var compileData;
        if (prop == "value")
            compileData = apf.lm.compile(this[prop], {
                xpathmode  : 3
            });
        else if (prop == "match")
            compileData = apf.lm.compile(this[prop], {
                xpathmode  : 3,
                injectself : true
            });
        else if (prop == "target")
            compileData = apf.lm.compile(this[prop], {
                xpathmode  : 2,
                injectself : true
            });
        else if (prop == "action")
            compileData = apf.lm.compile(this[prop], {
                nostring : true
            });
        else if (prop == "copy")
            compileData = apf.lm.compile(this[prop], {
                withopt  : true,
                nostring : true
            });
        else
            throw new Error("Missing property handler for compile");
        
        return (this["c" + prop] = compileData);
    }
    
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        target   : 1,
        parent   : 1,
        action   : 1,
        dragcopy : 1
    }, this.$attrExcludePropBind);

    this.$propHandlers["target"]   = 
    this.$propHandlers["parent"]   = 
    this.$propHandlers["action"]   = 
    this.$propHandlers["dragcopy"] = function(value, prop){
        delete this["c" + prop];
    }
    
    this.$noderegister = function(e){
         apf.GuiElement.propHandlers["drop"].call(e.amlNode, true);
    }
    
    //@todo removal
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        //Find parent that this rule works on
        var pNode = this;
        while (pNode && pNode.$bindingRule) 
            pNode = pNode.parentNode;
       
        if (!pNode)
            return;
        
        if (pNode.localName == "bindings") {
            pNode.addEventListener("noderegister", this.$noderegister);
            
            var nodes = pNode.$amlNodes;
            for (var i = 0; i < nodes.length; i++)
                apf.GuiElement.propHandlers["drop"].call(nodes[i], true);
        }
        else {
            apf.GuiElement.propHandlers["drop"].call(pNode, true);
        }
    });
}).call(apf.BindingDndRule.prototype = new apf.BindingRule());

apf.aml.setElement("drag", apf.BindingDndRule);
apf.aml.setElement("drop", apf.BindingDndRule);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/toolbar.js)SIZE(2825)TIME(1259091146)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element displaying a bar containing buttons and other aml elements.
 * This element is usually positioned in the top of an application allowing
 * the user to choose from grouped buttons.
 * Example:
 * <code>
 *  <a:menu id="menu5">
 *      <a:item>About us</a:item>
 *      <a:item>Help</a:item>
 *  </a:menu>
 *  <a:menu id="menu6">
 *      <a:item icon="email.png">Tutorials</a:item>
 *      <a:item>Live Helps</a:item>
 *      <a:divider></a:divider>
 *      <a:item>Visit Ajax.org</a:item>
 *      <a:item>Exit</a:item>
 *  </a:menu>
 *  <a:window 
 *    id          = "winMail"
 *    contextmenu = "menu6"
 *    width       = "300"
 *    height      = "200" 
 *    visible     = "true"
 *    resizable   = "true" 
 *    title       = "Mail message"
 *    icon        = "email.png">
 *      <a:toolbar>
 *          <a:menubar>
 *              <a:button submenu="menu6">File</a:button>
 *              <a:button submenu="menu5">Edit</a:button>
 *          </a:menubar>
 *      </a:toolbar>
 *  </a:window>
 * </code>
 *
 * @constructor
 * @define toolbar
 * @addnode elements
 * @allowchild bar, menubar
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @inherits apf.Presentation
 */

apf.toolbar = function(struct, tagName){
    this.$init(tagName || "toolbar", apf.NODE_VISIBLE, struct);
};

(function(){
    this.$focussable     = false;
    
    /**** DOM Hooks ****/
    
    
    /**** Init ****/

    this.$draw = function(){
        //Build Main Skin
        this.$ext = this.$getExternal();
        this.$int = this.$getLayoutNode("main", "container", this.$ext);
    };
}).call(apf.toolbar.prototype = new apf.Presentation());

apf.aml.setElement("toolbar", apf.toolbar);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/colorpicker.js)SIZE(12772)TIME(1260921690)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Element giving the user a visual choice of several colors presented in a
 * grid.
 *
 * @constructor
 * @define colorpicker
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @inherits apf.StandardBinding
 * @inherits apf.DataAction
 * @inherits apf.XForms
 *
 * @attribute {String} color the color that is selected in the color picker.
 *
 * @binding value  Determines the way the value for the element is retrieved 
 * from the bound data.
 * Example:
 * Sets the color based on data loaded into this component.
 * <code>
 *  <a:model id="mdlColor">
 *      <data color="#00099"></data>
 *  </a:model>
 *  <a:colorpicker 
 *    model = "mdlColor" 
 *    value = "[@color]" />
 * </code>
 * Example:
 * A shorter way to write this is:
 * <code>
 *  <a:model id="mdlColor">
 *      <data color="#00099"></data>
 *  </a:model>
 *  <a:colorpicker value="[mdlColor::@color]" />
 * </code>
 */
apf.colorpicker = function(struct, tagName){
    this.$init(tagName || "colorpicker", apf.NODE_VISIBLE, struct);
};

(function(){
    this.implement(
        
        apf.StandardBinding
        
        
        ,apf.DataAction
        
        
    );
    //Options
    this.$focussable = true; // This object can get the focus

    // PUBLIC METHODS
    this.setValue = function(value, type){
        //this.value = value;
        if (!type) type = "RGBHEX";
        var a;
        switch (type) {
            case "HSL":
                this.fill(value[0], value[1], value[2]);
                break;
            case "RGB":
                a = RGBtoHLS(value[0], value[1], value[2]);
                this.fill(a[0], a[1], a[2]);
                break;
            case "RGBHEX":
                var RGB = arguments[0].match(/(..)(..)(..)/);
                a = RGBtoHLS(Math.hexToDec(RGB[0]),
                    Math.hexToDec(RGB[1]), Math.hexToDec(RGB[2]));
                this.fill(a[0], a[1], a[2]);
                break;
        }
    };

    this.getValue = function(type){
        return HSLRangeToRGB(cH, cS, cL);
    };

    // PRIVATE METHODS
    var cL       = 120,
        cS       = 239,
        cH       = 0,
        cHex     = "#FF0000",
        HSLRange = 240;

    function HSLRangeToRGB(H, S, L){
        return HSLtoRGB(H / (HSLRange - 1), S / HSLRange,
            Math.min(L / HSLRange, 1))
    };

    function RGBtoHLS(R,G,B){
        var RGBMAX = 255,
            HLSMAX = HSLRange,
            UNDEF  = (HLSMAX*2/3),

        /* calculate lightness */
             cMax = Math.max(Math.max(R,G), B),
             cMin = Math.min(Math.min(R,G), B);
        L = (((cMax + cMin) * HLSMAX) + RGBMAX) / (2 * RGBMAX);

        if (cMax == cMin) {           /* r=g=b --> achromatic case */
            S = 0;                    /* saturation */
            H = UNDEF;                /* hue */
        }
        /* chromatic case */
        else {
            /* saturation */
            if (L <= (HLSMAX/2))
                S = (((cMax - cMin) * HLSMAX) + ((cMax + cMin) / 2)) / (cMax + cMin);
            else
                S = (((cMax - cMin) * HLSMAX) + ((2 * RGBMAX - cMax - cMin) / 2))
                  / (2 * RGBMAX - cMax - cMin);

            /* hue */
            Rdelta = (((cMax - R) * (HLSMAX / 6)) + ((cMax - cMin) / 2)) / (cMax - cMin);
            Gdelta = (((cMax - G) * (HLSMAX / 6)) + ((cMax - cMin) / 2)) / (cMax - cMin);
            Bdelta = (((cMax - B) * (HLSMAX / 6)) + ((cMax - cMin) / 2)) / (cMax - cMin);

            if (R == cMax)
                H = Bdelta - Gdelta;
            else if (G == cMax)
                H = (HLSMAX / 3) + Rdelta - Bdelta;
            else
                H = ((2 * HLSMAX) / 3) + Gdelta - Rdelta;

            if (H < 0)
                H += HLSMAX;
            if (H > HLSMAX)
                H -= HLSMAX;
        }

        return [H, S, L];
    }

    function hueToColorValue(hue){
        var V;

        if (hue < 0)
            hue = hue + 1
        else if (hue > 1)
            hue = hue - 1;

        if (6 * hue < 1)
            V = M1 + (M2 - M1) * hue * 6
        else if (2 * hue < 1)
            V = M2
        else if (3 * hue < 2)
            V = M1 + (M2 - M1) * (2 / 3 - hue) * 6
        else
            V = M1;

        return Math.max(Math.floor(255 * V), 0);
    };

    function HSLtoRGB(H, S, L){
        var R,  G,  B;

        if (S == 0)
            G = B = R = Math.round (255 * L);
        else {
            M2 = (L <= 0.5) ? (L * (1 + S)) : (L + S - L * S);

            M1 = 2 * L - M2;
            R = hueToColorValue(H + 1 / 3);
            G = hueToColorValue(H);
            B = hueToColorValue(H - 1 / 3);
        }

        return Math.decToHex(R) + "" + Math.decToHex(G) + "" + Math.decToHex(B);
    };

    this.fill = function(H, S, L){
        var Hex    = HSLRangeToRGB(H,S,L);
        this.value = Hex;

        //RGB
        var RGB            = Hex.match(/(..)(..)(..)/);
        this.tbRed.value   = Math.hexToDec(RGB[1]);
        this.tbGreen.value = Math.hexToDec(RGB[2]);
        this.tbBlue.value  = Math.hexToDec(RGB[3]);

        //HSL
        this.tbHue.value       = Math.round(H);
        this.tbSatern.value    = Math.round(S);
        this.tbLuminance.value = Math.round(L);

        //HexRGB
        this.tbHexColor.value  = Hex;

        //Shower
        this.shower.style.backgroundColor = Hex;

        //Luminance
        var HSL120                        = HSLRangeToRGB(H, S, 120);
        this.bar1.style.backgroundColor   = HSL120;
        this.bgBar1.style.backgroundColor = HSLRangeToRGB(H, S, 240);
        this.bar2.style.backgroundColor   = HSLRangeToRGB(H, S, 0);
        this.bgBar2.style.backgroundColor = HSL120;
    };

    this.movePointer = function(e){
        e = e || event;

        var ty = this.pHolder.ty;
        if ((e.clientY - ty >= 0) && (e.clientY - ty
          <= this.pHolder.offsetHeight - this.pointer.offsetHeight + 22))
            this.pointer.style.top = e.clientY - ty;
        if (e.clientY - ty < 21)
            this.pointer.style.top = 21;
        if (e.clientY - ty
          > this.pHolder.offsetHeight - this.pointer.offsetHeight + 19)
            this.pointer.style.top = this.pHolder.offsetHeight
                - this.pointer.offsetHeight + 19;

        // 255 - posY:
        cL = (255 - (this.pointer.offsetTop - 22)) / 2.56 * 2.4;
        this.fill(cH, cS, cL);

        e.returnValue  = false;
        e.cancelBubble = true;
    };

    this.setLogic = function(){
        var _self = this;
        this.pHolder.style.zIndex = 10;
        this.pHolder.onmousedown  = function(){
            this.ty = apf.getAbsolutePosition(this)[1] - 20;

            _self.movePointer();
            document.onmousemove = _self.movePointer
            document.onmouseup   = function(){ this.onmousemove = function(){}; };
        }

        this.container.onmousedown = function(e){
            e = e || event;

            this.active = true;
            if (e.srcElement == this) {
                if (e.offsetX >= 0 && e.offsetX <= 256
                  && e.offsetY >= 0 && e.offsetY <= 256) {
                    cS = (256 - e.offsetY) / 2.56 * 2.4
                    cH = e.offsetX / 2.56 * 2.39
                }
                _self.fill(cH, cS, cL);
                _self.shower.style.backgroundColor = _self.currentColor;
            }
            _self.point.style.display = "none";

            e.cancelBubble = true;
        }

        this.container.onmouseup = function(e){
            e = e || event;
            this.active               = false;
            _self.point.style.top     = e.offsetY - _self.point.offsetHeight - 2;
            _self.point.style.left    = e.offsetX - _self.point.offsetWidth - 2;
            _self.point.style.display = "block";

            _self.change(_self.tbHexColor.value);
        }

        this.container.onmousemove = function(e){
            e = e || event;
            if (this.active) {
                if (e.offsetX >= 0 && e.offsetX <= 256
                  && e.offsetY >= 0 && e.offsetY <= 256) {
                    cS = (256 - e.offsetY) / 2.56 * 2.4
                    cH = e.offsetX / 2.56 * 2.39
                }
                _self.fill(cH, cS, cL);
                _self.shower.style.backgroundColor = _self.currentColor;
            }
        }

        /*this.tbHexColor.host =
        this.tbRed.host =
        this.tbGreen.host =
        this.tbBlue.host = this;
        this.tbHexColor.onblur = function(){_self.setValue("RGBHEX", this.value);}
        this.tbRed.onblur = function(){_self.setValue("RGB", this.value, _self.tbGreen.value, _self.tbBlue.value);}
        this.tbGreen.onblur = function(){_self.setValue("RGB", _self.tbRed.value, this.value, _self.tbBlue.value);}
        this.tbBlue.onblur = function(){_self.setValue("RGB", _self.tbRed.value, _self.tbGreen.value, this.value);}
        */
    }

    // Databinding
    this.$mainBind = "color";

    this.$draw = function(parentNode, clear){
        //Build Main Skin
        this.$ext    = this.$getExternal();

        this.tbRed   = this.$getLayoutNode("main", "red", this.$ext);
        this.tbGreen = this.$getLayoutNode("main", "green", this.$ext);
        this.tbBlue  = this.$getLayoutNode("main", "blue", this.$ext);

        this.tbHue       = this.$getLayoutNode("main", "hue", this.$ext);
        this.tbSatern    = this.$getLayoutNode("main", "satern", this.$ext);
        this.tbLuminance = this.$getLayoutNode("main", "luminance", this.$ext);

        this.tbHexColor  = this.$getLayoutNode("main", "hex", this.$ext);
        var _self = this;
        this.tbHexColor.onchange = function(){
            _self.setValue(this.value, "RGBHEX");
        };

        this.shower = this.$getLayoutNode("main", "shower", this.$ext);

        this.bar1   = this.$getLayoutNode("main", "bar1", this.$ext);
        this.bgBar1 = this.$getLayoutNode("main", "bgbar1", this.$ext);
        this.bar2   = this.$getLayoutNode("main", "bar2", this.$ext);
        this.bgBar2 = this.$getLayoutNode("main", "bgbar2", this.$ext);

        this.pHolder   = this.$getLayoutNode("main", "pholder", this.$ext);
        this.pointer   = this.$getLayoutNode("main", "pointer", this.$ext);
        this.container = this.$getLayoutNode("main", "container", this.$ext);
        this.point     = this.$getLayoutNode("main", "point", this.$ext);

        var nodes = this.$ext.getElementsByTagName("input");
        for (var i = 0; i < nodes.length; i++) {
            nodes[i].onselectstart = function(e){
                e = e || event;
                e.cancelBubble = true;
            };
        }

        this.setLogic();

        this.setValue("ffffff");
        //this.fill(cH, cS, cL);
    }

    this.$loadAml = function(x){
        if (x.getAttribute("color"))
            this.setValue(x.getAttribute("color"));
    }

    this.$destroy = function(){
        this.container.host  =
        this.tbRed.host      =
        this.tbGreen.host    =
        this.tbBlue.host     =
        this.tbHexColor.host =
        this.pHolder.host    = null;
    }
}).call(apf.colorpicker.prototype = new apf.GuiElement());

apf.aml.setElement("colorpicker", apf.colorpicker);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/divider.js)SIZE(2382)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element displaying a divider. For use in toolbars, menu's and such.
 * @define divider
 * @constructor
 */
apf.divider = function(struct, tagName){
    this.$init(tagName || "divider", apf.NODE_VISIBLE, struct);
};

(function() {
    this.$focussable = false;
    
    this.addEventListener("AMLReparent", function(beforeNode, pNode, withinParent){
        if (!this.$amlLoaded)
            return;
        
        if (!withinParent && this.skinName != pNode.skinName) {
            //@todo for now, assuming dom garbage collection doesn't leak
            this.loadAml();
        }
    });
    
    /**
     * @ref amlNode#show
     */
    this.show = function(){
        this.$ext.style.display = "block";
    };
    
    /**
     * @ref amlNode#hide
     */
    this.hide = function(){
        this.$ext.style.display = "none";
    };
    
    this.$canLeechSkin = true;
    
    /**
     * @private
     */
    this.$loadAml = function(x) {
        this.$aml = x;

        if (this.$isLeechingSkin) {
            this.$ext = apf.insertHtmlNode(
                this.parentNode.$getLayoutNode("divider"), this.$pHtmlNode);
        }
        else {
            this.$ext = this.$getExternal("main");
        }
    };
}).call(apf.divider.prototype = new apf.Presentation);

apf.aml.setElement("divider", apf.divider);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/hbox.js)SIZE(6582)TIME(1263910419)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * @define vbox Container that stacks it's children vertically.
 * @see element.hbox
 * @define hbox Container that stacks it's children horizontally.
 * Example:
 * <code>
 *  <a:hbox height="500" width="600">
 *      <a:vbox height="500" width="500">
 *          <a:bar height="250" caption="Top bar" />
 *          <a:hbox width="500" height="250">
 *              <a:bar width="150" caption="Bottom left bar"/>
 *              <a:bar width="350" caption="Bottom Right bar"/>
 *          </a:hbox>
 *      </a:vbox>
 *      <a:bar width="100" caption="Right bar"/>
 *  </a:hbox>
 * </code>
 * Remarks:
 * The layouting engine of Ajax.org Platform lets you store layouts and set them
 * dynamically. It's very easy to make a layout manager this way. For more 
 * information see {@link object.layout}
 * @addnode elements
 * @constructor
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.9
 */
apf.hbox = function(struct, tagName){
    this.$init(tagName || "hbox", apf.NODE_VISIBLE, struct);
};
apf.vbox = function(struct, tagName){
    this.$init(tagName || "vbox", apf.NODE_VISIBLE, struct);
};

(function(){
    this.$focussable     = false;
    
    /**** DOM Hooks ****/
    //@todo rewrite these
    this.addEventListener("AMLRemoveChild", function(amlNode, doOnlyAdmin){
        if (doOnlyAdmin)
            return;
        
        if (amlNode.disableAlignment)
            amlNode.disableAlignment();
        
        
        if (amlNode.enableAnchoring)
            amlNode.enableAnchoring();
        
    });
    
    this.addEventListener("AMLInsert",function(amlNode, bNode, withinParent){
        if (withinParent)
            return;
        
        if (!amlNode.hasFeature(apf.__ALIGNMENT__)) {
            amlNode.implement(apf.Alignment);
            if (amlNode.hasFeature(apf.__ANCHORING__))
                amlNode.$disableAnchoring();
        }
        
        amlNode.enableAlignment();
    });
    
    this.addEventListener("AMLReparent", 
        function(bNode, pNode, withinParent, oldParentHtmlNode){
            if (withinParent)
                return;
            
            if (oldParentHtmlNode == this.$ext) {
                pNode.$int.insertBefofore(
                    document.createElement("div"),
                    bNode && bNode.$ext || null
                );
            }
        });
    
    this.addEventListener("AMLRemove", function(doOnlyAdmin){
        if (!doOnlyAdmin)
        
        if (this.$pHtmlNode != this.$ext && this.$ext.parentNode)
            this.$ext.parentNode.removeChild(this.$ext);
    });

    /**** Init ****/
    
    this.$draw = function(){
        this.$isParentOfChain = true;/*!this.parentNode.localName 
          || "vbox|hbox".indexOf(this.parentNode.localName) == -1;*/

        if (this.$isParentOfChain) {
            this.$int = 
            this.$ext = this.$pHtmlNode.appendChild(document.createElement("div"));
            this.$int.style.minHeight = "1px";
            this.$int.style.marginTop = "-1px";
           
            if ("absolute|relative".indexOf(apf.getStyle(this.$int, "position")) == -1)
                this.$int.style.position = "relative";
            this.$int.style.overflow = "visible";
            
            //@todo shouldn't this be generic?
            //this.implement(apf.Anchoring); /** @inherits apf.Anchoring */
            //this.enableAnchoring();
        }
    }
    
    this.$loadAml = function(x){
        var l     = apf.layout.get(this.$int || this.$pHtmlNode, apf.getBox(this.margin || "")),
            aData = apf.layout.parseXml(this, l, null, true);

        if (this.$isParentOfChain) {
            this.pData = aData;
            l.root = this.pData;

            if (this.childNodes.length)
                apf.layout.queue(this.$int || this.$pHtmlNode, null, l.root);

            
            if (!this.$int.offsetHeight && !this.$int.offsetWidth) {
                var _self = this;
                function propChange(name, old, value){
                    if (apf.isTrue(value) && (_self.$ext.offsetHeight || _self.$ext.offsetWidth)) {
                        //apf.layout.forceResize(_self.$int);
                        apf.layout.queue(_self.$int, null, l.root);

                        var p = _self;
                        while (p) {
                            if (p.unwatch)
                                p.unwatch("visible", propChange);
                            p = p.parentNode;
                        }
                    }
                };
                
                this.watch("visible", propChange);
                
                var p = this.parentNode;
                while(p) {
                    if (p.watch)
                        p.watch("visible", propChange);
                    p = p.parentNode;
                }
                
                return;
            }
            
        }
        else {
            var pData = this.parentNode.aData || this.parentNode.pData;
            this.aData = aData;
            this.aData.stackId = pData.children.push(this.aData) - 1;
            this.aData.parent  = pData;
        }
    };
}).call(apf.vbox.prototype = new apf.GuiElement());

apf.hbox.prototype = apf.vbox.prototype;

apf.aml.setElement("hbox", apf.hbox);
apf.aml.setElement("vbox", apf.vbox);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/browser.js)SIZE(5633)TIME(1259091146)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Element displaying the rendered contents of an URL.
 *
 * @constructor
 * @addnode elements:browser
 * @define browser
 *
 * @inherits apf.XForms
 * @inherits apf.StandardBinding
 * @inherits apf.DataAction
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @binding value  Determines the way the value for the element is retrieved 
 * from the bound data.
 * Example (BROKEN):
 * Sets the url based on data loaded into this component.
 * <code>
 *  <a:model id="mdlBrowser">
 *      <data url="http://www.w3c.org"></data>
 *  </a:model>
 *  <a:browser 
 *    model  = "mdlBrowser" 
 *    width  = "800" 
 *    height = "600" 
 *    value  = "[@url]" />
 * </code>
 * Example:
 * A shorter way to write this is:
 * <code>
 *  <a:model id="mdlBrowser">
 *      <data url="http://www.w3c.org"></data>
 *  </a:model>
 *  <a:browser 
 *    width  = "800" 
 *    height = "600" 
 *    value  = "[mdlBrowser::@url]" />
 * </code>
 */
apf.browser = function(struct, tagName){
    this.$init(tagName || "browser", apf.NODE_VISIBLE, struct);
};
(function(){
    this.implement(
        
        
        apf.DataAction
        
        
        ,apf.StandardBinding
        
    );

    /**
     * @attribute {String} src   the url to be displayed in this element
     * @attribute {String} value alias for the 'url' attribute
     */
    this.$supportedProperties.push("value", "src");
    this.$propHandlers["src"]   =
    this.$propHandlers["value"] = function(value, force){
        try {
            this.$int.src = value || "about:blank";
        }
        catch(e) {
            this.$int.src = "about:blank";
        }
    };

    this.getValue = function() {
        return this.value || this.src;
    };

    /**
     * Retrieves the current url that is displayed.
     */
    this.getURL = function(){
        return this.$int.src;
    };

    /**
     * Browses to the previous page
     */
    this.back = function(){
        this.$int.contentWindow.history.back();
    };

    /**
     * Browses to the next page
     */
    this.forward = function(){
        this.$int.contentWindow.history.forward();
    };

    /**
     * Reload the current page
     */
    this.reload = function(){
        this.$int.src = this.$int.src;
    };

    /**
     * Print the currently displayed page
     */
    this.print = function(){
        this.$int.contentWindow.print();
    };

    /**
     * Execute a string of javascript on the page. This is subject to browser
     * security and will most likely only work when the browsed page is loaded
     * from the same domain.
     * @param {String}  str     javascript string to be executed.
     * @param {Boolean} noError whether the execution can throw an exception. Defaults to false.
     */
    this.runCode = function(str, noError){
        if (noError) {
            try {
                this.$int.contentWindow.eval(str);
            } catch(e) {}
        }
        else {
            this.$int.contentWindow.eval(str);
        }
    };

    this.$draw = function(parentNode){
        if (!parentNode)
            parentNode = this.$pHtmlNode;

        //Build Main Skin
        if (apf.cannotSizeIframe) {
            //parentNode.appendChild(document.createElement("iframe"));//
            this.$ext = parentNode.appendChild(document.createElement("DIV"))
                .appendChild(document.createElement("<iframe frameborder='0'></iframe>")).parentNode;
            this.$ext.style.width  = "100px";
            this.$ext.style.height = "100px";
            this.$int = this.$ext.firstChild;
            //this.$int = this.$ext;
            this.$int.style.width  = "100%";
            this.$int.style.height = "100%";
            this.$int.frameBorder = 0;
        }
        else {
            this.$ext = parentNode.appendChild(document.createElement("iframe"));
            this.$ext.style.width  = "100px";
            this.$ext.style.height = "100px";
            this.$int              = this.$ext;
            //this.$ext.style.border = "2px inset white";
        }

        //this.$int = this.$ext.contentWindow.document.body;
        this.$ext.host = this;
        //this.$int.host = this;
    };
}).call(apf.browser.prototype = new apf.GuiElement());

apf.aml.setElement("browser", apf.browser);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/accordion.js)SIZE(22288)TIME(1262085721)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * The Accordion is component that allows you to provide multiple vertical or 
 * horizontal panes. You can display them one or more at a time. Each bar has 
 * a title and its content. Content can contain other components.
 * 
 * @define accordion
 * 
 * @attribute {String} animtype   animation effect for slide in and slide out, default is "normal normal"
 * Possible values:
 *     normal    Linear tweening method
 *     easein    Ease-in tweening method
 *     easeout   Ease-out tweening method
 *     none      animation is disabled
 *        
 * @attribute {Number} animdelay   the time between each step of animation, default is 10 ms.
 * 
 * @attribute {Boolean} multiexpand   allows expanding one or more bars, default is true
 * Possible values:
 *     true    one or more bars can be expanded at a time
 *     false   only one bar can be expanded at a time
 * 
 * @attribute {String} expand   sets event which activate bar, default is click
 * Possible values:
 *     click   bar will be expanded when user click on it
 *     hover   bar will be expanded when user hover over it with mouse
 * 
 * @attribute {Boolean} startexpanded   expands all bars on load, default is false
 * Possible values:
 *     true    expands all bars
 *     false   only chosen bars will be expanded
 * @see bar expanded="true" 
 * 
 * @inherits apf.Presentation
 * 
 * Example:
 * Horizontal acccordion component with 5 bars. First and third bar will be 
 * expanded on load.
 * 
 * <code>
 *  <a:accordion
 *    width           = "400"
 *    height          = "200"
 *    left            = "200"
 *    top             = "20"
 *    multiexpand     = "true"
 *    expand          = "click"
 *    startexpanded   = "false"
 *    skin            = "accordion_apf_hor">
 *      <a:bar title="Iron Maiden" expanded="true" icon="icon.png">
 *          <b>Discography</b>
 *          <ul>
 *              <li>Piece Of Mind</li>
 *              <li>X Factor</li>
 *          </ul>
 *      </a:bar>
 *      <a:bar title="Megadeth" icon="images/accordion_icon.png">
 *          <b>Discography</b>
 *          <ul>
 *              <li>Youthanasia</li>
 *          </ul>
 *      </a:bar>
 *      <a:bar title="Judas Priest" expanded="true" icon="icon.png">
 *          <b>Discography</b>
 *          <ul>
 *              <li>Painkiller</li>
 *          </ul>
 *      </a:bar>
 *      <a:bar title="Metallica" icon="images/accordion_icon.png">
 *          <b>Discography</b>
 *          <ul>
 *              <li>Load</li>
 *          </ul>
 *      </a:bar>
 *      <a:bar title="Behemoth" icon="images/accordion_icon.png">
 *          <b>Discography</b>
 *          <ul>
 *              <li>Satanica</li>
 *          </ul>
 *      </a:bar>
 *  </a:accordion>
 * </code>
 * 
 * Example:
 * Vertical accordion component with 2 bars. Only one bar can be expanded
 * at a time. Both bars conatins APF components.
 * 
 * <code>
 *  <a:accordion
 *    width           = "400"
 *    left            = "200"
 *    top             = "500"
 *    animtype        = "normal normal"
 *    animdelay       = "10"
 *    multiexpand     = "false"
 *    expand          = "click"
 *    startexpanded   = "false"
 *    skin            = "accordion_vertical">
 *      <a:bar title="Components" expanded="true" icon="icon.png">
 *          <a:label>Choose Your favourite component</a:label><br />
 *          <a:dropdown>
 *              <a:item>Bar</a:item>
 *              <a:item>Notifier</a:item>
 *              <a:item>Tree</a:item>
 *          </a:dropdown><br />
 *      </a:bar>
 *      <a:bar title="Blog" icon="images/accordion_icon.png">
 *          <a:label>Choose Your favourite blog</a:label><br />
 *          <a:radiobutton group="g1">overthinkings</a:radiobutton> 
 *          <a:radiobutton group="g1">Rik on code </a:radiobutton> 
 *          <a:radiobutton group="g1">Arnolds wor(l)ds</a:radiobutton>
 *          <a:radiobutton group="g1">MikedeBoer.nl </a:radiobutton>
 *          <a:radiobutton group="g1">All about Javascript </a:radiobutton>
 *          <a:radiobutton group="g1">observing the dos</a:radiobutton><br />
 *          <a:button>Vote</a:button><br />
 *      </a:bar>
 *  </a:accordion>
 * </code>
 *
 * @author      Lukasz Lipinski
 * @version     %I%, %G%
 * @since       2.2
 */
apf.accordion = function(struct, tagName){
    this.$init(tagName || "accordion", apf.NODE_VISIBLE, struct);
    
    this.$animtype1      = apf.tween.NORMAL;
    this.$animtype2      = apf.tween.NORMAL;
    this.animdelay       = 10;
    this.hoverdelay      = 500;
    this.multiexpand     = true;
    this.expand          = "click";
    this.startexpanded   = true;

    this.$animStep = {};
    this.$animStep[apf.tween.NORMAL]  = 5;
    this.$animStep[apf.tween.EASEIN]  = 10;
    this.$animStep[apf.tween.EASEOUT] = 10;
    
    /**
     * Keeps all bars
     * 
     * bars[oTitle.id] = {
     *   amlNode   : amlNode,
     *   htmlNode  : htmlNode,
     *   opened    : opened,
     *   htmlTitle : htmlTitle,
     *   htmlBody  : htmlBody,
     *   htmlIcon  : htmlIcon
     * };
     */
    this.bars = {};

    this.hoverTimer = null;
    
    /**
     * when "multiexpand" is false, only one bar with expanded="true"
     * can be opened
     */
    this.startExpanded = 0;
    
    this.$focussable     = false;
    
    this.animType = {
        "normal"  : apf.tween.NORMAL,
        "easein"  : apf.tween.EASEIN,
        "easeout" : apf.tween.EASEOUT,
        "none"    : "none"
    }
    
    this.lastOpened = [];
    
    /**
     * Only one opening action can be run in time
     */
    this.inprogress = false;
};

(function() {
    this.$booleanProperties["multiexpand"]  = true;
    this.$booleanProperties["startexpanded"] = true;
    
    this.$supportedProperties.push("animtype", "animdelay", "multiexpand",
        "expand", "startexpanded");
    
    /**** DOM Hooks ****/
    this.addEventListener("AMLRemoveChild", function(amlNode, doOnlyAdmin) {
        if (doOnlyAdmin)
            return;
    });
    
    this.addEventListener("AMLInsert",this.insertChild = function (amlNode, beforeNode, withinParent) {
        if (amlNode.tagName != "bar")
            return;

        amlNode.$propHandlers["icon"] = function(value) {
            var oIcon = this.$getLayoutNode("bar", "icon", this.$ext);
            if (!oIcon) return;

            if (oIcon.tagName == "img") 
                oIcon.setAttribute("src", value ? this.iconPath + value : "");
            else {
                oIcon.style.backgroundImage = value 
                    ? "url(" + this.iconPath + value + ")"
                    : "";
            }
        }
    });
    
    this.$propHandlers["animtype"] = function(value) {
        value = value.split(" ");
        
        if (value[0])
            this.$animtype1 = this.animType[value[0]];
        if (value[1])
            this.$animtype2 = this.animType[value[1]];
    };

    this.$propHandlers["animdelay"] = function(value) {
        this.animdelay = parseInt(value);
    };
    
    /**
     * Toggles the visibility of the container with content. Opens
     * or closes container using a slide effect. 
     * 
     * @param {Mixed} id   id of title
     */
    this.slideToggle = function(id) {
        if (!this.bars[id])
            return;

        if (this.bars[id].opened)
            this.slideUp(id);
        else
            this.slideDown(id);
    };

    /**
     * Shows the container with content using a slide effect.
     * 
     * @param {Mixed} id   id of title
     */
    this.slideDown = function(id) {
        var id2 = null;

        if (!this.bars[id] || this.inprogress) {
            return;
        }
        
        this.inprogress = true;

        var bar = this.bars[id];
        
        bar.htmlBody.style.display = "block";
        
        if (!this.multiexpand && this.lastOpened.length > 0) {
            var _temp = this.lastOpened.shift();
            if (_temp !== id)
                id2 = _temp;
        }
        
        this.lastOpened.push(id);

        this.$setStyleClass(bar.htmlNode, "active");

        if (this.$dir == "vertical") {
            //i don't know why scrollHeight in IE is equal 1
            if (bar.htmlBody.scrollHeight < 2) {
                var timer;
                clearInterval(timer);
                timer = setInterval(function() {
                    if (bar.htmlBody.scrollHeight > 0) {
                        _self.slideDown(bar.htmlTitle.id);
                        clearInterval(timer);
                    }
                }, 100);
            }
            
            bar.htmlBody.style.height = "1px";
        }

        if (this.$animtype1 == "none") {
            if (id2) {
                var bar2 = this.bars[id2];
                this.$setStyleClass(bar2.htmlNode, "", ["active"]);
                bar2.htmlBody.style.display = "none";
                
                if (this.$dir == "horizontal") {
                    bar2.htmlBody.style.width = "auto";
                }
            }
            
            if (this.$dir == "horizontal") {
                bar.htmlBody.style.width = "auto";
            }
            
            this.bars[id].opened = true;
            this.inprogress = false;
        }
        else {
            var _self = this;
            if (id2) {
                var bar2 = this.bars[id2];
                this.$setStyleClass(bar2.htmlNode, "", ["active"]);
                
                apf.tween.multi(bar.htmlBody, {
                    steps    : this.$animStep[this.$animtype1],
                    anim     : this.$animtype1,
                    interval : this.animdelay,
                    tweens : [{
                       type : this.$dir == "vertical" ? "scrollheight" : "scrollwidth",
                       from : 0,
                       to   : this.$dir == "vertical"
                                  ? bar.htmlBody.scrollHeight
                                  : bar.htmlBody.scrollWidth
                    },
                    {
                        type  : this.$dir == "vertical" ? "scrollheight" : "scrollwidth",
                        from  : this.$dir == "vertical"
                                   ? bar2.htmlBody.scrollHeight
                                   : bar2.htmlBody.scrollWidth,
                        to    : 0,
                        oHtml : bar2.htmlBody
                    }],
                    onfinish : function() {
                        //Slide down
                        _self.$setStyleClass(bar.htmlNode, "active", [""]);
        
                        if (_self.$dir == "horizontal") {
                            bar.htmlBody.style.width = "auto";
                        }
        
                        _self.bars[id].opened = true;
                        
                        //Slide up
                        _self.$setStyleClass(bar2.htmlNode, "", ["active"]);
                        bar2.htmlBody.style.display = "none";
        
                        if (_self.$dir == "horizontal") {
                            bar2.htmlBody.style.width = "auto";
                        }
        
                        _self.bars[id2].opened = false;
                        _self.inprogress = false;
                    }
                });
            }
            else {
                //var startSH = bar.htmlBody.scrollHeight;
                apf.tween.single(bar.htmlBody, {
                    steps    : this.$animStep[this.$animtype1],
                    type     : this.$dir == "vertical" ? "scrollheight" : "scrollwidth",
                    from     : 0,
                    to       : this.$dir == "vertical"
                                   ? bar.htmlBody.scrollHeight
                                   : bar.htmlBody.scrollWidth,
                    anim     : this.$animtype1,
                    interval : this.animdelay,
                    onfinish : function() {
                        _self.$setStyleClass(bar.htmlNode, "active", [""]);

                        //if (startSH !== bar.htmlBody.scrollHeight && _self.$dir == "vertical") {
                            //_self.slideDown(id);
                        //}

                        if (_self.$dir == "horizontal") {
                            bar.htmlBody.style.width = "auto";
                        }

                        _self.bars[id].opened = true;
                        
                        _self.inprogress = false;
                    }
                });
            }
        }
    };

    /**
     * Hides the container with content using a slide effect.
     * 
     * @param {Mixed} id   id of title
     */
    this.slideUp = function(id) {
        if (!this.bars[id] || this.inprogress) {
            return;
        }
        
        this.inprogress = true;

        var bar = this.bars[id];

        apf.setStyleClass(bar.htmlNode, "", ["active"]);

        if (this.$animtype2 == "none") {
            bar.htmlBody.style.display = "none";
            
            if (this.$dir == "horizontal")
                bar.htmlBody.style.width = "auto";
    
            this.bars[id].opened = false;
            this.inprogress = false;
        }
        else {
            var _self = this;
            apf.tween.single(bar.htmlBody, {
                steps    : this.$animStep[this.$animtype2],
                type     : this.$dir == "vertical" 
                               ? "scrollheight" 
                               : "scrollwidth",
                from     : this.$dir == "vertical"
                               ? bar.htmlBody.scrollHeight
                               : bar.htmlBody.scrollWidth,
                to       : 0,
                anim     : this.$animtype2,
                interval : this.animdelay,
                onfinish : function() {
                    _self.$setStyleClass(bar.htmlNode, "", ["active"]);
                    bar.htmlBody.style.display = "none";
    
                    if (_self.$dir == "horizontal")
                        bar.htmlBody.style.width = "auto";
    
                    _self.bars[id].opened = false;
                    _self.inprogress = false;
                }
            });
        }

        return false;
    };
    
    /**
     * Returns the id of title
     * 
     * @param {Number} number   number of title, 1 and more for counting 
     *                          from left to right for horizontal mode, and 
     *                          from top to bottom for vertical mode
     */
    this.$getbarIdByNumber = function(number) {
        var counter = 1;
        
        for (var id in this.bars) {
            if (counter++ == number)
                return id;
        }

        return null;
    };

    /**** Init ****/

    this.$draw = function() {
        //Build Main Skin
        this.$ext = this.$getExternal("main");
        this.$int = this.$getLayoutNode("main", "container", this.$ext);

        this.$dir = this.$getOption("main", "direction") || "vertical";
        
        var nodes = this.childNodes;
        var len = nodes.length;
        var node;

        var _self = this;
        
        var xmlBars = 0;
        var htmlBars = 0;
        
        var barsToOpen = [];

        for (var i = 0; i < len; i++) {
            node = nodes[i];

            if ((node.tagName || "").indexOf("a:bar") > -1 && !node.$amlLoaded) {
                xmlBars++;
                node.addEventListener("DOMNodeInsertedIntoDocument", function(e) {
                    htmlBars++;
                    
                    var htmlNode = _self.$ext.lastChild;
                    var amlNode = e.currentTarget;
                    var htmlCaption;
                    var htmlTitle;
                    var htmlIcon;
                    var htmlBody;

                    //is the bar expanded ?
                    var opened = (amlNode.getAttribute("expanded") 
                        ? (amlNode.getAttribute("expanded") == "true"
                        ? true : false) : false); 

                    //Looking for title and body nodes
                    var nodes = htmlNode.childNodes;
                    var l1 = nodes.length;
                    
                    for (var i = 0; i < l1; i++) {
                        if((nodes[i].className || "").indexOf("body") > -1) {
                            htmlBody = nodes[i];
                        }
                        if((nodes[i].className || "").indexOf("title") > -1) {
                            htmlTitle = nodes[i];
                        }
                        
                        //Looking for icon node
                        var subnodes = nodes[i].childNodes;
                        var l2 = subnodes.length;
                        for (var j = 0; j < l2; j++) {
                            if ((subnodes[j].className || "").indexOf("icon") > -1) {
                                htmlIcon = subnodes[j];
                            }
                            if (((subnodes[j].tagName || "").toLowerCase()).indexOf("span") > -1) {
                                htmlCaption = subnodes[j];
                            }
                        }
                    }

                    if (!htmlTitle && !htmlBody) {
                        return;
                    }
                    apf.setUniqueHtmlId(htmlTitle);
                    apf.setUniqueHtmlId(htmlBody);

                    //Set caption
                    var caption = amlNode.getAttribute("title");
                    if (caption) {
                        htmlCaption.innerHTML = caption;
                    }
                    
                    //set icon
                    var icon = amlNode.getAttribute("icon");
                    if (icon) {
                        htmlIcon.style.backgroundImage = "url(" + this.iconPath + icon + ")";
                    }

                    if (_self.expand == "click") {
                        htmlTitle.onmousedown = function(e) {
                            _self.slideToggle(this.id);
                        };
                        
                        //oIcon.onmousedown = function(e) {
                        //    _self.slideToggle(this.parentNode.id);
                        //};
                    }
                    else if (this.expand == "hover") {
                        htmlTitle.onmouseover = function(e) {
                            (e || event).cancelBubble = true;
                            var id = this.id;
                            
                            clearInterval(_self.hoverTimer);
                            _self.hoverTimer = setInterval(function() {
                                _self.slideToggle(id);
                                clearInterval(_self.hoverTimer);
                            }, _self.hoverdelay);
                        };
                        htmlIcon.onmouseover = function(e) {
                            (e || event).cancelBubble = true;
                            
                            var id = (e.srcElement || e.target).parentNode.id;
    
                            clearInterval(_self.hoverTimer);
                            _self.hoverTimer = setInterval(function() {
                                _self.slideToggle(id);
                                clearInterval(_self.hoverTimer);
                            }, _self.hoverdelay);
                           
                        };
                    }
                    
                    //This info must be pushed here, because i could be used in next condition
                    _self.bars[htmlTitle.id] = {
                        amlNode   : amlNode,
                        htmlNode  : htmlNode,
                        opened    : false,
                        htmlTitle : htmlTitle,
                        htmlBody  : htmlBody,
                        htmlIcon  : htmlIcon
                    };

                    if ((opened || _self.startexpanded) && (_self.multiexpand || _self.startExpanded == 0)) {
                        //_self.slideDown(htmlTitle.id);
                        barsToOpen.push(htmlTitle.id);
                        _self.startExpanded++;
                    }
                    
                    if (htmlBars == xmlBars) {
                        //this.$setStyleClass(oBody, "last");
        
                        _self.oEnding = _self.$getExternal("ending");
                        var oEnding = _self.$getLayoutNode("ending", "container", _self.oEnding);
                
                        _self.$int.appendChild(oEnding);
                    }
                });
            }
        }
        
        var openBarTimer = null;
        clearInterval(openBarTimer);
        openBarTimer = setInterval(function() {
            if (htmlBars == xmlBars) {
                for (var i = 0; i < barsToOpen.length; i++) {
                    var id = barsToOpen.pop();
                    _self.slideDown(id);
                }
                clearInterval(openBarTimer);
            }
        }, 50);
    };

    this.$loadAml = function(x) {

    };

    this.$destroy = function() {
        
    };
}).call(apf.accordion.prototype = new apf.Presentation());

apf.aml.setElement("accordion", apf.accordion);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/event.js)SIZE(2115)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Displays a popup element with a message with optionally an icon at the
 * position specified by the position attribute. After the timeout has passed
 * the popup will dissapear automatically. When the mouse hovers over the popup
 * it doesn't dissapear.
 *
 * @event click Fires when the user clicks on the representation of this event.
 */
apf.event = function(struct, tagName){
    this.$init(tagName || "event", apf.NODE_HIDDEN, struct);
};

(function() {
    this.$hasInitedWhen = false;

    this.$booleanProperties["repeat"] = true;
    this.$supportedProperties.push("when", "message", "icon", "repeat");

    this.$propHandlers["when"] = function(value) {
        if (this.$hasInitedWhen && value && this.parentNode && this.parentNode.popup) {
            var _self = this;
            $setTimeout(function() {
                _self.parentNode.popup(_self.message, _self.icon, _self);
            });
        }
        this.$hasInitedWhen = true;

        if (this.repeat)
            delete this.when;
    };

    this.$loadAml = function(x) {};
}).call(apf.event.prototype = new apf.AmlElement());

apf.aml.setElement("event", apf.event);


/*FILEHEAD(/var/lib/platform/source/trunk/elements/source.js)SIZE(1592)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Element 
 *
 * @constructor
 *
 * @define source
 * @addnode audio, video
 *
 * @author      Mike de Boer (mike AT javeline DOT com)
 * @version     %I%, %G%
 * @since       3.0
 */
apf.source = function(struct, tagName){
    this.$init(tagName || "source", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$supportedProperties.push("src", "type");

    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (this.parentNode.$addSource)
            this.parentNode.$addSource(this);
    });
}).call(apf.source.prototype = new apf.AmlElement());

apf.aml.setElement("source", apf.source);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/flashplayer.js)SIZE(4229)TIME(1264896063)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element displaying the contents of a .swf (adobe flash) file.
 *
 * @constructor
 * @define flashplayer
 * @allowchild {smartbinding}
 * @addnode elements
 *
 * @inherits apf.BaseSimple
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.9
 *
 * @binding value  Determines the way the value for the element is retrieved 
 * from the bound data.
 * Example:
 * Sets the flash source text based on data loaded into this component.
 * <code>
 *  <a:flashplayer>
 *      <a:bindings>
 *          <a:value select="@src" />
 *      </a:bindings>
 *  </a:flashplayer>
 * </code>
 * Example:
 * A shorter way to write this is:
 * <code>
 *  <a:flashplayer value="[@src]" />
 * </code>
 */
apf.flashplayer = function(struct, tagName){
    this.$init(tagName || "flashplayer", apf.NODE_VISIBLE, struct);
};

(function(){
    this.implement(
        
        apf.DataAction,
        
        apf.StandardBinding
    );

    /**** Public methods ****/
    
    
    
    /**
     * @ref global#setValue
     */
    this.setValue = function(value){
        this.setProperty("value", value, false, true);
    };
    
    
    
    /**** Properties and attributes ****/
    
    this.$supportedProperties.push("value");
    this.$propHandlers["value"] = function(value){
        this.setSource(value);
    };
    
    /**** Init ****/
    
    this.$draw = function(){
        //Build Main Skin
        this.$ext = 
        this.$int = this.$pHtmlNode.appendChild(document.createElement("div"));
        this.$ext.onclick = function(){this.host.dispatchEvent("click");}
        
        var src = this.getAttribute("src") || "";
        this.$ext.insertAdjacentHTML("beforeend",
            '<object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" \
              codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,0,0" \
              width="100%" \
              height="100%" \
              align="middle">\
                <param name="allowScriptAccess" value="sameDomain" />\
                <param name="allowFullScreen" value="false" />\
                <param name="movie" value="' + src + '" />\
                <param name="play" value="true" />\
                <param name="menu" value="false" />\
                <param name="quality" value="high" />\
                <param name="wmode" value="transparent" />\
                <param name="bgcolor" value="#ffffff" />\
                <embed src="' + src + '" play="true" menu="false" \
                  quality="high" wmode="transparent" bgcolor="#ffffff" width="100%" \
                  height="100%" align="middle" allowScriptAccess="sameDomain" \
                  allowFullScreen="false" type="application/x-shockwave-flash" \
                  pluginspage="http://www.macromedia.com/go/getflashplayer" />\
            </object>')
    };
    
    this.$loadAml = function(x){
    };
}).call(apf.flashplayer.prototype = new apf.GuiElement());

apf.aml.setElement("flashplayer", apf.flashplayer);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/bindingseriesrule.js)SIZE(1944)TIME(1257329183)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @attribute {String} formula 
 * @attribute {Number} length
 * @attribute {String} delimiter
 * @attribute {String} split
 * @attribute {String} css
 */
apf.BindingSeriesRule = function(struct, tagName){
    this.$init(tagName || "series", apf.NODE_HIDDEN, struct);
};

(function(){
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        formula : 1
    }, this.$attrExcludePropBind);

    this.$propHandlers["formula"] = function(value, prop){
        delete this["c" + prop];
    }
    
    /*this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        //Find parent that this rule works on
        var pNode = this;
        while (pNode && pNode.$bindingRule) 
            pNode = pNode.parentNode;
       
        if (!pNode)
            return;
    });*/
}).call(apf.BindingSeriesRule.prototype = new apf.BindingRule());

apf.aml.setElement("series", apf.BindingSeriesRule);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/defaults.js)SIZE(1802)TIME(1257329183)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.defaults = function(struct, tagName){
    this.$init(tagName || "services", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$parsePrio = "002";
    
    this.$propHandlers["for"] = function(value){
        if (this.$lastFor)
            apf.nameserver.remove("defaults_" + this.$lastFor, this);

        apf.nameserver.add("defaults_" + value, this);
        this.$lastFor = value;
    }
    
    //@todo apf3.x how should this work?
    this.addEventListener("DOMNodeRemovedFromDocument", function(e){
        apf.nameserver.remove("defaults_" + this.$lastFor, this);
    });
}).call(apf.defaults.prototype = new apf.AmlElement());

apf.aml.setElement("defaults", apf.defaults);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/iconmap.js)SIZE(3248)TIME(1259091146)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * element that provides a means to get icons from a
 * single image containing many icons.
 * Example:
 * <code>
 *  <a:iconmap 
 *    id     = "tbicons" 
 *    src    = "toolbar.icons.gif"
 *    type   = "horizontal" 
 *    size   = "20" 
 *    offset = "2,2" />
 *  <a:menu id="menu1">
 *      <a:item icon="tbicons:1">Tutorials</a:item>
 *      <a:item icon="tbicons:5">Contact</a:item>
 *  </a:menu>
 *  <a:toolbar>
 *      <a:menubar>
 *          <a:button submenu="menu1">File</a:button>
 *      </a:menubar>
 *  </a:toolbar>
 * </code>
 * @attribute {String} src    the location of the image.
 * @attribute {String} type   the spatial distribution of the icons within the image.
 *   Possible values:
 *   horizontal the icons are horizontally tiled.
 *   vertically the icons are vertically tiled.
 * @attribute {String} size   the width and height in pixels of an icon. Use this for square icons.
 * @attribute {String} width  the width of an icon in pixels.
 * @attribute {String} height the height of an icon in pixels.
 * @attribute {String} offset the distance from the calculated grid point that has to be added. This value consists of two numbers seperated by a comma. Defaults to 0,0.
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.iconmap = function(){
    this.$init("iconmap", apf.NODE_HIDDEN);
};

(function(){
    this.$parsePrio = "050";
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        
        if (!this.id) {
            throw new Error(apf.formatErrorString(0, this,
                "Creating icon map",
                "Could not create iconmap. Missing id attribute", this.$aml));
        }
        

        apf.skins.addIconMap({
            name   : this.id,
            src    : this.src,
            type   : this.type,
            size   : parseInt(this.size),
            width  : parseInt(this.width),
            height : parseInt(this.height),
            offset : (this.offset || "0,0").splitSafe(",")
        });
    });
}).call(apf.iconmap.prototype = new apf.AmlElement());

apf.aml.setElement("iconmap", apf.iconmap);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/progressbar.js)SIZE(8589)TIME(1259091146)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Element graphically representing a percentage value which increases
 * automatically with time. This element is most often used to show the progress
 * of a process. The progress can be either indicative or exact.
 * Example:
 * This example shows a progress bar that is only visible when an application is
 * synchronizing it's offline changes. When in this process it shows the exact
 * progress of the sync process.
 * <code>
 *  <a:progressbar
 *    value   = "{apf.offline.progress}"
 *    visible = "{apf.offline.syncing}" />
 *  </code>
 *
 * @constructor
 * @allowchild {smartbinding}
 * @addnode elements:progressbar
 *
 * @inherits apf.StandardBinding
 * @inherits apf.DataAction
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.9
 *
 * @binding value  Determines the way the value for the element is retrieved 
 * from the bound data.
 * Example:
 * Sets the progress position based on data loaded into this component.
 * <code>
 *  <a:model>
 *      <data progress="50"></data>
 *  </a:model>
 *  <a:progressbar min="0" max="100" value="[@progress]" />
 * </code>
 * Example:
 * A shorter way to write this is:
 * <code>
 *  <a:model id="mdlProgress">
 *      <data progress="50"></data>
 *  </a:model>
 *  <a:progressbar value="[mdlProgress::@progress]" />
 * </code>
 */
apf.progress    = function(struct, tagName){
    this.$init(tagName || "progress", apf.NODE_VISIBLE, struct);
};
apf.progressbar = function(struct, tagName){
    this.$init(tagName || "progressbar", apf.NODE_VISIBLE, struct);
};

(function(){
    
    this.implement(apf.DataAction);
    

    this.$focussable = false; // This object can get the focus

    /**** Properties and Attributes ****/

    this.value = 0;
    this.min   = 0;
    this.max   = 100;
    
    this.$running = false;
    this.$timer;

    /**
     * @attribute {Boolean} autostart whether the progressbar starts automatically.
     * @attribute {Boolean} autohide  whether the progressbar hides when the progress is at 100%. Setting this to true will hide the progressbar at start when autostart is not set to true.
     */
    this.$booleanProperties["autostart"] = true;
    this.$booleanProperties["autohide"] = true;

    this.$supportedProperties.push("value", "min", "max", "autostart", "autohide");
    
    /**
     * @attribute {String} value the position of the progressbar stated between 
     * the min and max value.
     */
    this.$propHandlers["value"] = function(value){
        this.value = parseInt(value) || this.min;

        if (this.value >= this.max)
            apf.setStyleClass(this.$ext, this.$baseCSSname + "Complete", [this.$baseCSSname + "Running"]);
        else
            apf.setStyleClass(this.$ext, this.$baseCSSname + "Running", [this.$baseCSSname + "Complete"]);

        this.oSlider.style.width = (this.value * 100 / (this.max - this.min)) + "%"
        
        /*Math.max(0,
            Math.round((this.$ext.offsetWidth - 5)
            * (this.value / (this.max - this.min)))) + "px";*/

        this.oCaption.nodeValue =
            Math.round((this.value / (this.max - this.min)) * 100) + "%";
    };

    /**
     * @attribute {Number} min the minimum value the progressbar may have. This is
     * the value that the progressbar has when it's at its start position.
     */
    this.$propHandlers["min"] = function(value){
        this.min = parseFloat(value);
    }

    /**
     * @attribute {Number} max the maximum value the progressbar may have. This is
     * the value that the progressbar has when it's at its end position.
     */
    this.$propHandlers["max"] = function(value){
        this.max = parseFloat(value);
    }

    /**** Public Methods ****/

    

    /**
     * Sets the value of this element. This should be one of the values
     * specified in the values attribute.
     * @param {String} value the new value of this element
     */
    this.setValue = function(value){
        this.setProperty("value", value, false, true);
    };

    /**
     * Returns the current value of this element.
     * @return {String}
     */
    this.getValue = function(){
        return this.value;
    };
    
    

    /**
     * Resets the progress indicator.
     * @param {Boolean} restart whether a this.$timer should start with a new indicative progress indicator.
     */
    this.clear = function(){
        this.$clear();
    }

    this.$clear = function(restart, restart_time){
        clearInterval(this.$timer);
        this.setValue(this.min);
        //this.oSlider.style.display = "none";
        apf.setStyleClass(this.$ext, "", [this.$baseCSSname + "Running", this.$baseCSSname + "Complete"]);

        if (restart) {
            var _self = this;
            this.$timer = setInterval(function(){
                _self.start(restart_time);
            });
        }
        
        if (this.autohide)
            this.hide();
        
        this.$running = false;
    };

    /**
     * Starts the progress indicator.
     * @param {Number} start the time between each step in milliseconds.
     */
    this.start = function(time){
        if (this.autohide)
            this.show();

        clearInterval(this.$timer);
        
        //if (this.value == this.max)
            //this.setValue(this.min + (this.max - this.min) * 0.5);
        
        //this.oSlider.style.display = "block";
        var _self = this;
        this.$timer = setInterval(function(){
            if (_self.$amlDestroyed)
                clearInterval(_self.$timer);
            else
                _self.$step();
        }, time || 1000);
        this.$setStyleClass(this.$ext, this.$baseCSSname + "Running");
    };

    /**
     * Pauses the progress indicator.
     */
    this.pause = function(){
        clearInterval(this.$timer);
    };

    /**
     * Stops the progress indicator from moving.
     * @param {Boolean} restart whether a this.$timer should start with a new indicative progress indicator.
     */
    this.stop = function(restart, time, restart_time){
        clearInterval(this.$timer);
        this.setValue(this.max);
        
        var _self = this;
        this.$timer = setInterval(function(){
            _self.$clear(restart, (restart_time || 0));
        }, time || 500);
    };

    /**** Private methods ****/

    this.$step = function(){
        if (this.value == this.max) 
            return;
        
        this.setValue(this.value + 1);
    };

    /**** Init ****/

    this.$draw = function(clear, parentNode, Node, transform){
        //Build Main Skin
        this.$ext     = this.$getExternal();
        this.oSlider  = this.$getLayoutNode("main", "progress", this.$ext);
        this.oCaption = this.$getLayoutNode("main", "caption", this.$ext);
    };

    this.$loadAml = function(x){
        if (this.autostart)
           this.start();

        if (this.autohide)
            this.hide();
    };

}).call(apf.progressbar.prototype = new apf.StandardBinding());


apf.progress.prototype = apf.progressbar.prototype;

apf.aml.setElement("progress",    apf.progress);
apf.aml.setElement("progressbar", apf.progressbar);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/collection.js)SIZE(2299)TIME(1257329183)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Virtual element acting as a parent for a set of child elements 
 * but only draws it's children. It doesn't have any representation itself.
 *
 * @constructor
 * @allowchild {elements}, {anyaml}
 *
 * @define collection
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.collection = function(struct, tagName){
    this.$init(tagName || "collection", apf.NODE_VISIBLE, struct);
};

apf.docklet = function(struct, tagName){
    this.$init(tagName || "docklet", apf.NODE_VISIBLE, struct);
};

(function(){
    this.$focussable = false;
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (this.parentNode && this.parentNode.$int != this.$pHtmlNode)
            this.$pHtmlNode = this.parentNode.$int; //@todo apf3.0 change this in the mutation events

        //this.$ext = this.$pHtmlNode;
        this.$int = this.$pHtmlNode;
        
        this.$originalNodes = this.parentNode.$originalNodes;

        this.skinName = this.parentNode.skinName;
    });
}).call(apf.collection.prototype = new apf.AmlElement());

apf.docklet.prototype = apf.collection.prototype;

apf.aml.setElement("collection", apf.collection);
apf.aml.setElement("docklet", apf.docklet);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/chart.js)SIZE(9732)TIME(1259713310)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Element displays a chart.
 *
 * @classDescription This class creates a new chart
 * @return {Chart} Returns a new chart
 * @type {Chart}
 * @constructor
 * @allowchild {elements}, {anyaml}
 * @addnode elements:chart
 *
 * @author      Rik Arends
 * @version     %I%, %G%
 * @since       0.4
 */

apf.Chart     = function(struct, tagName){
    this.$init(tagName || "chart", apf.NODE_VISIBLE, struct);
};

apf.aml.setElement("chart", apf.Chart);
 
(function(){
     //var space    = { x:1000000, w:-2000000, y:1000000, h:-2000000};    
    this.$timer    = null;
    this.$animTimer = null;
	this.$doinit   = true;
	this.$doresize = false;
    this.drawtime = 10;
    this.anim = 0;
    this.a = 0;
    this.b = 0;
    this.c = 0;
    this.d = 0;
    this.$supportedProperties = ["anim","a","b","c","d"];
    
    this.$redraw = function(now,resize){
        if(resize)this.$doresize = true;
        if(now){
            if(this.$timer)window.clearTimeout(this.$timer);
            this.$timer = null
            this.$drawChart();
        }else{
			var _self = this;
            if(!this.$timer) this.$timer = window.setTimeout(function(){
                _self.$timer = null;
                _self.$drawChart();
            },this.drawtime);
        }
    }
	
    this.$drawChart = function(){
        if (!this.childNodes) //We're being destroyed
            return;

        if (!this.$ext.offsetHeight && (apf.isIE || !this.$ext.offsetWidth)) //We're not visible, so let's not bother
            return;
        
		// check if we need to initialize or resize
		if(this.$doinit){
			this.$doinit = false;
			this.$doresize = false;
            this.$copyPos();
			apf.draw.initRoot(this);
		}else if (this.$doresize){
            this.$copyPos();
            apf.draw.resizeRoot(this);
		}
        for(var n, i = 0;i<this.childNodes.length;i++){
            if((n=this.childNodes[i]).$drawAxis){
				n.$drawAxis(this.$doresize);
			}
        }
		this.$doresize = false;
    }

    this.$copyPos = function(t, m){
        //@todo apf3.x @rik the height is resetted to 0 here. I don't know why.
        
		this.left = 0, this.top = 0; 
        var w,h,
            rw = this.width  != (w=this.$ext.offsetWidth),
            rh = this.height != (h=this.$ext.offsetHeight);
        //this.width  = w,this.height = h; //@todo @rik commented out for now
        if(t){
            if(m){
                t.left  = this.left + m.left,t.top   = this.top + m.top;
                t.width = this.width - (m.left+m.right),t.height=  this.height - (m.top+m.bottom);
            }else{
                t.left   = this.left,  t.top    = this.top;
                t.width  = this.width, t.height = this.height;
            }
        }
        return rw||rh;
    }
    
    this.$resize = function(){
		// lets set the width/height
        // lets check if we differ
		// call repaint
        if(this.$copyPos()){
            this.$redraw(true,true);
        }
	}
	
	this.$draw = function(){
        //Build Main Skin
        this.$ext = this.$getExternal();
        this.$int = this.$getLayoutNode("main", "container", this.$ext);
        
        var ox, oy, lx, ly, bt, stack = [], interact = false;
        var iebt = [0,1,2,3,3], ffbt = [1,3,2,0,0];

		var _self = this;
        this.$ext.onmousedown = function(e){
			if(this.$doinit)return;
            if (!e) e = event;
            if(e.button>4 || e.button<0)return;
            bt = (_self.canvas)?ffbt[e.button]:iebt[e.button];
            if(!bt)return;
            var keys = e.shiftKey?1:0 + e.ctrlKey?2:0 + e.altKey?4:0;
            //interact = true;
            var pos = apf.getAbsolutePosition(_self.$ext,document.documentElement);
                lx = e.clientX-pos[0] + document.documentElement.scrollLeft, 
                ly = e.clientY-pos[1] + document.documentElement.scrollTop;
            ox = lx , oy = ly;
            // we need to check if our mousedown was in the axis, ifso send it a mousedown and keep it on our eventstack
            for(var t, i = _self.childNodes.length-1;i>=0;i--){
                t = _self.childNodes[i];
				// check child name before pushing up
                if( ox >= t.left && ox <= t.left+t.width &&
                    oy >= t.top && oy <= t.top+t.height )
					if(t.$mouseDown){
                    t.$mouseDown(ox - t.left,oy - t.top, bt, keys);
                    stack.push( t );
                }
                //logw("init "+ox+" "+oy+" "+t.left+" "+t.width+" "+t.top+" "+t.height);
            }
            hasMoved = false;
        }
                
        this.$ext.oncontextmenu = function(){
            return false;   
        }

        this.$ext.onselectstart = function(){
            return false;
        }

        var hasMoved;
        this.addEventListener("contextmenu", function(e){
            if (hasMoved)
                e.cancelBubble = true;
        });

        this.$ext.onmouseup = function(e){
			if(this.$doinit)return;
            if (!e) e = event;
            bt = 0;
            var pos = apf.getAbsolutePosition(_self.$ext,document.documentElement);
            var x = e.clientX - pos[0] + document.documentElement.scrollLeft,
                y = e.clientY - pos[1] + document.documentElement.scrollTop;
            for(var t, i = stack.length-1;i>=0;i--)
                (t=stack[i]).$mouseUp(x - t.left, y - t.top);
            stack.length = 0;
        }

        this.$ext.onmousemove = function(e){
			if(this.$doinit)return;
            //if (!interact) return;
            if (!e) e = event;
            var pos = apf.getAbsolutePosition(_self.$ext,document.documentElement);
            var dx = (-lx + (lx=e.clientX-pos[0] + document.documentElement.scrollLeft)),
                dy = (-ly + (ly=e.clientY-pos[1] + document.documentElement.scrollTop));
            var keys = e.shiftKey?1:0 + e.ctrlKey?2:0 + e.altKey?4:0;

            if (bt) {
                if (bt == 2) 
                    hasMoved = true;

                for(var t, i = stack.length-1;i>=0;i--)
                    (t = stack[i]).$mouseMove(dx,dy,bt,ox-t.left,oy-t.top,lx-t.left,ly-t.top,keys);
            }
            else {
                for(var t, i = _self.childNodes.length-1;i>=0;i--)
                    if((t = _self.childNodes[i]).$mouseMove)
						t.$mouseMove(dx,dy,bt,ox-t.left,
							oy-t.top,lx-t.left,ly-t.top,keys);
            }
        }

        //@todo should use apf's abstraction for scrollwheel
		var wheelEvent = function(e) {
			if(this.$doinit)return;
            if(!e) e = window.event;
            
            var d = e.wheelDelta? 
                (window.opera ?-1:1) * e.wheelDelta / 120 :  
                (e.detail ? -e.detail / 3 : 0);
            var keys = e.shiftKey?1:0 + e.ctrlKey?2:0 + e.altKey?4:0;
            if(d){
                var pos = apf.getAbsolutePosition(_self.$ext,document.documentElement);
                // lets find if we are over a graph
                var x = e.clientX - pos[0] + document.documentElement.scrollLeft,
                    y = e.clientY - pos[1] + document.documentElement.scrollTop;
                for(var t, i = 0;i<_self.childNodes.length;i++){
                    t = _self.childNodes[i];
                    if( x >= t.left && x <= t.left+t.width &&
                        y >= t.top && y <= t.top+t.height ){
                        t.$mouseWheel(x - t.left,y - t.top,d,keys);
                    }
                }
            }
            if(e.preventDefault) e.preventDefault();
            e.returnValue = false;
        }
        if (!apf.supportVML && this.$ext.addEventListener){
            this.$ext.addEventListener('DOMMouseScroll', wheelEvent, false);
        }
        this.$ext.onmousewheel = wheelEvent;

        
        apf.layout.setRules(this.$ext, "resize", "var o = apf.all[" + this.$uniqueId + "];\
            if (o) o.$resize()", true);
        apf.layout.queue(this.$ext);
        
    }
	
    this.$loadAml = function(x){
        apf.draw.initDriver();
		
        if (this.anim > 0){
			var _self = this;
            this.$animTimer = window.setInterval(function(){
                _self.$redraw();
            }, this.anim);
        }
    }
    
    this.$destroy = function() {
        
        apf.layout.removeRule(this.$ext, "resize");
        
        
        this.$ext.onmousedown   = 
        this.$ext.oncontextmenu = 
        this.$ext.onselectstart = 
        this.$ext.onmouseup     = 
        this.$ext.onmousemove   = 
        this.$ext.onmousewheel  = null;
        
        window.clearTimeout(this.$timer);
        window.clearInterval(this.$animTimer);
    };
}).call(apf.Chart.prototype = new apf.Presentation());



/*FILEHEAD(/var/lib/platform/source/trunk/elements/bindingcolumnrule.js)SIZE(18940)TIME(1263859264)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @attribute {String} icon
 * @attribute {String} caption
 * @attribute {String} width
 * @attribute {String} options
 * @attribute {String} editor
 * @attribute {String} colspan
 * @attribute {String} align
 * @attribute {String} css
 */
apf.BindingColumnRule = function(struct, tagName){
    this.$init(tagName, apf.NODE_HIDDEN, struct);
    
    this.$className = "col" + this.$uniqueId;
};

(function(){
    this.$defaultwidth = "100";
    this.$width        = 100;
    
    this.$sortable  = true; //@todo set defaults based on localName of element to which its applied
    this.$resizable = true;
    this.$movable   = true;
    this.$cssInit   = false;
    
    this.$propHandlers["icon"]  = function(value, prop){
        
    }
    
    this.$propHandlers["caption"]  = function(value, prop){
        
    }
    
    this.$propHandlers["width"]  = function(value, prop){
        if (!value)
            value = this.$defaultwidth;

        this.$isPercentage = value && String(value).indexOf("%") > -1;
        this.$width = parseFloat(value);
    }
    
    this.$propHandlers["options"]  = function(value, prop){
        this.$sortable  = value.indexOf("sort") > -1;
        this.$resizable = value.indexOf("size") > -1;
        this.$movable   = value.indexOf("move") > -1;
    }
    
    this.$propHandlers["editor"]  = function(value, prop){
        
    }
    
    this.$propHandlers["colspan"]  = function(value, prop){
        
    }
    
    this.$propHandlers["align"]  = function(value, prop){
        
    }
    
    this.$propHandlers["css"]  = function(value, prop){
        
    }
    
    this.resize = function(newsize, pNode){
        var hN;
        if (this.$isPercentage) {
            var ratio = newsize / (this.$ext.offsetWidth - (pNode.$widthdiff - 3)), //div 0 ??
                next  = [],
                total = 0,
                node  = this.$ext.nextSibling;
            
            while (node && node.getAttribute("hid")) {
                hN = apf.all[node.getAttribute("hid")];
                if (hN.$isPercentage) {
                    next.push(hN);
                    total += hN.$width;
                }
                node = node.nextSibling;
            }
            
            var newPerc  = ratio * this.$width,
                diffPerc = newPerc - this.$width,
                diffRatio = (total - diffPerc) / total;
            if (diffRatio < 0.01) {
                if (newsize < 20) return;
                return this.resize(newsize - 10, pNode);//pNode.resizeColumn(nr, newsize - 10);
            }
            
            for (var n, i = 0; i < next.length; i++) {
                n = next[i];
                n.$width *= diffRatio;
                apf.setStyleRule("." + n.$className, "width", n.$width + "%"); //Set
                //apf.setStyleRule("." + pNode.$baseCSSname + " .records ."
                    //+ n.$className, "width", n.$width + "%", null, pNode.oWin); //Set
            }
            
            this.$width = newPerc;
            apf.setStyleRule("." + this.$className, "width", this.$width + "%"); //Set
            //apf.setStyleRule("." + pNode.$baseCSSname + " .records ."
                //+ h.$className, "width", this.$width + "%", null, pNode.oWin); //Set
        }
        else {
            var diff = newsize - this.$width;
            this.$width = newsize;
            if (apf.isIE && pNode.oIframe) {
                this.$ext.style.width = newsize + "px";
            }
            else {
                //apf.setStyleRule("." + this.$className, "width", newsize + "px"); //Set
            }
            apf.setStyleRule("." + this.$className, "width", newsize + "px", null, pNode.oWin); //Set
            
            pNode.$fixed += diff;
            var vLeft = (pNode.$fixed + 5) + "px";

            if (!this.$isFixedGrid) {
                //apf.setStyleRule("." + this.$baseCSSname + " .headings ." + hFirst.$className, "marginLeft", "-" + vLeft); //Set
                //apf.setStyleRule("." + this.$baseCSSname + " .records ." + hFirst.$className, "marginLeft", "-" + vLeft); //Set
                apf.setStyleRule("." + pNode.$baseCSSname + " .row" + pNode.$uniqueId,
                    "paddingRight", vLeft, null, this.oWin); //Set
                apf.setStyleRule("." + pNode.$baseCSSname + " .row" + pNode.$uniqueId,
                    "marginRight", "-" + vLeft, null, pNode.oWin); //Set
            
                //headings and records have same padding-right
                pNode.$int.style.paddingRight  =
                pNode.$head.style.paddingRight = vLeft;
            }
        }
    }
    
    this.hide = function(){
        apf.setStyleRule("." + this.$baseCSSname + " .records ." + h.$className,
            "visibility", "hidden", null, this.oWin);
        
        //Change percentages here
    }
    
    this.show = function(){
        apf.setStyleRule("." + this.$baseCSSname + " .records ." + h.$className,
            "visibility", "visible", null, this.oWin);
        
        //Change percentages here
    }
    
    /**
     * Sorts a column.
     * @param {Number} hid the heading number; this number is based on the sequence of the column elements.
     */
    this.sort = function(pNode){
        if (pNode.$lastSorted == this) {
            apf.setStyleClass(this.$int,
                pNode.toggleSortOrder()
                    ? "ascending"
                    : "descending", ["descending", "ascending"]);
            return;
        }

        var h;
        if (h = pNode.$lastSorted) {
            apf.setStyleRule("." + h.$className, "background", "white"); //This breaks row coloring
            apf.setStyleClass(h.$int, "", ["descending", "ascending"]);
        }
        
        apf.setStyleRule("." + this.$className, "background", "#f3f3f3");
        apf.setStyleClass(this.$int, "ascending", ["descending", "ascending"]);
        
        if (!pNode.length)
            return;
        
        pNode.resort({
            order : "ascending",
            xpath : this.cvalue2.xpaths[1]
            //type : 
        });
        
        pNode.$lastSorted = this;
    };
    
    /**
     * Moves a column to another position.
     * @param {Number} fromHid the heading number of the column to move; this number is based on the sequence of the column elements.
     * @param {Number} toHid   the position the column is moved to;
     */
    this.move = function(hTo, pNode){
        if (hTo && this == hTo) 
            return;
        
        var hFrom       = this,
            childNrFrom = apf.getChildNumber(hFrom.$int),
            childNrTo   = hTo && apf.getChildNumber(hTo.$int);

        pNode.$head.insertBefore(hFrom.$int, hTo && hTo.$int || null);

        if (!pNode.length)
            return;

        var node, nodes = pNode.$int.childNodes;
        for (var i = 0; i < nodes.length; i++) {
            if (pNode.$withContainer && ((i+1) % 2) == 0)
                continue;

            node = nodes[i];
            node.insertBefore(node.childNodes[childNrFrom], 
                typeof childNrTo != "undefined" && node.childNodes[childNrTo] || null);
        }
        
        /*if (this.$first == from || this.$first == to) {
            var hReset = this.$first == from ? hFrom : hTo;
            
            apf.setStyleRule("." + this.$baseCSSname + " .headings ."
                + hReset.className, "marginLeft", "-5px"); //Reset
            apf.setStyleRule("." + this.$baseCSSname + " .records ."
                + hReset.className, "marginLeft", "-5px"); //Reset
            
            this.$first = pNode.$head.firstChild.getAttribute("hid");
            var h = headings[this.$first];
            var vLeft = "-" + (this.$fixed + 5) + "px";

            apf.setStyleRule("." + this.$baseCSSname + " .headings ."
                + h.className, "marginLeft", vLeft); //Set
            apf.setStyleRule("." + this.$baseCSSname + " .records ."
                + h.className, "marginLeft", vLeft); //Set
        }*/
    }
    
    this.$draw = function(pNode, caption, width, className){
        //Find the parent this rule works on
        var pNode = pNode || this.parentNode;
        while (pNode.$bindingRule)
            pNode = pNode.parentNode;
        
        if (!pNode.hasFeature(apf.__PRESENTATION__))
            return;
            
        if (width) 
            this.$propHandlers["width"].call(this, width);

        //"." + this.$baseCSSname + " .headings 
        //if initial
        //only needs once if this works
        apf.importStylesheet([
          ["." + this.$className,
            "width:" + this.$width + (this.$isPercentage ? "%;" : "px;")
            + "text-align:" + this.align]
        ]);
        
        //Add to htmlRoot
        pNode.$getNewContext("headitem");
        var $head = pNode.$getLayoutNode("headitem");
        $head.setAttribute("class", this.$className + (className ? " " + className : ""));
        $head.setAttribute("hid", this.$uniqueId);
        
        var hCaption = pNode.$getLayoutNode("headitem", "caption");
        if (this.icon) {
            this.$sortable = false;
            $head.setAttribute("style", "background-image:url("
                + apf.getAbsolutePath(pNode.iconPath, this.icon) 
                + ")");
            hCaption.nodeValue = "&nbsp;";
        }
        else
            hCaption.nodeValue = this.caption || caption || "";
        
        this.$ext = this.$int = apf.insertHtmlNode($head, pNode.$head || pNode.$int);
        
        var dragging = false;
        var _self    = this;
        
        this.$int.onmouseover = function(e){
            if (!e) e = event;
            
            if (pNode.disabled) return;

            apf.setStyleClass(this, "hover", ["down"]);
        };
        
        this.$int.onmouseup = function(e){
            if (!e) e = event;
            
            if (pNode.disabled || !apf.isChildOf(dragging, this, true)) 
                return;
            
            apf.setStyleClass(this, "hover", ["down"]);

            if (_self.$sortable)
                _self.sort(pNode);
            
            //@todo pNode or Self?
            pNode.dispatchEvent("sortcolumn", _self);
        };
        
        this.$int.onmousedown = function(e){
            if (!e) e = event;
            dragging = target = this;
            
            if (pNode.disabled) return;

            //Resizing
            var pos   = apf.getAbsolutePosition(target),
                sLeft = pNode.$head.scrollLeft;
            var d     = e.clientX - pos[0] + sLeft;
            if (d < 4 || target.offsetWidth - d - 8 < 3
              && apf.getChildNumber(_self.$int) < pNode.$headings.length - 1) {
                var t = d < 4 && target.previousSibling || target;
                
                if (_self.$resizable) {
                    pos   = apf.getAbsolutePosition(t);
                    apf.setStyleClass(pNode.$pointer, "size_pointer", ["move_pointer"]);
                    pNode.$pointer.style.display = "block";
                    pNode.$pointer.style.left    = (t.offsetLeft - sLeft - 1) + "px";
                    pNode.$pointer.style.width   = (t.offsetWidth - pNode.$widthdiff + 1) + "px";
                    
                    
                    apf.plane.show(pNode.$pointer, null, true);
                    

                    dragging = true;
                    document.onmouseup = function(){
                        if (!e) e = event;
    
                        document.onmouseup = 
                        document.onmousemove = null;
                        
                        apf.all[t.getAttribute("hid")].resize(pNode.$pointer.offsetWidth, pNode);
                        
                        dragging = false;
                        pNode.$pointer.style.display = "none";
                        
                        
                        apf.plane.hide();
                        

                    };
                    
                    document.onmousemove = function(e){
                        if (!e) e = event;

                        pNode.$pointer.style.width = Math.max(10, 
                            Math.min(pNode.$int.offsetWidth - pNode.$pointer.offsetLeft - 20, 
                                e.clientX - pos[0] - 1 + sLeft)) + "px";
                    };
                    
                    return;
                }
            }
            
            apf.setStyleClass(target, "down", ["hover"]);
            
            //Moving
            if (!_self.$movable) {
                document.onmouseup = function(e){
                    document.onmouseup = null;
                    dragging = false;
                };
                
                return;
            }
            
            apf.setStyleClass(pNode.$pointer, "move_pointer", ["size_pointer"]);
            
            var x = e.clientX - target.offsetLeft, sX = e.clientX,
                y = e.clientY - target.offsetTop,  sY = e.clientY,
                copy;
            
            document.onmouseup = function(e){
                if (!e) e = event;
                
                document.onmouseup   =
                document.onmousemove = null;
                
                dragging = false;
                pNode.$pointer.style.display = "none";
                
                if (!copy)
                    return;
                    
                copy.style.top = "-100px";
                
                var el = document.elementFromPoint(e.clientX, e.clientY);
                if (el.parentNode == copy.parentNode) {
                    var pos = apf.getAbsolutePosition(el);
                    var beforeNode = (e.clientX - pos[0] > el.offsetWidth / 2
                        ? el.nextSibling
                        : el);

                    _self.move(beforeNode ? apf.all[beforeNode.getAttribute("hid")] : null, pNode);
                }
                
                apf.destroyHtmlNode(copy);
            };

            document.onmousemove = function(e){
                if (!e) e = event;
                
                if (!copy) {
                    if (Math.abs(e.clientX - sX) < 3 && Math.abs(e.clientY - sY) < 3)
                        return;
                    
                    copy = target.cloneNode(true);
                    copy.style.position = "absolute";
                    var diff = apf.getWidthDiff(target);
                    copy.style.width    = (target.offsetWidth - diff
                        - pNode.$widthdiff + 2) + "px";
                    copy.style.left     = target.offsetLeft;
                    copy.style.top      = target.offsetTop;
                    copy.style.margin   = 0;
                    copy.removeAttribute("hid")
                    
                    apf.setStyleClass(copy, "drag", ["ascending", "descending"]);
                    target.parentNode.appendChild(copy);
                }
                
                copy.style.top               = "-100px";
                pNode.$pointer.style.display = "none";
                
                var el = document.elementFromPoint(e.clientX, e.clientY);
                if (el.parentNode == copy.parentNode) {
                    var pos = apf.getAbsolutePosition(el);
                    pNode.$pointer.style.left = (el.offsetLeft 
                        + ((e.clientX - pos[0] > el.offsetWidth / 2)
                            ? el.offsetWidth - 8
                            : 0)) + "px";
                    pNode.$pointer.style.display = "block";
                }
                
                copy.style.left = (e.clientX - x) + 'px';
                copy.style.top  = (e.clientY - y) + 'px';
            };
        };
        
        this.$int.onmouseout = function(e){
            if (!e) e = event;
            
            if (pNode.disabled) return;
            
            pNode.$ext.style.cursor = "";
            apf.setStyleClass(this, "", ["hover", "down"]);
        };
        
        this.$int.onmousemove = function(e){
            if (dragging || pNode.disabled)
                return;
                
            if (!e) e = event;

            var pos   = apf.getAbsolutePosition(this),
                sLeft = pNode.$head.scrollLeft;
            var d = e.clientX - pos[0] + sLeft;

            if (d < 4 || this.offsetWidth - d - pNode.$widthdiff < 3 
              && apf.getChildNumber(_self.$int) < pNode.$headings.length - 1) {
                var t = d < 4 ? this.previousSibling : this;
                pNode.$ext.style.cursor = t && _self.$resizable
                    ? "w-resize"
                    : "default";
            }
            else {
                pNode.$ext.style.cursor = "default";
            }
        };
        
        return this;
    }
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        this.$draw();
    });
    
    this.addEventListener("DOMNodeRemovedFromDocument", function(e){
        if (!this.$int)
            return;
        
        this.$int.onmouseover   =
        this.$int.onmouseup     =
        this.$int.onmousedown   =
        this.$int.onmousemove   =
        this.$int.onmouseout    = null;
    });
    
}).call(apf.BindingColumnRule.prototype = new apf.BindingRule());

apf.aml.setElement("column", apf.BindingColumnRule);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/table.js)SIZE(20689)TIME(1263859264)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Any child element of this element is placed in a table. The size of the 
 * columns and rows of the table can be set by attributes. Child elements can
 * span multiple columns. Using '*' as a size indicator will use the remaining
 * size for that column or row, when the table's size is set.
 * Example:
 * This example shows a window with a table and two buttons that change the 
 * orientation of the table runtime. The textarea and it's label have a span set
 * to '*'. This means they will span the entire width of all columns, no matter
 * how many columns there are.
 * <code>
 *  <a:window visible="true" width="500" height="400">
 *      <a:table id="tableTest" 
 *        columns = "80, *"
 *        margin  = "10 10 10 10"
 *        padding = "5"
 *        bottom  = "35"
 *        top     = "0">
 *          <a:label>Name</a:label>
 *          <a:textbox />
 *          <a:label>Address</a:label>
 *          <a:textarea height="50" />
 *          <a:label>Country</a:label>
 *          <a:dropdown />
 *          
 *          <a:label span="*">Message</a:label>
 *          <a:textarea id="txtMessage" 
 *            height = "*" 
 *            span   = "*" />
 *      </a:table>
 *      
 *      <a:button 
 *        caption = "Two Columns"
 *        bottom  = "10"
 *        left    = "10"
 *        onclick = "tableTest.setAttribute('columns', '80, *');"/>
 *              
 *      <a:button 
 *        bottom  = "10"
 *        left    = "125"
 *        caption = "Four Columns"
 *        onclick = "tableTest.setAttribute('columns', '60, 120, 60, *');"/>
 *  </a:window>
 * </code>
 * Remarks:
 * This is one of three positioning methods.
 * See {@link baseclass.alignment}
 * See {@link baseclass.anchoring}
 *
 * @define table
 * @allowchild {elements}, {anyaml}
 * @addnode elements
 * @constructor
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       1.0
 */
apf.table = function(struct, tagName){
    this.$init(tagName || "table", apf.NODE_VISIBLE, struct);
};

(function(){
    var l = apf.layout;
    
    /**** Properties and Attributes ****/
    
    this.$focussable     = false;
    this.$update         = false;
    
    this.columns    = "100,*";
    this.padding    = 2;
    this.margin     = "5 5 5 5";
    this.cellheight = 19;
    
    /**
     * @attribute {String} columns      a comma seperated list of column sizes. A column size can be specified in a number (size in pixels) or using a number and a % sign to indicate a percentage. A '*' indicates the column spans the rest space. There can be only one '*' in the column string.
     * Example:
     * <code>
     *  <a:table columns="150, *, 20%" />
     * </code>
     * @attribute {String} padding      the space between each element. Defaults to 2.
     * @attribute {String} margin       the space between the container and the elements, space seperated in pixels for each side. Similar to css in the sequence top right bottom left. Defaults to "5 5 5 5".
     * Example:
     * <code>
     *  <a:table margin="10 10 40 10" />
     * </code>
     * @attribute {String} cellheight   the default height of each element. This can be overriden by setting a height on an element. The height will always size all elements of the same row. Defaults to 19.
     */
    this.$supportedProperties.push("columns", "padding", "margin", 
        "cellheight", "span");
    
    this.$propHandlers["columns"]    =
    this.$propHandlers["padding"]    =
    this.$propHandlers["margin"]     =
    this.$propHandlers["cellheight"] = function(value){
        if (!this.$update && apf.loaded)
            l.queue(this.$ext, this.$updateObj);
        this.$update = true;
    };
    
    function visibleHandler(){
        var p = this.parentNode;
        if (!p.$update && apf.loaded)
            l.queue(p.$ext, p.$updateObj);
        p.$update = true;
    }
    
    //@todo move this to enableTable, disableTable
    this.register = function(amlNode){
        amlNode.$propHandlers["width"]  = 
        amlNode.$propHandlers["height"] = 
        amlNode.$propHandlers["margin"] = 
        amlNode.$propHandlers["span"]   = this.$updateObj.updateTrigger;
        
        amlNode.addEventListener("prop.visible", visibleHandler);

        l.queue(this.$ext, this.$updateObj);
        this.$update = true;
    }
    
    this.unregister = function(amlNode){
        amlNode.$propHandlers["width"]  = 
        amlNode.$propHandlers["height"] = 
        amlNode.$propHandlers["margin"] = 
        amlNode.$propHandlers["span"]   = null;
        
        amlNode.removeEventListener("prop.visible", visibleHandler);
        
        l.queue(this.$ext, this.$updateObj);
        this.$update = true;
    }
    /*
         this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        this.register(this.parentNode);
    });
    */
    
    /**** DOM Hooks ****/
    
    this.addEventListener("DOMNodeRemoved", function(e){
        if (this.$isWaitingOnDisplay || !this.$updateObj)
            return;

        if (e.currentTarget == this) {
            var p = this;
            while (p) {
                p.unwatch("visible", this.$updateObj.propChange);
                p = p.parentNode;
            }
        }
        else if (e.relatedNode == this){
            this.unregister(e.currentTarget);
            e.currentTarget.$setLayout();
        }
    });

    this.addEventListener("DOMNodeInserted", function(e){
        if (this.$isWaitingOnDisplay || e.currentTarget != this)
            return;

        if (e.currentTarget == this) {
            var p = this;
            while (p) {
                p.watch("visible", this.$updateObj.propChange);
                p = p.parentNode;
            }
        }
        else if (e.relatedNode == this && !e.$moveWithinParent)
            e.currentTarget.$setLayout("table");
    });
    
    /**
     * @macro
     */
    function setPercentage(expr, value){
        return typeof expr == "string" 
            ? expr.replace(apf.percentageMatch, "((" + value + " * $1)/100)")
            : expr;
    }
    
    this.$isWaitingOnDisplay = false;
    this.$updateTable = function(){ //@todo prevent this from being called so much
        if (!this.$update)
            return;

        //@todo when not visible make all property settings rule based
        //@todo isnt there a better way for doing this? (faster)
        
        if (!this.$ext.offsetWidth) {
            this.$isWaitingOnDisplay = true;
            this.watch("visible", this.$updateObj.propChange);
            
            var p = this.parentNode;
            while(p) {
                p.watch("visible", this.$updateObj.propChange);
                p = p.parentNode;
            }
            
            return;
        }
        
        
        this.cellheight = parseInt(this.cellheight);
        this.padding    = parseInt(this.padding);
        
        var id;
        var pWidth      = "pWidth",
            pHeight     = "pHeight",

            cols        = setPercentage(this.columns, pWidth).split(/\s*,\s*/),
            collength   = cols.length,
            margin      = apf.getBox(this.margin),
            rowheight   = [],

            oCols       = [],
            jNodes      = this.childNodes,
            col, row, oExt, diff, j, m, cellInfo, span, jNode;

        this.ids = [this.$ext];
        for (var nodes = [], c = 0, i = 0, l = jNodes.length; i < l; i++) {
            jNode = jNodes[i];
            if (jNode.nodeType != 1 && jNode.nodeType != 7 
              || jNode.nodeFunc == apf.NODE_HIDDEN || jNode.visible === false)
                continue;
            
            
            if (jNode.hasFeature(apf.__ANCHORING__))
                jNode.$disableAnchoring();
            
            
            m = apf.getBox(String(jNode.margin));
            //for (j = 0; j < 4; j++)
                //m[j] += this.padding;

            diff = apf.getDiff(jNode.$ext);
            oExt = jNode.$ext;
            if (!oExt.getAttribute("id")) 
                apf.setUniqueHtmlId(oExt);
            if (apf.isIE)
                oExt.style.position = "absolute"; //Expensive
            
            span = jNode.span;
            
            cellInfo = {
                span    : span == "*" ? collength - (c % collength) : parseInt(span) || 1,
                m       : m,
                height  : setPercentage(jNode.height, pHeight),
                width   : jNode.width,
                oHtml   : oExt,
                hordiff : diff[0],
                verdiff : diff[1],
                id      : (apf.hasHtmlIdsInJs 
                    ? oExt.getAttribute("id")
                    : "document.getElementById('" + oExt.getAttribute("id") + "')")
                //"ids[" + (this.ids.push(oExt) - 1) + "]"
            }
            
            nodes.push(cellInfo);
            
            row = Math.floor(c / collength);
            c += cellInfo.span; //no check on span overflow
            
            if (cellInfo.height == "*" || rowheight[row] == "*") {
                rowheight[row] = "*";
                cellInfo.height = null;
            }
            else if(cellInfo.height && parseInt(cellInfo.height) != cellInfo.height) {
                rowheight[row] = cellInfo.height;
            }
            else if(typeof rowheight[row] != "string") {
                rowheight[row] = Math.max(rowheight[row] || 0, 
                    parseFloat(cellInfo.height || this.cellheight));
                    //+ cellInfo.m[0] + cellInfo.m[2]);
            }
        }
        var dt = new Date().getTime();
        
        if (nodes.length == 0) 
            return;

        var total, combCol, fillCol = null, fillRow = null;
        var rule = [
            "var ids = apf.all[" + this.$uniqueId + "].ids",
            "var total = 0, pHeight = ids[0].offsetHeight - " 
                + ((rowheight.length - 1) * this.padding + margin[0] + margin[2]),
            "var pWidth  = ids[0].offsetWidth - " 
                + ((collength - 1) * this.padding + margin[1] + margin[3]) 
        ];
        
        /*for (i = 0; i < this.ids.length; i++) {
            rule.push("var item" + i + " = ids[" + i + "]");
        }*/

        //Set column widths (only support for one *)
        for (total = 0, i = 0; i < collength; i++) {
            if (cols[i] == "*")
                fillCol = i;
            else {
                if (parseFloat(cols[i]) != cols[i]) {
                    rule.push("var colw" + i + "; total += colw" 
                        + i + " = " + cols[i]);
                    cols[i] = "colw" + i;
                }
                else
                    total += cols[i] = parseFloat(cols[i]);
            }
        }
        if (fillCol !== null) {
            rule.push("var colw" + fillCol + " = " + pWidth 
                    + " - total - " + total);
            cols[fillCol] = "colw" + fillCol;
        }
        
        //Set column start position
        var colstart = [margin[3]];
        rule.push("var coll0 = " + margin[3]);
        for (i = 1; i < collength; i++) {
            if (typeof colstart[i-1] == "number" && typeof cols[i-1] == "number") {
                colstart[i] = colstart[i-1] + cols[i-1] + this.padding;
            }
            else {
                rule.push("var coll" + i + " = coll" + (i - 1) + " + colw" 
                    + (i - 1) + " + " + this.padding);
                colstart[i] = "coll" + i;
            }
        }
        
        //Set row heights
        rule.push("total = 0");
        var needcalc = false;
        for (total = 0, i = 0; i < rowheight.length; i++) {
            if (rowheight[i] == "*")
                fillRow = i;
            else {
                if (parseFloat(rowheight[i]) != rowheight[i]) {
                    needcalc = true;
                    rule.push("var rowh" + i + "; total += rowh" 
                        + i + " = " + rowheight[i]);
                    rowheight[i] = "rowh" + i;
                }
                else
                    total += rowheight[i] = parseFloat(rowheight[i]);
            }
        }
        if (fillRow !== null) {
            needcalc = true;
            rule.push("var rowh" + fillRow + " = " + pHeight 
                    + " - total - " + total);
            rowheight[fillRow] = "rowh" + fillRow;
        }
        
        if (!needcalc)
            this.$ext.style.height = (total + ((rowheight.length-1) * this.padding) + margin[0] + margin[2]) + "px";
        
        //Set column start position
        var rowstart = [margin[0]];
        rule.push("var rowt0 = " + margin[0]);
        for (i = 1; i < rowheight.length; i++) {
            if (typeof rowstart[i-1] == "number" && typeof rowheight[i-1] == "number") {
                rowstart[i] = rowstart[i-1] + rowheight[i-1] + this.padding;
            }
            else {
                rule.push("var rowt" + i + " = rowt" + (i - 1) + " + rowh" 
                    + (i - 1) + " + " + this.padding);
                rowstart[i] = "rowt" + i;
            }
        }
        
        //Set all cells
        for (c = 0, i = 0; i < nodes.length; i++) {
            cellInfo = nodes[i]
            col      = c % collength;
            row      = Math.floor(c / collength);
            c       += cellInfo.span; //no check on span overflow
            id       = cellInfo.id;
            
            //Top
            if (typeof rowstart[row] == "number")
                cellInfo.oHtml.style.top = (rowstart[row] + cellInfo.m[0]) + "px";
            else
                rule.push(id + ".style.top    = rowt" 
                    + row + " + " + cellInfo.m[0] + " + 'px'");
            
            //Left
            if (typeof colstart[col] == "number")
                cellInfo.oHtml.style.left = (colstart[col] + cellInfo.m[3]) + "px";
            else
                rule.push(id + ".style.left   = coll" 
                    + col + " + " + cellInfo.m[3] + " + 'px'");
            
            //Width
            if (cellInfo.span && cellInfo.span > 1 && !cellInfo.width) {
                var cTotal = 0;
                for (combCol = [], j = 0; j < cellInfo.span; j++) {
                    if (typeof cols[col + j] == "number") {
                        cTotal += cols[col + j];
                    }
                    else {
                        combCol.push("colw" + (col + j));
                        cTotal -= 1000000;
                    }
                    
                    //if (j != cellInfo.span - 1)
                        //cTotal += this.padding;
                }

                var spanPadding = (cellInfo.span - 1) * this.padding;
                if (cTotal > 0) {
                    cellInfo.oHtml.style.width = (cTotal 
                        + spanPadding - (cellInfo.m[1] + cellInfo.m[3] 
                        + cellInfo.hordiff)) + "px";
                }
                else {
                    if (cTotal > -1000000)
                        combCol.push(cTotal + 1000000);
                    rule.push(id + ".style.width = (" + combCol.join(" + ") 
                        + " + " + spanPadding + " - " + (cellInfo.m[1] + cellInfo.m[3] 
                        + cellInfo.hordiff) + ") + 'px'");
                }
            }
            else {
                if (parseFloat(cellInfo.width) == cellInfo.width
                  || typeof cols[col] == "number")
                    cellInfo.oHtml.style.width = ((cellInfo.width || cols[col]) 
                        - (cellInfo.m[1] + cellInfo.m[3] + cellInfo.hordiff)) + "px";
                else
                    rule.push(id + ".style.width = (" 
                        + (cellInfo.width || "colw" + col) + " - " 
                        + (cellInfo.m[1] + cellInfo.m[3] + cellInfo.hordiff) 
                        + ") + 'px'");
            }

            //Height
            if (parseFloat(cellInfo.height) == cellInfo.height
                || typeof rowheight[row] == "number")
                cellInfo.oHtml.style.height = ((cellInfo.height || rowheight[row]
                    - (cellInfo.m[0] + cellInfo.m[2])) - cellInfo.verdiff) + "px";
            else
                rule.push(id + ".style.height = (" 
                    + (cellInfo.height || "rowh" + row) + " - " 
                    + (cellInfo.m[0] + cellInfo.m[2] + cellInfo.verdiff)
                    + ") + 'px'");
        }

        //rule.join("\n"), true);
        apf.layout.setRules(this.$ext, "table", (rule.length 
            ? "try{" + rule.join(";}catch(e){};\ntry{") + ";}catch(e){};" 
            : ""), true);
        apf.layout.queue(this.$ext);
        //Set size of table if necesary here...
        this.$update = false;
    };
    
    this.$draw = function(){
        var _self = this;
        this.$updateObj = {
            $updateLayout : function(){
                _self.$updateTable();
            },
            updateTrigger : function(value){
                if (!_self.$update && apf.loaded)
                    l.queue(_self.$ext, _self.$updateObj);
                _self.$update = true;
            },
            
            propChange : function (name, old, value){
                if (_self.$update && apf.isTrue(value) && _self.$ext.offsetWidth) {
                    _self.$updateTable();
                    apf.layout.activateRules(_self.$ext);
                    
                    var p = _self;
                    while (p) {
                        p.unwatch("visible", _self.$updateObj.propChange);
                        p = p.parentNode;
                    }
                    
                    _self.$isWaitingOnDisplay = false;
                }
            }
            
        }
        
        this.$ext = this.$pHtmlNode.appendChild(document.createElement("div"));
        this.$ext.className = "table " + (this.getAttributeNode("class") || "");
        this.$int = this.$ext;
        this.$ext.host = this;

        if (!this.$ext.getAttribute("id")) 
            apf.setUniqueHtmlId(this.$ext);

        this.$htmlId = apf.hasHtmlIdsInJs 
            ? this.$ext.getAttribute("id")
            : "document.getElementById('" + this.$ext.getAttribute("id") + "')";
        
        //this.$ext.style.height = "80%"
        //this.$ext.style.top       = 0;
        this.$ext.style.position  = "relative";
        this.$ext.style.minHeight = "10px";
        
        if (this.getAttribute("class")) 
            apf.setStyleClass(this.$ext, this.getAttribute("class"));

        if (!apf.isIE && !apf.table.$initedcss) {
            apf.importCssString(".table>*{position:absolute}");
            apf.table.$initedcss = true;
        }
    };
    
    this.$loadAml = function(x){
        if (!this.width && (apf.getStyle(this.$ext, "position") == "absolute"
          || this.left || this.top || this.right || this.bottom || this.anchors))
            this.$ext.style.width  = "100%"
    };
}).call(apf.table.prototype = new apf.GuiElement());

apf.aml.setElement("table", apf.table);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/tab.js)SIZE(2993)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */





/**
 * Element displaying a page and several buttons allowing a
 * user to switch between the pages. Each page can contain
 * arbitrary aml. Each page can render it's content during
 * startup of the application or when the page is activated.
 * Example:
 * <code>
 *  <a:tab id="tab">
 *      <a:page caption="General">
 *          <a:checkbox>Example</a:checkbox>
 *          <a:button>Example</a:button>
 *      </a:page>
 *      <a:page caption="Advanced">
 *          <a:checkbox>Test checkbox</a:checkbox>
 *          <a:checkbox>Test checkbox</a:checkbox>
 *          <a:checkbox>Test checkbox</a:checkbox>
 *      </a:page>
 *      <a:page caption="Ajax.org">
 *          <a:checkbox>This ok?</a:checkbox>
 *          <a:checkbox>This better?</a:checkbox>
 *      </a:page>
 *  </a:tab>
 * </code>
 *
 * @constructor
 * @define tab, pages, switch
 * @allowchild page
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.1
 *
 * @inherits apf.BaseTab
 */

apf["switch"] = function(struct, tagName){
    this.$hasButtons = false;
    this.$init(tagName || "switch", apf.NODE_VISIBLE, struct);
};

apf.pages     = function(struct, tagName){
    this.$hasButtons = false;
    this.$init(tagName || "pages", apf.NODE_VISIBLE, struct);
};

apf.tab       = function(struct, tagName){
    this.$hasButtons = true;
    this.$init(tagName || "tab", apf.NODE_VISIBLE, struct);
};

(function(){
    this.$focussable = apf.KEYBOARD; // This object can get the focus from the keyboard

    /**** Init ****/

    this.$draw = function(bSkinChange){
        //Build Main Skin
        this.$ext = this.$getExternal();
        this.$loadChildren();
    };
}).call(apf.tab.prototype = new apf.BaseTab());

apf["switch"].prototype =
apf.pages.prototype     = apf.tab.prototype;

apf.aml.setElement("switch", apf["switch"]);
apf.aml.setElement("pages",  apf.pages);
apf.aml.setElement("tab",    apf.tab);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/teleport.js)SIZE(1019)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.aml.setElement("teleport", apf.AmlElement);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/label.js)SIZE(4301)TIME(1259708672)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element displaying a text in the user interface, usually specifying
 * a description of another element. When the user clicks on the label it 
 * can set the focus to the connected aml element.
 * Example:
 * This example uses the for attribute to connect the label to the form element.
 * <code>
 *  <a:label for="txtAddress">Address</a:label>
 *  <a:textbox id="txtAddress" value="Some text" />
 * </code>
 *
 * @constructor
 * @allowchild {smartbinding}
 * @addnode elements
 *
 * @inherits apf.BaseSimple
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @binding value  Determines the way the value for the element is retrieved 
 * from the bound data.
 * Example:
 * Sets the label text based on data loaded into this component.
 * <code>
 *  <a:model id="mdlLabel">
 *      <data text="Some text"></data>
 *  </a:model>
 *  <a:label model="mdlLabel" value="[@text]" />
 * </code>
 * Example:
 * A shorter way to write this is:
 * <code>
 *  <a:model id="mdlLabel">
 *      <data text="Some text"></data>
 *  </a:model>
 *  <a:label value="[mdlLabel::@text]" />
 * </code>
 */
apf.label = function(struct, tagName){
    this.$init(tagName || "label", apf.NODE_VISIBLE, struct);
};

(function(){
    this.implement(
        
        apf.DataAction
        
    );

    var _self = this;
    
    this.$focussable = false;
    var forElement;
    
    
    
    /**
     * Sets the value of this element. This should be one of the values
     * specified in the values attribute.
     * @param {String} value the new value of this element
     */
    this.setValue = function(value){
        this.setProperty("value", value, false, true);
    };
    
    /**
     * Returns the current value of this element.
     * @return {String}
     */
    this.getValue = function(){
        return this.value;
    }
    
    
    
    /** 
     * @attribute {String} value the text displayed in the area defined by this 
     * element. Using the value attribute provides an alternative to using
     * the text using a text node.
     *
     * @attribute {String} for the id of the element that receives the focus 
     * when the label is clicked on.
     */
    this.$supportedProperties.push("caption", "value", "for");
    this.$propHandlers["caption"] = 
    this.$propHandlers["value"]   = function(value){
        this.$int.innerHTML = value;
    };
    this.$propHandlers["for"] = function(value){
        forElement = typeof value == "string" ? self[value] : value;
    };

    this.$draw = function(){
        //Build Main Skin
        this.$ext = this.$getExternal();
        this.$int = this.$getLayoutNode("main", "caption", this.$ext);
        if (this.$int.nodeType != 1) 
            this.$int = this.$int.parentNode;
        
        this.$ext.onmousedown = function(){
            if (forElement && forElement.$focussable && forElement.focussable)
                forElement.focus();
        }
    };
    
    this.$childProperty = "value";
    
}).call(apf.label.prototype = new apf.BaseSimple());

apf.aml.setElement("label", apf.label);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/slideshow.js)SIZE(46687)TIME(1265021706)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/** 
 * This element is used for viewing images. It's possible to add thumbnail and 
 * description to each of them. You can select a displayed image in several ways.
 * With a mouse buttons, the mousewheel or keyboard arrows. The thumbnails allow 
 * the user to quickly select the image from the displayed list.
 * 
 * Remarks:
 * The language variables possible to use of this component:
 * <groups>
 *     <english id="sub">
 *         <group id="slideshow">
 *             <key id="loadmsg">Loading...</key>
 *             <key id="defaulttitle">Default title</key>
 *             <key id="image">Picture</key>
 *             <key id="of">of</key>
 *         </group>
 *     </english>
 * </groups>
 * 
 * 
 * Example:
 * Slideshow component with 3 pictures. Each image has its own thumbnail 
 * and description. A new image is shown every 5 seconds.
 * <code>
 *  <a:model id="mdlImages" save-original="true" >
 *      <slideshow>
 *          <picture src="img1.jpg" thumb="thumb1.jpg" title="First Picture"></picture>
 *          <picture src="img2.jpg" thumb="thumb2.jpg" title="Second Picture"></picture>
 *          <picture src="img3.jpg" thumb="thumb3.jpg" title="Third Picture"></picture>
 *      </slideshow>
 *  </a:model>
 *  
 *  <a:slideshow 
 *    title = "number+text" 
 *    delay = "5" 
 *    model = "mdlImages">
 *      <a:bindings>
 *          <a:src   match="[@src]"></a:src>
 *          <a:title match="[@title]"></a:title>
 *          <a:thumb match="[@thumb]"></a:thumb>
 *          <a:each match="[picture]"></a:each>
 *      </a:bindings>
 *  </a:slideshow>
 * </code>
 * 
 * @attribute {String} title           the description of the picture on the slide. 
 *                                     Default is "number".
 *   Possible values:
 *   number        the description contains only slide number on a list.
 *   text          the description contains only text added by creator.
 *   number+text   the description contains slide number on a list and text 
 *                 added by creator.
 *   
 * @attribute {Number}  delay          the delay between slides when the play 
 *                                     button is pressed. Default is 5 seconds.
 * @attribute {Number}  thumbheight    the vertical size of thumbnail bar. 
 *                                     Default is 50px.
 * @attribute {String}  defaultthumb   the thumbnail shown when a slide doesn't 
 *                                     have one.
 * @attribute {String}  defaultimage   the image shown when a slide doesn't have 
 *                                     an image.
 * @attribute {String}  defaulttitle   the text shown when a slide doesn't have 
 *                                     a description.
 * @attribute {String}  loadmsg        this text displayd while the picture is 
 *                                     loading.
 * @attribute {Boolean} scalewidth     whether the width of the thumbnail is 
 *                                     scaled relative to its height.
 * 
 * @inherits apf.Cache
 * @inherits apf.MultiselectBinding
 * 
 * @author      Lukasz Lipinski
 * @version     %I%, %G% 
 *
 * @define slideshow
 * @addnode elements
 * 
 * @define bindings
 * @allowchild src, title, thumb
 *
 * @binding src      Determines the url to image file.
 * @binding title    Determines the image description text.
 * @binding thumb    Determines the url to thumbnail file.
 */
apf.slideshow = function(struct, tagName){
    this.$init(tagName || "slideshow", apf.NODE_VISIBLE, struct);
    
    this.title            = "number";
    this.thumbheight      = 50;
    this.loadmsg          = null;
    this.defaultthumb     = null;
    this.defaultimage     = null;
    this.defaulttitle     = null;
    this.delay            = 5;
    this.scalewidth       = false;

    /**
     * Contains current selected node, next node to select in two directions
     * and last selected node
     */
    this.previous         = null,
    this.next             = null,
    this.current          = null,
    this.last             = null;
    
    /**
     * Determinates that component is currently loading any image or not
     */
    this.inuse            = false;
    
    /**
     * Determinates that slideshow is playing or not
     */
    this.play             = false;
    
    /**
     * Determinates that thumbnail bar is displayed or not
     */
    this.thumbnails       = true;

    /**
     * Keep the last selected image which is saved there when 
     * slideshow component is busy 
     */
    this.lastChoose       = null;
    
    /**
     * Height of title container
     */
    this.$vSpace          = 210;
    this.$hSpace          = 150;
    
    /* TIMERS */
    this.tmrShowLast      = null; //timer for showLast function
    this.tmrIsResized     = null; 
    this.tmrPlay          = null;
    this.tmrKeyDown       = null;
    this.tmrOnScroll      = null;
    this.tmrZoom          = null;
    this.tmrHoverDelay    = null;
    
    /* Used in zooming to keep size of scaled image */
    this.$imageWidth;
    this.$imageHeight;

    this.viewPortWidth    = 0;
    this.viewPortHeight   = 0;
    
    this.$zooming         = false;
    
    this.$oEmpty;
    
    this.$IEResizeCounter = 0;
    
    this.lastOverflow = null;
    
    /* this.$hide and this.$show function are not overwritten */
    this.$positioning = "basic";
};

(function() {
    this.implement(
        
        apf.DataAction
        
        //,apf.Cache
    );

    this.$supportedProperties.push("model", "thumbheight", "title", "loadmsg",
                                   "defaultthumb", "defaulttitle",
                                   "defaultimage", "scalewidth");
    
    this.$booleanProperties["scalewidth"] = true;

    this.$propHandlers["thumbheight"] = function(value) {
        if (parseInt(value))
            this.thumbheight = parseInt(value);
    };

    this.$propHandlers["delay"] = function(value) {
        if (parseInt(value))
            this.delay = parseInt(value);
    };

    /**
     * Prepare previous and next xml representation of slide element dependent
     * of actual slide
     */
    this.$setSiblings = function() {
        var temp_n = this.getNextTraverse(this.current),
            temp_p = this.getNextTraverse(this.current, true);

        this.next     = temp_n ? temp_n : this.getFirstTraverseNode();
        this.previous = temp_p ? temp_p : this.getLastTraverseNode();
    };
    
    /**
     * When slideshow is downloading some image, and user is trying to change it,
     * new image is saved and will be displayed later by this method
     */
    this.$showLast = function() {
        var _self = this;
        
        clearInterval(this.tmrShowLast);
        this.tmrShowLast = setInterval(function() {
            if (!_self.inuse) {
                if (_self.lastChoose) {
                    _self.current = _self.lastChoose;
                    _self.lastChoose = null;
                    
                    _self.$refresh();
                }
                clearInterval(_self.tmrShowLast);
            }
        }, 100);
    };
    
    this.$paint = function() {
        var _self = this;

        this.current = this.getFirstTraverseNode();

        //Prepare area
        this.oImage.src               = "about:blank";
        this.oThumbnails.style.height = 
        this.otBody.style.height      = 
        this.otPrevious.style.height  = 
        this.otNext.style.height      = this.thumbheight + "px";
       
        
        this.oLoading.innerHTML       = this.loadmsg 
            || apf.language.getWord("sub.slideshow.loadmsg") 
            || "Loading...";

        //This function will be called when selected image will be downloaded
        this.oImage.onload = function() {
            _self.last                     = _self.current;
            _self.oBody.style.display      = "block";
            _self.oImageBase.style.display = "block";
            _self.oImageBase.src           = _self.oImage.src;

            //Get Image size
            this.style.display = "block";
            
            var imgWidth  = _self.oImageBase.offsetWidth || _self.oImageBase.width;
            var imgHeight = _self.oImageBase.offsetHeight || _self.oImageBase.height;
            
            this.style.display             = "none";
            _self.oImageBase.style.display = "none";
            
            //Get browser window dimension
            var windowWidth = apf.isIE
                    ? document.documentElement.offsetWidth
                    : window.innerWidth;
                windowHeight = apf.isIE
                    ? document.documentElement.offsetHeight
                    : window.innerHeight;
            
            //Get height of the bottom panel
            var bottomPanel = _self.$getPanelSize();

            //Get body margins
            var oBodyDiff = apf.getDiff(_self.oBody);
            
            //is the image resized ?
            var checkWH = [false, false];
            
            //calculate viewport size
            var viewPortHeight = windowHeight - bottomPanel / 2 - _self.$vSpace,
                viewPortWidth  = windowWidth - _self.$hSpace;
            
            var _imgHeight = imgHeight,
                _imgWidth  = imgWidth;

            //if image height is bigger than body, scale it
            if (_imgHeight > viewPortHeight) {
                _imgWidth = parseInt(_imgWidth * (viewPortHeight / _imgHeight));
                _imgHeight = viewPortHeight;
            }
            
            if (_imgWidth > viewPortWidth) {
                _imgHeight = parseInt(_imgHeight * (viewPortWidth / _imgWidth));
                _imgWidth = viewPortWidth;
            }
            
            _self.viewPortHeight = _imgHeight;
            _self.viewPortWidth  = _imgWidth;

            //resize image body horizontaly
            apf.tween.single(_self.oBody, {
                steps    : apf.isGecko
                    ? 20
                    : (Math.abs(imgWidth - _self.oBody.offsetWidth) > 40
                        ? 10
                        : 3),
                anim     : apf.tween.EASEIN,
                type     : "mwidth",
                from     : _self.oBody.offsetWidth - oBodyDiff[0],
                to       : _imgWidth,
                onfinish : function() {
                    checkWH[0] = true;
                }
            });
            
            //Resize image body verticaly
            apf.tween.single(_self.oBody, {
                steps     : apf.isGecko
                    ? 20
                    : (Math.abs(imgHeight - _self.oBody.offsetHeight) > 40
                        ? 10
                        : 3),
                anim     : apf.tween.EASEIN,
                type     : "mheight",
                margin   : -1 * (bottomPanel / 2 - 10),
                from     : _self.oBody.offsetHeight - oBodyDiff[1],
                to       : _imgHeight,
                onfinish : function() {
                    checkWH[1] = true;
                }
            });
            
            _self.oImage.style.display = "block";
            _self.oImage.style.width   = _imgWidth + "px";
            _self.oImage.style.height  = _imgHeight + "px";
            _self.oImage.style.display = "none";

            //do some things when image body is resized
            clearInterval(_self.tmrIsResized);
            _self.tmrIsResized = setInterval(function() {
                if (checkWH[0] && checkWH[1]) {
                    clearInterval(_self.tmrIsResized);
                    
                    if (_self.current)
                        _self.$setSiblings();

                    //_self.oTitle.style.visibility   = "visible";
                    _self.oConsole.style.visibility = "visible";
                    
                    _self.oImage.style.display = "block";
                    _self.oTitle.style.display = "block";

                    _self.$checkThumbSize();

                    if (_self.thumbnails) {
                        _self.oThumbnails.style.display = "block";
                    }

                    apf.tween.single(_self.oImage, {
                        steps : 2,
                        type  : "fade",
                        from  : 0,
                        to    : 1
                    });

                    apf.tween.single(_self.oTitle, {
                        steps : 10,
                        type  : "fade",
                        from  : 0,
                        to    : 1
                    });

                    _self.inuse = false;
                    _self.addSelection();

                    if (_self.play) {
                        _self.$play();
                    }
                }
            }, 30);
        };
        
        //If something went wrong
        this.oImage.onerror = function() {
            _self.inuse = false;
        };

        this.oImage.onabort = function() {
            _self.inuse = false;
        };
        
        //_self.oImage.src = (_self.$applyBindRule("src", _self.current) 
        //    || _self.defaultimage || "about:blank");

        this.oContent.innerHTML = _self.title == "text"
            ? this.$applyBindRule("title", this.current)
            : (this.title == "number+text"
                ? "<b>" 
                    + (apf.language.getWord("sub.slideshow.image") || "Image")
                    + " "
                    + (this.getPos() + 1) 
                    + " " + (apf.language.getWord("sub.slideshow.of") || "of") + " "
                    + this.getTraverseNodes().length
                    + "</b><br />"
                    + (this.$applyBindRule("title", this.current)
                        || (this.defaulttitle 
                            ? this.defaulttitle 
                            : (apf.language.getWord("sub.slideshow.defaulttitle") || "No description")))
                : "Image " + (this.getPos() + 1)
                    + " of " + this.getTraverseNodes().length);
    };
    
    /**
     * Return image position on imagelist
     * 
     * @return {Number} image position
     */
    this.getPos = function() {
        return Array.prototype.indexOf.call(this.getTraverseNodes(), this.current);
    };
    
    /**
     * Adds selection to thumbnail of actual selected image and removes selection
     * from previous. When the "move" param is set, selected thumbnail
     * is always in displayed area.
     * 
     * @param {Number}   thumbnail bar scrolling direction
     *     Possible values:
     *     1    when thumbnails are scrolling in right
     *     -1   when thumbnails are scrolling in left
     */
    this.addSelection = function(move) {
        var htmlElement = apf.xmldb.findHtmlNode(this.current, this),
            ww          = apf.isIE
                ? document.documentElement.offsetWidth
                : window.innerWidth,
                
            diffp       = apf.getDiff(this.otPrevious),
            diffn       = apf.getDiff(this.otNext),
            bp          = parseInt(apf.getStyle(this.otPrevious, "width")),
            bn          = parseInt(apf.getStyle(this.otNext, "width")),
            ew          = parseInt(apf.getStyle(htmlElement, "width"));

        /* checking visiblity */
        if (htmlElement.offsetLeft + ew + 5 >
            ww - bp - bn - diffp[0] - diffn[0]) {
            if (move) {
                if (move > 0)
                    this.$tPrevious();
                else if (move < 0)
                    this.$tNext();
                this.addSelection(move);
            }
        }
        if (this.$selected)
            this.$selected.className = "ssPicBox";
        if (htmlElement)
            htmlElement.className = "ssPicBox ssselected";

        this.$selected = htmlElement;
    };

    /**
     * When xml representation of new image is set, function initiate redrawing
     */
    this.$refresh = function() {
        var _self = this;

        //When slideshow is downloading some image, and user is trying to change it,
        //new image is saved and will be displayed later
        if (this.inuse) {
            this.lastChoose = this.current;
            this.$showLast();

            return;
        }

        if (this.play)
            clearInterval(this.tmrPlay);
        
        this.$setSiblings();
        this.inuse = true;

        apf.tween.single(this.oImage, {
            steps : 5,
            type  : "fade",
            from  : 1,
            to    : 0
        });
        
        //Hack for Chrome
        this.oTitle.style.display = "block";
        
        apf.tween.single(this.oTitle, {
            steps    : 3,
            type     : "fade",
            from     : 1,
            to       : 0,
            onfinish : function() {
                _self.oImage.style.left       = "0px";
                _self.oImage.style.top        = "0px";
                var _src = (_self.$applyBindRule("src", _self.current) 
                           || _self.defaultimage || _self.defaultthumb);
                var _src_temp = _self.oImage.src;

                _self.oImage.src = _src;
                _self.oImage.style.display = "none";

                // Safari and Chrome fix for reloading current image
                if (_self.oImage.src == _src_temp && apf.isWebkit) {
                    _self.inuse = false;
                    apf.tween.single(_self.oImage, {
                        steps : 5,
                        type  : "fade",
                        from  : 0,
                        to    : 1
                    });
                    apf.tween.single(_self.oTitle, {
                        steps : 3,
                        type  : "fade",
                        from  : 0,
                        to    : 1
                    });
                    //_self.oTitle.style.visibility = "visible";
                }

                _self.oContent.innerHTML = _self.title == "text"
                    ? _self.$applyBindRule("title", _self.current)
                    : (_self.title == "number+text"
                        ? "<b>" + (apf.language.getWord("sub.slideshow.image") || "Image")
                            + " "
                            + (_self.getPos() + 1) 
                            + " " + (apf.language.getWord("sub.slideshow.of") || "of") + " "
                            + _self.getTraverseNodes().length
                            + "</b><br />"
                            + (_self.$applyBindRule("title", _self.current)
                               || (_self.defaulttitle 
                                   ? _self.defaulttitle 
                                   : apf.language.getWord("sub.slideshow.defaulttitle") || "No description" ))
                        : "Image " + (_self.getPos() + 1) + " of "
                            + _self.getTraverseNodes().length);
            }
        });
    };

    /**
     * Selects image by its xml representation
     * 
     * @param {XMLElement}   badge  xml representation of image
     */
    this.select = function(badge) {
        this.current = badge;
        this.$show();
    };
    
    /**
     * Hides browser scrollbars
     */
    this.$hideScrollbars = function() {
        this.lastOverflow = document.documentElement.style.overflow == "hidden"
            ? "auto"
            : document.documentElement.style.overflow;
            
        document.documentElement.style.overflow = "hidden";
    };
    
    /**
     * Shows browser scrollbars
     */
    this.$showScrollbars = function() {
        document.documentElement.style.overflow = this.lastOverflow;
    };
    
    
    this.$show = function() {
        var _self = this;
        
        this.$hideScrollbars();
        
        this.oBeam.style.display = "none";
        this.oBody.style.display = "none";
        this.$int.style.display  = "block";
        this.$ext.style.display  = "block";

        apf.tween.single(_self.oCurtain, {
            steps    : 10, 
            type     : "fade",
            from     : 0,
            to       : 0.7,
            onfinish : function() {
                _self.oBeam.style.display = "block";
                apf.tween.single(_self.oBeam, {
                    steps    : 10, 
                    type     : "fade",
                    from     : 0,
                    to       : 1,
                    onfinish : function() {
                        _self.oBody.style.display    = "block";
                        _self.oBody.style.width      = "100px";
                        _self.oBody.style.height     = "100px";
                        _self.oBody.style.marginLeft = "-50px";
                        _self.oBody.style.marginTop  = "-50px";
                        apf.tween.single(_self.oBody, {
                            steps    : 5, 
                            type     : "fade",
                            from     : 0,
                            to       : 1,
                            onfinish : function() {
                                if (apf.isIE) {
                                    _self.oBody.style.filter = "";
                                    _self.oBeam.style.filter = "";
                                }
                                _self.$refresh();
                            }
                        });
                    }
                });
            }
        });
    };
    
    /**** Init ****/

    /**
     * Display next image from imagelist
     */
    this.$Next = function() {
        this.current = this.next;
        this.addSelection(-1);
        this.$refresh();
    };

    /**
     * Display previous image from imagelist
     */
    this.$Previous = function() {
        this.current = this.previous;
        this.addSelection(1);
        this.$refresh();
    };
    
    /**
     * Move first thumbnail from the left to end of imagebar elementlist.
     * It's possible to scroll imagebar to infinity.
     */
    this.$tNext = function() {
       this.otBody.appendChild(this.otBody.childNodes[0]);
    };

    /**
     * Move last thumbnail to begining of imagebar elementlist.
     * It's possible to scroll imagebar to infinity.
     */
    this.$tPrevious = function() {
       this.otBody.insertBefore(
           this.otBody.childNodes[this.otBody.childNodes.length - 1],
           this.otBody.firstChild); 
    };
    
    /**
     * Starts the slide show
     */
    this.$play = function() {
         var _self = this;
         clearInterval(this.tmrPlay);
         this.tmrPlay = setInterval(function() {
             _self.play = true;
             if (_self.inuse)
                 return;

             _self.$Next();
         }, _self.delay * 1000);
    };

    /**
     * Stops the slide show
     */
    this.$stop = function() {
        clearInterval(this.tmrPlay);
        this.tmrPlay = null;
        this.play = false;
    };
    
    /**
     * Adds selection to thumbnail and shows the image.
     * 
     * @param {HTMLElement}   oThumb   html representation of thumbnail element
     */
    this.$clickThumb = function(oThumb) {
        this.current = apf.xmldb.getNode(oThumb);
        this.addSelection();
        this.$refresh();
    };
    
    this.$getPanelSize = function() {
        var title_height = this.oTitle.offsetHeight 
            || parseInt(apf.getStyle(this.oTitle, "height")) 
            + apf.getDiff(this.oTitle)[1];
        
        return Math.max(
            this.oBeam.offsetHeight, 
            title_height 
            + (this.thumbnails 
                ? this.thumbheight 
                : 0) 
            + this.oConsole.offsetHeight
        );
    };
    
    this.$resize = function() {
        //because resize event is called 2 times in IE
        if (apf.isIE) {
            this.$IEResizeCounter++;
        
            if (this.$IEResizeCounter == 2) {
                this.$IEResizeCounter = 0;
                return;
            }
        }

        var _self = this;

        _self.oImage.style.display = "none";
        
        var windowWidth = apf.isIE
                ? document.documentElement.offsetWidth
                : window.innerWidth,
            windowHeight = apf.isIE
                ? document.documentElement.offsetHeight
                : window.innerHeight;

        var imgWidth    = _self.oImageBase.offsetWidth || _self.oImageBase.width;
        var imgHeight   = _self.oImageBase.offsetHeight || _self.oImageBase.height;
        var oBodyDiff   = apf.getDiff(this.oBody);
        var bottomPanel = this.$getPanelSize();
        
        //calculate viewport size
        var viewPortHeight = windowHeight - bottomPanel / 2 - _self.$vSpace;
        var viewPortWidth = windowWidth - _self.$hSpace;
        
        var _imgHeight = imgHeight;
        var _imgWidth  = imgWidth;

        //if image height is bigger than body, scale it
        if (_imgHeight > viewPortHeight) {
            _imgWidth  = parseInt(_imgWidth * (viewPortHeight / _imgHeight));
            _imgHeight = viewPortHeight;
        }
        
        if (_imgWidth > viewPortWidth) {
            _imgHeight = parseInt(_imgHeight * (viewPortWidth / _imgWidth));
            _imgWidth  = viewPortWidth;
        }
        
        this.viewPortHeight = _imgHeight;
        this.viewPortWidth = _imgWidth;
        
        var checkWH = [false, false];
        
        //resize image body horizontaly
        apf.tween.single(_self.oBody, {
            steps    : 5,
            anim     : apf.tween.EASEIN,
            type     : "mwidth",
            from     : _self.oBody.offsetWidth - oBodyDiff[0],
            to       : _imgWidth,
            onfinish : function() {
                checkWH[0] = true;
            }
        });
        
        //Resize image body verticaly
        apf.tween.single(_self.oBody, {
            steps    : 5,
            anim     : apf.tween.EASEIN,
            type     : "mheight",
            margin   : -1 * (bottomPanel / 2 - 10),
            from     : _self.oBody.offsetHeight - oBodyDiff[1],
            to       : _imgHeight,
            onfinish : function() {
                checkWH[1] = true;
            }
        });
        
        clearInterval(_self.tmrIsResized);
        _self.tmrIsResized = setInterval(function() {
            if (checkWH[0] && checkWH[1]) {
                clearInterval(_self.tmrIsResized);

                _self.oImage.style.display = "block";
                _self.oImage.style.width   = _imgWidth + "px";
                _self.oImage.style.height  = _imgHeight + "px";

                apf.tween.single(_self.oImage, {
                    steps : 2,
                    type  : "fade",
                    from  : 0,
                    to    : 1
                });
            }
        }, 30);
    };

    /**
     * Creates html representation of slideshow elements based on skin file
     * and adds events to each one.
     */
    this.$draw = function() {
        //Build Main Skin
        this.$pHtmlNode  = document.body;
        
        this.$ext        = this.$getExternal();
        this.$int        = this.$getLayoutNode("main", "container", this.$ext);
        this.oCurtain    = this.$getLayoutNode("main", "curtain", this.$ext);
        this.oBody       = this.$getLayoutNode("main", "body", this.$ext);
        this.oContent    = this.$getLayoutNode("main", "content", this.$ext);
        this.oImage      = this.$getLayoutNode("main", "image", this.$ext);
        this.oImageBase  = this.$getLayoutNode("main", "image_base", this.$ext);
        this.oClose      = this.$getLayoutNode("main", "close", this.$ext);
        this.oBeam       = this.$getLayoutNode("main", "beam", this.$ext);
        this.oTitle      = this.$getLayoutNode("main", "title", this.$ext);
        this.oThumbnails = this.$getLayoutNode("main", "thumbnails", this.$ext);
        this.otBody      = this.$getLayoutNode("main", "tbody", this.$ext);
        this.otPrevious  = this.$getLayoutNode("main", "tprevious", this.$ext);
        this.otNext      = this.$getLayoutNode("main", "tnext", this.$ext);
        this.oLoading    = this.$getLayoutNode("main", "loading", this.$ext);
        this.oEmpty      = this.$getLayoutNode("main", "empty", this.$ext);
        this.oConsole    = this.$getLayoutNode("main", "console", this.$ext);
        this.oPrevious   = this.$getLayoutNode("main", "previous", this.$ext);
        this.oPlay       = this.$getLayoutNode("main", "play", this.$ext);
        this.oNext       = this.$getLayoutNode("main", "next", this.$ext);

        var _self = this;
        
        
        //@todo add this to $destroy
        var rules = "var o = apf.all[" + this.$uniqueId + "];\
                     if (o) o.$resize()";
        apf.layout.setRules(this.$pHtmlNode, this.$uniqueId + "_scaling",
                            rules, true);
        apf.layout.queue(this.$pHtmlNode);
        
        
        this.oPrevious.onclick =
        this.oNext.onclick = function(e) {
            if ((this.className || "").indexOf("ssprevious") != -1)
                _self.$Previous();
            else if ((this.className || "").indexOf("ssnext") != -1)
                _self.$Next();
        };
        
        var tmrThumbButton = null;
        this.otPrevious.onmousedown = function(e) {
            tmrThumbButton = setInterval(function() {
                _self.$tPrevious();
            }, 50);
        };

        this.otNext.onmousedown = function(e) {
            tmrThumbButton = setInterval(function() {
                _self.$tNext();
            }, 50);
        };

        this.otNext.onmouseover = function(e) {
            _self.$setStyleClass(_self.otNext, "ssnhover");
        };

        this.otPrevious.onmouseover = function(e) {
            _self.$setStyleClass(_self.otPrevious, "ssphover");
        }

        this.otNext.onmouseout = function(e) {
            _self.$setStyleClass(_self.otNext, "", ["ssnhover"]);
        };

        this.otPrevious.onmouseout = function(e) {
            _self.$setStyleClass(_self.otPrevious, "", ["ssphover"]);
        };
        
        this.oPlay.onclick = function(e) {
            if (_self.tmrPlay) {
                _self.$stop();
                _self.$setStyleClass(_self.oPlay, "", ["ssstop"]);
                _self.$setStyleClass(_self.oPlay, "ssplay");
                _self.oNext.style.visibility     = "visible";
                _self.oPrevious.style.visibility = "visible";
                _self.oThumbnails.style.display  = "block";
            }
            else {
                 _self.$play();
                 _self.$setStyleClass(_self.oPlay, "", ["ssplay"]);
                 _self.$setStyleClass(_self.oPlay, "ssstop");
                 _self.oNext.style.visibility     = "hidden";
                 _self.oPrevious.style.visibility = "hidden";
                 _self.oThumbnails.style.display  = "none";
            }
        };
        
        this.oClose.onclick = function() {
            //_self.visible = true;
            _self.$hide();
            _self.$showScrollbars();
        };

        document.onmouseup = function(e) {
            clearInterval(tmrThumbButton);
            return false;
        };

        this.oImage.onmouseover = function(e) {
            _self.inuse = true;
            
            var e = e || event;
            var target = e.target || e.srcElement;
            
            var imgWidth  = _self.oImageBase.offsetWidth || _self.oImageBase.width;
            var imgHeight = _self.oImageBase.offsetHeight || _self.oImageBase.height;
            
            var windowWidth = apf.isIE
                ? document.documentElement.offsetWidth
                : window.innerWidth;
            var windowHeight = apf.isIE
                ? document.documentElement.offsetHeight
                : window.innerHeight;

            var diff = apf.getDiff(_self.oBody);
            var posX = _self.oBody.offsetLeft + diff[0] / 2;
            var posY = _self.oBody.offsetTop  + diff[1] / 2;

            var dx = 0, dy = 0;
            var w, h, ml, mt;
            var sx = e.clientX - posX;
            var sy = e.clientY - posY;

            w = _self.$imageWidth = parseInt(_self.oImage.style.width);
            h = _self.$imageHeight = parseInt(_self.oImage.style.height);
            
            //wg tej wartosci ustale miejsce na duzym obrazku i bede wiedział wg jakiego punktu mam rozszerzać go
            var percent_posX = sx / _self.$imageWidth;
            var percent_posY = sy / _self.$imageHeight;
            
            this.onmousemove = function(e) {
                var e = e || event;

                sx = e.clientX - posX;
                sy = e.clientY - posY;

                percent_posX = sx / _self.$imageWidth;
                percent_posY = sy / _self.$imageHeight;
                
                if((_self.$imageWidth == parseInt(_self.oImage.style.width) 
                    && _self.$imageHeight == parseInt(_self.oImage.style.height)) || _self.$zooming) {
                    return;
                }

                ml = -1 * (percent_posX * w - sx);
                mt = -1 * (percent_posY * h - sy);

                if (ml <= 0 && ml >= -1 * (w - _self.viewPortWidth)) {
                    _self.oImage.style.left = ml + "px";
                }
                
                if (mt <= 0 && mt >= -1 * (h - _self.viewPortHeight)) {
                    _self.oImage.style.top = mt + "px";
                }
            };

            //little delay to run zooming
            clearInterval(_self.tmrHoverDelay);
            _self.tmrHoverDelay = setInterval(function() {
                clearInterval(_self.tmrHoverDelay);
                clearInterval(_self.tmrZoom);

                _self.tmrZoom = setInterval(function() {
                    _self.$zooming = true;
                        w     = parseInt(_self.oImage.style.width);
                        h     = parseInt(_self.oImage.style.height);
                    var l     = parseInt(_self.oImage.style.left);
                    var t     = parseInt(_self.oImage.style.top);
                    var ratio = apf.isIE ? 0.03 : 0.01;
                    
                    if (w < imgWidth) {
                        _self.oImage.style.width = (w + w * ratio) + "px";
                        _self.oImage.style.left  = -1 * (percent_posX * w - sx) + "px";
                    }
                    if (h < imgHeight) {
                        _self.oImage.style.height = (h + h * ratio) + "px";
                        _self.oImage.style.top    = -1 * (percent_posY * h - sy) + "px";
                    }
                    
                    if (w >= imgWidth && h >= imgHeight) {
                        clearInterval(_self.tmrZoom);
                        _self.$zooming = false;
                    }
                }, apf.isIE ? 5 : 10);

            }, 1000);
        };

        this.oImage.onmouseout = function(e) {
            _self.inuse = false;
            clearInterval(_self.tmrZoom);
            clearInterval(_self.tmrHoverDelay);
            
            _self.oImage.style.width  = _self.$imageWidth + "px";
            _self.oImage.style.height = _self.$imageHeight + "px";
            
            _self.oImage.style.top  = "0px";
            _self.oImage.style.left = "0px";
            
            document.onmousemove = null;
        };
        
        var SafariChromeFix = false;
        apf.addEventListener("mousescroll", function(e) {
            if (!_self.xmlRoot || _self.$ext.style.display == "none")
                return;
            
            e = e || event;
            if (apf.isWebkit) {
                SafariChromeFix = SafariChromeFix ? false : true;
                if (!SafariChromeFix)
                    return;
            }

            var delta  = e.delta;
            
            var curNode  = _self.current;
            var nextNode = _self.getNextTraverse(curNode);
            var prevNode = _self.getNextTraverse(curNode, true);

            _self.next     = nextNode ? nextNode : _self.getFirstTraverseNode();
            _self.previous = prevNode ? prevNode : _self.getLastTraverseNode();

            _self.current = delta < 0 ? _self.next : _self.previous;

            _self.addSelection(delta);

            if (_self.current !== curNode) {
                clearInterval(_self.tmrOnScroll);
                _self.tmrOnScroll = setInterval(function() {
                    _self.$refresh();
                    clearInterval(_self.tmrOnScroll);
                }, 400);
            };
            return false;
        });
        
        apf.addEventListener("onkeydown", function(e) {
            e = (e || event);
            
            //39 - Right Arrow
            //37 - Left Arrow
    
            var key     = e.keyCode;
            var curNode = _self.current;
            var nextNode = _self.getNextTraverse(curNode);
            var prevNode = _self.getNextTraverse(curNode, true);
    
            _self.next = nextNode 
                ? nextNode 
                : _self.getFirstTraverseNode();
            _self.previous = prevNode 
                ? prevNode 
                : _self.getLastTraverseNode();
            _self.current = key == 39 
                ? _self.next 
                : (key == 37 
                    ? _self.previous 
                    : _self.current);
    
            _self.addSelection(key == 39 ? -1 : (key == 37 ? 1 : 0));
    
            if (_self.current !== curNode) {
                clearInterval(_self.tmrKeyDown);
                _self.tmrKeyDown = setInterval(function() {
                    _self.$refresh();
                    clearInterval(_self.tmrKeyDown);
                }, 550);
            };
            return false;
        });
    };
    
    /**
     * Closes slideshow component
     */
    this.$hide = function () {
        var _self = this;

        _self.$ext.style.display = "block";

        apf.tween.single(_self.oBody, {
            steps    : 10, 
            type     : "fade",
            from     : 1,
            to       : 0,
            onfinish : function() {
                _self.oBody.style.display = "none";
            }
        });
        
        apf.tween.single(_self.oBeam, {
            steps    : 10, 
            type     : "fade",
            from     : 1,
            to       : 0,
            onfinish : function() {
                _self.oBeam.style.display = "none";
                
                apf.tween.single(_self.oCurtain, {
                    steps    : 10, 
                    type     : "fade",
                    from     : 0.7,
                    to       : 0,
                    onfinish : function() {
                        _self.$int.style.display  = "none";
                        _self.$ext.style.display  = "none";
                    }
                });
            }
        });
    };
    
    this.$checkThumbSize = function() {
        var nodes = this.getTraverseNodes();
        var nodes_len = nodes.length;
        
        var picBoxes = this.otBody.childNodes;
        var picBoxed_len = picBoxes.length;
        
        var widthSum = 0;
        
        var boxDiff, srcThumb, htmlPicBox, h, w, bh, testImg, counter = 0;

        for (var i = 0; i < picBoxed_len; i++) {
            if ((picBoxes[i].className || "").indexOf("ssPicBox") > -1) {
                htmlPicBox = picBoxes[i];

                srcThumb = this.$applyBindRule("thumb", nodes[counter]);
                boxDiff = apf.getDiff(htmlPicBox);
                bh = this.thumbheight - 10 - boxDiff[1];
    
                if (this.scalewidth) {
                    testImg = new Image();
                    document.body.appendChild(testImg);

                    testImg.src = srcThumb ? srcThumb : this.defaultthumb;
                    
                    h = bh;
                    if (testImg.height < bh) {
                        w = testImg.width;
                    }
                    else {
                        testImg.setAttribute("height", bh);
                        w = testImg.width;
                    }
                    document.body.removeChild(testImg);
                }
                else {
                    h = w = bh;
                }
    
                widthSum += w + boxDiff[0]
                         + (parseInt(apf.getStyle(htmlPicBox, "margin-left")
                             || apf.getStyle(htmlPicBox, "marginLeft")))
                         + (parseInt(apf.getStyle(htmlPicBox, "margin-right")
                             || apf.getStyle(htmlPicBox, "marginRight")));
    
                htmlPicBox.style.width = w + "px";
                counter++;
            }
        }

        var thumbDiff = apf.getDiff(this.otBody);

        this.otPrevious.style.visibility = this.otNext.style.visibility =
            widthSum < this.oThumbnails.offsetWidth - thumbDiff[0]
                ? "hidden"
                : "visible";
    };

    this.$load = function(xmlRoot) {
        apf.xmldb.addNodeListener(xmlRoot, this);
        
        var nodes = this.getTraverseNodes();
        var nodes_len = nodes.length;
        
        var boxDiff, srcThumb, htmlPicBox, h, w, bh, testImg = null;
        for (var i = 0; i < nodes_len; i++) {
            //Create box for thumbnail
            htmlPicBox = this.otBody.appendChild(document.createElement("div"));
            //Get source path to thumbnail image
            srcThumb = this.$applyBindRule("thumb", nodes[i]);

            htmlPicBox.style.backgroundImage = 'url(' + (srcThumb ? srcThumb : this.defaultthumb) +  ')';
            
            htmlPicBox.className = "ssPicBox";
            boxDiff = apf.getDiff(htmlPicBox);
            
            bh = this.thumbheight - 10 - boxDiff[1];
            
            if (this.scalewidth) {
                testImg = new Image();
                document.body.appendChild(testImg);

                testImg.src = srcThumb ? srcThumb : this.defaultthumb;
                
                h = bh;
                if (testImg.height < bh) {
                    w = testImg.width;
                }
                else {
                    testImg.setAttribute("height", bh);
                    w = testImg.width;
                }
                document.body.removeChild(testImg);
            }
            else {
                h = w = bh;
            }
            
            htmlPicBox.style.height    = h + "px";
            htmlPicBox.style.width     = w + "px";
            htmlPicBox.style.marginTop = htmlPicBox.style.marginBottom = "5px";

            apf.xmldb.nodeConnect(this.documentId, nodes[i], htmlPicBox, this);

            var _self = this;
            htmlPicBox.onclick = function(e) {
                _self.$clickThumb(this);
            }
        }

        
        if (nodes_len != this.length)
            this.setProperty("length", nodes_len);
        

        this.$paint();
    }
    
    this.addEventListener("$clear", function(){return false});

    this.$destroy = function() {
        this.otNext.onmouseover =
        this.otPrevious.onmouseover =
        this.otNext.onmouseout =
        this.otPrevious.onmouseout =
        this.$ext.onresize =
        this.oImage.onmousedown =
        this.otNext.onmousedown =
        this.otPrevious.onmousedown =
        this.oNext.onclick =
        this.oPrevious.onclick = null;

        //this.removeEventListener("onkeydown", onkeydown_);
        //this.removeEventListener("mousescroll", onmousescroll_);

        this.x = null;
    };

    this.$setClearMessage = function(msg, className) {
        var ww = apf.isIE
            ? document.documentElement.offsetWidth
            : window.innerWidth;
        var bp = parseInt(apf.getStyle(this.otPrevious, "width"));
        var bn = parseInt(apf.getStyle(this.otNext, "width"));
        var ew = parseInt(apf.getStyle(this.oEmpty, "width"));
        
        this.$oEmpty = this.oCurtain.appendChild(this.oEmpty.cloneNode(true));

        apf.setNodeValue(this.$oEmpty, msg || "");

        this.$oEmpty.setAttribute("id", "empty" + this.$uniqueId);
        this.$oEmpty.style.display = "block";
        this.$oEmpty.style.left = ((ww - ew) / 2 - bp - bn) + "px";
        apf.setStyleClass(this.$oEmpty, className, ["ssloading", "ssempty", "offline"]);
    };

    this.$removeClearMessage = function() {
        if (!this.$oEmpty)
            this.$oEmpty = document.getElementById("empty" + this.$uniqueId);
        if (this.$oEmpty && this.$oEmpty.parentNode)
            this.$oEmpty.parentNode.removeChild(this.$oEmpty);
    };

    this.$setCurrentFragment = function(fragment) {
        this.otBody.appendChild(fragment);

        this.dataset = fragment.dataset;

        if (!apf.window.hasFocus(this))
            this.blur();
    };

    this.$getCurrentFragment = function() {
        var fragment = document.createDocumentFragment();

        while (this.otBody.childNodes.length) {
            fragment.appendChild(this.otBody.childNodes[0]);
        }
        fragment.dataset = this.dataset;

        return fragment;
    };


}).call(apf.slideshow.prototype = new apf.MultiselectBinding());


apf.aml.setElement("slideshow", apf.slideshow);

apf.aml.setElement("src",   apf.BindingRule);
apf.aml.setElement("title", apf.BindingRule);
apf.aml.setElement("thumb", apf.BindingRule);


/*FILEHEAD(/var/lib/platform/source/trunk/elements/scrollbar.js)SIZE(15384)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



//@todo: fix the stuff with all the uppercase variable and function names...wazzup?

/**
 * This library needs to be refactored.
 * @constructor
 * @private
 */
apf.scrollbar = function(struct, tagName){
    this.$init(tagName || "scrollbar", apf.NODE_VISIBLE, struct);
};

(function(){
    this.realtime = true;
    
    this.$scrollValue  = 0;
    this.$stepValue    = 0.03;
    this.$bigStepValue = 0.1;
    this.$curValue     = 0;
    this.$timer        = null;
    this.$scrollWait;
    this.$slideMaxHeight;
    
    this.addEventListener("focus", function(){
        this.$host.host.focus();
    });
    
    this.attach = function(oHtml, o, scroll_func){
        this.$host     = o;
        this.$onscroll = scroll_func;
        this.$viewheight     = oHtml.offsetHeight;
        this.$scrollheight   = this.$viewheight;
        this.$attachedHtml   = oHtml;
        
        oHtml.parentNode.appendChild(this.$ext);
        if (this.overflow == "scroll")
            this.$ext.style.display = "block";
        this.$ext.style.zIndex  = 100000;
        //this.$ext.style.left    = "166px";//(o.offsetLeft + o.offsetWidth) + "px";
        //this.$ext.style.top     = "24px";//o.offsetTop + "px";
        //this.$ext.style.height  = "160px";//o.offsetHeight + "px";
        
        //@todo use the main one on the document
        var _self = this;
        function wheel(e){
            if (!e) 
                e = event;
                
            var delta = null;
            if (e.wheelDelta) {
                delta = e.wheelDelta / 120;
                if (apf.isOpera)
                    delta *= -1;
            }
            else if (e.detail)
                delta = -e.detail / 3;
    
            if (delta !== null) {
                var ev = {delta: delta};
                var res = apf.dispatchEvent("mousescroll", ev);
                if (res === false || ev.returnValue === false) {
                    if (e.preventDefault)
                        e.preventDefault();
    
                    e.returnValue = false;
                }
            }
    
                
            _self.$stepValue = (o.limit / o.length) / 5;
            _self.$curValue += ((apf.isOpera ? 1 : -1) * delta * _self.$stepValue);
            _self.setScroll(true);
            
            if (e.preventDefault)
                e.preventDefault();
            return false;
        }
        
        if (document.addEventListener)
            document.addEventListener('DOMMouseScroll', wheel, false);
        else 
            oHtml.onmousewheel = wheel;
        
        this.$scrollWait     = 0;//(this.$host.len * COLS)/2;
        this.$slideMaxHeight = this.$ext.offsetHeight - this.$btnDown.offsetHeight - this.$btnUp.offsetHeight;
        this.$stepValue      = (this.$viewheight / this.$scrollheight) / 20;
        this.$bigStepValue   = this.$stepValue * 3;
        
        //this.$viewheight / this.$scrollheight
        if (o.length) {
            this.$caret.style.height = Math.max(5, ((o.limit / o.length)
                * this.$slideMaxHeight)) + "px";
            if (this.$caret.offsetHeight - 4 == this.$slideMaxHeight) 
                this.$ext.style.display = "none";
        }
        
        return this;
    };
    
    this.setScroll = function (timed, noEvent){
        if (this.$curValue > 1) 
            this.$curValue = 1;
        if (this.$curValue < 0) 
            this.$curValue = 0;
        this.$caret.style.top = (this.$btnUp.offsetHeight + (this.$ext.offsetHeight
            - (this.$btnUp.offsetHeight * 2) - this.$caret.offsetHeight) * this.$curValue) + "px";

        //status = this.$curValue;
        this.pos = this.$curValue;//(this.$caret.offsetTop-this.$btnUp.offsetHeight)/(this.$slideMaxHeight-this.$caret.offsetHeight);
        if (!noEvent)
            this.$onscroll(timed, this.pos);
    }
    
    this.scrollUp = function (v){
        if (v > this.$caret.offsetTop) 
            return this.$ext.onmouseup();
        this.$curValue -= this.$bigStepValue;
        this.setScroll();
        
        this.$slideFast.style.height = Math.max(1, this.$caret.offsetTop
            - this.$btnUp.offsetHeight) + "px";
        this.$slideFast.style.top    = this.$btnUp.offsetHeight + "px";
    }
    
    this.scrollDown = function (v){
        if (v < this.$caret.offsetTop + this.$caret.offsetHeight) 
            return this.$ext.onmouseup();
        this.$curValue += this.$bigStepValue;
        this.setScroll();
        
        this.$slideFast.style.top    = (this.$caret.offsetTop + this.$caret.offsetHeight) + "px";
        this.$slideFast.style.height = Math.max(1, this.$ext.offsetHeight - this.$slideFast.offsetTop
            - this.$btnUp.offsetHeight) + "px";
    }
    
    this.getPosition = function(){
        return this.pos;
    };
    
    this.setPosition = function(pos, noEvent){
        this.$curValue = pos;
        setScroll(null, noEvent);
    };
    
    this.update = function(oHtml){
        var oHtml = this.$attachedHtml;
        this.$ext.style.left = (oHtml.offsetLeft + oHtml.offsetWidth + 1) + 'px';
        this.$ext.style.top = (oHtml.offsetTop - 1) + 'px';
        this.$ext.style.height = (oHtml.offsetHeight - 2) + 'px';
        
        var o = this.$host;
        if (o.length) {
            this.$ext.style.display = "block";
            
            o.initialLimit = 0;
            o.findNewLimit();

            var indHeight;
            this.$slideMaxHeight = this.$ext.offsetHeight - this.$btnDown.offsetHeight - this.$btnUp.offsetHeight;
            this.$caret.style.height = ((indHeight = Math.max(10, (((o.limit - 1) / o.length)
                * this.$slideMaxHeight))) - apf.getHeightDiff(this.$caret)) + "px";
            this.$caret.style.top = (this.$curValue * (this.$slideMaxHeight - Math.round(indHeight)) + this.$btnUp.offsetHeight) + "px";
            
            this.$stepValue = (o.limit / o.length) / 20;
            this.$bigStepValue   = this.$stepValue * 3;
        }
        
        if (!o.length || o.limit >= o.length && oHtml.scrollHeight < oHtml.offsetHeight) {
            if (this.overflow == "scroll") {
                this.$caret.style.display = "none";
                this.disable();
            }
            else {
                this.$ext.style.display = "none";
            }
            
            oHtml.style.overflowY = "visible";
        }
        else {
            if (this.overflow == "scroll") {
                this.$caret.style.display = "block";
                this.enable();
            }
            else {
                this.$ext.style.display = "block";
                this.$caret.style.display = "block";
            }
            
            oHtml.style.overflowY = "scroll";
        }
        
        //this.$ext.style.top    = "-2px";
        //this.$ext.style.right  = 0;

        /*if (this.$ext.parentNode.offsetHeight)
            this.$ext.style.height = "400px";//(this.$ext.parentNode.offsetHeight - 20) + "px";
        else 
            this.$ext.style.height = "100%"*/
    }
    
    this.updatePos = function(){
        var o = this.$host;
        var indHeight = Math.round(Math.max(10, (((o.limit - 1) / o.length) * this.$slideMaxHeight)));
        this.$caret.style.top = (this.$curValue * (this.$slideMaxHeight - indHeight) + this.$btnUp.offsetHeight) + "px";
    }
    
    this.$onscroll = function(timed, perc){
        this.$host.scrollTop = (this.$host.scrollHeight - this.$host.offsetHeight + 4) * this.$curValue;
        /*var now = new Date().getTime();
         if (timed && now - this.$host.last < (timed ? this.$scrollWait : 0)) return;
         this.$host.last = now;
         var value = parseInt((DATA.length - this.$host.len + 1) * this.$curValue);
         showData(value);*/
    }
    
    this.$draw = function(){
        //Build Skin
        this.$getNewContext("main");
        this.$ext               = this.$getExternal();
        this.$ext.style.display = "none";
        
        this.$caret   = this.$getLayoutNode("main", "indicator", this.$ext);
        this.$slideFast   = this.$getLayoutNode("main", "slidefast", this.$ext);
        this.$btnUp       = this.$getLayoutNode("main", "btnup",     this.$ext)
        this.$btnDown     = this.$getLayoutNode("main", "btndown",   this.$ext);

        this.$startPos    = false;
        
        this.$caret.ondragstart = function(){
            return false
        };
        
        var _self = this;
        
        //document.getElementById('this.$btnUp').ondblclick = 
        this.$btnUp.onmousedown = function(e){
            if (!e) 
                e = event;
            this.className = "btnup btnupdown";
            clearTimeout(_self.$timer);
            
            _self.$curValue -= _self.$stepValue;
            
            _self.setScroll();
            e.cancelBubble = true;
            
            apf.window.$mousedown();
            
            _self.$timer = $setTimeout(function(){
                _self.$timer = setInterval(function(){
                    _self.$curValue -= _self.$stepValue;
                    _self.setScroll();
                }, 20);
            }, 300);
        };
        
        //document.getElementById('this.$btnDown').ondblclick = 
        this.$btnDown.onmousedown = function(e){
            if (!e) 
                e = event;
            this.className = "btndown btndowndown";
            clearTimeout(_self.$timer);
            
            _self.$curValue += _self.$stepValue;
            _self.setScroll();
            e.cancelBubble = true;
            
            apf.window.$mousedown();
            
            _self.$timer = $setTimeout(function(){
                _self.$timer = setInterval(function(){
                    _self.$curValue += _self.$stepValue;
                    _self.setScroll();
                }, 20);
            }, 300);
        };
        
        this.$btnUp.onmouseout = this.$btnUp.onmouseup = function(){
            this.className = "btnup";
            clearInterval(_self.$timer);
        };
        
        this.$btnDown.onmouseout = this.$btnDown.onmouseup = function(){
            this.className = "btndown";
            clearInterval(_self.$timer);
        };
        
        this.$caret.onmousedown = function(e){
            if (!e) 
                e = event;
            _self.$startPos = [e.offsetX, e.offsetY + _self.$btnUp.offsetHeight];
    
            if (this.setCapture)
                this.setCapture();
    
            document.onmousemove = function(e){
                if (!e) 
                    e = event;
                //if(e.button != 1) return _self.onmouseup();
                if (!_self.$startPos) 
                    return false;
                
                var next = _self.$btnUp.offsetHeight + (e.clientY - _self.$startPos[1]
                    - apf.getAbsolutePosition(_self.$ext)[1] - 2);
                var min = _self.$btnUp.offsetHeight;
                if (next < min) 
                    next = min;
                var max = (_self.$ext.offsetHeight - (_self.$btnUp.offsetHeight) - _self.$caret.offsetHeight);
                if (next > max) 
                    next = max;
                //_self.$caret.style.top = next + "px"
                
                _self.$curValue = (next - min) / (max - min);
                //setTimeout(function(){
                    _self.setScroll(true);
                //});
            };
            
            document.onmouseup = function(){
                _self.$startPos = false;
                if (!_self.realtime)
                    _self.setScroll();
                
                if (this.releaseCapture)
                    this.releaseCapture();
                
                document.onmouseup   = 
                document.onmousemove = null;
            };
    
            e.cancelBubble = true;
            apf.window.$mousedown();
            
            return false;
        };
        
        this.$ext.onmousedown = function(e){
            if (!e) 
                e = event;
            clearInterval(_self.$timer);
            var offset;
            
            if (e.offsetY > _self.$caret.offsetTop + _self.$caret.offsetHeight) {
                _self.$curValue += _self.$bigStepValue;
                _self.setScroll(true);
                
                _self.$slideFast.style.display = "block";
                _self.$slideFast.style.top     = (_self.$caret.offsetTop
                    + _self.$caret.offsetHeight) + "px";
                _self.$slideFast.style.height  = (_self.$ext.offsetHeight - _self.$slideFast.offsetTop
                    - _self.$btnUp.offsetHeight) + "px";
                
                offset = e.offsetY;
                _self.$timer = $setTimeout(function(){
                    _self.$timer = setInterval(function(){
                        _self.scrollDown(offset);
                    }, 20);
                }, 300);
            }
            else if (e.offsetY < _self.$caret.offsetTop) {
                _self.$curValue -= _self.$bigStepValue;
                _self.setScroll(true);
                
                _self.$slideFast.style.display = "block";
                _self.$slideFast.style.top = _self.$btnUp.offsetHeight + "px";
                _self.$slideFast.style.height = (_self.$caret.offsetTop - _self.$btnUp.offsetHeight) + "px";
                
                offset = e.offsetY;
                _self.$timer = $setTimeout(function(){
                    _self.$timer = setInterval(function(){
                        _self.scrollUp(offset);
                    }, 20);
                }, 300);
            }
        };
        
        this.$ext.onmouseup = function(){
            clearInterval(_self.$timer);
            if (!_self.realtime)
                _self.setScroll();
            _self.$slideFast.style.display = "none";
        };
    }
}).call(apf.scrollbar.prototype = new apf.Presentation());
apf.aml.setElement("scrollbar", apf.scrollbar);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/bindingloadrule.js)SIZE(1529)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @todo docs
 */
apf.BindingLoadRule = function(struct, tagName){
    this.$init(tagName, apf.NODE_HIDDEN, struct);
};

(function(){
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        get   : 1
    }, this.$attrExcludePropBind);

    this.$propHandlers["get"] = function(value, prop){
        delete this["c" + prop];
    }
}).call(apf.BindingLoadRule.prototype = new apf.BindingRule());

apf.aml.setElement("load", apf.BindingLoadRule);
apf.aml.setElement("insert", apf.BindingLoadRule);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/button.js)SIZE(27655)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */





/**
 * Element displaying a clickable rectangle that visually confirms to the
 * user when the area is clicked and then executes a command.
 *
 * @constructor
 * @define button, submit, trigger, reset
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @inherits apf.BaseButton
 */
apf.submit  = function(struct, tagName){
    this.$init(tagName || "submit", apf.NODE_VISIBLE, struct);
};

apf.trigger = function(struct, tagName){
    this.$init(tagName || "trigger", apf.NODE_VISIBLE, struct);
};

apf.reset   = function(struct, tagName){
    this.$init(tagName || "reset", apf.NODE_VISIBLE, struct);
};

apf.button  = function(struct, tagName){
    this.$init(tagName || "button", apf.NODE_VISIBLE, struct);
};

(function() {
    this.$useExtraDiv;
    this.$childProperty  = "caption";
    this.$inited         = false;
    this.$isLeechingSkin = false;
    this.$canLeechSkin   = true;

    /**** Properties and Attributes ****/

    this.$focussable = true; // This object can get the focus
    this.value       = null;
    
    this.$init(function(){
        //@todo reparenting
        var forceFocus, _self = this;
        this.$propHandlers["default"] = function(value){
            if (!this.focussable && value || forceFocus)
                this.setAttribute("focussable", forceFocus = value);

            this.parentNode.removeEventListener("focus", setDefault);
            this.parentNode.removeEventListener("blur", removeDefault);
    
            if (!value)
                return;
    
            //Currrently only support for parentNode, this might need to be expanded
            this.parentNode.addEventListener("focus", setDefault);
            this.parentNode.addEventListener("blur", removeDefault);
        };
    
        function setDefault(e){
            if (e.defaultButtonSet || e.returnValue === false)
                return;
    
            e.defaultButtonSet = true;
    
            if (this.$useExtraDiv)
                _self.$ext.appendChild(apf.button.$extradiv);
    
            _self.$setStyleClass(_self.$ext, _self.$baseCSSname + "Default");
    
            if (e.srcElement != _self && _self.$focusParent) {
                _self.$focusParent.addEventListener("keydown", btnKeyDown);
            }
        }
    
        function removeDefault(e){
            if (this.$useExtraDiv && apf.button.$extradiv.parentNode == _self.$ext)
                _self.$ext.removeChild(apf.button.$extradiv);
    
            _self.$setStyleClass(_self.$ext, "", [_self.$baseCSSname + "Default"]);
    
            if (e.srcElement != _self && _self.$focusParent) {
                _self.$focusParent.removeEventListener("keydown", btnKeyDown);
            }
        }
    
        function btnKeyDown(e){
            var ml;
    
            var f = apf.document.activeElement;
            if (f) {
                if (f.hasFeature(apf.__MULTISELECT__))
                    return;
    
                ml = f.multiline;
            }
    
            if (!_self.$ext.onmouseup)
                return;
    
            if (ml && ml != "optional" && e.keyCode == 13
              && e.ctrlKey || (!ml || ml == "optional")
              && e.keyCode == 13 && !e.ctrlKey && !e.shiftKey && !e.altKey)
                _self.$ext.onmouseup(e.htmlEvent, true);
        }
    
        this.addEventListener("focus", setDefault);
        this.addEventListener("blur", removeDefault);
        
        this.$enable = function(){
            if (this["default"]) {
                setDefault({});
                if (apf.document.activeElement)
                    apf.document.activeElement.focus(true);
            }
            if (this.state && this.value) {
                this.$setState("Down", {});
            }
    
            this.$doBgSwitch(1);
        };
    
        this.$disable = function(){
            if (this["default"])
                removeDefault({});
    
            this.$doBgSwitch(4);
            this.$setStyleClass(this.$ext, "",
                [this.$baseCSSname + "Over", this.$baseCSSname + "Down"]);
        };
    });

    /**
     * @attribute {String}  icon     the url from which the icon image is loaded.
     * @attribute {Boolean} state    whether this boolean is a multi state button.
     * @attribute {String}  value    the initial value of a state button.
     * @attribute {String}  tooltip  the text displayed when a user hovers with the mouse over the element.
     * @attribute {String}  color    the text color of the caption of this element.
     * @attribute {String}  caption  the text displayed on this element indicating the action when the button is pressed.
     * @attribute {String}  action   one of the default actions this button can perform when pressed.
     *   Possible values:
     *   undo     Executes undo on the action tracker of the target element.
     *   redo     Executes redo on the action tracker of the target element.
     *   remove   Removes the selected node(s) of the target element.
     *   add      Adds a node to the target element.
     *   rename   Starts the rename function on the target element.
     *   login    Calls log in on the auth element with the values of the textboxes of type username and password.
     *   logout   Calls lot out on the auth element.
     *   submit   Submits the data of a model specified as the target.
     *   ok       Executes a commitTransaction() on the target element, and closes or hides that element.
     *   cancel   Executes a rollbackTransaction() on the target element, and closes or hides that element.
     *   apply    Executes a commitTransaction() on the target element.
     *   close    Closes the target element.
     * @attribute {String}  target   id of the element to apply the action to. Defaults to the parent container.
     * @attribute {String}  default  whether this button is the default action for the containing window.
     * @attribute {String}  submenu  the name of the contextmenu to display when the button is pressed.
     */
    this.$booleanProperties["default"] = true;
    this.$supportedProperties.push("icon", "value", "tooltip", "state",
        "color", "caption", "action", "target", "default", "submenu");

    this.$propHandlers["icon"] = function(value){
        
        if (!this.oIcon)
            return apf.console.warn("No icon defined in the Button skin", "button");
        

        if (value)
            this.$setStyleClass(this.$ext, this.$baseCSSname + "Icon");
        else
            this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Icon"]);

        apf.skins.setIcon(this.oIcon, value, this.iconPath);
    };

    this.$propHandlers["value"] = function(value){
        if (value === undefined)
            value = !this.value;
        this.value = value;

        if (this.value)
            this.$setState("Down", {});
        else
            this.$setState("Out", {});
    };

    this.$propHandlers["tooltip"] = function(value){
        this.$ext.setAttribute("title", value);
    };

    this.$propHandlers["state"] = function(value){
        this.$setStateBehaviour(value == 1);
    };

    this.$propHandlers["color"] = function(value){
        if (this.oCaption)
            this.oCaption.parentNode.style.color = value;
    };

    this.$propHandlers["caption"] = function(value){
        if (value)
            this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Empty"]);
        else
            this.$setStyleClass(this.$ext, this.$baseCSSname + "Empty");

        if (this.oCaption)
            this.oCaption.nodeValue = String(value || "").trim();
    };

    

    //@todo move this to menu.js
    function menuKeyHandler(e){
        return;
        var key = e.keyCode;

        var next, nr = apf.getChildNumber(this);
        if (key == 37) { //left
            next = nr == 0
                ? this.parentNode.childNodes.length - 1
                : nr - 1;
            this.parentNode.childNodes[next].dispatchEvent("mouseover");
        }
        else if (key == 39) { //right
            next = (nr >= this.parentNode.childNodes.length - 1)
                ? 0
                : nr + 1;
            this.parentNode.childNodes[next].dispatchEvent("mouseover");
        }
    }

    function menuDown(e){
        var menu = self[this.submenu];

        this.value = !this.value;

        if (this.value)
            this.$setState("Down", {});

        
        if (!menu) {
            throw new Error(apf.formatErrorString(0, this,
                "Showing submenu",
                "Could not find submenu '" + this.submenu + "'"));
        }
        

        if (!this.value) {
            menu.hide();
            this.$setState("Over", {}, "toolbarover");

            this.parentNode.menuIsPressed = false;
            if (this.parentNode.hasMoved)
                this.value = false;

            if (apf.hasFocusBug)
                apf.window.$focusfix();

            return false;
        }

        this.parentNode.menuIsPressed = this;

        var pos = apf.getAbsolutePosition(this.$ext, menu.$ext.offsetParent);
        menu.display(pos[0],
            pos[1] + this.$ext.offsetHeight, false, this,
            null, null, this.$ext.offsetWidth - 2);

        this.parentNode.hasMoved = false;

        e.htmlEvent.cancelBubble = true;

        return false;
    }

    function menuOver(){
        var menuPressed = this.parentNode.menuIsPressed;

        if (!menuPressed || menuPressed == this)
            return;

        menuPressed.setValue(false);
        var oldMenu = self[menuPressed.submenu];
        oldMenu.$propHandlers["visible"].call(oldMenu, false, true);//.hide();

        this.setValue(true);
        this.parentNode.menuIsPressed = this;

        var menu = self[this.submenu];

        
        if (!menu) {
            throw new Error(apf.formatErrorString(0, this,
                "Showing submenu",
                "Could not find submenu '" + this.submenu + "'"));
        }
        

        var pos = apf.getAbsolutePosition(this.$ext, menu.$ext.offsetParent);

        menu.display(pos[0],
            pos[1] + this.$ext.offsetHeight, true, this,
            null, null, this.$ext.offsetWidth - 2);

        //apf.window.$focus(this);
        this.$focus();

        this.parentNode.hasMoved = true;

        return false;
    }

    /**
     * @attribute {string} submenu If this attribute is set, the button will
     * function like a menu button
     */
    this.$propHandlers["submenu"] = function(value){
        if (!value){
            if (this.value && this.parentNode)
                menuDown.call(this);

            this.$focussable = true;
            this.$setNormalBehaviour();
            this.removeEventListener("mousedown", menuDown);
            this.removeEventListener("mouseover", menuOver);
            this.removeEventListener("keydown", menuKeyHandler, true);
            return;
        }

        this.$focussable = false;
        this.$setStateBehaviour();

        this.addEventListener("mousedown", menuDown);
        this.addEventListener("mouseover", menuOver);
        this.addEventListener("keydown", menuKeyHandler, true);
    };
    

    /**** Public Methods ****/

    

    /**
     * Sets the value of this element. This should be one of the values
     * specified in the values attribute.
     * @param {String} value the new value of this element
     */
    this.setValue = function(value){
        this.setProperty("value", value, false, true);
    };

    /**
     * Sets the text displayed as caption of this element.
     *
     * @param  {String}  value  required  The string to display.
     * @see    baseclass.validation
     */
    this.setCaption = function(value){
        this.setProperty("caption", value, false, true);
    };

    /**
     * Sets the URL of the icon displayed on this element.
     *
     * @param  {String}  value  required  The URL to the location of the icon.
     * @see    element.button
     * @see    element.modalwindow
     */
    this.setIcon = function(url){
        this.setProperty("icon", url, false, true);
    };
    
    

    /**** Private state methods ****/

    this.$setStateBehaviour = function(value){
        this.value     = value || false;
        this.isBoolean = true;
        this.$setStyleClass(this.$ext, this.$baseCSSname + "Bool");

        if (this.value) {
            this.$setStyleClass(this.$ext, this.$baseCSSname + "Down");
            this.$doBgSwitch(this.states["Down"]);
        }
    };

    this.$setNormalBehaviour = function(){
        this.value     = null;
        this.isBoolean = false;
        this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Bool"]);
    };

    this.$setState = function(state, e, strEvent){
        if (this.disabled)
            return;

        if (strEvent && this.dispatchEvent(strEvent, {htmlEvent: e}) === false)
            return;

        this.$doBgSwitch(this.states[state]);
        var bs = this.$baseCSSname;
        this.$setStyleClass(this.$ext, (state != "Out" ? bs + state : ""),
            [(this.value ? "" : bs + "Down"), bs + "Over"]);

        if (this.submenu) {
            bs = this.$baseCSSname + "menu";
            this.$setStyleClass(this.$ext, (state != "Out" ? bs + state : ""),
            [(this.value ? "" : bs + "Down"), bs + "Over"]);
        }

        //if (state != "Down")
            //e.cancelBubble = true;
    };

    this.$clickHandler = function(){
        // This handles the actual OnClick action. Return true to redraw the button.
        if (this.isBoolean && !this.submenu) {
            this.setProperty("value", !this.value);
            return true;
        }
    };

    
    this.$submenu = function(hide, force){
        if (hide) {
            this.setValue(false);
            this.$setState("Out", {}, "mouseout");
            this.parentNode.menuIsPressed = false;
        }
    };
    

    /**** Init ****/

    this.$draw  = function(){
        var pNode, isToolbarButton = (pNode = this.parentNode).localName == "toolbar" 
            || pNode.parentNode && pNode.parentNode.localName == "toolbar";
        
        if (isToolbarButton) {
            if (typeof this.focussable == "undefined")
                this.focussable = false;
            
            this.$focussable = apf.KEYBOARD;
        }

        //Build Main Skin
        this.$ext     = this.$getExternal();
        this.oIcon    = this.$getLayoutNode("main", "icon", this.$ext);
        this.oCaption = this.$getLayoutNode("main", "caption", this.$ext);

        this.$useExtraDiv = apf.isTrue(this.$getOption("main", "extradiv"));
        if (!apf.button.$extradiv && this.$useExtraDiv) {
            (apf.button.$extradiv = document.createElement("div"))
                .className = "extradiv"
        }

        if (this.localName == "submit")
            this.action = "submit";
        else if (this.localName == "reset")
            this.action = "reset";

        this.$setupEvents();
    };

    
    this.addEventListener("$skinchange", function(){
        if (this.caption)
            this.$propHandlers["caption"].call(this, this.caption);

        if (this.icon)
            this.$propHandlers["icon"].call(this, this.icon);

        this.$updateState({reset:1});
        //this.$blur();

        //if (this.$focussable !== true && this.hasFocus())
            //apf.window.$focusLast(this.$focusParent);
    });
    

    
    //@todo solve how this works with XForms
    this.addEventListener("click", function(e){
        var action = this.action;

        //#-ifdef __WITH_HTML5
        if (!action)
            action = this.localName;
        //#-endif

        var _self = this;
        $setTimeout(function(){
            (apf.button.actions[action] || apf.K).call(_self);
        });
    });
    

    
}).call(apf.button.prototype = new apf.BaseButton());

// submit, trigger, reset, button
apf.submit.prototype  =
apf.trigger.prototype =
apf.reset.prototype   = apf.button.prototype;

apf.aml.setElement("submit",  apf.submit);
apf.aml.setElement("trigger", apf.trigger);
apf.aml.setElement("reset",   apf.reset);
apf.aml.setElement("button",  apf.button);


apf.submit.action   =
apf.trigger.actions =
apf.reset.actions   =
apf.button.actions  = {
    
    "undo" : function(action){
        var tracker;
        if (this.target && self[this.target]) {
            tracker = self[this.target].localName == "actiontracker"
                ? self[this.target]
                : self[this.target].getActionTracker();
        }
        else {
            var at, node = this;
            while(node.parentNode)
                at = (node = node.parentNode).$at;
        }

        (tracker || apf.window.$at)[action || "undo"]();
    },

    "redo" : function(){
        apf.button.actions.undo.call(this, "redo");
    },
    

    
    "remove" : function(){
        if (this.target && self[this.target])
            self[this.target].remove()
        
        else
            apf.console.warn("Target to remove wasn't found or specified:'"
                             + this.target + "'");
        
    },

    "add" : function(){
        if (this.target && self[this.target])
            self[this.target].add()
        
        else
            apf.console.warn("Target to add wasn't found or specified:'"
                             + this.target + "'");
        
    },

    "rename" : function(){
        if (this.target && self[this.target])
            self[this.target].startRename()
        
        else
            apf.console.warn("Target to rename wasn't found or specified:'"
                             + this.target + "'");
        
    },
    

    
    "login" : function(){
        var parent = this.target && self[this.target]
            ? self[this.target]
            : this.parentNode;

        var vg = parent.$validgroup || new apf.ValidationGroup();
        if (!vg.childNodes.length)
            vg.childNodes = parent.childNodes.slice();

        var vars = {};
        function loopChildren(nodes){
            for (var node, i = 0, l = nodes.length; i < l; i++) {
                node = nodes[i];

                if (node.hasFeature(apf.__VALIDATION__)
                  && !node.$validgroup && !node.form) {
                    node.setProperty("validgroup", vg);
                }

                if (node.type)
                    vars[node.type] = node.getValue();

                if (vars.username && vars.password)
                    return;

                if (node.childNodes.length)
                    loopChildren(node.childNodes);
            }
        }
        loopChildren(parent.childNodes);

        if (!vg.isValid())
            return;

        if (!vars.username || !vars.password) {
            
            throw new Error(apf.formatErrorString(0, this,
                "Clicking the login button",
                "Could not find the username or password box"));
            

            return;
        }

        var auth = this.ownerDocument.getElementsByTagNameNS(apf.ns.apf,"auth")[0];
        if (!auth)
            return;
       
        auth.loginFn(vars.username, vars.password);
        //apf.auth.login(vars.username, vars.password);
    },

    "logout" : function(){
        var auth = this.ownerDocument.getElementsByTagNameNS(apf.ns.apf, "auth")[0];
        if (!auth)
            return;

        auth.logoutFn();
    },
    

    
    "submit" : function(doReset){
        var vg, model;

        var parent = this.target && self[this.target]
            ? self[this.target]
            : this.parentNode;

        if (parent.localName == "model")
            model = parent;
        else {
            if (!parent.$validgroup) {
                parent.$validgroup = parent.validgroup
                    ? self[parent.validgroup]
                    : new apf.ValidationGroup();
            }

            vg = parent.$validgroup;
            if (!vg.childNodes.length)
                vg.childNodes = parent.childNodes.slice();

            function loopChildren(nodes){
                for (var node, i = 0, l = nodes.length; i < l; i++) {
                    node = nodes[i];

                    if (node.getModel) {
                        model = node.getModel();
                        if (model)
                            return false;
                    }

                    if (node.childNodes.length)
                        if (loopChildren(node.childNodes) === false)
                            return false;
                }
            }
            loopChildren(parent.childNodes);

            if (!model) {
                model = apf.globalModel;
                if (!model) {
                    
                    throw new Error(apf.formatErrorString(0, this,
                        "Finding a model to submit",
                        "Could not find a model to submit."));
                    
    
                    return;
                }
            }
        }

        if (doReset) {
            model.reset();
            return;
        }

        if (vg && !vg.isValid())
            return;

        model.submit();
    },

    "reset" : function(){
        apf.button.actions["submit"].call(this, true);
    },
    

    
    "ok" : function(){
        var node;

        if (this.target) {
            node = self[this.target];
        }
        else {
            var node = this.parentNode;
            while (node && !node.hasFeature(apf.__TRANSACTION__)) {
                node = node.parentNode;
            }

            if (node && !node.hasFeature(apf.__TRANSACTION__))
                return;
        }

        if (node.commit() && node.close) 
            node.close();
    },

    "cancel" : function(){
        var node;

        if (this.target) {
            node = self[this.target];
        }
        else {
            var node = this.parentNode;
            while (node && !node.hasFeature(apf.__TRANSACTION__)) {
                node = node.parentNode;
            }

            if (node && !node.hasFeature(apf.__TRANSACTION__))
                return;
        }

        node.rollback();
        if (node.close)
            node.close();
    },

    "apply" : function(){
        var node;

        if (this.target) {
            node = self[this.target];
        }
        else {
            var node = this.parentNode;
            while (node && !node.hasFeature(apf.__TRANSACTION__)) {
                node = node.parentNode;
            }

            if (node && !node.hasFeature(apf.__TRANSACTION__))
                return;
        }

        if (node.autoshow)
            node.autoshow = -1;
        if (node.commit(true))
            node.begin("update");
    },
    

    "close" : function(){
        var parent = this.target && self[this.target]
            ? self[this.target]
            : this.parentNode;

        while(parent && !parent.close)
            parent = parent.parentNode;

        if (parent && parent.close)
            parent.close();
        
        else
            apf.console.warn("Target to close wasn't found or specified:'"
                             + this.target + "'");
        
    }
};





/*FILEHEAD(/var/lib/platform/source/trunk/elements/statusbar.js)SIZE(3828)TIME(1259091146)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element displaying a bar consisting of bars containing other text, icons
 * and more aml. This element is usually placed in the bottom of the screen to 
 * display context sensitive and other information about the state of the 
 * application.
 * Example:
 * <code>
 *  <a:statusbar>
 *      <a:section icon="application.png">Ajax.org</a:section>
 *      <a:section>Some status information</a:section>
 *      <a:section>
 *          <a:progressbar anchors="6 5 5 5" autostart="true" />
 *      </a:section>
 *  </a:statusbar>
 * </code>
 *
 * @constructor
 * @define statusbar
 * @allowchild bar
 * @allowchild progressbar
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.9
 */
apf.statusbar = function(struct, tagName){
    this.$init(tagName || "statusbar", apf.NODE_VISIBLE, struct);
};

(function(){
    this.$focussable     = false;
    
    /**** DOM Hooks ****/
    var insertChild;
    
    this.addEventListener("AMLRemoveChild", function(amlNode, doOnlyAdmin){
        if (doOnlyAdmin)
            return;

    });
    
    this.addEventListener("AMLInsert",insertChild = function (amlNode, beforeNode, withinParent){
        if (amlNode.tagName != "bar")
            return;
        
        amlNode.$propHandlers["caption"] = function(value){
            apf.setNodeValue(
                this.$getLayoutNode("bar", "caption", this.$ext), value);
        }
        amlNode.$propHandlers["icon"] = function(value){
            var oIcon = this.$getLayoutNode("bar", "icon", this.$ext);
            if (!oIcon) return;
        
            if (value)
                this.$setStyleClass(this.$ext, this.$baseCSSname + "Icon");
            else
                this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Icon"]);
            
            if (oIcon.tagName == "img") 
                oIcon.setAttribute("src", value ? this.iconPath + value : "");
            else {
                oIcon.style.backgroundImage = value 
                    ? "url(" + this.iconPath + value + ")"
                    : "";
            }
        }
    });
    
    
    /**** Init ****/
    
    this.$draw = function(){
        //Build Main Skin
        this.$ext = this.$getExternal();
        this.$int = this.$getLayoutNode("main", "container", this.$ext);
    };
    
    this.$loadAml = function(x){
        var nodes = this.childNodes;
        for (var i = nodes.length - 1; i >= 0; i--) {
            if (nodes[i].localName == "section") {
                nodes[i].addEventListener("DOMNodeInsertedIntoDocument", function(){
                    this.$setStyleClass(this.$ext, this.$baseCSSname + "Last");
                });
                break;
            }
        }
    };
}).call(apf.statusbar.prototype = new apf.Presentation());

apf.aml.setElement("statusbar", apf.statusbar);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/smartbinding.js)SIZE(31930)TIME(1263686463)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @term smartbinding Smartbinding is a type of bidirectional databinding where 
 * rules specify how data is rendered in a component <i>and</i> how changes to
 * the bound data are sent back to the server (or other data source). 
 * Smartbindings are specifically designed to solve the problem of databinding
 * for Ajax applications that connect to remote (non-local) datasources.
 * A smartbinding element can contain three elements; {@link element.bindings bindings}, 
 * {@link element.actions actions} and {@link element.model model}.
 *
 * See also more information about {@link term.binding binding rules} and
 * {@link term.action action rules}.
 *
 * Model:
 * The model is the place where your xml data resides. Data is loaded into the
 * model using a {@link term.datainstruction data instruction} as the following
 * example shows:
 * <code>
 *  <a:model src="get_person.php?id=10" />
 * </code>
 * An element can connect directly to a model in order to bind to data.
 * <code>
 *  <a:model id="mdlExample" />
 *  <a:tree model="mdlExample" />
 * </code>
 *
 * The model can also be part of a smartbinding that is used by the element. 
 * A smartbinding can be used by multiple elements referenced by id:
 * <code>
 *  <a:smartbinding id="sbExample">
 *      <a:model />
 *      ...
 *  </a:smartbinding>
 *  <a:tree smartbinding="sbExample" />
 * </code>
 *
 * Bindings:
 * The bindings element is a container for binding rules. Binding rules determine
 * how an element renders the data that it's bound to. Some binding rules specify
 * how data can be interacted with (i.e. {@link baseclass.multiselect.binding.select the select rule}).
 * Check the {@link term.binding term binding rules} for more information.
 *
 * Actions:
 * The actions element is a container for action rules. Action rules influence 
 * and trigger several parts of the user interaction. 
 * <ol>
 *  <li>It determines whether a user action can be executed on the bound and/or 
 *      selected {@link term.datanode data node}.</li>
 *  <li>It dispatches events, before and after the data is changed.</li>
 *  <li>It creates a {@link http://en.wikipedia.org/wiki/Command_pattern command object} 
 *      that is pushed on the undo stack of the {@link element.actiontracker actiontracker} 
 *      connected to the element that triggered the action.</li>
 *  <li>The command object contains all the information to send the change back 
 *      to the server</li>
 * </ol>
 * So in short, an action rule is always triggered by the user, creates an 
 * undo item and sends the change back to the server.
 * Check the {@link term.action term action rules} for more information.
 *
 * See:
 * {@link baseclass.databinding.attribute.smartbinding}
 */

/**
 * @term binding Binding rules determine how an element displays the data that 
 * its bound to (ex.: {@link element.tree.binding.caption the caption rule}), 
 * and determines how it can be interacted with 
 * (ex.: {@link baseclass.multiselect.binding.select the select rule}).
 * Binding rules are part of the {@link term.smartbinding smartbinding concept}.
 * 
 * Basic:
 * Let's take a simple example, that of a {@link element.textbox textbox}. A 
 * textbox has a {@link element.textbox.attribute.value value attribute}. This
 * attribute can be set like this:
 * <code>
 *  <a:textbox value="The text" />
 * </code>
 * In many cases it's handy to bind the value of the textbox to data. Imagine
 * you are editing a contact's name in a textbox. In this case you would want to 
 * bind the value of the textbox to the xml data. The binding rule is configured
 * to determine this value based on the bound xml. Let's look at an example:
 * <code>
 *  <a:model id="mdlExample">
 *      <contact>
 *          <name>Test</name>
 *      </contact>
 *  </a:model>
 *  
 *  <a:textbox value="[mdlExample::name]" />
 * </code>
 * The textbox binds to the data of the model. The bind rule sets how the value
 * is retrieved from the bound data. In this case the value of the name node is
 * retrieved. <strong>When the user changes the value of the textbox, the name
 * node is updated with that value.</strong> Subsequently <strong>when the xml
 * changes the value of the textbox is updated</strong>.
 *
 * Each attribute on an element can be bound to data by using the attribute
 * name as the name of the binding rule. In the next example, the visible
 * attribute of a textbox is based on the availability of a {@link term.datanode data node}:
 * <code>
 *  <a:textbox>
 *      <a:bindings>
 *          <a:visible match="[name]" value="true" />
 *      </a:bindings>
 *  </a:textbox>
 * </code>
 * Each element has a primary bind rule that can be accessed in a short format.
 * This is usually the value bind rule. The short format works as follows:
 * <code>
 *  <a:model id="mdlExample">
 *      <contact>
 *          <name>Test</name>
 *      </contact>
 *  </a:model>
 *  <a:textbox value="[name]" model="mdlExample" />
 * </code>
 *
 * Advanced:
 * For multi node components databinding adds another conceptual step. The basics
 * stay the same, though a way is introduced to do 'foreach' on the data to 
 * determine which nodes are rendered. This is done using the 
 * {@link element.multiselectbinding.binding.each each binding rule} and
 * the selected nodes are called {@link term.eachnode each nodes}.
 *
 * When the set of each nodes is determined, each is rendered based on other
 * binding rules that determine whatever is deemed necesary by the component. 
 * This can be the caption, icon, tooltip, whether an item is seletable and so on.
 * In the next example a list is bound to some data representing a contact list.
 * Each contact's name is displayed as the caption of the item.
 * <code>
 *  <a:model id="mdlSmart1">
 *      <data>
 *          <contact>
 *              <name>Ruben</name>
 *              <company>Javeline</company>
 *          </contact>
 *          <contact>
 *              <name>Łukasz</name>
 *              <company>Javeline</company>
 *          </contact>
 *      </data>
 *  </a:model>
 *  <a:list model="mdlSmart1">
 *      <a:bindings>
 *          <a:caption value="[name]" />
 *          <a:icon value="contact.png" />
 *          <a:each match="[contact]" />
 *      </a:bindings>
 *  </a:list>
 * </code>
 * 
 * Fallbacks:
 * By stacking multiple binding rules it's possible to define different ways to
 * determine the value for an attribute. Let's say we have a tree that displays
 * files and folders. A file and a folder can have custom icons. If these are 
 * not specified, they each default to an icon representing their type. This would
 * be encoded like this:
 * <code>
 *  <a:bindings>
 *      <a:icon match="[@icon]" />
 *      <a:icon match="[folder]" value="folder.png" />
 *      <a:icon match="[file]" value="file.png" />
 *  </a:bindings>
 * </code>
 *
 * Processors:
 * There are several ways to convert the data retrieved from the xml data into
 * the needed string or boolean. The following example uses {@link term.livemarkup live markup}
 * to determine the icon by the extension of the filename:
 * <code>
 *  <a:model id="mdlSmart1">
 *      <data>
 *          <contact>
 *              <name>Ruben</name>
 *              <filename>Baseclasses</filename>
 *          </contact>
 *          <contact>
 *              <name>Łukasz</name>
 *              <filename>application.png</filename>
 *          </contact>
 *      </data>
 *  </a:model>
 *  <a:list model="mdlSmart1">
 *      <a:bindings>
 *          <a:caption value="[name]" />
 *          <a:icon><?lm
 *              var ext = {[filename].split(".").shift()};
 *              ext == [filename] ? "unknown.png" : ext + ".png";
 *          ?></a:icon>
 *          <a:each match="[contact]" />
 *      </a:bindings>
 *  </a:list>
 * </code>
 * Instead of live markup you can use xslt as well. Furthermore you can apply some
 * javascript to the result by calling a method. The following examples shows
 * a caption where a javascript method inserts smileys.
 * <code>
 *  <a:bindings>
 *      <a:caption match="[body]" method="insertSmileys" />
 *  </a:bindings>
 * </code>
 *
 * Extending:
 * Two special binding rules are the {@link baseclass.databinding.binding.load load}
 * and the {@link element.tree.binding.insert insert} bindings. These bindings
 * are used to load and insert new data into the data bound to the element that
 * uses them. With these rules an application can start out with only a bit of
 * data and when the user needs it extends the data. A simple example is that of
 * a tree element that loads subnodes whenever a user expands a node. This can
 * be achieved in the following way:
 * <code>
 *  <a:model id="mdlSmart2">
 *      <data>
 *          <item title="Title 1" id="1" leaf="long"></item>
 *          <item title="Title 2" id="2"></item>
 *      </data>
 *  </a:model>
 *  
 *  <a:tree model="mdlSmart2">
 *      <a:bindings>
 *          <a:caption match = "[@title]" />
 *          <a:insert  
 *            match = "[item[not(@leaf)]]" 
 *            get   = "http://servername.com/insert.php?keyword=[@id]" />
 *          <a:each match="[item]" />
 *      </a:bindings>
 *  </a:tree>
 * </code>
 * For more information about how data can be loaded into aml elements please
 * check {@link term.datainstruction data instructions}.
 */

/**
 * @term action Action rules determine whether a user can execute an action and
 * takes care of executing the change both locally and on a remote server. Each
 * triggered action creates an item on the undo stack.
 * Action rules are part of the {@link term.smartbinding smartbinding concept}.
 *
 * Syntax:
 * Actions are added to {@link element.actions}. The <i>select</i> attribute specifies
 * whether an action can be executed. The <i>set</i> attribute specifies how the change
 * to the data is send to the server. The following example shows a remove 
 * action on a datagrid. A jsp script is called to process the change. This is
 * specified using a {@link term.datainstruction data instruction}.
 * <code>
 *  <a:datagrid>
 *      <a:actions>
 *          <a:remove select = "self::contact[not(@readonly)]"
 *                    set    = "remove_contact.jsp?id=[@dbid]" />
 *      </a:actions>
 *  </a:datagrid>
 * </code>
 *
 * Defaults:
 * The default behaviour for all components is to enable all actions when no
 * actions element has been assigned. This can be change by setting 
 * {@link element.appsettings.attribute.auto-disable-actions}. When a actions
 * element <i>is</i> assigned, all actions are disabled unless they are specified.
 * When the select attribute on an action is not set the action will always be
 * allowed. 
 * 
 * Flow:
 * Action rules influence and trigger several parts of the user interaction. 
 * <ol>
 *  <li>It determines whether a user action can be executed on the bound and/or 
 *      selected {@link term.datanode data node}.</li>
 *  <li>It dispatches events, before and after the data is changed.</li>
 *  <li>It creates a {@link http://en.wikipedia.org/wiki/Command_pattern command object} 
 *      that is pushed on the undo stack of the {@link element.actiontracker actiontracker} 
 *      connected to the element that triggered the action.</li>
 *  <li>The command object ({@link core.undodata UndoData}) contains all the 
 *      information to send the change back to the server.</li>
 * </ol>
 *
 * Fallbacks:
 * By stacking multiple action rules it's possible to define different ways to
 * deal with user actions. Let's say we have a tree that displays
 * files and folders. Renaming a file and a folder might have different handlers. 
 * This would be encoded like this:
 * <code>
 *  <a:tree 
 *    id             = "tree" 
 *    height         = "200" 
 *    width          = "250"
 *    model          = "filesystem.xml"
 *    actiontracker  = "atExample"
 *    startcollapsed = "false" 
 *    onerror        = "alert('Sorry this action is not permitted');return false">
 *      <a:each match="[folder|drive]">
 *          <a:caption match="[@caption]" />
 *          <a:icon value="Famfolder.gif" />
 *      </a:each>
 *      <a:rename match = "[file]"   
 *                set    = "rename_folder.php?id=[@fid]" />
 *      <a:rename match = "[folder]" 
 *                set    = "rename_file.php?id=[@fid]" />
 * </a:tree>
 *       
 * <a:button 
 *   caption = "Rename"
 *   right   = "10" 
 *   top     = "10"
 *   onclick = "tree.startRename()" />
 * <a:button onclick="tree.getActionTracker().undo();">Undo</a:button>
 * </code>
 *
 * Undo:
 * When an action is execute it creates an entry on the undostack of an 
 * actiontracker. Undo can be triggered by calling the undo method.
 * <code>
 *  myTree.getActionTracker().undo();
 *  //or
 *  ActionTracker.undo();
 * </code>
 * Executing will revert the change to the data. This will also be communicated
 * to the server. In some cases the call to the server is not symmetric; the set
 * call cannot be used to revert. For these situations set the undo attribute.
 * <code>
 *  <a:tree id="tree" height="200" width="250"
 *    model          = "filesystem.xml"
 *    actiontracker  = "atExample"
 *    startcollapsed = "false" 
 *    onerror        = "alert('Sorry this action is not permitted');return false">
 *      <a:each match="[folder|drive]">
 *          <a:caption match="[@caption]" />
 *          <a:icon value="Famfolder.gif" />
 *      </a:each>
 *      <a:remove set  = "remove.php?id=[@fid]"
 *                undo = "undo_remove.php?id=[@fid]">
 *      </a:remove>
 *  </a:tree>
 *  <a:button onclick="tree.getActionTracker().undo();">Undo</a:button>
 *  <a:button onclick="tree.remove();">Remove</a:button>
 * </code>
 * In the example above the server is required to support reverting remove. 
 * Another possibility is to add the item again as shown in this example:
 * <code>
 *  <a:remove set  = "remove.php?id=[@id]"
 *            undo = "add.php?xml=[.]">
 *  </a:remove>
 * </code>
 *
 * Javascript:
 * Each action has a method associated with it that exists on the element that
 * the action rule is assigned to. The method has the same name as the action 
 * and can be called from javascript. For instance, the {@link baseclass.multiselect.binding.remove remove action}:
 * <code>
 *  myTree.remove();
 *  myTree.remove(dataNode);
 * </code>
 *
 * Add:
 * Adding {@link term.datanode data nodes} to an element is a bit more advanced because the origin of
 * the new data can be encoded in {@link baseclass.multiselect.binding.add the add action rule}. 
 * There are three ways to provide the data to add a node. 
 * 
 * The first is by calling the add method using javascript.
 * <code>
 *  <a:list id="myList">
 *      <a:add set="{comm.addProduct([.])}" />
 *  </a:list>
 *  <a:script>
 *      myList.add('<product name="USB drive" type="storage" />');
 *  </a:script>
 * </code>
 *
 * The second by specifying the template as a child of the add action rule:
 * <code>
 *  <a:add set="{comm.addProduct([.])}">
 *      <product name="USB drive" type="storage" />
 *  </a:add>
 * </code>
 * The third way gets the added node from the server.
 * <code>
 *  <a:rpc id="comm" protocol="cgi">
 *      <a:method 
 *        name = "createNewProduct" 
 *        url  = "http://yourserver.com/create_product.php" />
 *  </a:rpc>
 *  <a:list id="myList" width="200">
 *      <a:bindings>
 *          <a:caption match="[text()]" />
 *          <a:value match="[text()]" />
 *          <a:each match="[product]" />
 *      </a:bindings>
 *      <a:add get="{comm.createNewProduct()}" />
 *      <a:model>
 *          <data>
 *              <product>LCD Panel</product>
 *          </data>
 *      </a:model>
 *  </a:list>
 *  <a:button onclick="myList.add()">Add product</a:button>
 * </code>
 *
 * Purging:
 * Sometimes it's necesary to not send the changes directly to the server. For
 * instance when the application offers a <i>save</i> button. To achieve this
 * set the {@link element.actiontracker.attribute.realtime realtime attribute}
 * of the actiontracker to false. The save button can call the 
 * {@link element.actiontracker.method.purge purge method} to have the 
 * actiontracker send the calls.
 * <code>
 *  <a:actiontracker id="myAt" realtime="false" />
 *  <a:list actiontracker="myAt" />
 *  <a:button onclick="myAt.purge()">Save</a:button>
 * </code>
 * N.B. At a certain amount of changes this way will become inefficient and 
 * you'll want to send the state of your data to the server directly. You can
 * do that like this:
 * <code>
 *  <a:list id="myList" width="200">
 *      <a:bindings>
 *          <a:caption match="[text()]" />
 *          <a:value match="[text()]" />
 *          <a:each match="[product]" />
 *      </a:bindings>
 *      <a:model>
 *          <data>
 *              <product>LCD Panel</product>
 *          </data>
 *      </a:model>
 *      <a:rename />
 *      <a:remove />
 *  </a:list>
 *  <a:button onclick="myList.getModel().submit('save.php', myList.xmlRoot)">
 *      Save
 *  </a:button>
 * </code>
 * See also {@link element.model.method.submit}.
 * 
 * Transactions:
 * A transaction is a 
 * set of changes to data which are treated as one change. When one of the 
 * changes in the set fails, all the changes will be cancelled. In the case of
 * a gui this is happens when a user decides to cancel after 
 * making several changes. A good example are the well known <i>Properties</i> 
 * windows with an ok, cancel and apply button. 
 *
 * When a user edits data, for instance user information, all the changes are
 * seen as one edit and put on the undo stack as a single action. Thus clicking
 * undo will undo the entire transaction, not just the last change done by that
 * user in the edit window. Transaction support both optimistic and pessimistic 
 * locking. For more information on transactions see {@link baseclass.transaction}.
 */
 
/**
 * @term datanode A data node is the term used for any xml node (attribute, 
 * element, textnode or otherwise) that is used in a databound context. So when
 * xml is loaded into a {@link element.model model} we refer to those xml nodes 
 * as data nodes.
 */
 
/**
 * Element containing information on how databound elements process data.
 * The {@link term.smartbinding smartbinding} element specifies how data is transformed and rendered 
 * in databound elements. It also specifies how changes on the bound data are 
 * send to their original data source ({@link element.actions actions}) and
 * which {@link term.datanode data nodes} can be dragged and dropped ({@link element.dragdrop dragdrop}).
 * Example:
 * A simple example of a smartbinding transforming data into representation
 * <code>
 *  <a:smartbinding id="sbProducts">
 *          <a:bindings>
 *               <a:caption match="[text()]" />
 *               <a:value match="[text()]" />
 *               <a:each match="[product]" />
 *           </a:bindings>
 *      </a:smartbinding>
 *     
 *      <a:list smartbinding="sbProducts" width="200">
 *          <a:model>
 *               <data>
 *                   <product>LCD Panel</product>
 *               </data>
 *           </a:model>
 *      </a:list>
 * </code>
 * Example:
 * This is an elaborate example showing how to create a filesystem tree with
 * files and folders in a tree. The smartbinding element describes how the
 * files and folders are transformed to tree elements and how actions within
 * the tree are sent to the data source. In this case {@link teleport.webdav WebDAV}
 * is used. The drag and drop rules specify which elements can be dragged and
 * where they can be dropped.
 * <code>
 *  <a:smartbinding id="sbFilesystem" model="{myWebdav.getRoot()}">
 *      <a:bindings>
 *          <a:insert match="[folder]" get="{myWebdav.readdir([@path])}" />
 *          <a:each match="[file|folder]" sort="[@name]" sort-method="filesort" />
 *          <a:caption match="[@name]" />
 *          <a:icon match="[folder]" value="icoFolder.png" />
 *          <a:icon match="[file]" method="getIcon" />
 *          <a:drag match="[folder|file]" copy="event.ctrlKey" /> 
 *          <a:drop 
 *            match  = "[folder|file]" 
 *            target = "[folder]" 
 *            action = "tree-append" /> 
 *      </a:bindings>
 *      <a:add type="folder" get="{myWebdav.mkdir([@id], 'New Folder')}" />
 *      <a:add type="file" get="{myWebdav.create([@id], 'New File', '')}" />
 *      <a:rename set="{myWebdav.move(oldValue, [@name], [@id])}"/>
 *      <a:copy match="[.]" set="{myWebdav.copy([@id], [../@id])}"/>
 *      <a:move match="[.]" set="{myWebdav.move()}"/>
 *      <a:remove match="[.]" set="{myWebdav.remove([@path])}"/>
 *  </a:smartbinding>
 *
 *  <a:tree 
 *    dragcopy     = "true" 
 *    model        = "mdlFilesystem" 
 *    smartbinding = "sbFilesystem" />
 *
 *  <a:script>
 *      function filesort(value, args, xmlNode) {
 *          return (xmlNode.tagName == "folder" ? 0 : 1) + value;
 *      }
 *
 *      function getIcon(xmlNode){
 *          xmlNode.getAttribute('name').match(/\.([^\.]*)$/);
 *              
 *          var ext = RegExp.$1;
 *          return (SupportedIcons[ext.toUpperCase()]
 *              ? SupportedIcons[ext.toUpperCase()] + ".png" 
 *              : "unknown.png");
 *      }
 *  </a:script>
 * </code>
 * Remarks:
 * Each element has it's own set of binding rules it uses to render the data 
 * elements. The same goes for it's actions. To give an example, a slider has 
 * one action called 'change'. This action is called when then value of the 
 * slider changes. A tree element has several actions - among others: 'add',
 * 'remove', 'move', 'copy' and 'rename'. 
 * 
 * Smartbindings enable many other features in a Ajax.org Platform
 * application. Actions done by the user can be undone by calling 
 * {@link element.actiontracker.method.undo} of the element. The 
 * Remote Smartbinding element can send changes on data to other clients.
 *
 * This element is created especially for reuse. Multiple elements can reference
 * a single smartbinding element by setting the value of the 'smartbinding'
 * attribute to the ID of this smartbinding element. If an element is only used
 * for a single other element it can be set as it's child. In fact, each of the
 * children of the smartbinding element can exist outside the smartbinding
 * element and referenced indepently.
 * Example:
 * This example shows a smartbinding element which references to its children as
 * stand alone elements.
 * <code>
 *  <a:bindings id="bndExample">
 *      ...
 *  </a:bindings>
 *  <a:actions id="actExample">
 *      ...
 *  </a:actions>
 *  <a:dragdrop id="ddExample">
 *      ...
 *  </a:dragdrop>
 *  <a:model id="mdlExample" />
 *
 *  <a:smartbinding id="sbExample"
 *    actions  = "actExample" 
 *    bindings = "bndExample" 
 *    dragdrop = "ddExample" 
 *    model    = "mdlExample" />
 *
 *  <a:list smartbinding="sbExample" />
 *  <a:tree binding="bndExample" action="actExample" model="example.php" />
 * </code>
 * Example:
 * The shortest method to add binding rules to an element is as follows:
 * <code>
 *  <a:tree each="[file|folder]" caption="[@name]" icon="[@icon]" />
 * </code>
 * @see baseclass.databinding
 * @see baseclass.databinding.attribute.smartbinding
 * @see term.smartbinding
 * @see term.binding
 * @see term.action
 * 
 * @define smartbinding
 * @allowchild bindings, actions, ref, action, dragdrop, model
 * @addnode smartbinding, global
 *
 * @constructor
 * @apfclass
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 *
 * @default_private
 */
apf.smartbinding = function(struct, tagName){
    this.$init(tagName || "smartbinding", apf.NODE_HIDDEN, struct);

    this.$bindNodes = {};
};

(function(){
    this.$supportedProperties = ["bindings", "actions", "model"];
    this.$handlePropSet = function(prop, value, force){
        switch(prop) {
            //@todo apf3 change this to use apf.setModel();
            case "model":
                if (typeof value == "string")
                    value = apf.nameserver.get("model", value);
                this.model          = apf.nameserver.register("model", this.name, value);
                //this.modelBaseXpath = xpath;
                
                var amlNode;
                for (var uniqueId in this.$bindNodes) {
                    amlNode = this.$bindNodes[uniqueId];
                    this.model.unregister(amlNode);
                    this.model.register(amlNode, this.$modelXpath[amlNode.getHost
                        ? amlNode.getHost().$uniqueId
                        //this is a hack.. by making Models with links to other
                        //models possible, this should not be needed
                        : amlNode.$uniqueId] || this.modelBaseXpath);
                    //this.$bindNodes[uniqueId].load(this.model);
                }
                break;
            case "bindings":
                if (this.$bindings)
                    this.remove(this.$bindings);
                
                this.$bindings = typeof value == "object" 
                    ? value 
                    : apf.nameserver.lookup("bindings", value);
                
                this.add(this.$bindings);
                
                break;
            case "actions":
                if (this.$actions)
                    this.remove(this.$actions);
                
                this.$actions = typeof value == "object" 
                    ? value 
                    : apf.nameserver.lookup("actions", value);
                
                this.add(this.$actions);
            
                break;
        }
        
        this[prop] = value;
        
        
        /*if (!apf.nameserver.get(name, attr[i].nodeValue))
            throw new Error(apf.formatErrorString(1036, this, 
                "Connecting " + name, 
                "Could not find " + name + " by name '" 
                + attr[i].nodeValue + "'"));*/
        
    };
    
    this.add = function(node){
        for (var uId in this.$bindNodes)
            node.register(this.$bindNodes[uId]);
        
        this["$" + node.localName] = node;
    };
    
    this.remove = function(node){
        for (var uId in this.$bindNodes)
            node.unregister(this.$bindNodes[uId]);
    };
    
    this.register = function(amlNode){
        this.$bindNodes[amlNode.$uniqueId] = amlNode;
        
        if (this.$bindings)
            this.$bindings.register(amlNode);
        if (this.$actions)
            this.$actions.register(amlNode);
        if (this.$model)
            this.$model.register(amlNode);
    };

    this.unregister = function(amlNode){
        //unregister element
        this.$bindNodes[amlNode.$uniqueId] = null;
        delete this.$bindNodes[amlNode.$uniqueId];
        
        if (this.$bindings)
            this.$bindings.unregister(amlNode);
        if (this.$actions)
            this.$actions.unregister(amlNode);
        if (this.$model)
            this.$model.unregister(amlNode);
    };
    
    /**
     * Loads xml data in the model of this smartbinding element.
     * 
     * @param  {mixed}  xmlNode the {@link term.datanode data node} loaded into
     * the model of this smartbinding element. This can be an XMLElement, a 
     * string or null. 
     * @private
     */
    this.load = function(xmlNode){
        //@todo fix this
        new apf.model().register(this).load(xmlNode);
    };
    
    this.clear = function(state){
        //for all elements do clear(state);
    };
    
    /**
     * @private
     *
     * @attribute {String} bindings the id of the bindings element that contains 
     * the {@link term.binding binding rules} for all elements connected to 
     * this smartbinding element
     * Example:
     * <code>
     *  <a:smartbinding id="sbExample" bindings="bndExample" />
     * </code>
     * @see element.bindings
     * @see term.binding
     * @see term.smartbinding
     *
     * @attribute {String} actions  the id of the actions element that provides 
     * the {@link term.action action rules} for all elements connected to 
     * this smartbinding element
     * Example:
     * <code>
     *  <a:smartbinding id="sbExample" bindings="actExample" />
     * </code>
     * @see element.actions
     * @see term.action
     * @see term.smartbinding
     *
     * @attribute {String} dragdrop the id of the dragdrop element that provides 
     * the drag and drop rules for all elements connected to this smartbinding 
     * element
     * Example:
     * <code>
     *  <a:smartbinding id="sbExample" dragdrop="ddExample" />
     * </code>
     * @see element.dragdrop
     * @see term.smartbinding
     *
     * @attribute {String} model    the id of the model element that provides 
     * the data for all elements connected to this smartbinding element.
     * Example:
     * <code>
     *  <a:smartbinding id="sbExample" model="mdlExample" />
     * </code>
     * @see element.model
     * @see term.smartbinding
     *
     * @define bindings element containing all the binding rules for the data 
     * bound elements referencing this element.
     * Example:
     * <code>
     *  <a:bindings id="bndFolders" >
     *      <a:caption select="@name" />
     *      <a:icon select="@icon" />
     *      <a:each select="folder" sort="@name" />
     *  </a:bindings>
     *
     *  <a:tree bindings="bndFolders" />
     * </code>
     * @see element.smartbinding
     * @allowchild {bindings}
     * @addnode smartbinding, global
     * @addnode smartbinding, global
     */
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (this.parentNode.hasFeature(apf.__DATABINDING__))
            this.register(this.parentNode);

        
        apf.console.info(this.name
            ? "Creating SmartBinding [" + this.name + "]"
            : "Creating implicitly assigned SmartBinding");
        
    });
}).call(apf.smartbinding.prototype = new apf.AmlElement());

apf.aml.setElement("smartbinding", apf.smartbinding);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/markupedit.js)SIZE(46373)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */








var HAS_CHILD = 1 << 1,
    IS_CLOSED = 1 << 2,
    IS_LAST   = 1 << 3,
    IS_ROOT   = 1 << 4;

/**
 * Element for editing markup in the same way firebug provides.
 *
 * @experimental
 * @todo see if it's possible to create a tree baseclass
 * @constructor
 * @allowchild {smartbinding}
 * @addnode elements:markupedit
 *
 * @inherits apf.XForms
 * @inherits apf.MultiSelect
 * @inherits apf.Cache
 * @inherits apf.DataAction
 * @inherits apf.GuiElement
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.98.3
 * @default_private
 *
 * @binding css      Determines a css class for a node.
 * @binding empty    Determines the empty message of a node.
 */
apf.markupedit = function(struct, tagName){
    this.$init(tagName || "markupedit", apf.NODE_VISIBLE, struct);
};

(function(){
    this.implement(
        
        
        apf.DataAction,
        
        apf.Rename,
        apf.MultiSelect,
        apf.Cache
    );

    this.$isTreeArch  = true; // Tree Architecture for loading Data
    this.$focussable = true; // This object can get the focus
    
    this.clearMessage  = "There are no items";
    this.startClosed   = true;
    this.animType      = 0;
    this.animSteps     = 3;
    this.animSpeed     = 20;
    
    
    this.dynCssClasses = [];
    
    
    var _self = this;
    
    /* ********************************************************************
                                        PUBLIC METHODS
    *********************************************************************/
    
    /**
     * Sets an attribute to an xml node
     *
     */
    this.setAttributeValue = function(xmlNode, name, value){
        if (!xmlNode)
            xmlNode = this.caret || this.selected;

        if (!xmlNode || xmlNode.getAttribute(name) == value) 
            return;
        
        this.$executeAction("setAttribute", [xmlNode, name, value],
            "setAttributeValue", xmlNode);
    };
    
    /**
     * Renames an attribute of an xml node
     *
     */
    this.renameAttribute = function(xmlNode, name, newName){
        if (!xmlNode)
            xmlNode = this.caret || this.selected;

        if (!xmlNode || name == newName) 
            return;
        
        this.$executeAction("multicall", [
              {func: "removeAttribute", args: [xmlNode, name]},
              {func: "setAttribute", args: [xmlNode, newName, xmlNode.getAttribute(name)]}
            ], "renameAttribute", xmlNode);
    };
    
    /**
     * Sets a text node to an xml node
     *
     */
    this.setTextNode = function(xmlNode, value){
        if (!xmlNode)
            xmlNode = this.caret || this.selected;

        if (!xmlNode || apf.queryValue(xmlNode, "text()") == value) 
            return;
        
        this.$executeAction("setTextNode", [xmlNode, value], "setTextNode", xmlNode);
    };
    
    
    /**
     * @private
     */
    this.slideToggle = function(htmlNode, force){
        if(this.noCollapse) 
            return;
        
        if (!htmlNode)
            htmlNode = this.$selected;
        
        var id = htmlNode.getAttribute(apf.xmldb.htmlIdTag);
        while (!id && htmlNode.parentNode)
            var id = (htmlNode = htmlNode.parentNode)
                .getAttribute(apf.xmldb.htmlIdTag);

        var elClass, container = this.$getLayoutNode("item", "container", htmlNode);
        if (apf.getStyle(container, "display") == "block") {
            if (force == 1) return;
            elClass = this.$getLayoutNode("item", "openclose", htmlNode);
            elClass.className = elClass.className.replace(/min/, "plus");
            this.slideClose(container, apf.xmldb.getNode(htmlNode));
        }
        else {
            if (force == 2) return;
            elClass = this.$getLayoutNode("item", "openclose", htmlNode);
            elClass.className = elClass.className.replace(/plus/, "min");
            this.slideOpen(container, apf.xmldb.getNode(htmlNode));
        }
    };
    
    var lastOpened = {};
    /**
     * @private
     */
    this.slideOpen = function(container, xmlNode, immediate){
        if (!xmlNode)
            xmlNode = this.selected;
        
        var htmlNode = apf.xmldb.findHtmlNode(xmlNode, this);
        if (!container)
            container = this.$findContainer(htmlNode);

        if (this.singleopen) {
            var pNode = this.getTraverseParent(xmlNode)
            var p = (pNode || this.xmlRoot).getAttribute(apf.xmldb.xmlIdTag);
            if (lastOpened[p] && lastOpened[p][1] != xmlNode 
              && this.getTraverseParent(lastOpened[p][1]) == pNode) 
                this.slideToggle(lastOpened[p][0], 2);//lastOpened[p][1]);
            lastOpened[p] = [htmlNode, xmlNode];
        }
        
        container.style.display = "block";
        
        if (immediate) {
            container.style.height = "auto";
            return;
        }

        apf.tween.single(container, {
            type    : 'scrollheight', 
            from    : 0, 
            to      : container.scrollHeight, 
            anim    : this.animType, 
            steps   : this.animOpenStep,
            interval: this.animSpeed,
            onfinish: function(container){
                if (xmlNode && _self.$hasLoadStatus(xmlNode, "potential")) {
                    $setTimeout(function(){
                        _self.$extend(xmlNode, container);
                    });
                    container.style.height = "auto";
                }
                else {
                    //container.style.overflow = "visible";
                    container.style.height = "auto";
                }
            }
        });
    };

    /**
     * @private
     */
    this.slideClose = function(container, xmlNode){
        if (this.noCollapse) 
            return;
        
        if (!xmlNode)
            xmlNode = this.selected;
        
        if (this.singleopen) {
            var p = (this.getTraverseParent(xmlNode) || this.xmlRoot)
                .getAttribute(apf.xmldb.xmlIdTag);
            lastOpened[p] = null;
        }
        
        container.style.height   = container.offsetHeight;
        container.style.overflow = "hidden";

        apf.tween.single(container, {
            type    : 'scrollheight', 
            from    : container.scrollHeight, 
            to      : 0, 
            anim    : this.animType, 
            steps   : this.animCloseStep,
            interval: this.animSpeed,
            onfinish: function(container, data){
               container.style.display = "none";
            }
        });
    };

    //check databinding for how this is normally implemented
    //PROCINSTR
    this.doUpdate = function(xmlNode, container){
        var rule       = this.$getBindRule("insert", xmlNode);
        var xmlContext = rule && rule[1] 
            ? rule[1](xmlNode) 
            : null;
        
        if (rule && xmlContext) {
            this.$setLoadStatus(xmlNode, "loading");
            
            if (rule.getAttribute("get")) {
                this.getModel().$insertFrom(rule.getAttribute("get"), {
                    xmlNode     : xmlContext,
                    insertPoint : xmlContext, 
                    amlNode     : this
                });
            }
            else {
                var data = this.$applyBindRule("Insert", xmlNode);
                if (data)
                    this.insert(data, {insertPoint: xmlContext});
            }
        }
        else
            if (!this.prerender) {
                this.$setLoadStatus(xmlNode, "loading");
                var result = this.$addNodes(xmlNode, container, true); //checkChildren ???
                xmlUpdateHandler.call(this, "insert", xmlNode, result);
            }
    };
    
    /* ***********************
                Skin
    ************************/

    var treeState = {};
    treeState[0]                                     = "";
    treeState[HAS_CHILD]                             = "min";
    treeState[HAS_CHILD | IS_CLOSED]                 = "plus";
    treeState[IS_LAST]                               = "last";
    treeState[IS_LAST | HAS_CHILD]                   = "minlast";
    treeState[IS_LAST | HAS_CHILD | IS_CLOSED]       = "pluslast";
    treeState[IS_ROOT]                               = "root";

    this.fixItem = function(xmlNode, htmlNode, isDeleting, oneLeft, noChildren){
        if (!htmlNode) return;

        if (isDeleting) {
            //if isLast fix previousSibling
            var prevSib;
            if (prevSib = this.getNextTraverse(xmlNode, true))
                this.fixItem(prevSib, this.$findHtmlNode(
                    prevSib.getAttribute(apf.xmldb.xmlIdTag) + "|" 
                    + this.$uniqueId), null, true);

            //if no sibling fix parent
            if (!this.emptyMessage 
              && xmlNode.parentNode.selectNodes(this.each).length == 1) //@todo each parent??
                this.fixItem(xmlNode.parentNode, this.$findHtmlNode(
                    xmlNode.parentNode.getAttribute(apf.xmldb.xmlIdTag) 
                    + "|" + this.$uniqueId), null, false, true); 
        }
        else {
            var hasChildren, container = this.$getLayoutNode("item", "container", htmlNode);
            
            if (noChildren)
                hasChildren = false;
            else
                if (xmlNode.selectNodes(this.each).length > 0)
                    hasChildren = true;
            else
                if (this.$getBindRule("insert", xmlNode))
                    hasChildren = true;
            else
                hasChildren = false;
            
            var isClosed = hasChildren && container.style.display != "block";
            var isLast   = this.getNextTraverse(xmlNode, null, oneLeft ? 2 : 1) 
                ? false 
                : true;

            var state = (hasChildren ? HAS_CHILD : 0) | (isClosed ? IS_CLOSED : 0) 
                | (isLast ? IS_LAST : 0);
            this.$setStyleClass(this.$getLayoutNode("item", "openclose", 
                htmlNode), treeState[state], ["min", "plus", "last", "minlast", 
                "pluslast"]);
            this.$setStyleClass(this.$getLayoutNode("item", "container", 
                htmlNode), treeState[state], ["min", "plus", "last", "minlast", 
                "pluslast"]);
            
            if (!hasChildren)
                container.style.display = "none";
            
            if (state & HAS_CHILD) {
                //this.$getLayoutNode("item", "openclose", htmlNode).onmousedown = new Function('e', 'if(!e) e = event; if(e.button == 2) return;var o = apf.lookup(' + this.$uniqueId + ');o.slideToggle(this);if(o.onmousedown) o.onmousedown(e, this);apf.cancelBubble(e, o);');
                //this.$getLayoutNode("item", "icon", htmlNode)[this.opencloseaction || "ondblclick"] = new Function('var o = apf.lookup(' + this.$uniqueId + '); o.slideToggle(this);o.choose();');
                //this.$getLayoutNode("item", "select", htmlNode)[this.opencloseaction || "ondblclick"] = new Function('e', 'var o = apf.lookup(' + this.$uniqueId + '); o.slideToggle(this, true);o.choose();(e||event).cancelBubble=true;');
            }
            /*else{
                //Experimental
                this.$getLayoutNode("item", "openclose", htmlNode).onmousedown = null;
                this.$getLayoutNode("item", "icon", htmlNode)[this.opencloseaction || "ondblclick"] = null;
                this.$getLayoutNode("item", "select", htmlNode)[this.opencloseaction || "ondblclick"] = null;
            }*/
        }
    };
    
    this.startRenameThis = function(oHtml, Lid, isName){
        this.$getCaptionElement = function(){
            return oHtml;
        }
        
        var attrName = oHtml.getAttribute("aname");
        
        var xmlNode = apf.xmldb.getNodeById(Lid);
        this.$getCaptionXml = function(){ //@todo
            return attrName ? xmlNode.getAttributeNode(attrName) : xmlNode.firstChild;
        }
        
        this.getSelectFromRule = function(setname, cnode){
            return [null, attrName ? xmlNode.getAttributeNode(attrName) : xmlNode.firstChild];
        };
        
        if (isName) {
            var renCallback = function(e){
                this.removeEventListener("beforerename", renCallback, true);
                this.removeEventListener("stoprename", renRemove, true);

                if (e.args[2] == attrName)
                    return false;
                    
                var changes = [];
                changes.push({
                    func : "removeAttribute",
                    args : [xmlNode, attrName]
                });
                
                changes.push({
                    func : "setAttribute",
                    args : [xmlNode, e.args[2], xmlNode.getAttribute(attrName) || ""]
                });
                
                e.action = "multicall";
                e.args   = changes;
            };
            var renRemove = function(){
                this.removeEventListener("beforerename", renCallback, true);
                this.removeEventListener("stoprename", renRemove, true);
            };
            this.addEventListener("beforerename", renCallback, true);
            this.addEventListener("stoprename", renRemove, true);
        }
        
        this.startRename();
        
        if (isName)
            this.oTxt[apf.hasContentEditable ? "innerHTML" : "value"] = attrName;
    }
    
    /**
     * @todo  Make it xmlNode locked
     * @todo  Use escape(27) key to cancel change (see rename)
     */
    function addAttribute(pNode, name, value, htmlNode, Lid){
        _self.$getNewContext("attribute");
        var elName = _self.$getLayoutNode("attribute", "name");
        var elValue = _self.$getLayoutNode("attribute", "value");
        apf.setNodeValue(elName, name);
        apf.setNodeValue(elValue, (value.length > 50 ? "..." : value));
        if (value.length > 50)
            elValue.setAttribute("title", value);
        
        elName.setAttribute("aname", name);
        elName.setAttribute("onmousedown", "apf.lookup(" + _self.$uniqueId + ").startRenameThis(this, '" + Lid + "', true);\
            event.cancelBubble=true;");
        elName.setAttribute("onmouseup", "\
            event.cancelBubble=true;\
            return false;");
        elName.setAttribute("onkeydown", "if (event.keyCode==13) {\
              this.blur();\
              return false;\
            };\
            event.cancelBubble=true;");
        elName.setAttribute("onselectstart", "event.cancelBubble = true;");
        elName.setAttribute("ondblclick", "event.cancelBubble = true;");
        
        elValue.setAttribute("aname", name);
        elValue.setAttribute("onmousedown", "apf.lookup(" + _self.$uniqueId + ").startRenameThis(this, '" + Lid + "');\
            event.cancelBubble=true;");
        elValue.setAttribute("onmouseup", "apf.selectTextHtml(this);\
            event.cancelBubble=true;\
            return false;");
        elValue.setAttribute("onkeydown", "if (event.keyCode==13) {\
              this.blur();\
              return false;\
            };\
            event.cancelBubble=true;");
        elValue.setAttribute("onselectstart", "event.cancelBubble = true;");
        elValue.setAttribute("ondblclick", "event.cancelBubble = true;");
        
        if (pNode.style) {
            htmlNode = apf.insertHtmlNode(
                _self.$getLayoutNode("attribute"), 
                pNode, 
                _self.$getLayoutNode("item", "begintag", htmlNode).nextSibling);
            
            animHighlight(htmlNode);
            animHighlight(_self.$getLayoutNode("attribute", "name", htmlNode));
            animHighlight(_self.$getLayoutNode("attribute", "value", htmlNode));
        }
        else
            pNode.appendChild(_self.$getLayoutNode("attribute"));
    }
    
    function addTextnode(pNode, value, Lid){
        _self.$getNewContext("textnode");
        var elTextNode = _self.$getLayoutNode("textnode", "text");
        var elTag = _self.$getLayoutNode("textnode", "tag");
        apf.setNodeValue(elTextNode, (value.length > 50 ? "..." : value));
        if (value.length > 50)
            elTextNode.setAttribute("title", value);
        
        elTextNode.setAttribute("onmousedown", "apf.lookup(" + _self.$uniqueId + ").startRenameThis(this, '" + Lid + "');");
        elTextNode.setAttribute("onmouseup", "\
            event.cancelBubble=true;\
            return false;");
        elTextNode.setAttribute("onkeydown", "if (event.keyCode==13) {\
              this.blur();\
              return false;\
            };\
            event.cancelBubble=true;");
        elTextNode.setAttribute("onselectstart", "event.cancelBubble = true;");
        elTextNode.setAttribute("ondblclick", "event.cancelBubble = true;");
        
        apf.setNodeValue(elTag, "&gt;");
        
        if (pNode.style) {
            var htmlNode = apf.insertHtmlNode(
                _self.$getLayoutNode("textnode"), pNode, pNode.lastChild);
            animHighlight(_self.$getLayoutNode("textnode", "text", htmlNode));
        }
        else
            pNode.appendChild(_self.$getLayoutNode("textnode"));
    }

    //This can be optimized by NOT using getLayoutNode all the time
    this.initNode = function(xmlNode, state, Lid){
        //Setup Nodes Interaction
        this.$getNewContext("item");
        
        var hasChildren = (state & HAS_CHILD || this.emptyMessage 
            && this.$applyBindRule("empty", xmlNode));
        
        //should be restructured and combined events set per element 
        var elItem = this.$getLayoutNode("item");
        elItem.setAttribute("onmouseover", 'var o = apf.lookup(' + this.$uniqueId + ');\
            if (o.onmouseover) \
                o.onmouseover(event, this);');
        elItem.setAttribute("onmouseout", 'var o = apf.lookup(' + this.$uniqueId + ');\
            if(o.onmouseout) \
                o.onmouseout(event, this)');
        elItem.setAttribute("onmousedown", 'var o = apf.lookup(' + this.$uniqueId + ');\
            if (o.onmousedown) \
                o.onmousedown(event, this);');
        elItem.setAttribute(apf.xmldb.htmlIdTag, Lid);
        
        //Set open/close skin class & interaction
        this.$setStyleClass(this.$getLayoutNode("item", "openclose"), 
            treeState[state]);
        this.$setStyleClass(this.$getLayoutNode("item", "container"), 
            treeState[state])
        var elOpenClose = this.$getLayoutNode("item", "openclose");
        if (hasChildren)
            elOpenClose.setAttribute(this.opencloseaction || "onmousedown",
                "var o = apf.lookup(" + this.$uniqueId + ");\
                o.slideToggle(this);\
                if (o.onmousedown) \
                    o.onmousedown(event, this);\
                apf.cancelBubble(event,o);");
        
        //Select interaction
        var elSelect = this.$getLayoutNode("item", "select");
        if (hasChildren) {
            var strFunc2 = "var o = apf.lookup(" + this.$uniqueId + ");\
                o.slideToggle(this, true);";
            //if(this.opencloseaction != "onmousedown") elSelect.setAttribute(this.opencloseaction || "ondblclick", strFunc2);
        }
        //if(event.button != 1) return; 
        //apf.isChildOf(o.$selected, this) && o.selected [REMOVED THIS LINE... dunno what the repurcusions are exactly]
        elSelect.setAttribute("onmousedown", "var o = apf.lookup(" + this.$uniqueId + ");\
            apf.cancelBubble(event, o);\
            if (o.hasFocus()) \
                o.select(this);\
            if (o.onmousedown) \
                o.onmousedown(event, this);" 
            + (strFunc2 && this.opencloseaction == "onmousedown" ? strFunc2 : ""));
        //if(!elSelect.getAttribute("ondblclick")) elSelect.setAttribute("ondblclick", 'var o = apf.lookup(' + this.$uniqueId + ');o.choose();');

        //elItem.setAttribute("contextmenu", 'alert(1);var o = apf.lookup(' + this.$uniqueId + ');o.dispatchEvent("contextMenu", o.selected);');
        
        var elBegin = this.$getLayoutNode("item", "begintag");
        apf.setNodeValue(elBegin, "&lt;" + xmlNode.tagName);
        
        //attributes
        var elAttributes = this.$getLayoutNode("item", "attributes");
        var len = xmlNode.attributes.length;
        if (typeof len == "function")
            len = xmlNode.attributes.length();
        for (var i = 0; i < len; i++) {
            var attr = xmlNode.attributes.item(i);
            if (attr.nodeName.match(/a_id|a_listen|a_doc|a_loaded/))
                continue;
            
            addAttribute(elAttributes, attr.nodeName, 
                attr.nodeValue, null, Lid);
        }
        
        var elBeginTail = this.$getLayoutNode("item", "begintail");
        var elEnd = this.$getLayoutNode("item", "endtag");
        if (!(state&HAS_CHILD)) {
            elEnd.setAttribute("style", "display:none");

            if (xmlNode.childNodes.length) {
                addTextnode(elAttributes, xmlNode.childNodes[0].nodeValue, Lid);
                apf.setNodeValue(elBeginTail, "&lt;/" + xmlNode.tagName + "&gt;");
            }
            else
                apf.setNodeValue(elBeginTail, " /&gt;");
        }
        else {
            apf.setNodeValue(elEnd, "&lt;/" + xmlNode.tagName + "&gt;");
            apf.setNodeValue(elBeginTail, "&gt;");
        }
        elBeginTail.parentNode.appendChild(elBeginTail);
        
        elEnd.setAttribute("onmousedown", 'var o = apf.lookup(' + this.$uniqueId + ');apf.cancelBubble(event, o);');
        
        
        var cssClass = this.$applyBindRule("css", xmlNode);
        if (cssClass) {
            this.$setStyleClass(this.$getLayoutNode("item", null, 
                this.$getLayoutNode("item")), cssClass);
            if (cssClass)
                this.dynCssClasses.push(cssClass);
        }
        

        return this.$getLayoutNode("item");
    };
    
    this.$deInitNode = function(xmlNode, htmlNode){
        //Lookup container
        var containerNode = this.$getLayoutNode("item", "container", htmlNode);
        var pContainer    = htmlNode.parentNode;
        
        //Remove htmlNodes from tree
        containerNode.parentNode.removeChild(containerNode);
        pContainer.removeChild(htmlNode);
        
        //Fix Images (+, - and lines)
        if (xmlNode.parentNode != this.xmlRoot)
            this.fixItem(xmlNode, htmlNode, true);
        
        if (this.emptyMessage && !pContainer.childNodes.length)
            this.setEmpty(pContainer);
        
        //Fix look (tree thing)
        this.fixItem(xmlNode, htmlNode, true);
        
        if (xmlNode == this.selected)
            this.clearSelection();
        
        //this.fixItem(xmlNode.parentNode, apf.xmldb.findHtmlNode(xmlNode.parentNode, this));
        /*throw new Error();
        if(xmlNode.previousSibling) //should use each here
            this.fixItem(xmlNode.previousSibling, apf.xmldb.findHtmlNode(xmlNode.previousSibling, this));*/
    };
    
    function animHighlight(oHtml){
        if (!oHtml.offsetHeight) return;
        
        apf.setStyleClass(oHtml, "highlight");
        $setTimeout(function(){
            apf.tween.css(oHtml, "highlight", {
                anim    : 0, 
                steps   : 20, 
                interval: 30}, true);
        }, 400);
    }
    
    this.$updateNode = function(xmlNode, htmlNode){
        //Attributes
        var len, i, aLookup   = {};
        var elAttributes = this.$getLayoutNode("item", "attributes", htmlNode);
        var elEnd        = this.$getLayoutNode("item", "endtag", htmlNode);
        var elBeginTail  = this.$getLayoutNode("item", "begintail", htmlNode);

        //if (typeof len == "function")
            len = xmlNode.attributes.length;
        for (var i = 0; i < len; i++) {
            var attr = xmlNode.attributes.item(i);
            if (attr.nodeName.match(/a_id|a_listen|a_doc|a_loaded/))
                continue;
            aLookup[attr.nodeName] = attr.nodeValue;
        }

        var doneFirstChild     = false;
        var nodes = [], cnodes = elAttributes.childNodes;
        for (i = 0; i < cnodes.length; i++)
            nodes.push(cnodes[i]);
        
        for (i = 0; i < nodes.length; i++) {
            if (nodes[i].nodeType != 1)
                continue;
            
            if (nodes[i].className.indexOf("textnode") > -1) {
                if (xmlNode.childNodes.length == 1 
                  && xmlNode.childNodes[0].nodeType == 3) {
                    var elText = this.$getLayoutNode("textnode", "text", nodes[i]);
                    if (xmlNode.firstChild.nodeValue != elText.innerHTML) {
                        elText.innerHTML = xmlNode.firstChild.nodeValue;
                        //Animate change here
                        animHighlight(elText);
                    }
                }
                else {
                    nodes[i].parentNode.removeChild(nodes[i]);//apf.removeChild here??
                    apf.setNodeValue(elBeginTail, " /&gt;");
                }
                
                doneFirstChild = true;
            }
            
            if (nodes[i].className.indexOf("attribute") == -1) 
                continue;
            
            var elName  = this.$getLayoutNode("attribute", "name", nodes[i]);
            var elValue = this.$getLayoutNode("attribute", "value", nodes[i]);
            
            //Remove attribute if it no longer exists
            var name = elName.innerHTML;
            if (!aLookup[name])
                nodes[i].parentNode.removeChild(nodes[i]);//apf.removeChild here??
            //Change it
            else if(aLookup[name] != elValue.innerHTML) {
                elValue.innerHTML = aLookup[name];
                
                animHighlight(elValue);
                //Animate change here...
                delete aLookup[name];
            } 
            else if(aLookup[name])
                delete aLookup[name];
            
            elName.setAttribute("aname", name);
            elValue.setAttribute("aname", name);
        }
        
        //Add the remaining attributes
        for (var attr in aLookup) {
            addAttribute(elAttributes, attr, aLookup[attr], htmlNode, xmlNode.getAttribute(apf.xmldb.xmlIdTag));
        }
        
        //Add textnode if its not there yet
        if (!doneFirstChild && xmlNode.childNodes.length == 1 
          && xmlNode.childNodes[0].nodeType == 3) {
            addTextnode(elAttributes, xmlNode.childNodes[0].nodeValue);
            apf.setNodeValue(elBeginTail, "</" + xmlNode.tagName + ">");
        }
        
        
        var cssClass = this.$applyBindRule("css", xmlNode);
        if (cssClass || this.dynCssClasses.length) {
            this.$setStyleClass(htmlNode, cssClass, this.dynCssClasses);
            if (cssClass && !this.dynCssClasses.contains(cssClass))
                this.dynCssClasses.push(cssClass);
        }
        
    };
    
    this.clearEmpty = function(container){
        container.innerHTML = "";
    };
        
    this.setEmpty = function(container){
        this.$getNewContext("empty");
        var oItem = this.$getLayoutNode("empty");
        this.$getLayoutNode("empty", "caption").nodeValue = this.emptyMessage;
        apf.insertHtmlNode(oItem, container);
        
        if (!this.startClosed) {
            if (container.style) {
                //container.style.display = "block";
                //container.style.height = "auto";
            }
            //else container.setAttribute("style", "display:block;height:auto;");
        }
    };
    
    this.$setLoading = function(xmlNode, container){
        this.$getNewContext("Loading");
        this.$setLoadStatus(xmlNode, "potential");
        apf.insertHtmlNode(this.$getLayoutNode("loading"), container);
    };
    
    this.$removeLoading = function(htmlNode){
        if (!htmlNode) return;
        this.$getLayoutNode("item", "container", htmlNode).innerHTML = "";
    };
    
    function xmlUpdateHandler(e){
        /*
            Display the animation if the item added is 
            * Not in the cache
            - Being insterted using xmlUpdate
            - there is at least 1 child inserted
        */
        
        if (e.action == "move-away")
            this.fixItem(e.xmlNode, apf.xmldb.findHtmlNode(e.xmlNode, this), true);

        if (e.action != "insert") return;
        
        var htmlNode = this.$findHtmlNode(e.xmlNode.getAttribute(apf.xmldb.xmlIdTag)+"|"+this.$uniqueId);
        if (!htmlNode) return;
        if (this.$hasLoadStatus(e.xmlNode, "loading") && e.result.length > 0) {
            var container = this.$getLayoutNode("item", "container", htmlNode);
            this.slideOpen(container, e.xmlNode);
        }
        else
            this.fixItem(e.xmlNode, htmlNode);
        
        //Can this be removed?? (because it was added in the insert function)
        if (this.$hasLoadStatus(e.xmlNode, "loading"))
            this.$setLoadStatus(e.xmlNode, "loaded");
    }
    
    this.addEventListener("xmlupdate", xmlUpdateHandler);
    
    /* ***********************
        Keyboard Support
    ************************/
    
    
    this.addEventListener("keydown", function(e){
        var key      = e.keyCode;
        var ctrlKey  = e.ctrlKey;
        var shiftKey = e.shiftKey;
        var selHtml  = this.$caret || this.$selected;
        
        if (!selHtml || this.renaming) 
            return;

        var selXml = this.caret || this.selected;
        var oExt   = this.$ext;

        switch (key) {
            case 13:
                if (this.$tempsel)
                    this.$selectTemp();
            
                if (this.ctrlselect == "enter")
                    this.select(this.caret, true);
            
                this.choose(selHtml);
                break;
            case 32:
                if (ctrlKey)
                    this.select(this.caret, true);
                break;
            case 46:
                if (this.$tempsel)
                    this.$selectTemp();
            
                //DELETE
                //this.remove();
                this.remove(this.mode ? this.caret : null); //this.mode != "check"
                break;
            case 109:
            case 37:
                //LEFT
                if (this.$tempsel)
                    this.$selectTemp();
                    
                if (this.caret.selectSingleNode(this.each))
                    this.slideToggle(this.$caret || this.$selected, 2)
                break;
            case 107:
            case 39:
                //RIGHT
                if (this.$tempsel)
                    this.$selectTemp();
            
                if (this.caret.selectSingleNode(this.each))
                    this.slideToggle(this.$caret || this.$selected, 1)
                break;
            case 187:
                //+
                if (shiftKey)
                    arguments.callee(39);
            break;
            case 189:
                //-
                if (!shiftKey)
                    arguments.callee(37);
                break;
            case 38:
                //UP
                if (!selXml && !this.$tempsel) 
                    return;
                
                var node = this.$tempsel 
                    ? apf.xmldb.getNode(this.$tempsel) 
                    : selXml;
                
                var sNode = this.getNextTraverse(node, true);
                if (sNode) {
                    var nodes = this.getTraverseNodes(sNode);
                    
                    do {
                        var container = this.$getLayoutNode("item", "container",
                            this.$findHtmlNode(apf.xmldb.getID(sNode, this)));
                        if (container && apf.getStyle(container, "display") == "block" 
                          && nodes.length) {
                                sNode = nodes[nodes.length-1];
                        }
                        else 
                            break;
                    }
                    while (sNode && (nodes = this.getTraverseNodes(sNode)).length);
                }
                else if (this.getTraverseParent(node) == this.xmlRoot) {
                    this.dispatchEvent("selecttop");
                    return;
                }
                else
                    sNode = this.getTraverseParent(node);

                if (sNode && sNode.nodeType == 1)
                   this.$setTempSelected (sNode, ctrlKey, shiftKey);
                
                if (this.$tempsel && this.$tempsel.offsetTop < oExt.scrollTop)
                    oExt.scrollTop = this.$tempsel.offsetTop;
                
                return false;
             
                break;
            case 40:
                //DOWN
                if (!selXml && !this.$tempsel) 
                    return;
                    
                var node = this.$tempsel 
                    ? apf.xmldb.getNode(this.$tempsel) 
                    : selXml;
                
                var sNode = this.getFirstTraverseNode(node);
                if (sNode) {
                    var container = this.$getLayoutNode("item", "container",
                        this.$findHtmlNode(apf.xmldb.getID(node, this)));
                    if (container && apf.getStyle(container, "display") != "block")
                        sNode = null;
                }
                
                while (!sNode) {
                    var pNode = this.getTraverseParent(node);
                    if (!pNode) break;
                    
                    var i = 0;
                    var nodes = this.getTraverseNodes(pNode);
                    while (nodes[i] && nodes[i] != node)
                        i++;
                    sNode = nodes[i+1];
                    node  = pNode;
                }
                
                if (sNode && sNode.nodeType == 1)
                   this.$setTempSelected (sNode, ctrlKey, shiftKey);
                
                if (this.$tempsel && this.$tempsel.offsetTop + this.$tempsel.offsetHeight
                  > oExt.scrollTop + oExt.offsetHeight)
                    oExt.scrollTop = this.$tempsel.offsetTop 
                        - oExt.offsetHeight + this.$tempsel.offsetHeight + 10;
                
                return false;
                break;
            case 33: //@todo
                //PGUP
                break;
            case 34: //@todo
                //PGDN
                break;
            case 36: //@todo
                //HOME
                break;
            case 35: //@todo
                //END
                break;
        }
    }, true);
    
    
    /* ***********************
            DATABINDING
    ************************/

    var nodes = [];

    this.$add = function(xmlNode, Lid, xmlParentNode, htmlParentNode, beforeNode, isLast){
        //Why is this function called 3 times when adding one node? (hack/should)
        var loadChildren = this.$getBindRule("insert", xmlNode) ? true : false;
        var hasChildren  = (loadChildren 
            || xmlNode.selectSingleNode(this.each)) ? true : false;
        
        var startClosed  = this.startClosed;// || this.$applyBindRule("collapse", xmlNode, ".") !== false;
        var state        = (hasChildren ? HAS_CHILD : 0) 
            | (startClosed && hasChildren  || loadChildren ? IS_CLOSED : 0) 
            | (isLast ? IS_LAST : 0);

        var htmlNode     = this.initNode(xmlNode, state, Lid);
        var container    = this.$getLayoutNode("item", "container");
        if (!startClosed && !this.noCollapse)
            container.setAttribute("style", "overflow:visible;height:auto;display:block;");
        
        //TEMP on for dynamic subloading
        if (!hasChildren || loadChildren)
            container.setAttribute("style", "display:none;");
        
        //Dynamic SubLoading (Insertion) of SubTree
        if (loadChildren && !this.$hasLoadStatus(xmlNode))
            this.$setLoading(xmlNode, container);
        else if(!this.getTraverseNodes(xmlNode).length 
          && this.$applyBindRule("empty", xmlNode))
            this.setEmpty(container);

        if (!htmlParentNode && (xmlParentNode == this.xmlRoot 
          || xmlNode == this.xmlRoot)) {
            nodes.push(htmlNode);
            if (!apf.isChildOf(htmlNode, container, true))
                nodes.push(container);
            
            this.$setStyleClass(htmlNode,  "root");
            this.$setStyleClass(container, "root");
            
            //if(xmlNode == xmlParentNode) return container;
        }
        else {
            if (!htmlParentNode) {
                htmlParentNode = apf.xmldb.findHtmlNode(xmlNode.parentNode, this);
                htmlParentNode = htmlParentNode 
                    ? this.$getLayoutNode("item", "container", htmlParentNode) 
                    : this.$int;
            }
            
            if (htmlParentNode == this.$int) {
                this.$setStyleClass(htmlNode,  "root");
                this.$setStyleClass(container, "root");
                
                if (this.renderRoot) {
                    var realParent = apf.xmldb.findHtmlNode(this.xmlRoot, this);
                    htmlParentNode = this.$getLayoutNode("item", "container", realParent);
                }
            }
            
            if (!beforeNode && this.getNextTraverse(xmlNode))
                beforeNode = apf.xmldb.findHtmlNode(this.getNextTraverse(xmlNode), this);
            if (beforeNode && beforeNode.parentNode != htmlParentNode)
                beforeNode = null;

            if (htmlParentNode.style && this.getTraverseNodes(xmlNode.parentNode).length == 1) 
                this.clearEmpty(htmlParentNode);
        
            //alert("|" + htmlNode.nodeType + "-" + htmlParentNode.nodeType + "-" + beforeNode + ":" + container.nodeType);
            //Insert Node into Tree
            if (htmlParentNode.style) {
                var q = apf.insertHtmlNode(htmlNode, htmlParentNode, beforeNode);
                animHighlight(this.$getLayoutNode("item", "select", q));
                
                if (!apf.isChildOf(htmlNode, container, true)) 
                    var container = apf.insertHtmlNode(container, htmlParentNode, beforeNode);
            }
            else {
                htmlParentNode.insertBefore(htmlNode, beforeNode);
                if (!apf.isChildOf(htmlParentNode, container, true)) 
                    htmlParentNode.insertBefore(container, beforeNode);
            }

            //Fix parent if child is added to drawn parentNode
            if (htmlParentNode.style) {
                if(!startClosed && this.openOnAdd 
                  && htmlParentNode != this.$int 
                  && htmlParentNode.style.display != "block") 
                    this.slideOpen(htmlParentNode, xmlParentNode);
                
                //this.fixItem(xmlNode, htmlNode); this one shouldn't be called, because it should be set right at init
                this.fixItem(xmlParentNode, apf.xmldb.findHtmlNode(xmlParentNode, this));
                if (this.getNextTraverse(xmlNode, true)) { //should use each here
                    this.fixItem(this.getNextTraverse(xmlNode, true), 
                        apf.xmldb.findHtmlNode(this.getNextTraverse(xmlNode, true), this));
                }
            }
        }
        
        if (this.prerender) 
            this.$addNodes(xmlNode, container, true); //checkChildren (optimization) ???
        else
            this.$setLoadStatus(xmlNode, "potential");

        return container;
    };
    
    this.$fill = function(){
        var container;

        //Please please consider moving this to apf.databinding and make it generic.. this is a mess
        /*if(this.renderRoot){
            var htmlNode = apf.xmldb.findHtmlNode(this.xmlRoot, this);
            if(!htmlNode || htmlNode.parentNode != this.$int){
                var nodes = nodes;
                nodes = [];
                
                var Lid = apf.xmldb.nodeConnect(this.documentId, this.xmlRoot, null, this);
                var p = this.$add(this.xmlRoot, Lid, this.xmlRoot, null, null, true);
                for(var i=0;i<nodes.length;i++) p.appendChild(nodes[i]);
            }
            else{
                container = this.$getLayoutNode("item", "container", htmlNode);
            }
        }*/

        apf.insertHtmlNodes(nodes, container || this.$int);
        nodes.length = 0;
    };
    
    this.$getParentNode = function(htmlNode){
        return htmlNode 
            ? this.$getLayoutNode("item", "container", htmlNode) 
            : this.$int;
    };
    
    /* ***********************
            SELECT
    ************************/
    
    this.$calcSelectRange = function(xmlStartNode, xmlEndNode){
        //should be implemented :)
        return [xmlStartNode, xmlEndNode];
    };
    
    this.$findContainer = function(htmlNode){
        return this.$getLayoutNode("item", "container", htmlNode);
    };
    
    this.multiselect = false; // Initially Disable MultiSelect
    
    this.$selectDefault = function(xmlNode){
        if (this.select(this.getFirstTraverseNode(xmlNode), null, null, null, true)) 
            return true;
        else{
            var nodes = this.getTraverseNodes(xmlNode);
            for(var i=0;i<nodes.length;i++){
                if(this.$selectDefault(nodes[i])) return true;
            }
        }
    };
    
    this.$select = function(o){
        if(!o || !o.style) return;
        this.$setStyleClass(this.$getLayoutNode("item", "class", o), "selected");
        return o;
    };

    this.$deselect = function(o){
        if(!o) return;
        this.$setStyleClass(this.$getLayoutNode("item", "class", o), "", ["selected", "indicate"]);
        return o;
    };
    
    this.$indicate = function(o){
        if(!o) return;
        this.$setStyleClass(this.$getLayoutNode("item", "class", o), "indicate");
        return o;
    };

    this.$deindicate = function(o){
        if(!o) return;
        this.$setStyleClass(this.$getLayoutNode("item", "class", o), "", ["indicate"]);
        return o;
    };
    
    /* *********
        INIT
    **********/
    //render the outer framework of this object
    this.$draw = function(){
        //Build Main Skin
        this.$ext = this.$getExternal(); 
        this.$int = this.$getLayoutNode("main", "container", this.$ext);
        this.opencloseaction = this.$getOption("Main", "openclose");
        
        //Need fix...
        //this.$ext.style.MozUserSelect = "none";

        this.$ext.onclick = function(e){
            this.host.dispatchEvent("click", {htmlEvent : e || event});
        }
    };
    
    this.$loadAml = function(x){
        this.openOnAdd   = !apf.isFalse(x.getAttribute("openonadd"));
        this.startClosed = !apf.isFalse(this.getAttribute("startclosed") 
            || this.$getOption("Main", "startclosed"));
        this.noCollapse  = apf.isTrue(this.getAttribute("nocollapse"));
        if (this.noCollapse)
            this.startClosed = false;
        this.singleopen  = apf.isTrue(this.getAttribute("singleopen"));
        this.prerender   = !apf.isFalse(this.getAttribute("prerender"));
    };
    
    this.$destroy = function(){
        this.$ext.onclick = null;
        apf.destroyHtmlNode(this.oDrag);
        this.oDrag = null;
    };
}).call(apf.markupedit.prototype = new apf.GuiElement());

apf.aml.setElement("markupdit", apf.markupedit);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/bindingeachrule.js)SIZE(8636)TIME(1259091146)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @define bindings
 * @allowchild each
 * @binding each Determines the list of elements for which each
 * gets a visual representation within the element. It also can determine
 * the sequence of how the elements are visualized by offering a way to
 * specify the sort order. (N.B. The sorting mechanism is very similar to
 * that of XSLT)
 * Example:
 * This example contains a list that displays elements with the tagName
 * 'mail' that do not have a deleted attribute set to 1.
 * <code>
 *  <a:model id="mdlList">
 *      <data>
 *          <item date="2009-11-12" deleted="0"></item>
 *          <item date="2009-11-11" deleted="0"></item>
 *          <item date="2009-11-10" deleted="0"></item>
 *          <item date="2009-11-09" deleted="1"></item>
 *          <item date="2009-11-08" deleted="1"></item>
 *      </data>
 *  </a:model>
 *  <a:list id="list" width="200" height="200" model="mdlList">
 *      <a:bindings>
 *          <a:caption match="[@date]" />
 *          <a:each match="[item[not(@deleted='1')]]" />
 *      </a:bindings>
 *  </a:list>
 * </code>
 * Example:
 * This example shows how to use the each rule to order files based
 * on their modified data.
 * <code>
 *  <a:model id="mdlList">
 *      <data>
 *          <item date="2009-11-12"></item>
 *          <item date="2009-11-11"></item>
 *      </data>
 *  </a:model>
 *  <a:list width="200" height="200" model="mdlList">
 *      <a:each match="[item]" sort="[@date]" order="ascending">
 *          <a:caption match="[@date]" />
 *      </a:each>
 *  </a:list>
 * </code>
 * Example:
 * This example shows how to do complex sorting using a javascript callback function.
 * <code>
 *  <a:each select="file|folder" sort="[@name]" sort-method="compare" />
 *  <a:script>
 *      function compare(value, args, xmlNode) {
 *          //Sort all folders together and all files and then sort on alphabet.
 *          return (xmlNode.tagName == "folder" ? 0 : 1) + value;
 *      }
 *  </a:script>
 * </code>
 * @attribute {String} select       an xpath statement which selects the nodes
 *                                  which will be rendered.
 * @attribute {String} sort         an xpath statement which selects the value
 *                                  which is subject to the sorting algorithm.
 * @attribute {String} data-type    the way sorting is executed. See
 *                                  {@link baseclass.multiselectbinding.binding.each.attribute.sort-method}
 *                                  on how to specify a custom sort method.
 *   Possible values:
 *   string  Sorts alphabetically
 *   number  Sorts based on numerical value (i.e. 9 is lower than 10).
 *   date    Sorts based on the date sequence (21-6-1980 is lower than 1-1-2000).
 *           See {@link baseclass.multiselectbinding.binding.each.attribute.date-format}
 *           on how to specify the date format.
 * @attribute {String} date-format  the format of the date on which is sorted.
 *   Possible values:
 *   YYYY   Full year
 *   YY     Short year
 *   DD     Day of month
 *   MM     Month
 *   hh     Hours
 *   mm     Minutes
 *   ss     Seconds
 * Example:
 * <code>
 *  date-format="DD-MM-YYYY"
 * </code>
 * @attribute {String} sort-method  the name of a javascript function to executed
 *                                  to determine the value to sort on.
 * @attribute {String} order        the order of the sorted list.
 *   Possible values:
 *   ascending  Default sorting order
 *   descending Reverses the default sorting order.
 * @attribute {String} case-order   whether upper case characters have preference
 *                                  above lower case characters.
 *   Possible values:
 *   upper-first    Upper case characters are higher.
 *   lower-first    Lower case characters are higher.
 */
apf.BindingEachRule = function(struct, tagName){
    this.$init(tagName, apf.NODE_HIDDEN, struct);
    
    var _self = this;
    this.$noderegister = function(e){
        e.amlNode.$handleBindingRule(_self.match, "each");
    
        
        e.amlNode.$sort = _self.sort ? new apf.Sort(_self) : null;
        
    }
};

(function(){
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        "sort"         : 1,
        "data-type"    : 1,
        "date-format"  : 1,
        "sort-method"  : 1,
        "order"        : 1,
        "case-order"   : 1
    }, this.$attrExcludePropBind);

    this.$propHandlers["sort"]        = 
    this.$propHandlers["data-type"]   = 
    this.$propHandlers["date-format"] = 
    this.$propHandlers["order"]       = 
    this.$propHandlers["case-order"]  = function(value, prop){
        delete this["c" + prop];
        
        //@todo apf3.0 change sort
    }
    
    this.addEventListener("prop.match", function(e){
        var pNode = this.parentNode;//@todo apf3.0 get a list via $bindings
        if (pNode.localName == "bindings") {
            var nodes = pNode.$amlNodes;
            for (var i = 0; i < nodes.length; i++) {
                nodes[i].$handleBindingRule(this.match, "each");
            }
        }
        else
            pNode.$handleBindingRule(this.match, "each");
    });
    
    //@todo apf3.0 optimize
    var f;
    this.addEventListener("DOMNodeInserted", f = function(e){
        if (e.currentTarget != this)
            return;
        
        var pNode = this.parentNode;//@todo apf3.0 get a list via $bindings
        if (pNode.localName == "bindings") {
            pNode.addEventListener("noderegister", this.$noderegister);
            
            var nodes = pNode.$amlNodes;
            for (var i = 0; i < nodes.length; i++) {
                nodes[i].$handleBindingRule(this.match, "each");
    
                
                nodes[i].$sort = this.sort ? new apf.Sort(this) : null;
                
            }
        }
        else {
            pNode.$handleBindingRule(this.match, "each");
    
            
            pNode.$sort = this.sort ? new apf.Sort(this) : null;
            
        }
    });
    
    this.addEventListener("DOMNodeRemoved", function(e){
        if (e.currentTarget != this)
            return;
        
        //@todo apf3.0 how does this conflict with setting it through an attribute.
        //this.$clearDynamicProperty("each");
        //pNode.setProperty("each", null);//@todo double?
        //@todo remove model?
        
        //@todo this should be near $handleBindingRule...
        var pNode = this.parentNode;//@todo apf3.0 get a list via $bindings
        if (pNode.localName == "bindings") {
            pNode.removeEventListener("noderegister", this.$noderegister);
            
            var nodes = pNode.$amlNodes;
            for (var i = 0; i < nodes.length; i++) {
                //delete nodes[i].each; //@todo apf3.x is already set by new one
    
                
                delete nodes[i].$sort;
                
            }
        }
        else {
            //delete pNode.each; //@todo apf3.x is already set by new one
            
            
            delete pNode.$sort;
            
        }
    });
    
    this.addEventListener("DOMNodeInsertedIntoDocument", f);
    
}).call(apf.BindingEachRule.prototype = new apf.BindingRule());

apf.aml.setElement("each", apf.BindingEachRule);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/webdav.js)SIZE(44853)TIME(1263859264)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Element implementing WebDAV remote filesystem protocol.
 * WebDAV stands for "Web-based Distributed Authoring and Versioning". It is a
 * set of extensions to the HTTP protocol which allows users to collaboratively
 * edit and manage files on remote web servers (from: {@link http://www.webdav.org}.
 * This Object aims to be a complete implementation of {@link http://www.webdav.org/specs/rfc4918.html RFC4981}
 * and provides a scriptable interface to any WebDAV server.
 * Example:
 * Writing to a file with a WebDAV connector
 * <code>
 *  <a:webdav id="myWebDAV"
 *    url   = "http://my-webdav-server.com/dav_files/" />
 *     
 *  <a:script>
 *      // write the text 'bar' to a file on the server called 'foo.txt'
 *      myWebDAV.write('http://my-webdav-server.com/dav_files/foo.txt', 'bar');
 *  </a:script>
 * </code>
 *
 * Remarks:
 * Calls can be made to a server using a special {@link term.datainstruction data instruction}
 * format.
 * <code>
 *  get="{myWebdav.authenticate([@username], [@password])}"
 *  get="{myWebdav.login(...alias for authenticate...)}"
 *  set="{myWebdav.logout()}"
 *  get="{myWebdav.read([@id])}"
 *  get="{myWebdav.create([@id], 'New File.txt', '')}"
 *  set="{myWebdav.write([@id], [@data])}"
 *  set="{myWebdav.store(...alias for write...)}"
 *  set="{myWebdav.save(...alias for write...)}"
 *  set="{myWebdav.copy([@id], [../@id])}"
 *  set="{myWebdav.cp(...alias for copy...)}"
 *  set="{myWebdav.rename([@name], [@id])}"
 *  set="{myWebdav.move([@id], [../@id])}"
 *  set="{myWebdav.mv(...alias for move...)}"
 *  set="{myWebdav.remove([@id])}"
 *  set="{myWebdav.rmdir(...alias for remove...)}"
 *  set="{myWebdav.rm(...alias for remove...)}"
 *  get="{myWebdav.readdir([@id])}"
 *  get="{myWebdav.scandir(...alias for readdir...)}"
 *  load="{myWebdav.getroot()}"
 *  set="{myWebdav.lock([@id])}"
 *  set="{myWebdav.unlock([@id])}"
 * </code>
 *
 * @event authfailure Fires when the authentication process failed or halted.
 *   bubbles: yes
 *   cancelable: Prevents an authentication failure to be thrown
 *   object:
 *     {String}        username   the username used for the login attempt
 *     {String}        server     the server address (URI) of the XMPP server
 *     {String}        message    a more detailed explanation of the error
 * @event connectionerror Fires when the connection with the WebDAV server dropped.
 *   bubbles: yes
 *   cancelable: Prevents an connection error to be thrown
 *   object:
 *     {String}        username   the username used for the last-active session
 *     {String}        server     the server address (URI) of the WebDAV server
 *     {String}        message    a more detailed explanation of the error
 * @event onfilecontents Fires when a {@link teleport.webdav.method.read read} request has
 * completed successfully and returns the content-body of the requested file
 *   bubbles: yes
 *   object:
 *      {String}       data       the ASCI representation of the file content-body
 *
 * @define webdav
 * @addnode teleport
 *
 * @author      Mike de Boer
 * @version     %I%, %G%
 * @since       1.0
 * @constructor
 *
 * @inherits apf.Class
 * @inherits apf.BaseComm
 * @inherits apf.http
 * @namespace apf
 *
 * @default_private
 */

apf.webdav = function(struct, tagName){
    this.$init(tagName || "webdav", apf.NODE_HIDDEN, struct);

    this.$locks       = {};
    this.$lockedStack = [];
    this.$lockId      = 0;
    this.$serverVars  = {};
    this.$fsCache     = [];
};

(function() {
    this.useHTTP = true;
    this.method  = "GET";

    this.$showHidden = false;

    /**
     * @attribute {String}  [show-hidden] Flag that specifies if hidden files
     *                                    should be passed
     */
    this.$booleanProperties["showhidden"]  = true;
    this.$supportedProperties.push("showhidden");

    this.$propHandlers["showhidden"]  = function(value) {
        this.$showHidden = value;
    };

    /*
     * Simple helper function to store session variables in the private space.
     *
     * @param {String} name
     * @param {mixed}  value
     * @type  {mixed}
     * @private
     */
    this.$regVar = function(name, value) {
        this.$serverVars[name] = value;

        return value;
    };

    /*
     * Simple helper function to complete remove variables that have been
     * stored in the private space by register()
     *
     * @param {String} name
     * @type  {void}
     * @private
     */
    function unregister() {
        for (var i = 0; i < arguments.length; i++) {
            if (typeof this.$serverVars[arguments[i]] != "undefined") {
                this.$serverVars[arguments[i]] = null;
                delete this.$serverVars[arguments[i]];
            }
        }
    }

    /*
     * Simple helper function that retrieves a variable, stored in the private
     * space.
     *
     * @param {String} name
     * @type  {mixed}
     * @private
     */
    this.$getVar = function(name) {
        return this.$serverVars[name] || "";
    };

    /**
     * Wrapper function that handles and executes each HTTP request. It also takes
     * care of streams that are incomplete or different than usual, thus produce
     * invalid XML that needs to be tidied prior to processing.
     * It also takes care of processing authentication process/ negotiation
     *
     * @param {Function}  fCallback    Function to execute when the request was successful
     * @param {String}    sPath        Path to the WebDAV resource
     * @param {sBody}     [sBody]      Optional body text (used for PUTs, for example)
     * @param {Object}    [oHeaders]   Additional headers in key: value format
     * @param {Boolean}   [bUseXml]    Tells the function whether to return XML. Defaults to FALSE
     * @param {Function}  [fCallback2] Optional second callback, passed to fCallback as arguments. Used mainly by the data instructions
     * @type  {void}
     */
    this.doRequest = function(fCallback, sPath, sBody, oHeaders, bUseXml, fCallback2) {
        if (!this.$getVar("authenticated")) {
            return onAuth.call(this, {
                method : this.doRequest,
                context: this,
                args   : arguments
            });
        }

        if (bUseXml) {
            if (!oHeaders)
                oHeaders = {};
            oHeaders["Content-type"] = "text/xml; charset=utf-8";
        }

        var _self = this;
        return this.get(this.$server + sPath || "", {
            callback: function(data, state, extra) {
                if (state != apf.SUCCESS) {
                    var oError;

                    oError = WebDAVError.call(this, "Url: " + extra.url + "\nInfo: " + extra.message);

                    if (extra.tpModule.retryTimeout(extra, state, _self, oError) === true)
                        return true;

                    throw oError;
                }

                var iStatus = parseInt(extra.http.status);
                if (iStatus == 401) //authentication requested
                    return; // 401's are handled by the browser already, so no need for additional processing...

                var sResponse = (extra.http.responseText || "");
                if (sResponse.replace(/^[\s\n\r]+|[\s\n\r]+$/g, "") != ""
                  && sResponse.indexOf('<?xml version=') == 0) {
                    try {
                        data = (extra.http.responseXML && extra.http.responseXML.documentElement)
                            ? apf.xmlParseError(extra.http.responseXML)
                            : apf.getXmlDom(extra.http.responseText);

                        if (!apf.supportNamespaces)
                            data.setProperty("SelectionLanguage", "XPath");

                        extra.data = data.documentElement;
                    }
                    catch(e) {
                        throw WebDAVError.call(this, "Received invalid XML\n\n" + e.message);
                    }
                }

                if (typeof fCallback == "function")
                    fCallback.call(_self, data, state, extra, fCallback2);
            },
            nocache       : false,
            useXML        : false,//true,
            ignoreOffline : true,
            data          : sBody || "",
            headers       : oHeaders,
            username      : this.$getVar("auth-username") || null,
            password      : this.$getVar("auth-password") || null
        });
    };

    /*
     * Something went wrong during the authentication process; this function
     * provides a central mechanism for dealing with this situation
     *
     * @param     {String}  msg
     * @type      {Boolean}
     * @exception {Error} A general Error object
     * @private
     */
    function notAuth(msg) {
        unregister.call(this, 'auth-password');

        var extra = {
            username : this.$getVar('auth-username'),
            server   : this.$server,
            message  : msg || "Access denied. Please check you username or password."
        }

        var cb = this.$getVar('auth-callback');
        if (cb) {
            cb(null, apf.ERROR, extra);
            unregister.call(this, 'auth-callback');
        }

        
        apf.console.error(extra.message + ' (username: ' + extra.username
                          + ', server: ' + extra.server + ')', 'webdav');
        

        return this.dispatchEvent("authfailure", extra);
    }

    /*
     * Our connection to the server has dropped, or the WebDAV server can not be
     * reached at the moment. We will cancel the authentication process and
     * dispatch a 'connectionerror' event
     *
     * @param {String}  msg
     * @type  {Boolean}
     * @private
     */
    function connError(msg) {
        unregister.call(this, 'auth-password');

        var extra = {
            username : this.$getVar('auth-username'),
            server   : this.$server,
            message  : msg || "Could not connect to server, please contact your System Administrator."
        }

        var cb = this.$getVar('auth-callback');
        if (cb) {
            cb(null, apf.ERROR, extra);
            unregister.call(this, 'auth-callback');
        }

        
        apf.console.error(extra.message + ' (username: ' + extra.username
                          + ', server: ' + extra.server + ')', 'webdav');
        

        return this.dispatchEvent("connectionerror", extra);
    }

    /*
     * Wrapper function for generation WebDAV-specific Error reporting
     * 
     * @param {String} sMsg Message that lists the error details
     * @type  {Error}
     * @private
     */
    function WebDAVError(sMsg) {
        return new Error(apf.formatErrorString(0, this,
                         "WebDAV Communication error", sMsg));
    }

    /*
     * Integration with {@link auth} to implement application wide single
     * sign-on for WebDAV
     *
     * @param {Function} callback Will be executed upon successful authentication
     * @type  {void}
     * @private
     */
    function onAuth(callback) {
        var oDoc, authRequired = false;
        if (apf.isIE) {
            try {
                oDoc = new ActiveXObject("Msxml2.DOMDocument");
            }
            catch(e) {}
        }
        else if (document.implementation && document.implementation.createDocument) {
            try {
                oDoc = document.implementation.createDocument("", "", null);
            }
            catch (e) {}
        }

        try {
            if (apf.isIE) { // only support IE for now, other browsers cannot detect 401's silently yet...
                oDoc.async = false;
                oDoc.load(this.$server + this.$rootPath);
            }
        }
        catch (e) {
            authRequired = true;
        }
        
        var auth = this.ownerDocument.getElementsByTagNameNS(apf.ns.apf, "auth")[0];
        if (authRequired) {
            auth.authRequired(callback);
        }
        else {
            this.$regVar("authenticated", true);
            if (callback && callback.method)
                callback.method.apply(callback.context, callback.args);
        }
    }

    /**
     * Attempts to authenticate the session using HTTP-AUTH (simple
     * authentication mechanism)
     *
     * @param {String}   username Username of the password-protected WebDAV resource
     * @param {String}   password Password in plaintext format
     * @param {Function} callback Function to be executed when the authentication succeeded
     * @type  {void}
     */
    this.authenticate = function(username, password, callback) {
        this.$regVar("auth-username", username);
        this.$regVar("auth-password", password);
        this.$regVar("auth-callback", callback);

        var auth = apf.document.getElementsByTagNameNS(apf.ns.apf, "auth")[0];
        if (!auth)
            return;
        
        this.doRequest(function(data, state, extra) {
            if (extra.http.status == 401)
                return auth.authRequired();
            this.$regVar("authenticated", true);
            var cb = this.$getVar("auth-callback");
            if (cb) {
                cb(null, state, extra);
                unregister.call(this, 'auth-callback');
            }
        }, this.$rootPath, null, {}, false, null);
    };

    /**
     * Unset all cached values.
     * 
     * @type {void}
     */
    this.reset = function() {
        unregister.call(this, "authenticated");
        unregister.call(this, "auth-username");
        unregister.call(this, "auth-password");
        unregister.call(this, "auth-callback");
    };

    //------------ Filesystem operations ----------------//

    /**
     * Read the content of a file as plaintext and pass the data to a callback
     * function
     * 
     * @param {String}   sPath    Path to the file on the WebDAV server
     * @param {Function} callback Function to execute when the request was successful
     * @type  {void}
     */
    this.read = function(sPath, callback) {
        this.method = "GET";
        this.doRequest(function(data, state, extra) {
            var iStatus = parseInt(extra.http.status);
            if (iStatus == 403) { //Forbidden
                var oError = WebDAVError.call(this, "Unable to read file. Server says: "
                             + apf.webdav.STATUS_CODES["403"]);
                if (this.dispatchEvent("error", {
                    error   : oError,
                    bubbles : true
                  }) === false)
                    throw oError;
            }
            else {
                callback
                    ? callback.call(this, data, state, extra)
                    : this.dispatchEvent('onfilecontents', {data: data});
            }
        }, sPath);
    };

    /**
     * Reads the contents of a directory resource (one level deep) and passes
     * the resulting XML to a  callback function to be processed further.
     * see {@link teleport.webdav.method.getProperties}
     *
     * @param {String}   sPath    Path to the file on the WebDAV server
     * @param {Function} callback Function to execute when the request was successful
     * @type  {void}
     */
    this.readDir = function(sPath, callback) {
        if (sPath.charAt(sPath.length - 1) != "/")
            sPath += "/";
        return this.getProperties(sPath, 1, callback);
    };

    /**
     * Creates a new directory resource on the WebDAV server.
     * 
     * @param {String}   sPath    Path of the new directory on the WebDAV server
     * @param {Function} callback Function to execute when the request was successful
     * @type  {void}
     */
    this.mkdir = function(sPath, callback) {
        var oLock = this.lock(sPath);
        if (!oLock.token)
            return updateLockedStack.call(this, oLock, "mkdir", arguments);

        this.method = "MKCOL";
        this.doRequest(function(data, state, extra) {
            var iStatus = parseInt(extra.http.status);
            if (iStatus == 201) { //Created
                // TODO: refresh parent node...
            }
            else if (iStatus == 403 || iStatus == 405 || iStatus == 409
              || iStatus == 415 || iStatus == 507) {
                var oError = WebDAVError.call(this, "Unable to create directory '" + sPath
                             + "'. Server says: "
                             + apf.webdav.STATUS_CODES[String(iStatus)]);
                if (this.dispatchEvent("error", {
                    error   : oError,
                    bubbles : true
                  }) === false)
                    throw oError;
            }
            this.unlock(oLock);
        }, sPath, null, oLock.token
            ? { "If": "<" + oLock.token + ">" }
            : null, true, callback);
    };

    /**
     * Reads the properties of a resource on the server.
     * see {@link teleport.webdav.method.getProperties}
     *
     * @param {String}   sPath    Path to the resource on the WebDAV server
     * @type  {void}
     */
    this.list = function(sPath) {
        return this.getProperties(sPath, 0);
    };

    /**
     * Write new contents (plaintext) to a file resource on the server, with or
     * without an existing lock on the resource.
     * 
     * @param {String}   sPath    Path to the file on the WebDAV server
     * @param {String}   sContent New content-body of the file
     * @param {String}   [sLock]  Lock token that MAY be omitted in preference of a lock refresh
     * @param {Function} callback Function to execute when the request was successful
     * @type  {void}
     */
    this.write = function(sPath, sContent, sLock, callback) {
        var oLock = this.lock(sPath);
        if (!oLock.token)
            return updateLockedStack.call(this, oLock, "write", arguments);

        this.method = "PUT";
        this.doRequest(function(data, state, extra) {
            var iStatus = parseInt(extra.http.status);
            if (iStatus == 409 || iStatus == 405) { //Conflict || Not Allowed
                var oError = WebDAVError.call(this, "Unable to write to file. Server says: "
                             + apf.webdav.STATUS_CODES[String(iStatus)]);
                if (this.dispatchEvent("error", {
                    error   : oError,
                    bubbles : true
                  }) === false)
                    throw oError;
                callback.call(this, data, apf.ERROR, extra);
            }
            else {
                this.getProperties(sPath, 0, callback);
            }
        }, sPath, sContent, sLock
            ? {"If": "<" + sLock + ">"}
            : null);
    };

    /**
     * Copies a file or directory resource to any location on the same WebDAV
     * server.
     * 
     * @param {String}   sFrom      Path to the file on the WebDAV server to be copied
     * @param {String}   sTo        New location to place the copy at
     * @param {Boolean}  bOverwrite Tells whether to overwrite any existing resource
     * @param {Function} callback   Function to execute when the request was successful
     * @type  {void}
     */
    this.copy = function(sFrom, sTo, bOverwrite, callback) {
        if (!sTo || sFrom == sTo) return;
        
        var oLock = this.lock(sFrom);
        if (!oLock.token)
            return updateLockedStack.call(this, oLock, "copy", arguments);

        this.method  = "COPY";
        var oHeaders = {
            "Destination": this.$server + sTo
        };
        if (typeof bOverwrite == "undefined")
            bOverwrite = true;
        if (!bOverwrite)
            oHeaders["Overwrite"] = "F";
        if (oLock.token)
            oHeaders["If"] = "<" + oLock.token + ">";
        this.doRequest(function(data, state, extra) {
            unregisterLock.call(this, sFrom);
            var iStatus = parseInt(extra.http.status);
            if (iStatus == 403 || iStatus == 409 || iStatus == 412 
              || iStatus == 423 || iStatus == 424 || iStatus == 502
              || iStatus == 507) {
                var oError = WebDAVError.call(this, "Unable to copy file '" + sFrom
                             + "' to '" + sTo + "'. Server says: "
                             + apf.webdav.STATUS_CODES[String(iStatus)]);
                if (this.dispatchEvent("error", {
                    error   : oError,
                    bubbles : true
                  }) === false)
                    throw oError;
            }
            else {
                // nodes needs to be added to the cache, callback passed through
                // to notify listener(s)
                this.getProperties(sTo, 0, callback);
            }
        }, sFrom, null, oHeaders);
    };

    /**
     * Moves a file or directory resource to any location on the same WebDAV
     * server.
     * 
     * @param {String}   sFrom      Path to the file on the WebDAV server to be moved
     * @param {String}   sTo        New location to move the resource to
     * @param {Boolean}  bOverwrite Tells whether to overwrite any existing resource
     * @param {Function} callback   Function to execute when the request was successful
     * @type  {void}
     */
    this.move = function(sFrom, sTo, bOverwrite, callback) {
        if (!sTo || sFrom == sTo) return;
        
        var oLock = this.lock(sFrom);
        if (!oLock.token)
            return updateLockedStack.call(this, oLock, "move", arguments);

        this.method  = "MOVE";
        var oHeaders = {
            "Destination": this.$server + sTo
        };
        if (typeof bOverwrite == "undefined")
            bOverwrite = true;
        if (!bOverwrite)
            oHeaders["Overwrite"] = "F";
        if (oLock.token)
            oHeaders["If"] = "<" + oLock.token + ">";
        this.doRequest(function(data, state, extra) {
            unregisterLock.call(this, sFrom);
            var iStatus = parseInt(extra.http.status);
            if (iStatus == 403 || iStatus == 409 || iStatus == 412
              || iStatus == 423 || iStatus == 424 || iStatus == 502) {
                var oError = WebDAVError.call(this, "Unable to move file '" + sFrom
                             + "' to '" + sTo + "'. Server says: "
                             + apf.webdav.STATUS_CODES[String(iStatus)]);
                if (this.dispatchEvent("error", {
                    error   : oError,
                    bubbles : true
                  }) === false)
                    throw oError;
            }
            else { //success!!
                getItemByPath.call(this, sFrom).path = sTo;
            }
            callback.call(this, data, state, extra);
        }, sFrom, null, oHeaders);
    };

    /**
     * Removes an existing directory or file resource from the WebDAV server.
     * 
     * @param {String}   sPath    Path to the resource to be removed from the WebDAV server
     * @param {Function} callback Function to execute when the request was successful
     * @type  {void}
     */
    this.remove = function(sPath, callback) {
        var oLock = this.lock(sPath);
        if (!oLock.token)
            return updateLockedStack.call(this, oLock, "remove", arguments);

        this.method = "DELETE";
        this.doRequest(function(data, state, extra) {
            unregisterLock.call(this, sPath);
            var iStatus = parseInt(extra.http.status);
            if (iStatus == 423 || iStatus == 424) { //Failed dependency (collections only)
                var oError = WebDAVError.call(this, "Unable to remove file '" + sPath
                             + "'. Server says: "
                             + apf.webdav.STATUS_CODES[String(iStatus)]);
                if (this.dispatchEvent("error", {
                    error   : oError,
                    bubbles : true
                  }) === false)
                    throw oError;
            }
            callback.call(this, data, state, extra);
        }, sPath, null, oLock.token 
            ? { "If": "<" + oLock.token + ">" }
            : null);
    };

    /**
     * Wrapper function that centrally manages locking of resources. Files and
     * directories (resources) can be locked prior to any modifying operation to
     * prevent the resource being modified by another user before the transaction
     * of this user has finished or even started.
     *
     * @see teleport.webdav.method.unlock
     * @param {String}   sPath      Path to the resource on the server to be locked
     * @param {Number}   [iDepth]   Depth of lock recursion down the tree, should be '1' or 'Infinity'
     * @param {Number}   [iTimeout] Lifetime of the lock, in seconds. Defaults to Infinite.
     * @param {String}   [sLock]    Previous lock token
     * @param {Function} [callback] Function that is executed upon a successful LOCK request
     * @type  {Object}
     */
    this.lock = function(sPath, iDepth, iTimeout, sLock, callback) {
        // first, check for existing lock
        var oLock = this.$locks[sPath];
        if (oLock && oLock.token) {
            //@todo renew the lock (if needed - check timeout)...
            return oLock;
        }

        this.method = "LOCK"

        iTimeout = iTimeout ? "Infinite, Second-4100000000" : "Second-" + iTimeout;
        var oHeaders = {
            "Timeout": iTimeout
        };
        if (iDepth)
            oHeaders["Depth"] = iDepth || "Infinity";
        if (sLock)
            oHeaders["If"] = "<" + sLock + ">";
        var xml = '<?xml version="1.0" encoding="utf-8"?>'
                + '<D:lockinfo xmlns:D="' + apf.webdav.NS.D + '">'
                +     '<D:lockscope><D:exclusive /></D:lockscope>'
                +     '<D:locktype><D:write /></D:locktype>'
                +     '<D:owner><D:href>'
                +      document.location.toString().escapeHTML() +
                +     '</D:href></D:owner>'
                + '</D:lockinfo>';
        this.doRequest(registerLock, sPath, xml, oHeaders, true, callback);
        return newLock.call(this, sPath);
    };

    /**
     * Wrapper function that centrally manages the unlocking of resources that
     * have been locked earlier on.
     *
     * @see teleport.webdav.method.lock
     * @param {Object}   oLock    Object representing a Lock on a resource
     * @param {Function} callback Function that is executed upon a successful UNLOCK request
     * @type  {void}
     */
    this.unlock = function(oLock, callback) {
        if (typeof oLock == "string")
            oLock = this.$locks[oLock];
        if (!oLock || !oLock.token) return;

        this.method = "UNLOCK";
        this.doRequest(function(data, state, extra) {
            unregisterLock.call(this, extra.url.replace(this.$server, ''));
        }, oLock.path, null, {
            "Lock-Token": "<" + oLock.token + ">"
        }, true, callback);
    };

    /*
     * Add a new lock token/ object to the stack
     * 
     * @path {String} sPath Path pointing to the resource on the server
     * @type {Object}
     * @private
     */
    function newLock(sPath) {
        return $this.locks[sPath] = {
            path : sPath,
            id   : this.$lockId++,
            token: null
        };
    }

    /*
     * Handler function that registers a lock globally when a LOCK request was
     * successful. It parses all the info it received from the server response
     * and caches that info for reuse.
     * 
     * @param {XmlDocument} data  Actual XML data, received from the server
     * @param {Number}      state Internal - JPF defined - state of the request
     * @param {Object}      extra Simple object that contains additional request data
     * @type  {void}
     * @private
     */
    function registerLock(data, state, extra) {
        var iStatus = parseInt(extra.http.status),
            sPath   = extra.url.replace(this.$server, ''),
            oLock   = this.$locks[sPath] || newLock.call(this, sPath);
        if (iStatus == 409 || iStatus == 423 || iStatus == 412) {
            // lock failed, so unregister it immediately
            unregisterLock.call(this, extra.url.replace(this.$server, ''));
            var oError = WebDAVError.call(this, "Unable to apply lock to '" + sPath
                         + "'. Server says: "
                         + apf.webdav.STATUS_CODES[String(iStatus)]);
            if (this.dispatchEvent("error", {
                error   : oError,
                bubbles : true
              }) === false)
                throw oError;
        }
        
        var NS     = apf.webdav.NS,
            oOwner = $xmlns(data, "owner",     NS.ns0)[0],
            oToken = $xmlns(data, "locktoken", NS.D)[0];
        oLock.path    = sPath;
        oLock.type    = "write";
        oLock.scope   = $xmlns(data,   "exclusive", NS.D).length ? "exclusive" : "shared";
        oLock.depth   = $xmlns(data,   "depth",     NS.D)[0].firstChild.nodeValue;
        oLock.owner   = $xmlns(oOwner, "href",      NS.ns0)[0].firstChild.nodeValue;
        oLock.timeout = $xmlns(data,   "timeout",   NS.D)[0].firstChild.nodeValue;
        oLock.token   = $xmlns(oToken, "href",      NS.D)[0].firstChild.nodeValue.split(":")[1];

        purgeLockedStack.call(this, oLock);
    }

    /*
     * Removes a Lock token/ object from the stack.
     * 
     * @param {String} sPath Path pointing to the resource on the server
     * @type  {void}
     * @private
     */
    function unregisterLock(sPath) {
        var oLock = this.$locks[sPath];
        if (!oLock) return;
        purgeLockedStack.call(this, oLock, true);
        this.$locks[sPath] = oLock = null;
        delete this.$locks[sPath];
    }

    /*
     * Update the stack of lock requests (NOT the stack of valid locks!) with a
     * new Lock, or an updated one (lifetime may have changed)
     * 
     * @param {Object} oLock Object that contains specific info about the Lock
     * @param {String} sFunc Name of the function that requested the lock
     * @param {Array}  aArgs List of arguments that should get passed to that function when the lock is available
     * @type  {Object}
     * @private
     */
    function updateLockedStack(oLock, sFunc, aArgs) {
        return this.$lockedStack.push({
            lockId: oLock.id,
            func  : sFunc,
            args  : aArgs
        });
    }

    /*
     * Purge the stack of lock requests, called when a lock request returned a
     * result. If bFailed is set to TRUE, the function that requested the lock
     * will be executed.
     *
     * @param {Object}  oLock   Simple object that represents a validated Lock
     * @param {Boolean} bFailed Tells whether the requesting function may be excuted
     * @type  {void}
     * @private
     */
    function purgeLockedStack(oLock, bFailed) {
        for (var i = this.$lockedStack.length - 1; i >= 0; i--) {
            if (this.$lockedStack[i].lockId != oLock.id) continue;
            if (!bFailed)
                this[this.$lockedStack[i].func].apply(this, this.$lockedStack[i].args);
            this.$lockedStack.remove(i);
        }
    }

    /**
     * Request the server to list the properties of a specific resource and,
     * possibly, its children.
     *
     * @param {String}   sPath    Path pointing to the resource on the server
     * @param {Number}   iDepth   Depth of lock recursion down the tree, should be '1' or 'Infinity'
     * @param {Function} callback Function that is executed upon a successful LOCK request
     * @param {Object}   oHeaders Additional headers in key: value format
     * @type  {void}
     */
    this.getProperties = function(sPath, iDepth, callback, oHeaders) {
        // Note: caching is being done by an external model
        this.method = "PROPFIND";
        // XXX maybe we want to change this to allow getting selected props
        var xml = '<?xml version="1.0" encoding="utf-8" ?>'
                + '<D:propfind xmlns:D="' + apf.webdav.NS.D + '">'
                +       '<D:allprop />'
                + '</D:propfind>';
        oHeaders = oHeaders || {};
        oHeaders["Depth"] = typeof iDepth != "undefined" ? iDepth : 1
        this.doRequest(parsePropertyPackets, sPath, xml, oHeaders, true, callback);
    };

    /**
     * Request the server to change and set properties of a specific resource
     * with different values.
     * @todo Untested functionality
     * 
     * @param {String} sPath     Path pointing to the resource on the server
     * @param {Object} oPropsSet A mapping from namespace to a mapping of key/value pairs (where value is an *entitized* XML string)
     * @param {Object} oPropsDel A mapping from namespace to a list of names
     * @param {String} sLock     Lock identifier
     * @private
     */
    this.setProperties = function(sPath, oPropsSet, oPropsDel, sLock) {
        this.method = "PROPPATCH";
        
        this.doRequest(function(data, state, extra) {
            
            apf.console.dir(data);
            
        }, sPath, buildPropertiesBlock.call(this, oPropsSet, oPropsDel),
           sLock ? {"If": "<" + sLock + ">"} : null, true);
    };

    /*
     * create the XML for a PROPPATCH request.
     * 
     * @param {Object} oPropsSet A mapping from namespace to a mapping of key/value pairs (where value is an *entitized* XML string)
     * @param {Object} oPropsDel A mapping from namespace to a list of names
     * @type  {String}
     * @private
     */
    function buildPropertiesBlock(oPropsSet, oPropsDel) {
        var aOut = ['<?xml version="1.0" encoding="utf-8" ?>',
            '<D:propertyupdate xmlns:D="', apf.webdav.NS.D, '">'];

        var bHasProps = false, ns, i, j;
        for (ns in oPropsSet) {
            bHasProps = true;
            break;
        }
        if (bHasProps) {
            aOut.push('<D:set>');
            for (ns in oPropsSet) {
                for (i in oPropsSet[ns])
                    aOut.push('<D:prop>', oPropsSet[ns][i], '</D:prop>')
            }
            aOut.push('</D:set>');
        }
        bHasProps = false;
        for (ns in oPropsDel) {
            bHasProps = true;
            break;
        }
        if (bHasProps) {
            aOut.push('<D:remove><D:prop>');
            for (ns in oPropsDel) {
                for (i = 0, j = oPropsDel[ns].length; i < j; i++)
                    aOut.push('<', oPropsDel[ns][i], ' xmlns="', ns, '"/>')
            }
            aOut.push('</D:prop></D:remove>');
        }

        aOut.push('</D:propertyupdate>');
        return aOut.join('');
    }

    /*
     * Handler function that parses the response of a successful PROPFIND 
     * request. It parses all the info it received from the server response
     * and caches that info for reuse.
     *
     * @param {XmlDocument} data     Actual XML data, received from the server
     * @param {Number}      state    Internal - JPF defined - state of the request
     * @param {Object}      extra    Simple object that contains additional request data
     * @param {Function}    callback Function to be executed when all the property packets have been parsed
     * @type  {void}
     * @private
     */
    function parsePropertyPackets(oXml, state, extra, callback) {
        if (parseInt(extra.http.status) == 403) {
            // TODO: dispatch onerror event
            return;
        }

        var aResp = $xmlns(oXml, "response", apf.webdav.NS.D),
            aOut = [];
        if (aResp.length) //we got a valid result set, so assume that any possible AUTH has succeeded
            this.$regVar("authenticated", true);
        for (var i = aResp.length > 1 ? 1 : 0, j = aResp.length; i < j; i++)
            aOut.push(parseItem.call(this, aResp[i]));

        if (callback)
            callback.call(this, "<files>" + aOut.join("") + "</files>", state, extra);
    }

    /*
     * Turn an XML WebDAV node that represents a resource and turn it into a 
     * reusable JS object, cache it so that it can be reused later.
     * 
     * @param {XmlNode} oNode
     * @type  {String}
     * @private
     */
    function parseItem(oNode) {
        var NS      = apf.webdav.NS,
            sPath   = $xmlns(oNode, "href", NS.D)[0].firstChild
                      .nodeValue.replace(/[\\\/]+$/, ""),
            sName   = decodeURIComponent(sPath.split("/").pop()),
            bHidden = (sName.charAt(0) == ".");

        if (!this.$showHidden && bHidden)
            return "";
        
        var iId, oItem = getItemByPath.call(this, sPath);
        if (oItem && typeof oItem.id == "number")
            iId = oItem.id;
        else
            iId = this.$fsCache.length;

        var sType  = $xmlns(oNode, "collection", NS.D).length > 0 ? "folder" : "file",
            aCType = $xmlns(oNode, "getcontenttype", NS.D),
            aExec  = $xmlns(oNode, "executable", NS.lp2);
        oItem = this.$fsCache[iId] = {
            id          : iId,
            path        : sPath,
            type        : sType,
            size        : parseInt(sType == "file"
                ? $xmlns(oNode, "getcontentlength", NS.lp1)[0].firstChild.nodeValue
                : 0),
            name        : sName,
            contentType : (sType == "file" && aCType.length
                ? aCType[0].firstChild.nodeValue
                : ""),
            creationDate: $xmlns(oNode, "creationdate", NS.lp1)[0].firstChild.nodeValue,
            lastModified: $xmlns(oNode, "getlastmodified", NS.lp1)[0].firstChild.nodeValue,
            etag        : $xmlns(oNode, "getetag", NS.lp1)[0].firstChild.nodeValue,
            lockable    : ($xmlns(oNode, "locktype", NS.D).length > 0),
            executable  : (aExec.length > 0 && aExec[0].firstChild.nodeValue == "T")
        };
        
        return oItem.xml = "<" + sType + " id='" + iId + "'  type='" + sType
            + "' size='" + oItem.size + "' name='" + oItem.name + "' contenttype='"
            + oItem.contentType + "' creationdate='" + oItem.creationDate
            + "' lockable='" + oItem.lockable.toString() + "' hidden='"
            + bHidden.toString() + "' executable='" + oItem.executable.toString()
            + "'/>";
    }

    /*
     * Retrieve a file or directory resource from cache by searching for a 
     * matching path name.
     * 
     * @param {String} sPath Path pointing to a resource on the server
     * @type  {Object}
     * @private
     */
    function getItemByPath(sPath) {
        for (var i = 0, j = this.$fsCache.length; i < j; i++) {
            if (this.$fsCache[i].path == sPath)
                return this.$fsCache[i];
        }
        return null;
    }

    /**
     * Retrieve a file or directory resource from cache by searching for a 
     * matching resource identifier.
     * 
     * @param {Number} iId WebDAV resource identifier pointing to a resource on the server
     * @type  {Object}
     * @private
     */
    this.getItemById = function(iId) {
        if (typeof iId == "string")
            iId = parseInt(iId);
        return this.$fsCache[iId] || null;
    };

    

    /**
     * Instruction handler for WebDav protocols.
     */
    this.exec = function(method, args, callback){
        var oItem = this.getItemById(args[0]);
        // RULE for case aliases: first, topmost match is the preferred term for any
        //                        action and should be used in demos/ examples in
        //                        favor of other aliases.
        switch (method) {
            case "login":
            case "authenticate":
                this.authenticate(args[0], args[1], callback);
                break;
            case "logout":
                this.reset();
                break;
            case "read":
                this.read(oItem.path, callback);
                break;
            case "create":
                this.write(oItem.path + "/" + args[1], args[2], null, callback);
                break;
            case "write":
            case "store":
            case "save":
                this.write(oItem.path, args[1], null, callback);
                break;
            case "copy":
            case "cp":
                var oItem2 = this.getItemById(args[1]);
                this.copy(oItem.path, oItem2.path, args[2], callback);
                break;
            case "rename":
                oItem = this.getItemById(args[1]);
                if (!oItem) break;
    
                var sBasepath = oItem.path.replace(oItem.name, '');
                //TODO: implement 'Overwrite' setting...
                this.move(oItem.path, sBasepath + args[0], false, callback);
                break;
            case "move":
            case "mv":
                //TODO: implement 'Overwrite' setting...
                this.move(oItem.path, this.getItemById(args[1]).path + "/"
                    + oItem.name, false, callback);
                break;
            case "remove":
            case "rmdir":
            case "rm":
                this.remove(oItem.path, callback);
                break;
            case "scandir":
            case "readdir":
                this.readDir(oItem.path, callback);
                break;
            case "getroot":
                this.getProperties(this.$rootPath, 0, callback);
                break;
            case "mkdir":
                break;
            case "lock":
                this.lock(oItem.path, null, null, null, callback);
                break;
            case "unlock":
                this.unlock(oItem.path, callback);
                break;
            default:
                
                throw new Error(apf.formatErrorString(0, null, "Saving/Loading data",
                    "Invalid WebDAV method '" + method + "'"));
                
                break;
        }
    };
    
    
}).call(apf.webdav.prototype = new apf.Teleport());

apf.aml.setElement("webdav", apf.webdav);

// Collection of shorthands for all namespaces known and used by this class
apf.webdav.NS = {
    D    : "DAV:",
    ns0  : "DAV:",
    lp1  : "DAV:",
    lp2  : "http://apache.org/dav/props/"
};

apf.webdav.STATUS_CODES = {
    '100': 'Continue',
    '101': 'Switching Protocols',
    '102': 'Processing',
    '200': 'OK',
    '201': 'Created',
    '202': 'Accepted',
    '203': 'None-Authoritive Information',
    '204': 'No Content',
    '1223': 'No Content',
    '205': 'Reset Content',
    '206': 'Partial Content',
    '207': 'Multi-Status',
    '300': 'Multiple Choices',
    '301': 'Moved Permanently',
    '302': 'Found',
    '303': 'See Other',
    '304': 'Not Modified',
    '305': 'Use Proxy',
    '307': 'Redirect',
    '400': 'Bad Request',
    '401': 'Unauthorized',
    '402': 'Payment Required',
    '403': 'Forbidden',
    '404': 'Not Found',
    '405': 'Method Not Allowed',
    '406': 'Not Acceptable',
    '407': 'Proxy Authentication Required',
    '408': 'Request Time-out',
    '409': 'Conflict',
    '410': 'Gone',
    '411': 'Length Required',
    '412': 'Precondition Failed',
    '413': 'Request Entity Too Large',
    '414': 'Request-URI Too Large',
    '415': 'Unsupported Media Type',
    '416': 'Requested range not satisfiable',
    '417': 'Expectation Failed',
    '422': 'Unprocessable Entity',
    '423': 'Locked',
    '424': 'Failed Dependency',
    '500': 'Internal Server Error',
    '501': 'Not Implemented',
    '502': 'Bad Gateway',
    '503': 'Service Unavailable',
    '504': 'Gateway Time-out',
    '505': 'HTTP Version not supported',
    '507': 'Insufficient Storage'//,
//    12002 ERROR_INTERNET_TIMEOUT
//    12007 ERROR_INTERNET_NAME_NOT_RESOLVED
//    12029 ERROR_INTERNET_CANNOT_CONNECT
//    12030 ERROR_INTERNET_CONNECTION_ABORTED
//    12031 ERROR_INTERNET_CONNECTION_RESET
//    12152 ERROR_HTTP_INVALID_SERVER_RESPONSE
};




/*FILEHEAD(/var/lib/platform/source/trunk/elements/editor.js)SIZE(17168)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Element displaying a Rich Text Editor, like M$ Office Word in a browser
 * window. Even though this Editor does not offer the same amount of features
 * as Word, we did try to make it behave that way, simply because it is
 * considered to be the market leader among word-processors.
 * Example:
 * <code>
 *  <a:editor
 *    id     = "myEditor"
 *    left   = "100"
 *    width  = "50%"
 *    height = "90%-10">
 *    Default value...
 *  </a:editor>
 * </code>
 *
 * @constructor
 * @addnode elements:editor
 *
 * @author      Mike de Boer
 * @version     %I%, %G%
 * @since       1.0
 *
 * @inherits apf.XForms
 * @inherits apf.StandardBinding
 *
 * @binding value  Determines the way the value for the element is retrieved 
 * from the bound data.
 * Example:
 * Sets the text based on data loaded into this component.
 * <code>
 *  <a:model id="mdlEditor">
 *      <data>
 *          <body>Some text</body>
 *      </data>
 *  </a:model>
 *  <a:editor 
 *    width  = "600" 
 *    height = "300" 
 *    model  = "mdlEditor" 
 *    value  = "[body/text()]" />
 * </code>
 */
apf.editor = function(struct, tagName){
    this.$init(tagName || "editor", apf.NODE_VISIBLE, struct);
};

(function() {
    this.implement(
        apf.ContentEditable
        
    );
    
    this.value  = "";
    this.$value = "";

    this.$oWin      =
    this.$oBookmark =
    this.$fTimer    = null;

    /**** Properties and Attributes ****/

    this.isContentEditable = true;

    this.$supportedProperties.push("value", "characterset");

    this.$propHandlers["value"] = function(html){
        if (typeof html != "string")// || html == ""
            html = "";//apf.isIE ? "<br />" :

        // If the HTML string is the same as the contents of the iframe document,
        // don't do anything...
        if (this.$value.replace(/\r/g, "") == html)
            return;
        
        this.$value = html;

        
        html = html.replace(/<p[^>]*>/gi, "").replace(/<\/p>/gi, 
            "<br _apf_marker='1' /><br _apf_marker='1' />");

        html = apf.htmlCleaner.prepare(html);
        

        if (this.$pluginsActive == "code") {
            this.$plugins["code"].update(this, html);
        }
        else {
            this.$activeDocument.body.innerHTML = html;
            this.$controlAgentBehavior(this.$activeDocument.body);
        }
            
        this.dispatchEvent("sethtml", {editor: this});
    };

    /**
     * Important function; tells the right <i>iframe</i> element that it may be
     * edited by the user.
     *
     * @type void
     */
    this.makeEditable = function() {
        var _self = this;
        
        if (apf.isIE) {
            $setTimeout(function() {
                _self.$activeDocument.body.contentEditable = true;
            });
        }
        else {
            try {
                this.$activeDocument.designMode = "on";
                if (apf.isGecko) {
                    // Tell Gecko (Firefox 1.5+) to enable or not live resizing of objects
                    this.$activeDocument.execCommand("enableObjectResizing",
                        false, this.imagehandles);
                    // Disable the standard table editing features of Firefox.
                    this.$activeDocument.execCommand("enableInlineTableEditing",
                        false, this.tablehandles);
                }
            }
            catch (e) {}
        }
        
        //this.$propHandlers["value"].call(this, "");
        this.dispatchEvent("complete", {editor: this});
    };

    

    /**
     * processes the current state of the editor's content and outputs the result that
     *      can be used inside any other content or stored elsewhere.
     *
     * @return The string of (X)HTML that is inside the editor.
     * @type {String}
     */
    this.getValue = function(bStrict) {
        return (this.$value = apf.htmlCleaner.parse(
            this.$activeDocument.body.innerHTML, bStrict));
    };

    /**
     * replace the (X)HTML that's inside the Editor with something else
     *
     * @param {String} html
     * @type  {void}
     */
    this.setValue = function(value){
        return this.setProperty("value", value, false, true);
    };
    
    

    /**
     * Invoked by the Databinding layer when a model is reset/ cleared.
     * 
     * @type {void}
     */
    this.addEventListener("$clear", function(e) {
        if (!e.nomsg) {
            this.value = "";
            return this.$propHandlers["value"].call(this, "");
        }
    });

    /**
     * Paste (clipboard) data into the Editor
     *
     * @see element.editor.method.inserthtml
     * @param {Event} e
     * @type  {void}
     * @private
     */
    function onPaste(e) {
        var _self = this;
        $setTimeout(function() {
            var s = this.$activeDocument.body.innerHTML;
            if (s.match(/mso[a-zA-Z]+/i)) { //check for Paste from Word
                var o = _self.$plugins["pasteword"];
                if (o)
                    _self.$propHandlers["value"].call(_self, o.parse(s));
            }
            if (_self.realtime)
                _self.change(_self.getValue());
        });
    }

    /**
     * Event handler; fired when the user clicked inside the editable area.
     *
     * @see object.abstractevent
     * @param {Event} e
     * @type void
     * @private
     */
    function onClick(e) {
        if (this.$oBookmark && apf.isGecko) {
            var oNewBm = _self.$selection.getBookmark();
            if (typeof oNewBm.start == "undefined" && typeof oNewBm.end == "undefined") {
                //this.$selection.moveToBookmark(this.$oBookmark);
                //RAAAAAAAAAAH stoopid firefox, work with me here!!
            }
        }

        var which  = e.which,
            button = e.button,
            _self  = this;
        $setTimeout(function() {
            var rClick = ((which == 3) || (button == 2));
            
            if (apf.document.activeElement != this) {
                //this.$visualFocus(true);
                _self.focus({});
            }

            else
                if (!rClick)
                _self.$focus({});
        });

        apf.AbstractEvent.stop(e);
    }

    /**
     * Event handler; fired when the user right clicked inside the editable area
     *
     * @param {Event} e
     * @type  {void}
     * @private
     */
    function onContextmenu(e) {
        if (this.state == apf.DISABLED) return;
        //if (apf.isIE)
        //    this.$visualFocus(true);
        this.$notifyAllPlugins("context", e);
    }

    /**** Focus Handling ****/

    /**
     * Fix for focus handling to mix 'n match nicely with other JPF elements
     *
     * @param {Event} e
     * @type  {void}
     */
    this.$focus = function(e){
        if (!this.$ext || this.$ext.disabled)
            return;

        this.setProperty("state", (this.$pluginsActive == "code")
            ? apf.DISABLED
            : apf.OFF);

        this.$setStyleClass(this.$ext, this.$baseCSSname + "Focus");

        var _self = this;

        function delay(){
            try {
                if (!_self.$fTimer || document.activeElement != _self.$ext) {
                    _self.$visualFocus(true);
                    clearInterval(_self.$fTimer);
                }
                else {
                    clearInterval(_self.$fTimer);
                    return;
                }
            }
            catch(e) {}
        }

        if (e && e.mouse && apf.isIE) {
            clearInterval(this.$fTimer);
            this.$fTimer = setInterval(delay, 1);
        }
        else
            delay();
    };

    /**
     * Probe whether we should apply a focus correction to the editor at any
     * given interval
     *
     * @param {Event} e
     * @type  {Boolean}
     */
    this.$isContentEditable = function(e){
        return apf.isChildOf(this.$activeDocument, e.srcElement, true);
    };

    /**
     * Fix for focus/ blur handling to mix 'n match nicely with other JPF
     * elements
     *
     * @param {Event} e
     * @type  {void}
     */
    this.$blur = function(e){
        if (!this.$ext)
            return;

        var pParent = apf.popup.last && apf.lookup(apf.popup.last);
        if (pParent && pParent.editor == this)
            apf.popup.forceHide();

        this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Focus"]);

        var bCode = (this.$pluginsActive == "code");
        if (!this.realtime || bCode) {
            this.change(bCode
                ? this.$plugins["code"].getValue()
                : this.getValue());
        }

        this.setProperty("state", apf.DISABLED);
    };

    /**
     * Add various event handlers to a <i>Editor</i> object.
     *
     * @type {void}
     */
    this.$addListeners = function() {
        var _self = this;
        apf.AbstractEvent.addListener(this.$activeDocument, "mouseup", onClick.bindWithEvent(this, false));
        //apf.AbstractEvent.addListener(this.$activeDocument, 'select', onClick.bindWithEvent(this));
        apf.AbstractEvent.addListener(this.$activeDocument, "keyup", apf.window.$keyup);
        apf.AbstractEvent.addListener(this.$activeDocument, "keydown", apf.window.$keydown);
        apf.AbstractEvent.addListener(this.$activeDocument, "mousedown", function(e){
            e = e || window.event;
            _self.$selection.cache();
            
            apf.popup.forceHide();
            
            apf.window.$mousedown(e);
        });

        apf.AbstractEvent.addListener(this.$activeDocument, "contextmenu", onContextmenu.bindWithEvent(this, false));
        
        apf.AbstractEvent.addListener(this.$activeDocument, "focus", apf.window.$focusevent);
        apf.AbstractEvent.addListener(this.$activeDocument, "blur", apf.window.$blurevent);
        
        this.$activeDocument.host = this;

        apf.AbstractEvent.addListener(this.$activeDocument.body, "paste", onPaste.bindWithEvent(this, false));
    };

    //this.addEventListener("contextmenu", onContextmenu);

    /**** Button Handling ****/

    /**
     * Draw all the HTML elements at startup time.
     *
     * @type {void}
     */
    this.$draw = function() {
        this.$editable(function() {
            //this.plugins   = new apf.editor.plugins(this.$plugins, this);
            var oEditor = this.$getLayoutNode("main", "editor",  this.$ext),
                _self   = this;

            this.iframe = document.createElement("iframe");
            this.iframe.setAttribute("frameborder", "0");
            this.iframe.setAttribute("border", "0");
            this.iframe.setAttribute("marginwidth", "0");
            this.iframe.setAttribute("marginheight", "0");
            oEditor.appendChild(this.iframe);
            this.$oWin = this.iframe.contentWindow;
            this.$activeDocument = this.$oWin.document;

            this.$selection = new apf.selection(this.$oWin,
                this.$activeDocument, this);

            // get the document style (CSS) from the skin:
            // see: apf.presentation.getCssString(), where the following statement
            // is derived from.
            var sCss = apf.queryValue($xmlns(apf.skins.skins[
                this.skinName.split(":")[0]].xml, "docstyle", apf.ns.aml)[0],
                "text()");
            if (!sCss) {
                sCss = "\
                    html {\
                        cursor: text;\
                        border: 0;\
                    }\
                    body {\
                        margin: 8px;\
                        padding: 0;\
                        border: 0;\
                        color: #000;\
                        font-family: Verdana,Arial,Helvetica,sans-serif;\
                        font-size: 10pt;\
                        background: #fff;\
                        word-wrap: break-word;\
                    }\
                    .itemAnchor {\
                        background:url(images/editor/items.gif) no-repeat left bottom;\
                        line-height:6px;\
                        overflow:hidden;\
                        padding-left:12px;\
                        width:12px;\
                    }\
                    .visualAid table,\
                    .visualAid table td {\
                        border: 1px dashed #bbb;\
                    }\
                    .visualAid table td {\
                        margin: 8px;\
                    }\
                    h1 {\
                        margin : 15px 0 15px 0;\
                    }\
                    p {\
                        margin: 0;\
                        padding: 0;\
                    }\
                    sub, sup {\
                        line-height: 10px;\
                    }";
            }
            var c = this.getAttribute("characterset")
                || this.getAttribute("charset") || apf.characterSet;
            this.$activeDocument.open();
            this.$activeDocument.write('<?xml version="1.0" encoding="' + c + '"?>\
                <html>\
                <head>\
                    <meta http-equiv="Content-Type" content="text/html; charset=' + c + '" />\
                    <title></title>\
                    <style type="text/css">' + sCss + '</style>\
                </head>\
                <body class="visualAid"></body>\
                </html>');
            this.$activeDocument.close();

            
            if (apf.hasFocusBug)
                apf.sanitizeTextbox(this.$activeDocument.body);
            

            
            // setup layout rules:
            //@todo add this to $destroy
            apf.layout.setRules(this.$ext, this.$uniqueId + "_editor",
                "var o = apf.all[" + this.$uniqueId + "];\
                if (o) o.$resize()");
            apf.layout.queue(this.$ext);
            

            this.$addListeners();

            // do the magic, make the editor editable.
            this.makeEditable();

            $setTimeout(function() {
                _self.setProperty("state", apf.DISABLED);
            });
        });
    };

    /**
     * Takes care of setting the proper size of the editor after a resize event
     * was fired through the JPF layout manager
     * @see object.layout
     * 
     * @type {void}
     */
    this.$resize = function() {
        if (!this.iframe || !this.iframe.parentNode || !this.$ext.offsetHeight)
            return;
            
        var h = (this.$ext.offsetHeight - this.oToolbar.offsetHeight - 2);
        if (!h || h < 0)
            h = 0;

        this.iframe.parentNode.style.height = h + "px";

        //TODO: check if any buttons from the toolbar became invisible/ visible again...
        this.$notifyAllPlugins("resize");

        if (this.$pluginsActive == "code")
            this.$plugins["code"].setSize(this);
    };

    /**
     * Parse the block of AML that constructed this editor instance for arguments
     * like width, height, etc.
     *
     * @param {XMLRootElement} x
     * @type  {void}
     */
    this.addEventListener("DOMNodeInsertedIntoDocument", function(){
        this.$int = this.$getLayoutNode("main", "container", this.$ext);

        if (apf.isOnlyChild(this.firstChild, [3,4]))
            this.$handlePropSet("value", this.firstChild.nodeValue.trim());

        //if (typeof this.realtime == "undefined")
            //this.$propHandlers["realtime"].call(this);
    });

    this.$destroy = function() {
        this.$selection.$destroy();
        this.$selection = this.$activeDocument.host = this.oToobar =
            this.$activeDocument = this.$oWin = this.iframe = null;
    };

}).call(apf.editor.prototype = new apf.StandardBinding());


apf.aml.setElement("editor", apf.editor);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/text.js)SIZE(13370)TIME(1263910419)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Element displaying a rectangle containing arbitrary (X)HTML.
 * This element can be databound and use databounding rules to
 * convert data into (X)HTML using for instance XSLT or JSLT.
 *
 * @constructor
 * @define text
 * @addnode elements
 *
 * @inherits apf.Cache
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.1
 * @todo Please refactor this object
 */
apf.text = function(struct, tagName){
    this.$init(tagName || "text", apf.NODE_VISIBLE, struct);
};

(function(){
    this.implement(
        apf.ChildValue,
        
        apf.Cache
        
    );

    this.$focussable       = true; // This object can't get the focus
    this.focussable        = false;
    this.$allowSelect      = true;
    this.$hasStateMessages = true;

    this.$textTimer = this.$lastMsg = this.$lastClass = this.$changedHeight = null;

    /**** Properties and Attributes ****/

    /**
     * @attribute {Boolean} scrolldown  whether this elements viewport is always
     *                                  scrolled down. This is especially useful
     *                                  when this element is used to displayed
     *                                  streaming content such as a chat conversation.
     * @attribute {Boolean} secure      whether the content loaded in this element
     *                                  should be filtered in order for it to not
     *                                  be able to execute javascript. This is
     *                                  especially useful when the content does
     *                                  not come from a trusted source, like a
     *                                  web service or xmpp feed.
     */
    this.$booleanProperties["scrolldown"] = true;
    this.$booleanProperties["secure"]     = true;
    this.$supportedProperties.push("behavior", "scrolldown", "secure", "value");

    /**
     * @attribute {String} behaviour specifying how this elements handles new values
     *   Possible values
     *   normal   new values replace the old value.
     *   addonly  new values are added to the current value.
     */
    this.$propHandlers["behavior"] = function(value){
        this.addOnly = value == "addonly";
    }

    /**
     * @attribute {String} value the contents of this element. This can be text or html or xhtml.
     */
    this.$propHandlers["value"] = function(value){
        var cacheObj = false;

        if (value)
            this.$removeClearMessage();
        //@todo else

        if (typeof value != "string")
            value = value ? value.toString() : "";

        if (this.secure) {
            value = value.replace(/<a /gi, "<a target='_blank' ")
                .replace(/<object.*?\/object>/g, "")
                .replace(/<script.*?\/script>/g, "")
                .replace(new RegExp("ondblclick|onclick|onmouseover|onmouseout"
                    + "|onmousedown|onmousemove|onkeypress|onkeydown|onkeyup|onchange"
                    + "|onpropertychange", "g"), "ona");
        }

        if (this.addOnly) {
            if (cacheObj)
                cacheObj.contents += value;
            else
                this.$int.insertAdjacentHTML("beforeend", value);
        }
        else {
            value = value.replace(/\<\?xml version="1\.0" encoding="UTF-16"\?\>/, "");

            if (cacheObj)
                cacheObj.contents = value;
            else
                this.$int.innerHTML = value;//.replace(/<img[.\r\n]*?>/ig, "")
        }

        //Iframe bug fix for IE (leaves screen white);
        if (apf.cannotSizeIframe && this.oIframe)
            this.oIframe.style.width = this.oIframe.offsetWidth + "px";

        if (this.scrolldown && this.$scrolldown)
            this.oScroll.scrollTop = this.oScroll.scrollHeight;
    };

    this.$propHandlers["empty-message"] = function(value) {
        if (!this.childNodes.length)
            this.$setClearMessage(this["empty-message"]);
    };

    /**** Public methods ****/

    

    /**
     * Sets the value of this element. This should be one of the values
     * specified in the values attribute.
     * @param {String} value the new value of this element
     */
    this.setValue = function(value){
        this.setProperty("value", value, false, true);
    };

    /**
     * Returns the current value of this element.
     * @return {String}
     */
    this.getValue = function(){
        return this.$int.innerHTML;
    };
    
    

    /**** Keyboard Support ****/

    
    this.addEventListener("keydown", function(e){
        var key      = e.keyCode;

        switch (key) {
            case 33:
                //PGUP
                this.$int.scrollTop -= this.$int.offsetHeight;
                break;
            case 34:
                //PGDN
                this.$int.scrollTop += this.$int.offsetHeight;
                break;
            case 35:
                //END
                this.$int.scrollTop = this.$int.scrollHeight;
                break;
            case 36:
                //HOME
                this.$int.scrollTop = 0;
                break;
            case 38:
                this.$int.scrollTop -= 10;
                break;
            case 40:
                this.$int.scrollTop += 10;
                break;
            default:
                return;
        }

        return false;
    }, true);
    

    /**** Private methods ****/

    
    this.$xmlUpdate = function(action, xmlNode, listenNode, UndoObj){
        if (this.addOnly && action != "add") return;

        //Action Tracker Support
        if (UndoObj)
            UndoObj.xmlNode = this.addOnly ? xmlNode : this.xmlRoot;//(contents ? contents.xmlRoot : this.xmlRoot);

        //Refresh Properties
        if (this.addOnly) {
            apf.xmldb.nodeConnect(this.documentId, xmlNode, null, this);
            var cacheObj = this.$findHtmlNode(listenNode.getAttribute("id")
                + "|" + this.$uniqueId);

            this.$propHandlers["value"].call(this,
                this.$applyBindRule("value", xmlNode) || "");
        }
        else {
            this.$propHandlers["value"].call(this,
                this.$applyBindRule("value", this.xmlRoot) || "");
        }
    };

    this.$load = function(node){
        //Add listener to XMLRoot Node
        apf.xmldb.addNodeListener(node, this);
        var value = this.$applyBindRule("value", node);

        if (value || typeof value == "string") {
            if (this.caching) {
                var cacheObj = this.$findHtmlNode(node.getAttribute("id")
                    + "|" + this.$uniqueId);
                if (cacheObj)
                    cacheObj.contents = value;
            }
            this.$propHandlers["value"].call(this, value);
        }
        else
            this.$propHandlers["value"].call(this, "");
    };
    

    
    this.$getCurrentFragment = function(){
        return {
            nodeType : 1,
            contents : this.$int.innerHTML
        }
    };

    this.$setCurrentFragment = function(fragment){
        this.$int.innerHTML = fragment.contents;
        if (this.scrolldown)
            this.$int.scrollTop = this.$int.scrollHeight;
    };

    this.$setClearMessage = this.$updateClearMessage = function(msg, className){
        if (this.$lastClass)
            this.$removeClearMessage();
        //@todo move to setClearMessage
        apf.setStyleClass(this.$ext, 
            (this.$lastClass = this.$baseCSSname + (className || "Empty").uCaseFirst()));//"Empty");

        if (msg) {
            if (!this.height) {
                if (this.$int.offsetHeight 
                  && apf.getStyle(this.$int, "height") == "auto" 
                  && (this.$changedHeight = true))
                    this.$int.style.height = (this.$int.offsetHeight 
                      - apf.getHeightDiff(this.$int)) + "px";
                this.$int.innerHTML = msg;
            }
            this.$lastMsg = this.$int.innerHTML;
        }
    };

    this.$removeClearMessage = function(){
        if (this.$lastClass) {
            apf.setStyleClass(this.$ext, "", [this.$lastClass]);
            this.$lastClass = null;
        }
        
        if (this.$int.innerHTML == this.$lastMsg) {
            if (this.$changedHeight && !(this.$changedHeight = false))
                this.$int.style.height = "";
            this.$int.innerHTML = ""; //clear if no empty message is supported
        }
    };

    this.caching = false; //Fix for now
    

    /**** Init ****/

    this.$draw = function(){
        var _self = this;

        this.$ext = this.$getExternal();
        this.$int = this.$getLayoutNode("main", "container", this.$ext);

        if (apf.hasCssUpdateScrollbarBug && !apf.getStyle(this.$int, "padding"))
            this.$fixScrollBug();

        this.oScroll = this.oFocus ? this.oFocus.parentNode : this.$int;

        this.$scrolldown = true;
        this.oScroll.onscroll = function(){
            _self.$scrolldown = this.scrollTop >= this.scrollHeight
                - this.offsetHeight + apf.getVerBorders(this);
        }
        clearInterval(this.$textTimer);
        this.$textTimer = setInterval(function(){
            if (_self.oScroll && _self.$scrolldown && _self.scrolldown) {
                _self.oScroll.scrollTop = _self.oScroll.scrollHeight;
            }
        }, 60);

        if (this.$int.tagName.toLowerCase() == "iframe") {
            if (apf.isIE) {
                this.oIframe = this.$int;
                var iStyle = this.skin.selectSingleNode("iframe_style");
                this.oIframe.contentWindow.document.write(
                    "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\
                    <head>\
                        <style>" + (iStyle ? iStyle.firstChild.nodeValue : "") + "</style>\
                        <script>\
                            document.onkeydown = function(e){\
                                if (!e) e = event;\
                                if (" + 'top.apf.disableF5' + " && e.keyCode == 116) {\
                                    e.keyCode = 0;\
                                    return false;\
                                }\
                            }\
                        </script>\
                    </head>\
                    <body oncontextmenu='return false'></body>");
                this.$int = this.oIframe.contentWindow.document.body;
            }
            else {
                var node = document.createElement("div");
                this.$ext.parentNode.replaceChild(node, this.$ext);
                node.className = this.$ext.className;
                this.$ext = this.$int = node;
            }
        }
        else {
            this.$int.onselectstart = function(e){
                (e ? e : event).cancelBubble = true;
            };

            this.$int.oncontextmenu = function(e){
                if (!this.host.contextmenus)
                    (e ? e : event).cancelBubble = true;
            };

            this.$int.style.cursor = "";

            this.$int.onmouseover = function(e){
                if (!self.STATUSBAR) return;
                if (!e)
                    e = event;

                if (e.srcElement.tagName.toLowerCase() == "a") {
                    if (!this.lastStatus)
                        this.lastStatus = STATUSBAR.getStatus();
                    STATUSBAR.status("icoLink.gif", e.srcElement.getAttribute("href"));
                }
                else if (this.lastStatus) {
                    STATUSBAR.status(this.lastStatus[0], this.lastStatus[1]);
                    this.lastStatus = false;
                }
            };
        }
    };

    this.addEventListener("DOMNodeRemovedFromDocument", function() {
        clearInterval(this.$textTimer);
        apf.destroyHtmlNode(this.oDrag);
        
        if (this.oScroll)
            this.oScroll.onscoll = this.oScroll = null;
        
        this.oDrag = this.oIframe = this.oFocus  = null;
    });
}).call(apf.text.prototype = new apf.BaseSimple());

apf.aml.setElement("text", apf.text);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/propedit.js)SIZE(42429)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element providing a sortable, selectable grid containing scrollable 
 * information. Grid columns can be reordered and resized.
 * Example:
 * This example shows a datagrid width several columns mixing percentage and
 * fixed size columns.
 * <code>
 *  <a:datagrid model="mdlNews" options="move|size">
 *      <a:bindings>
 *          <a:column type="icon" width="16" value="newspaper.png" />
 *          <a:column caption="Date" select="publication/@date" width="70" />
 *            <a:column caption="Title" width="180" select="title" />
 *          <a:column caption="Subtitle" select="subtitle" width="100%" />
 *          <a:each select="news" />
 *      </bindings>
 *      <a:actions />
 *  </datagrid>
 * </code>
 * Example:
 * This example shows a spreadsheet component. The spreadsheet component is an
 * alias for the datagrid. It has a different skin and different defaults.
 * <code>
 *  <a:spreadsheet>
 *      <a:bindings>
 *          <a:column caption="A" select="@field3" />
 *          <a:column caption="B" select="@field1" />
 *          <a:column caption="C" select="@field2" />
 *          <a:column caption="D" select="@field4" />
 *          <a:column caption="E" select="@field5" />
 *          <a:each select="record" />
 *      </bindings>
 *      <a:model>
 *          <records>
 *              <record field1="b" field2="b" field3="c" field4="d" field5="e" />
 *              <record field1="g" field2="b" field3="c" field4="d" field5="e" />
 *          </records>
 *      </model>
 *  </spreadsheet>
 * </code>
 * Example:
 * This example shows a propedit (property editor) component. The propedit 
 * component is an alias for the datagrid. It has a different skin and different
 * defaults. See {@link element.datagrid.attribute.template the template attribute}.
 * <code>
 *  <a:propedit template="mdlTemplate" />
 * </code>
 *
 * @constructor
 * @define datagrid, spreadsheet, propedit
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @inherits apf.Cache   
 * @inherits apf.StandardBinding
 *
 * @event beforelookup  Fires before the value lookup UI is shown.
 *   cancelable: Prevents the lookup value from being processed.
 *   object:
 *   {String}      value     the value that has been found.
 *   {XMLElement}  xmlNode   the selected node.
 *   {HTMLElement} htmlNode  the node that is updated.
 * @event afterlookup   Fires after a lookup value is processed.
 *   object:
 *   {Mixed}       value     the value that has been found.
 *   {XMLElement}  xmlNode   the selected node.
 *   {HTMLElement} htmlNode  the node that is updated.
 *   {Nodeset}     nodes     ???.
 * @event multiedit     Fires before a multiedit request is done. Used to display the UI.
 *   object:
 *   {XMLElement} xmlNode   the selected node.
 *   {XMLElement} dataNode  the {@link term.datanode data node}.
 *   Example:
 *   <code>
 *      <a:propedit 
 *        lookupaml      = "tmpLookup"
 *        onbeforelookup = "clearLookup(event.xmlNode, event.value)" 
 *        onafterlookup  = "loadLookup(event.xmlNode, event.value, this)"
 *        onmultiedit    = "loadMultiEdit(event, this)">
 *          <a:bindings>
 *              <a:template select="self::product" value="mdlProps:product" />
 *          </bindings>
 *      </propedit>
 *
 *      <a:template id="tmpLookup" autoinit="true">
 *          <a:list id="lstLookup" skin="mnulist" style="width:auto;margin-bottom:3px" 
 *            model="mdlLookup" empty-message="No results" height="{lstLookup.length * 20}"
 *            autoselect="false">
 *              <a:bindings>
 *                  <a:caption select="self::picture"><![CDATA[
 *                      {name} | {description}
 *                  ]]></caption>
 *                  <!-- use @descfield -->
 *                  <a:caption><![CDATA[[
 *                      var field = n.parentNode.getAttribute("descfield");
 *                      %(value(field) || "[Geen Naam]");
 *                  ]]]></caption>
 *                  <a:icon select="self::product" value="package_green.png" />
 *                  <a:icon value="table.png" />
 *                  <a:each select="node()[local-name()]" />
 *              </bindings>
 *              <a:actions />
 *          </list>
 *          
 *          <a:toolbar>
 *              <a:bar>
 *                  <a:button id="btnLkpPrev" disabled="true" 
 *                      onclick="...">&lt; Previous</button>
 *                  <a:spinner id="spnLookup" width="40" 
 *                      min="1" max="1" onafterchange="..." />
 *                  <a:button id="btnLkpNext" disabled="true" 
 *                      onclick="...">Next &gt;</button>
 *              </bar>
 *          </toolbar>
 *      </template>
 *   </code>
 */
apf.propedit    = function(struct, tagName){
    this.$init(tagName || "propedit", apf.NODE_VISIBLE, struct);
};

(function(){
    this.$init(function(){
        //this.$headings       = [],
        //this.$cssRules       = []; //@todo Needs to be reset;
        this.$nodes          = [];
        //this.$lastOpened     = {};
        
        this.$editors        = {};
        
        
        this.dynCssClasses = [];
        
        
        this.addEventListener("keydown", keyHandler, true);
    });
    
    /*this.implement(
        
        //apf.Rename
        
        
        //apf.DragDrop,
        
        //apf.Cache,  
    );*/
    
    this.$focussable     = true; // This object can get the focus
    this.$isTreeArch     = true; // This element has a tree architecture
    this.$isWindowContainer = -1;
    
    this.startClosed     = true;
    this.$animType       = apf.tween.NORMAL;
    this.$animSteps      = 3;
    this.$animSpeed      = 20;

    this.$useiframe      = 0;
    
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        properties : 1
    }, this.$attrExcludePropBind);
    
    /**
     * @attribute {Boolean} iframe     whether this element is rendered inside an iframe. This is only supported for IE. Default is false for datagrid and true for spreadsheet and propedit.
     */
    this.$booleanProperties["iframe"]     = true;

    /**
     * @attribute {String} template the {@link terms.datainstruction data instruction} 
     * to fetch a template definition of the layout for this component. A template
     * consists of descriptions of columns (or rows for propedit) for which
     * several settings are determined such as validation rules, edit component 
     * and selection rules.
     * Example:
     * This example contains a template that describes the fields in a property
     * editor for xml data representing a news article.
     * <code>
     *  <news>
     *      <prop caption="Title *" type="text" select="title" required="true" 
     *        minlength="4" invalidmsg="Incorrect title;The title is required."/>
     *      <prop caption="Subtitle *" type="text" select="subtitle" 
     *        required="true" minlength="4" 
     *        invalidmsg="Incorrect subtitle;The subtitle is required."/>
     *      <prop caption="Source" type="text" select="source" minlength="4" 
     *        invalidmsg="Incorrect source;The source is required."/>
     *      <prop select="editors_choice" caption="Show on homepage"
     *        overview="overview" type="dropdown">
     *          <item value="1">Yes</item> 
     *          <item value="0">No</item> 
     *      </prop>
     *      <prop caption="Auteur*" select="author" descfield="name" 
     *        overview="overview" maxlength="10" type="lookup" 
     *        foreign_table="author" required="true" /> 
     *      <prop select="categories/category" descfield="name" type="lookup" 
     *        multiple="multiple" caption="Categorie" overview="overview" 
     *        foreign_table="category" /> 
     *      <prop caption="Image" type="custom" 
     *        exec="showUploadWindow('news', 'setNewsImage', selected)" 
     *        select="pictures/picture/file" />
     *      <prop select="comments" descfield="title" caption="Comments" 
     *        type="children" multiple="multiple">
     *          <props table="news_comment" descfield="title">
     *              <prop select="name" datatype="string" caption="Name*" 
     *                required="1" maxlength="255" 
     *                invalidmsg="Incorrect name;The name is required."/> 
     *              <prop select="email" datatype="apf:email" caption="Email" 
     *                maxlength="255" 
     *                invalidmsg="Incorrect e-mail;Please retype."/> 
     *              <prop select="date" datatype="xsd:date" caption="Date*" 
     *                required="1" 
     *                invalidmsg="Incorrect date;Format is dd-mm-yyyy."/> 
     *              <prop select="title" datatype="string" caption="Title*" 
     *                required="1" maxlength="255" 
     *                invalidmsg="Incorrect title;Title is required."/> 
     *              <prop select="body" caption="Message*" required="1" 
     *                invalidmsg="Incorrect message;Message is required."/> 
     *          </props>
     *      </prop>
     *  </news>
     * </code>
     */
    this.$propHandlers["properties"] = function(value){
        var _self = this;

        apf.setModel(value, {load: function(data){
            if (typeof data == "string")
                data = apf.getXml(data);
            
            _self.$properties = data;
            if (_self.xmlRoot)
                _self.$load(data);
        }});
    };
    
    this.$canLoadData = function(){
        return true;
    }
    
    this.$columns = ["50%", "50%"];
    this.$propHandlers["columns"] = function(value){
        this.$columns = value && value.splitSafe(",") || ["50%", "50%"];
        
        if (this.$headings) {
            this.$headings[0].setProperty("width", this.$columns[0]);
            this.$headings[1].setProperty("width", this.$columns[1]);
        }
    }
    
    function scrollIntoView(){
        var Q = (this.current || this.$selected),
            o = this.$int;
        o.scrollTop = (Q.offsetTop) - 21;
    }

    /**** Keyboard Support ****/
    
    this.$findHtmlNode = function(id) {
        return this.$pHtmlDoc.getElementById(id);
    }
    
    
    function keyHandler(e){
        var key      = e.keyCode,
            ctrlKey  = e.ctrlKey,
            shiftKey = e.shiftKey;
        
        var selXml = this.$lastEditor && this.$lastEditor[2],
            oInt   = this.$useiframe ? this.oDoc.documentElement : this.$int,
            margin, node, hasScroll, hasScrollX, hasScrollY, items, lines;

        switch (key) {
            case 36:
                //HOME
                return false;
            case 35:
                //END
                return false;
            case 107:
                //+
                break;
            case 37:
                //LEFT
                this.$slideToggle(this.$selected.firstChild);
                return false;
            case 107:
            case 39:
                //RIGHT
                this.$slideToggle(this.$selected.firstChild);
                    
                return false;
            case 38:
                //UP
                var node  = selXml;
                var sNode = selXml.previousSibling;
                while(sNode && sNode.nodeType != 1) sNode = sNode.previousSibling;
                
                if (sNode) {
                    var last = sNode, nodes;
                    while ((nodes = last.selectNodes("prop")).length)
                        last = nodes[nodes.length - 1];
                    sNode = last;
                }
                else {
                    sNode = node.parentNode
                    if (sNode[apf.TAGNAME] != "prop") {
                        sNode = sNode.previousSibling;
                        while(sNode && sNode.nodeType != 1) sNode = sNode.previousSibling;
                        
                        if (sNode && sNode[apf.TAGNAME] != "prop") {
                            sNode = (nodes = sNode.selectNodes("prop"))[nodes.length - 1];
                            while(sNode && sNode.nodeType != 1) sNode = sNode.previousSibling;
                        }
                    }
                }

                if (!sNode)
                    return;

                var selHtml = apf.xmldb.findHtmlNode(sNode, this);
                while (!selHtml.offsetWidth)
                    selHtml = apf.xmldb.findHtmlNode(sNode = sNode.parentNode, this);
                
                var top = apf.getAbsolutePosition(selHtml, this.$int)[1]
                     - (selHtml.offsetHeight/2);
                if (top <= this.$ext.scrollTop)
                    this.$ext.scrollTop = top;
                
                this.select(selHtml);
                
                return false;
            case 40:
                //DOWN
                var node, sNode = (node = selXml).selectSingleNode("prop") || node.nextSibling;
                do {
                    while(sNode && (sNode.nodeType != 1 || sNode[apf.TAGNAME] != "prop")) 
                        sNode = sNode.nextSibling;
                    
                    if (!sNode) {
                        sNode = node.parentNode.nextSibling;
                        if (sNode && sNode[apf.TAGNAME] != "prop")
                            sNode = sNode.selectSingleNode("prop");
                    }
                }while(sNode && sNode.nodeType != 1);
                
                if (!sNode)
                    return;

                var selHtml = apf.xmldb.findHtmlNode(sNode, this);
                while (!selHtml.offsetWidth)
                    selHtml = apf.xmldb.findHtmlNode(sNode = sNode.parentNode, this);
                
                if (sNode == node) {
                    sNode = node.nextSibling
                    while(sNode && (sNode.nodeType != 1 || sNode[apf.TAGNAME] != "prop")) 
                        sNode = sNode.nextSibling;
                    var selHtml = apf.xmldb.findHtmlNode(sNode, this);
                }
                
                var top = apf.getAbsolutePosition(selHtml, this.$int)[1] 
                    + (selHtml.offsetHeight/2);
                if (top > this.$ext.scrollTop + this.$ext.offsetHeight)
                    this.$ext.scrollTop = top - this.$ext.offsetHeight;
                
                this.select(selHtml);
                
                return false;
        };
    }
    
    
    
    /**** Focus ****/
    // Too slow for IE
    
    this.$focus = function(){
        if (!this.$ext || (apf.isIE && this.$useiframe && this.cssfix)) //@todo fix this by fixing focussing for this component
            return;

        this.$setStyleClass(this.oFocus || this.$ext, this.$baseCSSname + "Focus");
        
        if (this.oDoc)
            this.$setStyleClass(this.oDoc.documentElement, this.$baseCSSname + "Focus");
    };

    this.$blur = function(){
        
        if (this.renaming)
            this.stopRename(null, true);
        

        //@todo fix this by fixing focussing for this component
        if (!this.$ext || (apf.isIE && this.$useiframe && this.cssfix))
            return;

        this.$setStyleClass(this.oFocus || this.$ext, "", [this.$baseCSSname + "Focus"]);
        
        if (this.oDoc)
            this.$setStyleClass(this.oDoc.documentElement, "", [this.$baseCSSname + "Focus"]);
    };
    
    /**** Sliding functions ****/
    
    this.$slideToggle = function(htmlNode){
        container = htmlNode.parentNode.lastChild;
        
        if (apf.getStyle(container, "display") == "block") {
            htmlNode.className = htmlNode.className.replace(/min/, "plus");
            this.$slideClose(container);
        }
        else {
            htmlNode.className = htmlNode.className.replace(/plus/, "min");
            this.$slideOpen(container);
        }
    };
    
    this.$slideOpen = function(container){
        container.style.display = "";

        apf.tween.single(container, {
            type    : 'scrollheight', 
            from    : 3, 
            diff    : -2,
            to      : container.scrollHeight, 
            anim    : this.$animType,
            steps   : this.$animSteps,
            interval: this.$animSpeed,
            onfinish: function(container){
                container.style.overflow = "visible";
                container.style.height = "auto";
            }
        });
    };

    this.$slideClose = function(container){
        container.style.height   = container.offsetHeight;
        container.style.overflow = "hidden";

        apf.tween.single(container, {
            type    : 'scrollheight', 
            from    : container.scrollHeight, 
            diff    : -2,
            to      : 0, 
            anim    : this.$animType,
            steps   : this.$animSteps,
            interval: this.$animSpeed,
            onfinish: function(container, data){
               container.style.display = "none";
            }
        });
    };
    
    this.$findContainer = function(htmlNode) {
        var node = htmlNode.nextSibling;
        if (!node)
            return htmlNode;
        return node.nodeType == 1 ? node : node.nextSibling;
    };
    
    /**** Databinding ****/
    
    this.addEventListener("bindingsload", this.$loaddatabinding = function(e){
        var rules = e.bindings["properties"];
        if (!rules || !rules.length)
            return;
        
        for (var i = 0, l = rules.length; i < l; i++) {
            
        }
    });
    
    this.$unloaddatabinding = function(){
    };

    /**
     * Returns a column definition object based on the column number.
     * @param {Number} hid the heading number; this number is based on the sequence of the column elements.
     */
    this.getColumn = function(nr){
        return this.$headings[nr || this.$lastcol || 0];
    };
    
    /**** Column management ****/

    /** 
     * Resizes a column.
     * @param {Number} hid      the heading number; this number is based on the sequence of the column elements. 
     * @param {Number} newsize  the new size of the column.
     * @todo optimize but bringing down the string concats
     */
    this.resizeColumn = function(nr, newsize){
        var h = this.$headings[nr];
        h.resize(newsize);
    };

    /**
     * Hides a column.
     * @param {Number} hid      the heading number; this number is based on the sequence of the column elements. 
     */
    this.hideColumn = function(nr){
        var h = this.$headings[nr];
        h.hide();
    };
    
    /**
     * Shows a hidden column.
     * @param {Number} hid      the heading number; this number is based on the sequence of the column elements. 
     */
    this.showColumn = function(nr){
        var h = this.$headings[nr];
        h.show();
    };
    
    /**** Databinding ****/
    
    /*
    Property:
    - caption
    - editor (name of widget, lm function returning amlNode or lm template ref)
        - children being aml nodes
    - value (lm, only when widget is created by grid)
    
    validation attr: (only when widget is created by grid)
    - required
    - datatype
    - required
    - pattern
    - min
    - max
    - maxlength
    - minlength
    - notnull
    - checkequal
    - validtest
    
    Group:
    - name
    - properties
    
    Move from dg to widgets:
    - autocomplete with template
    - dropdown with bound multicheck
    
    Furthermore it supports:
    - properties binding rule to switch properties
    - special node introspection mode
        - .listAttributes()
            - returns array of objects
                - name
                - editor
                - validation rules
        - .setAttribute(name, value)
        - .getAttribute(name)
        - .addEventListener("prop." + name);
        - .removeEventListener("prop." + name);
    */
    
    this.$getProperties = function(xmlNode){
        if (this.properties) {
            if (!this.$properties) {
                //@todo wait
                return false;
            }
            else return this.$properties;
        }
        else if (this.$bindings.properties) {
            var props = this.$bindings.properties;
            for (var i = 0; i < props.length; i++) {
                if (!props[i].match) //compile via lm
                    return xx; //async request entry
            }
        }
        
        return false;
    }
    
    this.$load = function(xmlNode){
        var p = this.$getProperties();
        if (!p) return false;
        
        var output = [];
        var docId = this.documentId = apf.xmldb.getXmlDocId(p);
        
        //Add listener to XMLRoot Node
        apf.xmldb.addNodeListener(xmlNode, this); //@todo apf3 potential cleanup problem
        apf.xmldb.addNodeListener(this.xmlRoot, this);

        var _self = this, doc = p.ownerDocument;
        (function walk(nodes, parent, depth){
            for (var u, s, cell, sLid, pnode, html, node, i = 0, l = nodes.length; i < l; i++) {
                node = nodes[i];
                _self.$getNewContext("row") 
                html = _self.$getLayoutNode("row");
                
                if (node[apf.TAGNAME] == "group") {
                    _self.$getNewContext("cell");
                    apf.setStyleClass(html, "heading");

                    cell = html.appendChild(_self.$getLayoutNode("cell"));
                    apf.setNodeValue(_self.$getLayoutNode("cell", "caption", cell),
                        (node.getAttribute("caption") || "").trim() || ""); //@todo for IE but seems not a good idea
                
                    //group|
                    pnode = html.appendChild(doc.createElement("blockquote"));
                    walk(node.selectNodes("prop"), pnode, depth);
                    html.insertBefore(u = doc.createElement("u"), html.firstChild).appendChild(doc.createTextNode(" "));
                    u.setAttribute("class", "min");
                }
                else {
                    apf.xmldb.nodeConnect(docId, node, html, _self);
                
                    //Build the Cells
                    _self.$getNewContext("cell");
                    h = _self.$headings[0];
        
                    cell = html.appendChild(_self.$setStyleClass(_self.$getLayoutNode("cell"), h.$className));
                    apf.setNodeValue(_self.$getLayoutNode("cell", "caption", cell),
                        (node.getAttribute("caption") || "").trim() || ""); //@todo for IE but seems not a good idea

                    if (depth)
                        cell.firstChild.setAttribute("style", "padding-left:" + (depth * 15) + "px");
                    
                    _self.$getNewContext("cell");
                    h = _self.$headings[1];

                    cell = html.appendChild(_self.$setStyleClass(_self.$getLayoutNode("cell"), h.$className));
                    apf.setNodeValue(_self.$getLayoutNode("cell", "caption", cell),
                        ((apf.lm.compile(node.getAttribute("value"), {nostring: true}))(_self.xmlRoot) || "") || ""); //@todo for IE but seems not a good idea
                    
                    if ((s = node.selectNodes("prop")).length) {
                        pnode = html.appendChild(doc.createElement("blockquote"));
                        pnode.setAttribute("style", "display:none;overflow:hidden;height:0;");
                        walk(s, _self.$getLayoutNode("heading", "container", pnode), depth + 1);
                        
                        //Add opener
                        html.insertBefore(u = doc.createElement("u"), html.firstChild).appendChild(doc.createTextNode(" "));
                        u.setAttribute("class", "plus");
                    }
                }

                if (!parent)
                    output.push(html);
                else
                    parent.appendChild(html);
            }
        })(p.selectNodes("group|prop"), null, 0);
        
        apf.insertHtmlNodes(output, this.$int);
        
        this.setProperty("root", this.xmlRoot); //or xmlNode ??
        
        //@todo select the first one
        this.select(this.$findHtmlNode(
            p.selectSingleNode(".//prop").getAttribute(apf.xmldb.xmlIdTag) 
            + "|" + this.$uniqueId));
    }
    
    this.$xmlUpdate = function(action, xmlNode, listenNode, UndoObj){
        if (this.$lastEditor[0] == UndoObj.amlNode) {
            this.$lastEditor[1].firstChild.innerHTML = 
                ((apf.lm.compile(this.$lastEditor[2].getAttribute("value"), {
                    nostring: true
                }))(this.xmlRoot) || "") || "";
        }
        else {
            var p = this.$getProperties();
            var node, htmlNode, nodes = p.selectNodes(".//prop");
            for (var i = 0, l = nodes.length; i < l; i++) {
                node     = nodes[i];
                htmlNode = this.$findHtmlNode(
                    node.getAttribute(apf.xmldb.xmlIdTag) + "|" + this.$uniqueId);
                
                htmlNode.childNodes[htmlNode.firstChild.tagName == "U" ? 2 : 1]
                  .firstChild.innerHTML = 
                    ((apf.lm.compile(node.getAttribute("value"), {
                        nostring: true
                    }))(this.xmlRoot) || "") || "";
            }
            
        }
    }
    
    this.select = function(htmlNode){
        if (this.$selected == htmlNode) {
            /*var oEditor = this.$lastEditor[0];
            $setTimeout(function(){
                oEditor.focus();
            });*/
            
            return;
        }

        if (this.$selected)
            this.$setStyleClass(this.$selected, "", ["selected"]);

        this.$setStyleClass(htmlNode, "selected");
        this.$selected = htmlNode;
        
        if (this.$lastEditor) {
            //this.$lastEditor[0].$blur();
            this.$lastEditor[0].setProperty("visible", false);
            
            var nodes = this.$lastEditor[1].childNodes;
            for (var i = 0, l = nodes.length; i < l; i++) {
                if (!nodes[i].host)
                    nodes[i].style.display = "";
            }
        }
        
        var prop = apf.xmldb.getNode(htmlNode);
        var _self = this;
        
        /*
            - editor (name of widget, lm function returning amlNode or lm template ref)
            - children being aml nodes
         */
        var editParent = this.$selected.childNodes[this.$selected.firstChild.tagName == "U" ? 2 : 1];
        var oEditor, editor = prop.getAttribute("editor");
        var ceditor = apf.lm.compile(editor, {xpathmode: 2});
        if (ceditor.type == 2) {
            if (!this.$editors[editor]) {
                var constr = apf.namespaces[apf.ns.aml].elements[editor];
                var info   = {
                    htmlNode : editParent,
                    width    : "100%+2",
                    style    : "position:relative;z-index:10000",
                    value    : "[{" + this.id + ".root}::" 
                        + (v = prop.getAttribute("value")).substr(1, v.length - 2) 
                        + "]",
                    focussable : false
                };
                
                //@todo copy all non-known properties of the prop element

                if (constr.prototype.hasFeature(apf.__MULTISELECT__)) {
                    info.caption   = "[text()]";
                    info.eachvalue = "[@value]";
                    info.each      = "item";
                    info.model     = "{apf.xmldb.getElementById('" 
                        + prop.getAttribute(apf.xmldb.xmlIdTag) + "')}";
                }

                oEditor = this.$editors[editor] = new constr(info);
                
                var box = apf.getBox(apf.getStyle(oEditor.$ext, "margin"));
                if (box[1] || box[3]) {
                    oEditor.setAttribute("width", "100%+2-" + (box[1] + box[3]));
                }
                else if (!box[3])
                    oEditor.$ext.style.marginLeft = "-1px";
                
                //oEditor.$focussable = false;
                /*oEditor.addEventListener("focus", function(){
                    _self.focus();
                    this.$focus();
                });*/
                oEditor.parentNode   = this;
                oEditor.$focusParent = this;
                oEditor.setAttribute("focussable", "true");
                //delete oEditor.parentNode;
                
                //@todo set actiontracker
            }
            else {
                oEditor = this.$editors[editor];
                
                if (oEditor.hasFeature(apf.__MULTISELECT__))
                    oEditor.setAttribute("model", "{apf.xmldb.getElementById('" 
                        + prop.getAttribute(apf.xmldb.xmlIdTag) + "')}");

                oEditor.setAttribute("value", "[{" + this.id + ".root}::" 
                    + (v = prop.getAttribute("value")).substr(1, v.length - 2) 
                    + "]");

                oEditor.setProperty("visible", true);
                editParent.appendChild(oEditor.$ext);
            }
            
            /*setTimeout(function(){
                oEditor.focus();
            });*/
        }
        else {
            //Create dropdown 
            
            var obj = ceditor.call(this, this.xmlRoot);
            if (obj.localName == "template") {
                //add template contents to dropped area
            }
            else {
                //add xml into dropped area
            }
        }
        
        var nodes = editParent.childNodes;
        for (var i = 0, l = nodes.length; i < l; i++) {
            if (!nodes[i].host)
                nodes[i].style.display = "none";
        }

        this.$lastEditor = [oEditor, editParent, prop];
    }
    
    /*this.addEventListener("blur", function(){
        if (this.$lastEditor)
            this.$lastEditor[0].$blur();
    });
    
    this.addEventListener("focus", function(){
        if (this.$lastEditor)
            this.$lastEditor[0].$focus();
    });*/
    
    /**** Init ****/

    this.$draw = function(){
        //Build Main Skin
        this.$ext     = this.$getExternal();
        this.$int     = this.$getLayoutNode("main", "body", this.$ext);
        this.$head    = this.$getLayoutNode("main", "head", this.$ext);
        this.$pointer = this.$getLayoutNode("main", "pointer", this.$ext);

        if (this.$head.firstChild)
            this.$head.removeChild(this.$head.firstChild);
        if (this.$int.firstChild)
            this.$int.removeChild(this.$int.firstChild);

        var widthdiff = this.$widthdiff = this.$getOption("main", "widthdiff") || 0;
        this.$defaultwidth = this.$getOption("main", "defaultwidth") || "100";
        this.$useiframe    = apf.isIE && (apf.isTrue(this.$getOption("main", "iframe")) || this.iframe);

        var _self = this;
        
        //Initialize Iframe 
        if (this.$useiframe && !this.oIframe) {
            //this.$int.style.overflow = "hidden";
            //var sInt = this.$int.outerHTML 
            var sClass   = this.$int.className;
            //this.$int.parentNode.removeChild(this.$int);
            this.oIframe = this.$int.appendChild(document.createElement(apf.isIE 
                ? "<iframe frameborder='0'></iframe>"
                : "iframe"));
            this.oIframe.frameBorder = 0;
            this.oWin = this.oIframe.contentWindow;
            this.oDoc = this.oWin.document;
            this.oDoc.write('<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">\
                <html xmlns="http://www.w3.org/1999/xhtml">\
                    <head><script>\
                        apf = {\
                            lookup : function(uid){\
                                return window.parent.apf.lookup(uid);\
                            },\
                            Init : {add:function(){},run:function(){}}\
                        };</script>\
                    </head>\
                    <body></body>\
                </html>');
            //Import CSS
            //this.oDoc.body.innerHTML = sInt;
            this.$int = this.oDoc.body;//.firstChild;
            this.$int.className = sClass;//this.oIframe.parentNode.className;
            this.oDoc.documentElement.className = this.$ext.className;
            //this.oDoc.body.className = this.$ext.className;

            apf.skins.loadCssInWindow(this.skinName, this.oWin, this.mediaPath, this.iconPath);
            
            if (apf.isIE) //@todo this can be removed when focussing is fixed for this component
                this.$setStyleClass(this.oDoc.documentElement, this.$baseCSSname + "Focus");
            
            apf.convertIframe(this.oIframe, true);

            if (apf.getStyle(this.oDoc.documentElement, apf.isIE 
              ? "overflowY" : "overflow-y") == "auto") {
                //@todo ie only
                this.oIframe.onresize = function(){
                    _self.$head.style.marginRight = 
                      _self.oDoc.documentElement.scrollHeight > _self.oDoc.documentElement.offsetHeight 
                        ? "16px" : "0";
                }
                
                this.addEventListener("afterload", this.oIframe.onresize);
                this.addEventListener("xmlupdate", this.oIframe.onresize);
            }
            
            this.oDoc.documentElement.onmousedown = function(e){
                if (!e) e = _self.oWin.event;
                if ((e.srcElement || e.target).tagName == "HTML")
                    apf.popup.forceHide();
            }
                        
            this.oDoc.documentElement.onscroll = 
                function(){
                    if (_self.$isFixedGrid)
                        _self.$head.scrollLeft = _self.oDoc.documentElement.scrollLeft;
                };
        }
        else {
            if (apf.getStyle(this.$int, apf.isIE 
              ? "overflowY" : "overflow-y") == "auto") {
                this.$resize = function(){
                    _self.$head.style.marginRight = 
                      _self.$int.scrollHeight > _self.$int.offsetHeight 
                        ? "16px" : "0";
                }
                
                
                apf.layout.setRules(this.$ext, this.$uniqueId + "_datagrid",
                    "var o = apf.all[" + this.$uniqueId + "];\
                     if (o) o.$resize()");
                apf.layout.queue(this.$ext);
                
                
                this.addEventListener("afterload", this.$resize);
                this.addEventListener("xmlupdate", this.$resize);
            }
            
            this.$int.onmousedown = function(e){
                if (!e) e = event;
                if ((e.srcElement || e.target) == this)
                    apf.popup.forceHide();
            }
            
            this.$int.onscroll = 
                function(){
                    if (_self.$isFixedGrid)
                        _self.$head.scrollLeft = _self.$int.scrollLeft;
                };
        }
        
        var _self = this;
        this.$int.onmousedown = function(e){
            if (!e) e = event;
            var target = e.srcElement || e.target;
            
            if (target == this) return;
            
            if (target.tagName == "U") {
                _self.$slideToggle(target);
                return;
            }
            
            while (target.host || (target.getAttribute(apf.xmldb.htmlIdTag) || "").indexOf("|") == -1) {
                target = target.parentNode;
                if (target == this) return;
            }

            _self.select(target);
        }
    };
    
    this.$loadAml = function(x){
        //Create two columns
        this.$headings = [
            new apf.BindingColumnRule().$draw(this, "Property", this.$columns[0], "first"),
            new apf.BindingColumnRule().$draw(this, "Value", this.$columns[1])
        ];
    };
    
    this.$destroy = function(){
        apf.popup.removeContent(this.$uniqueId);
        
        this.$ext.onclick = this.$int.onresize = null;
        
        
        apf.layout.removeRule(this.$int, "dg" + this.$uniqueId);
        apf.layout.activateRules(this.$int);
        
    };

}).call(apf.propedit.prototype = new apf.DataBinding());


apf.aml.setElement("propedit",    apf.propedit);
apf.aml.setElement("column",      apf.BindingColumnRule);
apf.aml.setElement("description", apf.BindingRule);
apf.aml.setElement("color",       apf.BindingRule);





/*FILEHEAD(/var/lib/platform/source/trunk/elements/slider.js)SIZE(25648)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Element allowing the user to select a value from a range of
 * values between a minimum and a maximum value.
 * Example:
 * This example shows a slider that influences the position of a video. The
 * value attribute of the slider is set using property binding. The square
 * brackets imply a {@link term.propertybinding bidirectional binding}.
 * <code>
 *  <a:video id="player1"
 *    src      = "elements/video/demo_video.flv"
 *    autoplay = "true">
 *      Unsupported video codec.
 *  </a:video>
 *
 *  <a:button onclick="player1.play()">play</a:button>
 *  <a:button onclick="player1.pause()">pause</a:button>
 *
 *  <a:slider value="[player1.position]" />
 * </code>
 * Example:
 * This example shows two slider which lets the user indicate a value in a form.
 * <code>
 *  <a:model id="mdlSlider">
 *      <data hours_hd="2" decide_buy="3"></data>
 *  </a:model>
 *  <a:label>How would you grade the opening hours of the helpdesk</a:label>
 *  <a:slider 
 *    model = "mdlSlider" 
 *    value = "[@hours_hd]"
 *    mask  = "no opinion|bad|below average|average|above average|good"
 *    min   = "0"
 *    max   = "5"
 *    step  = "1"
 *    slide = "snap" />
 *  <a:label>How soon will you make your buying decision</a:label>
 *  <a:slider 
 *    model = "mdlSlider" 
 *    value = "[@decide_buy]"
 *    mask  = "undecided|1 week|1 month|6 months|1 year|never"
 *    min   = "0"
 *    max   = "5"
 *    step  = "1"
 *    slide = "snap" />
 *  </code>
 *
 * @constructor
 * @define slider, range
 * @allowchild {smartbinding}
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.9
 *
 * @inherits apf.StandardBinding
 * @inherits apf.XForms
 *
 * @binding value  Determines the way the value for the element is retrieved 
 * from the bound data.
 * Example:
 * Sets the slider position based on data loaded into this component.
 * <code>
 *  <a:model id="mdlSlider">
 *      <data value="5"></data>
 *  </a:model>
 *  <a:slider 
 *    model = "mdlSlider" 
 *    min   = "0" 
 *    max   = "10" 
 *    step  = "1" 
 *    mask  = "#" 
 *    value = "[@value]" />
 * </code>
 * Example:
 * A shorter way to write this is:
 * <code>
 *  <a:model id="mdlSlider">
 *      <data value="5"></data>
 *  </a:model>
 *  <a:slider 
 *    min   = "0" 
 *    max   = "10" 
 *    step  = "1" 
 *    mask  = "#" 
 *    value = "[mdlSlider::@value]" />
 * </code>
 */
apf.range  = function(struct, tagName){
    this.$init(tagName || "range", apf.NODE_VISIBLE, struct);
};

apf.slider = function(struct, tagName){
    this.$init(tagName || "slider", apf.NODE_VISIBLE, struct);
};

(function(){
    this.implement(
        
        apf.DataAction
        
        
    );

    this.$focussable = true; // This object can get the focus

    this.$dragging   = false;
    this.$onlySetXml = false;

    /**** Properties and Attributes ****/
    this.disabled    = false; // Object is enabled
    this.realtime    = true;
    this.balloon     = true;
    this.value       = 0;
    this.mask        = "%";
    this.min         = 0;
    this.max         = 1000001;

    this.$supportedProperties.push("step", "mask", "min", "max", "slide",
        "value", "markers");

    this.$booleanProperties["realtime"] = true;
    this.$booleanProperties["markers"]  = true;
    this.$booleanProperties["balloon"]  = true;

    /**
     * @attribute {Boolean} realtime whether the slider updates it's value realtime,
     *                               or just when the user stops dragging.
     * @attribute {Boolean} balloon  whether to show the balloon with extra
     *                               information on the position of the slider.
     *                               Default is true when the skin supports it.
     * @attribute {Number}  step     specifying the step size of a discreet slider.
     * Example:
     * <code>
     *  <a:label>How much money do you make annualy.</a:label>
     *  <a:range 
     *    value = "2000"
     *    min   = "0"
     *    max   = "5000"
     *    step  = "1000"
     *    slide = "snap" />
     * </code>
     */
    this.$propHandlers["step"] = function(value){
        this.step = parseInt(value) || 0;

        if (!this.$hasLayoutNode("marker"))
            return;

        if (!this.slider)
            this.slideDiscreet = true;
    };
    

    /**
     * @attribute {Boolean} markers whether to display a marker at each discrete step.
     */
    this.$propHandlers["markers"] = function(value){
        //Remove Markers
        var i,
            markers = this.oMarkers.childNodes;
        for (i = markers.length - 1; i >= 0; i--) {
            if (markers[i].tagName == "U" && markers[i].nodeType == 1) //small hack
                apf.destroyHtmlNode(markers[i]);
        }

        if (!this.step && this.$aml)
            this.step = parseInt(this.getAttribute("step")) || 0;

        //Add markers
        if (value && this.step) {
            var pos, o,
                nodes = [],
                max   = (this.max == 1000001) ? 1 : this.max,

                count = (max - this.min) / this.step,
                prop  = this.$dir == "horizontal" ? "left" : "top",
                size  = this.$dir == "horizontal"
                    ? this.$ext.offsetWidth - this.oKnob.offsetWidth 
                      - apf.getWidthDiff(this.oContainer)
                    : this.$ext.offsetHeight - this.oKnob.offsetHeight;

            for (i = 0; i < count + 1; i++) {
                this.$getNewContext("marker");
                o = this.$getLayoutNode("marker");
                pos = Math.max(0, (i * (1 / (count))));
                o.setAttribute("style", prop + ":" + Math.round(pos * size) + "px");
                nodes.push(o);
            }
            apf.insertHtmlNodes(nodes, this.oMarkers);
        }
    };
    
    this.$resize = function(){
        this.$propHandlers.value.call(this, this.value);

        var count = (this.max - this.min) / this.step;
        if (!count) return;

        var pos, i,
            prop = this.$dir == "horizontal" ? "left" : "top",
            size = this.$dir == "horizontal"
                ? this.$ext.offsetWidth - this.oKnob.offsetWidth 
                  - apf.getWidthDiff(this.oContainer)
                : this.$ext.offsetHeight - this.oKnob.offsetHeight,
            nodes = this.oMarkers.getElementsByTagName("U");//small hack
        for (i = nodes.length - 1; i >= 0; i--) {
            pos = Math.max(0, i * (1 / count));
            nodes[i].style[prop] = Math.round(pos * size) + "px";
        }
    };

    /**
     * @attribute {String} mask a pipe '|' seperated list of strings that are
     * used as the caption of the slider when their connected value is picked.
     * Example:
     * <code>
     *  <a:label>How big is your cat?</a:label>
     *  <a:slider value="2"
     *    mask  = "don't know|20cm|25cm|30cm|35cm|bigger than 35cm"
     *    min   = "0"
     *    max   = "5"
     *    step  = "1"
     *    slide = "snap" />
     * </code>
     */
    this.$propHandlers["mask"] = function(value){
        if (!value)
            this.mask = "%";

        if (!this.mask.match(/^(%|#)$/))
            this.mask = value.split(/\||;/);
    };

    /**
     * @attribute {String} progress a value between 0 and 1 which is visualized
     * inside the slider. This can be used to show a progress indicator for
     * the download of movies or other media.
     * Example:
     * <code>
     *  <a:video id="player1"
     *    src      = "elements/video/demo_video.flv"
     *    autoplay = "true">
     *      Unsupported video codec.
     *  </a:video>
     *
     *  <a:slider value="[player1.position]" progress="{player1.progress}" />
     * </code>
     */
    this.$propHandlers["progress"] = function(value){
        if (!this.oProgress) {
            this.oProgress =
              apf.insertHtmlNode(this.$getLayoutNode("progress"),
                this.$getLayoutNode("main", "progress", this.$ext));
        }

        this.oProgress.style.width = ((value || 0) * 100) + "%";
    };

    /**
     * @attribute {Number} min the minimal value the slider can have. This is
     * the value that the slider has when the grabber is at it's begin position.
     */
    this.$propHandlers["min"] = function(value){
        this.min = parseInt(value) || 0;
        if (this.markers)
            this.$propHandlers["markers"].call(this, this.markers);
        if (this.value < this.min || this.value != this.$value) { //@todo apf3.0
            this.value = -1; //@todo apf3.0
            this.setProperty("value", this.$value);
        }
    };

    /**
     * @attribute {Number} max the maximal value the slider can have. This is
     * the value that the slider has when the grabber is at it's end position.
     */
    this.$propHandlers["max"] = function(value){
        this.max = parseInt(value) || 1;
        if (this.markers)
            this.$propHandlers["markers"].call(this, this.markers);
        if (this.value > this.min || this.value != this.$value) { //@todo apf3.0
            this.value = -1; //@todo apf3.0
            this.setProperty("value", this.$value);
        }
    };

    /**
     * @attribute {String} slide the way the grabber can be handled
     *   Possible values:
     *   normal     the slider moves over a continuous space.
     *   discrete   the slider's value is discrete but the grabber moves over a continuous space and only snaps when the user lets go of the grabber.
     *   snap       the slider snaps to the discrete values it can have while dragging.
     * Remarks:
     * Discrete space is set by the step attribute.
     */
    this.$propHandlers["slide"] = function(value){
        this.slideDiscreet = value == "discrete";
        this.slideSnap     = value == "snap";
    };

    /**
     * @attribute {String} value the value of slider which is represented in
     * the position of the grabber using the following
     * formula: (value - min) / (max - min)
     */
    this.$propHandlers["value"] = function(value, prop, force, animate){
        if (!this.$dir || this.$onlySetXml)
            return; //@todo fix this

        if (this.$dragging && !force && !this.realtime)
            return;

        this.$value = value;
        this.value = Math.max(this.min, Math.min(this.max, value)) || 0;

        var max, min, offset,
            _self      = this,
            multiplier = this.max == this.min
                ? 0
                : (this.value - this.min) / (this.max - this.min);

        if (this.$dir == "horizontal") {
            max = (this.oContainer.offsetWidth
                - apf.getWidthDiff(this.oContainer))
                - this.oKnob.offsetWidth;
            min = parseInt(apf.getBox(
                apf.getStyle(this.oContainer, "padding"))[3]);

            offset = (((max - min) * multiplier) + min);

            if (animate) {
                apf.tween.single(this.oKnob, {
                    type    : 'left',
                    steps   : 5,
                    interval: 10,
                    from    : this.oKnob.offsetLeft,
                    to      : offset,
                    anim    : apf.tween.NORMAL,
                    oneach  : function(oNode) {
                        if (_self.oFill)
                            _self.oFill.style.width = (oNode.offsetLeft + 3) + "px";
                    }
                });
            }
            else {
                this.oKnob.style.left = offset + "px";
                if (this.oFill)
                    this.oFill.style.width = (offset + 3) + "px";
            }
        }
        else {
            max = (this.oContainer.offsetHeight
                - apf.getHeightDiff(this.oContainer))
                - this.oKnob.offsetHeight;
            min = parseInt(apf.getBox(
                apf.getStyle(this.oContainer, "padding"))[0]);

            offset = (((max - min) * (1 - multiplier)) + min);

            if (animate) {
                apf.tween.single(this.oKnob, {
                    type    : 'top',
                    steps   : 5,
                    interval: 10,
                    from    : this.oKnob.offsetTop,
                    to      : offset,
                    anim    : apf.tween.NORMAL,
                    oneach  : function(oNode) {
                        if (_self.oFill)
                            _self.oFill.style.height = (oNode.offsetTop + 3) + "px";
                    }
                });
            }
            else {
                this.oKnob.style.top = offset + "px";
                if (this.oFill)
                    this.oFill.style.height = (offset + 3) + "px";
            }
        }

        if (this.oLabel) {
            //Percentage
            if (this.mask == "%") {
                this.oLabel.nodeValue = Math.round(multiplier * 100) + "%";
            }
            //Number
            else if (this.mask == "#") {
                //status = this.value;
                this.oLabel.nodeValue = this.step
                    ? (Math.round(this.value / this.step) * this.step)
                    : this.value;
            }
            //Lookup
            else {
                this.oLabel.nodeValue = this.mask[Math.round(this.value - this.min)
                    / (this.step || 1)]; //optional floor ??
            }
        }
    };

    /**** Public methods ****/

    
    
    /**
     * Sets the value of this element. This should be one of the values
     * specified in the values attribute.
     * @param {String} value the new value of this element
     */
    this.setValue = function(value){
        this.setProperty("value", value, false, true);
    };

    /**
     * Returns the current value of this element.
     * @return {String}
     */
    this.getValue = function(){
        return this.step
            ? Math.round(parseInt(this.value) / this.step) * this.step
            : this.value;
    };
    
    

    /**** Keyboard support ****/

    
    this.addEventListener("keydown", function(e){
        var key      = e.keyCode;
        var ctrlKey  = e.ctrlKey;

        switch (key) {
            case 37:
                //LEFT
                if (this.$dir != "horizontal")
                    return;
                this.setValue(this.value - (ctrlKey ? 0.01 : 0.1));
                break;
            case 38:
                //UP
                if (this.$dir != "vertical")
                    return;
                this.setValue(this.value + (ctrlKey ? 0.01 : 0.1));
                break;
            case 39:
                //RIGHT
                if (this.$dir != "horizontal")
                    return;
                this.setValue(this.value + (ctrlKey ? 0.01 : 0.1));
                break;
            case 40:
                //DOWN
                if (this.$dir != "vertical")
                    return;
                this.setValue(this.value - (ctrlKey ? 0.01 : 0.1));
                break;
            default:
                return;
        }

        return false;
    }, true);
    

    /**** Init ****/

    this.$draw = function(){
        //Build Main Skin
        this.$ext     = this.$getExternal();
        this.oLabel   = this.$getLayoutNode("main", "status", this.$ext);
        this.oMarkers = this.$getLayoutNode("main", "markers", this.$ext);
        this.oKnob    = this.$getLayoutNode("main", "slider", this.$ext);
        this.oFill    = this.$getLayoutNode("main", "fill", this.$ext);
        this.oBalloon = this.$getLayoutNode("main", "balloon", this.$ext);
        this.$int     = this.oContainer = this.$getLayoutNode("main",
            "container", this.$ext);

        this.$dir     = this.$getOption("main", "direction") || "horizontal";

        this.oKnob.style.left = (parseInt(apf.getBox(
            apf.getStyle(this.$ext, "padding"))[3])) + "px";

        var _self = this;
        function prepareKnob(e) {
            this.x   = (e.clientX || e.x);
            this.y   = (e.clientY || e.y);
            this.stX = this.offsetLeft;
            this.siX = this.offsetWidth
            this.stY = this.offsetTop;
            this.siY = this.offsetheight
            this.startValue = _self.value;

            if (_self.$dir == "horizontal") {
                this.max = parseInt(apf.getStyle(_self.oContainer, "width"))
                    - this.offsetWidth;
                this.min = parseInt(apf.getBox(
                    apf.getStyle(_self.oContainer, "padding"))[3]);
            }
            else {
                this.max = parseInt(apf.getStyle(_self.oContainer, "height"))
                    - this.offsetHeight;
                this.min = parseInt(apf.getBox(
                    apf.getStyle(_self.oContainer, "padding"))[0]);
            }
        }

        function getKnobValue(o, e, slideDiscreet){
            var to = (_self.$dir == "horizontal")
                ? (e.clientX || e.x) - o.x + o.stX
                : (e.clientY || e.y) - o.y + o.stY;
            to = (to > o.max ? o.max : (to < o.min ? o.min : to));
            var value = (((to - o.min) * 100 / (o.max - o.min) / 100)
                * (_self.max - _self.min)) + _self.min;

            value = slideDiscreet
                ? (Math.round(value / _self.step) * _self.step)
                : value;
            value = (_self.$dir == "horizontal") ? value : 1 - value;

            return value;
        }

        this.oKnob.onmousedown = function(e){
            if (_self.disabled)
                return false;

            //@todo use start action here

            e = e || window.event;
            document.dragNode = this;

            prepareKnob.call(this, e);

            _self.$setStyleClass(this, "btndown", ["btnover"]);

            apf.dragMode = true;

            _self.$dragging = true;
            
            if (_self.balloon && _self.oBalloon) {
                _self.oBalloon.style.display = "block";
                _self.oBalloon.style.left = (_self.oKnob.offsetLeft 
                    - (_self.oBalloon.offsetWidth 
                    - _self.oKnob.offsetWidth)/2) + "px";
            }
            
            var startValue = this.value;
            document.onmousemove = function(e){
                e = e || window.event;
                var o = this.dragNode;
                if (!o) {
                    apf.dragMode = document.onmousemove = document.onmouseup = null;
                    return; //?
                }

                var knobValue = getKnobValue(o, e, _self.slideSnap);
                if (_self.realtime) {
                    //_self.value = -1; //reset value //@todo apf3.0 please fix this to be not needed. just set a flag to not do change detect
                    if (_self.slideDiscreet) {
                        this.$onlySetXml = true;//blrgh..
                        var rValue = _self.change(Math.round(knobValue / _self.step)
                            * _self.step);
                        this.$onlySetXml = false;
                        if (rValue !== false) {
                            _self.$propHandlers["value"].call(_self, knobValue, 
                                "value", true);
                        }
                    }
                    else {
                        _self.change(knobValue);
                    }
                }
                else {
                    _self.$propHandlers["value"].call(_self, knobValue, "value", true);
                }
                
                if (_self.balloon && _self.oBalloon) {
                    _self.oBalloon.style.left = (_self.oKnob.offsetLeft 
                        - (_self.oBalloon.offsetWidth 
                        - _self.oKnob.offsetWidth)/2) + "px";
                }
                
                /*clearTimeout(timer);
                if (new Date().getTime() - lastTime > 20) {
                    _self.$propHandlers["value"].call(_self, knobValue, true);
                    lastTime = new Date().getTime();
                }
                else {
                    timer = $setTimeout(function(){
                        _self.$propHandlers["value"].call(_self, knobValue, true);
                        lastTime = new Date().getTime();
                    }, 20);
                }*/
            }

            document.onmouseup = function(e){
                var o = this.dragNode;
                this.dragNode = null;

                o.onmouseout();

                _self.$dragging = false;

                var knobValue = getKnobValue(o, e || window.event,
                    _self.slideDiscreet || _self.slideSnap);

                _self.value = startValue;
                var rValue = startValue != knobValue
                    ? _self.change(knobValue, true) : false;
                
                if (rValue !== false && _self.slideDiscreet)
                    _self.$propHandlers["value"].call(_self, knobValue, "value", true);

                apf.dragMode         = false;
                document.onmousemove = 
                document.onmouseup   = null;

                if (_self.balloon && _self.oBalloon) {
                    _self.oBalloon.style.left = (_self.oKnob.offsetLeft 
                        - (_self.oBalloon.offsetWidth 
                        - _self.oKnob.offsetWidth)/2) + "px";

                    $setTimeout(function(){
                        if (apf.isIE) {
                            _self.oBalloon.style.display = "none";
                        }
                        else {
                            apf.tween.single(_self.oBalloon, {
                                type : "fade",
                                from : 1,
                                to   : 0,
                                steps : 5,
                                onfinish : function(){
                                    _self.oBalloon.style.display = "none";
                                    _self.oBalloon.style.opacity = 1;
                                }
                            })
                        }
                    }, _self.slideDiscreet ? 200 : 0);
                }
            };
            //event.cancelBubble = true;
            return false;
        };

        this.oKnob.onmouseup = this.oKnob.onmouseover = function(){
            if (document.dragNode != this)
                _self.$setStyleClass(this, "btnover", ["btndown"]);
        };

        this.oKnob.onmouseout = function(){
            if (document.dragNode != this)
                _self.$setStyleClass(this, "", ["btndown", "btnover"]);
        };

        this.$ext.onmousedown = function(e) {
            if (_self.disabled) return false;
            e = e || window.event;

            var o = _self.oKnob;
            if ((e.srcElement || e.target) != o) {
                var p = apf.getAbsolutePosition(o);
                prepareKnob.call(o, {
                    x : p[0] + o.offsetWidth / 2,
                    y : p[1] + o.offsetHeight / 2
                });
                var value = getKnobValue(o, e, _self.slideDiscreet || _self.slideSnap);
                _self.$propHandlers["value"].call(_self, getKnobValue(o, e, _self.slideDiscreet), "value", true, true);
                _self.setValue(value);
            }
        };

        
        if (apf.isIphone)
            apf.iphone.linkEvents(this.oKnob);
        
    };

    this.addEventListener("DOMNodeInsertedIntoDocument", function() {
        if (this.max == 1000001)
            this.setProperty("max", 1);
        //this.$propHandlers["value"].call(this, this.value);

        //@todo this goes wrong with skin switching. smartbindings is called again.
        
        
        apf.layout.setRules(this.$ext, "knob",
            "apf.all[" + this.$uniqueId + "].$resize()", true);
        apf.layout.queue(this.$ext);
        
    });

    this.$destroy = function(){
        this.oKnob.onmousedown =
        this.oKnob.onmouseup   =
        this.oKnob.onmouseover =
        this.oKnob.onmouseout  = null;
        
        
        apf.layout.removeRule(this.$ext, "knob");
        
    };

}).call(apf.slider.prototype = new apf.StandardBinding());


apf.range.prototype = apf.slider.prototype;

apf.aml.setElement("range",  apf.range);
apf.aml.setElement("slider", apf.slider);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/colorpicker2.js)SIZE(11338)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Element giving the user a visual choice to pick a color just like Photoshop
 * does it!
 *
 * @constructor
 * @define colorpicker
 * @addnode elements
 *
 * @author      Mike de Boer (mike AT javeline DOT com)
 * @version     %I%, %G%
 * @since       3.0
 *
 * @inherits apf.StandardBinding
 * @inherits apf.DataAction
 *
 * @attribute {String} value the color that is selected in the color picker.
 *
 * @binding value  Determines the way the value for the element is retrieved
 * from the bound data.
 * Example:
 * Sets the color based on data loaded into this component.
 * <code>
 *  <a:colorpicker>
 *      <a:bindings>
 *          <a:value match="[@color]" />
 *      </a:bindings>
 *  </a:colorpicker>
 * </code>
 * Example:
 * A shorter way to write this is:
 * <code>
 *  <a:model id="mdlColor">
 *      <data color="#00099"></data>
 *  </a:model>
 *  <a:colorpicker 
 *    model = "mdlColor" 
 *    value = "[@color]" />
 * </code>
 */
apf.colorpicker = function(struct, tagName){
    this.$init(tagName || "colorpicker", apf.NODE_VISIBLE, struct);
};

(function(){
    this.value       = "ff0000";
    this.changeTimer = null;

    var c = apf.color;

    this.$supportedProperties.push("color", "red", "green", "blue", "hue",
        "saturation", "brightness", "hex");

    this.$propHandlers["red"]        =
    this.$propHandlers["green"]      =
    this.$propHandlers["blue"]       =
    this.$propHandlers["hue"]        =
    this.$propHandlers["saturation"] = 
    this.$propHandlers["brightness"] = 
    this.$propHandlers["hex"]        = function(val, doChange) {
        clearTimeout(this.changeTimer);
        if (doChange) {
            var _self = this;
            this.changeTimer = $setTimeout(function() {
                _self.$change();
            });
        }
    };

    this.$propHandlers["value"] = function(val) {
        this.$restoreOriginal();
    };

    this.$restoreOriginal = function() {
        this.$change(c.hexToHSB(this.value));
        this.oCustomColor.style.backgroundColor = 
            (this.value.substr(0, 1) != "#" ? "#" : "") + this.value;
    };

    this.$change = function(hsb) {
        if (!hsb) {
            hsb = {
                h: this.hue,
                s: this.saturation,
                b: this.brightness
            };
        }
        hsb = c.fixHSB(hsb);
        
        var hex = c.HSBToHex(hsb),
            rgb = c.HSBToRGB(hsb);

        this.oNewColor.style.backgroundColor = "#" + hex;

        this.setProperty("red", rgb.r);
        this.setProperty("green", rgb.g);
        this.setProperty("blue", rgb.b);
        this.setProperty("saturation", hsb.s);
        this.setProperty("brightness", hsb.b);
        this.setProperty("hue", hsb.h);
        this.setProperty("hex", hex);

        this.oSelector.style.background = "#" + c.HSBToHex({h: hsb.h, s: 100, b: 100});
        this.oHue.style.top          = parseInt(150 - 150 * hsb.h / 360, 10) + "px";
        this.oSelectorInd.style.left = parseInt(150 * hsb.s / 100, 10) + "px";
        this.oSelectorInd.style.top  = parseInt(150 * (100 - hsb.b) / 100, 10) + "px";
    };

    this.$draw = function() {
        if (!this.id)
            this.setProperty("id", "colorpicker" + this.$uniqueId);

        //Build Main Skin
        this.$ext          = this.$getExternal();
        this.oSelector     = this.$getLayoutNode("main", "selector", this.$ext);
        this.oSelectorInd  = this.$getLayoutNode("main", "selector_indic", this.$ext);
        this.oHue          = this.$getLayoutNode("main", "hue", this.$ext);
        this.oNewColor     = this.$getLayoutNode("main", "newcolor", this.$ext);
        this.oCustomColor  = this.$getLayoutNode("main", "customcolor", this.$ext);
        this.oInputs       = this.$getLayoutNode("main", "inputs", this.$ext);

        this.$restoreOriginal();

        //attach behaviours
        var _self = this,
            doc   = (!document.compatMode || document.compatMode == 'CSS1Compat')
                ? document.html : document.body;
        function stopMoving() {
            document.onmousemove = document.onmouseup = null;
            _self.$change();
            return false;
        }
        function selectorDown() {
            var el  = this,
                pos = apf.getAbsolutePosition(el);
            
            function selectorMove(e) {
                e = e || event;
                var pageX = e.pageX || e.clientX + (doc ? doc.scrollLeft : 0),
                    pageY = e.pageY || e.clientY + (doc ? doc.scrollTop  : 0);
                // only the saturation and brightness change...
                _self.brightness = parseInt(100 * (150 - Math.max(0, Math.min(150,
                    (pageY - pos[1])))) / 150, 10);
                _self.saturation = parseInt(100 * (Math.max(0, Math.min(150,
                    (pageX - pos[0])))) / 150, 10);
                _self.$change();
                pos = apf.getAbsolutePosition(el);
                return false;
            }
            document.onmousemove = selectorMove;
            document.onmouseup   = function(e) {
                selectorMove(e);
                return stopMoving(e);
            };
        }
        
        function hueDown(e) {
            var el  = this,
                pos = apf.getAbsolutePosition(el);

            function hueMove(e) {
                e = e || event;
                var pageY = e.pageY || e.clientY + (doc ? doc.scrollTop : 0);
                _self.hue  = parseInt(360 * (150 - Math.max(0,
                    Math.min(150, (pageY - pos[1])))) / 150, 10);
                _self.$change();
                pos = apf.getAbsolutePosition(el);
            }
            document.onmousemove = hueMove;
            document.onmouseup   = function(e) {
                hueMove(e);
                return stopMoving(e);
            };
        }
        this.oSelector.onmousedown       = selectorDown;
        this.oHue.parentNode.onmousedown = hueDown;
        this.oCustomColor.onmousedown    = function() {
            _self.$restoreOriginal();
        };

        function spinnerChange(e) {
            var o     = e.currentTarget,
                isRGB = false;
            if (o.id.indexOf("hue") > -1)
                _self.hue = e.value;
            else if (o.id.indexOf("saturation") > -1)
                _self.saturation = e.value;
            else if (o.id.indexOf("brightness") > -1)
                _self.brightness = e.value;
            else if (o.id.indexOf("red") > -1)
                _self.red = e.value, isRGB = true;
            else if (o.id.indexOf("green") > -1)
                _self.green = e.value, isRGB = true;
            else if (o.id.indexOf("blue") > -1)
                _self.blue = e.value, isRGB = true;

            if (isRGB) {
                var hsb = c.RGBToHSB({r: _self.red, g: _self.green, b: _self.blue});
                _self.hue = hsb.h;
                _self.saturation = hsb.s;
                _self.brightness = hsb.b;
            }

            _self.$change();
        }

        //append APF widgets for additional controls
        var skin = apf.getInheritedAttribute(this.parentNode, "skinset");
        new apf.table({
            htmlNode: this.oInputs,
            skinset: skin,
            left: 206,
            top: 52,
            width: 150,
            columns: "50%,50%",
            cellheight: 26,
            childNodes: [
                new apf.spinner({
                    id: this.id + "_hue",
                    width: 62,
                    min: 0,
                    max: 360,
                    value: "{" + this.id + ".hue}",
                    onafterchange: spinnerChange
                }),
                new apf.spinner({
                    id: this.id + "_red",
                    width: 62,
                    min: 0,
                    max: 255,
                    value: "{" + this.id + ".red}",
                    onafterchange: spinnerChange
                }),
                new apf.spinner({
                    id: this.id + "_saturation",
                    width: 62,
                    min: 0,
                    max: 100,
                    value: "{" + this.id + ".saturation}",
                    onafterchange: spinnerChange
                }),
                new apf.spinner({
                    id: this.id + "_green",
                    width: 62,
                    min: 0,
                    max: 255,
                    value: "{" + this.id + ".green}",
                    onafterchange: spinnerChange
                }),
                new apf.spinner({
                    id: this.id + "_brightness",
                    width: 62,
                    min: 0,
                    max: 100,
                    value: "{" + this.id + ".brightness}",
                    onafterchange: spinnerChange
                }),
                new apf.spinner({
                    id: this.id + "_blue",
                    width: 62,
                    min: 0,
                    max: 255,
                    value: "{" + this.id + ".blue}",
                    onafterchange: spinnerChange
                })
            ]
        });

        new apf.label({
            htmlNode: this.oInputs,
            skinset: skin,
            left: 212,
            top: 142,
            width: 7,
            value: "#",
            "for": this.id + "_hex"
        });

        new apf.textbox({
            htmlNode: this.oInputs,
            skinset: skin,
            left: 222,
            top: 140,
            width: 75,
            value: "{" + this.id + ".hex}",
            onafterchange: function(e) {
                _self.hex = c.fixHex(e.value);
                var hsb   = c.hexToHSB(_self.hex);
                _self.hue = hsb.h;
                _self.saturation = hsb.s;
                _self.brightness = hsb.b;
                _self.$change();
            }
        });
    };

    this.$destroy = function() {
        this.$ext = this.oSelector = this.oSelectorInd = this.oHue =
            this.oNewColor = this.oCustomColor = this.oInputs = null;
    };

}).call(apf.colorpicker.prototype = new apf.StandardBinding());


apf.aml.setElement("colorpicker", apf.colorpicker);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/codeeditor.js)SIZE(16237)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/state.js)SIZE(10916)TIME(1259708672)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * @private
 */
apf.StateServer = {
    states: {},
    groups: {},
    locs  : {},

    removeGroup: function(name, elState){
        this.groups[name].remove(elState);
        if (!this.groups[name].length) {
            if (self[name]) {
                self[name].destroy();
                self[name] = null;
            }

            delete this.groups[name];
        }
    },

    addGroup: function(name, elState, pNode){
        if (!this.groups[name]) {
            this.groups[name] = [];

            var pState = new apf.state("state", null, null, true);
            pState.parentNode = pNode;
            pState.implement(apf.AmlNode);
            pState.name   = name;
            pState.toggle = function(){
                for (var next = 0, i = 0; i < apf.StateServer.groups[name].length; i++) {
                    if (apf.StateServer.groups[name][i].active) {
                        next = i + 1;
                        break;
                    }
                }

                apf.StateServer.groups[name][
                    (next == apf.StateServer.groups[name].length) ? 0 : next
                  ].activate();
            }

            this.groups[name].pState = self[name] = pState;
        }

        if (elState)
            this.groups[name].push(elState);

        return this.groups[name].pState;
    },

    removeState: function(elState){
        delete this.states[elState.name];
    },

    addState: function(elState){
        this.states[elState.name] = elState;
    }
}

/**
 * Element that specifies a certain state of (a part of) the application. With
 * state we mean a collection of properties on objects that have a certain
 * value at one time. This element allows you to specify which properties on
 * which elements should be set when a state is activated. This element can
 * belong to a state-group containing multiple elements with a default state.
 * Example:
 * This example shows a log in window and four state elements in a state-group.
 * <code>
 *   <a:appsettings>
 *       <a:auth 
 *         login         = "{comm.login(username, password)}" 
 *         logout        = "{comm.logout()}"
 *         autostart     = "false"
 *         window        = "winLogin"
 *         fail-state    = "stFail"
 *         error-state   = "stError"
 *         login-state   = "stIdle"
 *         logout-state  = "stLoggedOut"
 *         waiting-state = "stLoggingIn" />
 *   </a:appsettings>
 *   <a:teleport>
 *       <a:rpc id="comm" protocol="cgi">
 *           <a:method name="login" url="http://localhost/login.php">
 *               <a:variable name="username" />
 *               <a:variable name="password" />
 *           </a:method>
 *           <a:method name="logout" url="http://localhost/logout.php" />
 *       </a:rpc>
 *   </a:teleport>
 *  
 *   <a:state-group
 *     loginMsg.visible  = "false"
 *     winLogin.disabled = "false">
 *       <a:state id="stFail"
 *         loginMsg.value   = "Username or password incorrect"
 *         loginMsg.visible = "true" />
 *       <a:state id="stError"
 *         loginMsg.value   = "An error has occurred. Please check your network."
 *         loginMsg.visible = "true" />
 *       <a:state id="stLoggingIn"
 *         loginMsg.value    = "Please wait whilst logging in..."
 *         loginMsg.visible  = "true"
 *         winLogin.disabled = "true"
 *         btnLogout.visible = "false" />
 *       <a:state id="stIdle"
 *         btnLogout.visible = "true" />
 *       <a:state id="stLoggedOut"
 *         btnLogout.visible = "false"
 *         loginMsg.visible  = "false"
 *         winLogin.disabled = "false" />
 *  </a:state-group>
 * 
 *  <a:window id="winLogin" visible="true" width="400" height="400">
 *      <a:label>Username</a:label>
 *      <a:textbox type="username" value="Lukasz" />
 *  
 *      <a:label>Password</a:label>
 *      <a:textbox type="password" value="ppp" />
 * 
 *      <a:label id="loginMsg" />
 *      <a:button action="login">Log in</a:button>
 *  </a:window>
 *  <a:button id="btnLogout" visible="false" action="logout">Log out</a:button>
 * </code>
 * Example:
 * This example shows a label using property binding to get it's caption
 * based on the current state.
 * <code>
 *  <a:state group="stRole" id="stUser" caption="You are a user" active="true" />
 *  <a:state group="stRole" id="stAdmin" caption="You have super powers" />
 *
 *  <a:label value="{stRole.caption}" />
 *  <a:button onclick="stAdmin.activate()">Become admin</a:button>
 * </code>
 *
 * @event change Fires when the active property of this element changes.
 *
 * @constructor
 * @define state
 * @addnode global
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.9
 */
apf.state = function(struct, tagName){
    this.$init(tagName || "state", apf.NODE_HIDDEN, struct);
    
    this.$signalElements = [];
    this.$groupAdded     = {};
    this.$locationAdded  = '';
};

(function(){
    /**** Properties and Attributes ****/

    this.$supportedProperties.push("active");

    /**
     * @attribute {Boolean} active whether this state is the active state
     */
    this.$propHandlers["active"] = function(value){
        //Activate State
        if (apf.isTrue(value)) {
            if (this.group) {
                var nodes = apf.StateServer.groups[this.group];
                if (!nodes) {
                    apf.StateServer.addGroup(this.group, this);
                    nodes = apf.StateServer.groups[this.group];
                }
                
                for (var i = 0; i < nodes.length; i++) {
                    if (nodes[i] != this && nodes[i].active !== false)
                        nodes[i].deactivate();
                }
            }

            var q = this.$signalElements;
            for (var i = 0; i < q.length; i++) {
                if (!self[q[i][0]] || !self[q[i][0]].setProperty) {
                    
                    throw new Error(apf.formatErrorString(1013, this,
                        "Setting State",
                        "Could not find object to give state: '"
                        + q[i][0] + "' on property '" + q[i][1] + "'"));
                    
                    
                    continue;
                }

                self[q[i][0]].setProperty(q[i][1], this[q[i].join(".")]);
            }

            if (this.group) {
                var attr = this.attributes;
                for (var i = 0; i < attr.length; i++) {
                    if (attr[i].nodeName.match(/^on|^(?:group|id)$|^.*\..*$/))
                        continue;
                    self[this.group].setProperty(attr[i].nodeName,
                        attr[i].nodeValue);
                }
                apf.StateServer.groups[this.group].pState.dispatchEvent("change");
            }

            this.dispatchEvent("change");

            
            apf.console.info("Setting state '" + this.name + "' to ACTIVE");
            
        }

        //Deactivate State
        else {
            this.setProperty("active", false);
            this.dispatchEvent("change");

            
            apf.console.info("Setting state '" + this.name + "' to INACTIVE");
            
        }
    };


    /**** Public methods ****/

    

    /**
     * Sets the value of this element. This should be one of the values
     * specified in the values attribute.
     * @param {String} value the new value of this element
     */
    this.setValue = function(value){
        this.active = 9999;
        this.setProperty("active", value, false, true);
    };

    /**
     * Actives this state, setting all the properties on the elements that
     * were specified.
     */
    this.activate = function(){
        this.active = 9999;
        this.setProperty("active", true, false, true);
    };

    /**
     * Deactivates the state of this element. This is mostly a way to let all
     * elements that have property bound to this state know it is no longer
     * active.
     */
    this.deactivate = function(){
        this.setProperty("active", false, false, true);
    };
    
    

    /**** Init ****/

    this.$propHandlers["group"] = function(value){  
        if (value) {
            apf.StateServer.addGroup(value, this);
            this.$groupAdded = {'value' : value, elState : this};
        }
        else {
            apf.StateServer.removeGroup(this.$groupAdded.value, this.$groupAdded.elState);
            this.$groupAdded     = {};
        }
    }

    this.$propHandlers["location"] = function(value){
        if (value) {
            apf.StateServer.locs[value] = this;
            this.$locationAdded = value;
        }
        else {
            delete apf.StateServer.locs[this.$locationAdded];
            this.$locationAdded = '';
        }
    }
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        apf.StateServer.addState(this);

        //Properties initialization
        var attr = this.attributes;
        for (var s, i = 0; i < attr.length; i++) {
            s = attr[i].nodeName.split(".");
            if (s.length == 2)
                this.$signalElements.push(s);
        }
    });

    this.addEventListener("DOMNodeRemovedFromDocument", function(){
        this.$signalElements = null;
        apf.StateServer.removeState(this);
        if (this.group)
            apf.StateServer.removeGroup(this.group, this);
    });
}).call(apf.state.prototype = new apf.AmlElement());

apf.aml.setElement("state", apf.state);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/checkbox.js)SIZE(7215)TIME(1264692894)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */





/**
 * Element displaying a clickable rectangle having two states which
 * can be toggled by user interaction.
 * Example:
 * <code>
 *  <a:checkbox values="full|empty">the glass is full</a:checkbox>
 * </code>
 *
 * @constructor
 *
 * @define checkbox
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @inherits apf.BaseButton
 * @inherits apf.XForms
 *
 * @binding value  Determines the way the value for the element is retrieved 
 * from the bound data.
 * Example:
 * Sets the value of the checkbox based on data loaded into this component.
 * <code>
 *  <a:model id="mdlCheckbox">
 *      <data answer="Something"></data>
 *  </a:model>
 *  <a:checkbox 
 *    model = "mdlCheckbox" 
 *    value = "[@answer]">Caption</a:checkbox>
 * </code>
 * Example:
 * A shorter way to write this is:
 * <code>
 *  <a:model id="mdlCheckbox">
 *      <data answer="Something"></data>
 *  </a:model>
 *  <a:checkbox value="[mdlCheckbox::@answer]">Caption</a:checkbox>
 * </code>
 */
apf.checkbox = function(struct, tagName){
    this.$init(tagName || "checkbox", apf.NODE_VISIBLE, struct);
};

(function() {
    this.implement(
        
        
        apf.DataAction
        
    );

    //Options
    this.$notfromext = true;
    this.$focussable = true; // This object can get the focus
    this.checked     = false;
    this.$values     = [1, 0]

    /**** Properties and Attributes ****/

    this.$booleanProperties["checked"] = true;
    this.$supportedProperties.push("value", "checked", "label", "values");

    /**
     * @attribute {String}  value    the value of this element.
     */
    this.$propHandlers["value"] = function(value){
        value = (typeof value == "string" ? value.trim() : value);

        this.checked = (value !== undefined
            && value.toString() == this.$values[0].toString());

        if (value !== null && value.toString() == this.$values[0].toString())
            apf.setStyleClass(this.$ext, this.$baseCSSname + "Checked");
        else
            apf.setStyleClass(this.$ext, "", [this.$baseCSSname + "Checked"]);
    };

    /**
     * @attribute {Boolean} checked  whether the element is in the checked state.
     */
    this.$propHandlers["checked"] = function(value) {
        if (!this.$values) {
            if (this.getAttribute("values"))
                this.$propHandler["values"].call(this, this.getAttribute("values"));
            else
                this.$values = [false, true];
        }
        this.setProperty("value", this.$values[value ? 0 : 1]);
    };

    /**
     * @attribute {String}  label    the caption of the label explaining what
     * the meaning of the checked state of this element is.
     */
    this.$propHandlers["label"] = function(value){
        if (!this.$ext)
            return;

        apf.setNodeValue(
            this.$getLayoutNode("main", "label", this.$ext), value);
    };

    /**
     * @attribute {String}  values   a pipe seperated list of two values which
     * correspond to the two states of the checkbox. The first for the checked
     * state, the second for the unchecked state. Defaults to "true|false".
     */
    this.$propHandlers["values"] = function(value){
        this.$values = typeof value == "string"
            ? value.split("\|")
            : (value || [1, 0]);
    };

    /**** Public Methods ****/

    

    /**
     * Sets the value of this element. This should be one of the values
     * specified in the values attribute.
     * @param {String} value the new value of this element
     */
    this.setValue = function(value){
        if (!this.$values) return;
        this.setProperty("value", value, false, true);
    };

    /**
     * Returns the current value
     */
    this.getValue = function(){
        return this.xmlRoot ? this.$values[this.checked ? 0 : 1] : this.value;
    };

    /**
     * Sets the checked state and related value
     */
    this.check = function(){
        this.setProperty("value", this.$values[0], false, true);
    };

    /**
     * Sets the unchecked state and related value
     */
    this.uncheck = function(){
        this.setProperty("value", this.$values[1], false, true);
    };
    
    

    /**** Private state handling methods ****/

    this.addEventListener("$clear", function(){
        this.setProperty("value", this.$values[1]);
    });

    this.$enable = function(){
        if (this.$int) this.$int.disabled = false;
        this.$doBgSwitch(1);
    };

    this.$disable = function(){
        if (this.$int) this.$int.disabled = true;
        this.$doBgSwitch(4);
    };

    this.$setState = function(state, e, strEvent){
        if (this.disabled) return;

        this.$doBgSwitch(this.states[state]);
        this.$setStyleClass(this.$ext, (state != "Out" ? this.$baseCSSname + state : ""),
            [this.$baseCSSname + "Down", this.$baseCSSname + "Over"]);
        this.state = state; // Store the current state so we can check on it coming here again.

        this.dispatchEvent(strEvent, e);

        /*if (state == "Down")
            apf.cancelBubble(e, this);
        else
            e.cancelBubble = true;*/
    };

    this.$clickHandler = function(){
        //this.checked = !this.checked;
        this.change(this.$values[(!this.checked) ? 0 : 1]);

        
        if (this.validate) //@todo rewrite button
            this.validate(true);
        

        return true;
    };

    /**** Init ****/

    this.$draw = function(){
        //Build Main Skin
        this.$ext = this.$getExternal();
        this.$int = this.$getLayoutNode("main", "input", this.$ext);

        this.$setupEvents();
    };

    this.$childProperty = "label";

    
    this.addEventListener("$skinchange", function(){
        if (this.label)
            this.$propHandlers["label"].call(this, this.label);
    })
    
}).call(apf.checkbox.prototype = new apf.BaseButton());

apf.aml.setElement("checkbox", apf.checkbox);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/application.js)SIZE(1838)TIME(1258118723)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @todo description
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.application = function(){
    this.$init("application", apf.NODE_HIDDEN);
    
    if (!apf.isO3) {    
        this.$int        = document.body;
        this.$tabList    = []; //Prevents documentElement from being focussed
        this.$focussable = apf.KEYBOARD;
        this.focussable  = true;
        this.visible     = true;
        this.$isWindowContainer = true;
        this.focus = function(){ this.dispatchEvent("focus"); };
        this.blur  = function(){ this.dispatchEvent("blur"); };
    
        
        apf.window.$addFocus(this);
        
    }
};
apf.application.prototype = new apf.AmlElement();
apf.aml.setElement("application", apf.application);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/img.js)SIZE(7359)TIME(1260814793)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Element displaying a picture. This element can read databound resources.
 * Example:
 * This example shows a list with pictures. When one is selected its displayed
 * in the img element.
 * <code>
 *  <a:model id="mdlPictures"> 
 *      <pictures> 
 *          <picture title="Landscape" src="slideshow_img/landscape.jpg" />
 *          <picture title="Animal" src="http://example.com/animal.jpg" />
 *          <picture title="River" src="http://example.com/river.jpg" />
 *      </pictures> 
 *  </a:model>
 *  <a:list 
 *    id     = "lstPics" 
 *    skin   = "thumbnail" 
 *    height = "200" 
 *    width  = "400" 
 *    model  = "mdlPictures">
 *      <a:each match = "[picture]" >
 *          <a:name match="[@title]" />
 *          <a:image match="[@src]" />
 *      </a:each>
 *  </a:list>
 *  <a:img 
 *    model  = "{lstPics.selected}" 
 *    value  = "[@src]" 
 *    width  = "200" 
 *    height = "200" />
 * </code>
 *
 * @constructor
 * @define img
 * @allowchild {smartbinding}
 * @addnode elements
 *
 * @inherits apf.BaseSimple
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @event click Fires when a user presses a mouse button while over this element.
 *
 * @binding value  Determines the way the value for the element is retrieved 
 * from the bound data.
 * Example:
 * Sets the image source based on data loaded into this component.
 * <code>
 *  <a:img>
 *      <a:bindings>
 *          <a:value match="[@src]" />
 *      </a:bindings>
 *  </a:img>
 * </code>
 * Example:
 * A shorter way to write this is:
 * <code>
 *  <a:model id="mdlPictures"> 
 *      <data src="path/to/image.jpg" /> 
 *  </a:model>
 *  <a:img 
 *    model  = "mdlPictures" 
 *    value  = "[@src]" 
 *    width  = "300" 
 *    height = "300" />
 * </code>
 */
apf.img = function(struct, tagName){
    this.$init(tagName || "img", apf.NODE_VISIBLE, struct);
};

apf.preview = function(struct, tagName){
    this.$init(tagName || "preview", apf.NODE_VISIBLE, struct);
};

(function(){
    
    
    /**
     * Sets the value of this element. This should be one of the values
     * specified in the values attribute.
     * @param {String} value the new value of this element
     */
    this.setValue = function(value){
        this.setProperty("value", value, false, true);
    };
    
    /**
     * Returns the current value of this element.
     * @return {String}
     */
    this.getValue = function(value){
        return this.value;
    };
    
    
    
    this.$supportedProperties.push("value", "src");
    /**
     * @attribute {String} value the url location of the image displayed.
     */
    this.$propHandlers["src"] = 
    this.$propHandlers["value"] = function(value){
        if (this.oImage.nodeType == 1)
            this.oImage.style.backgroundImage = "url(" + value + ")";
        else
            this.oImage.nodeValue = value;
        
        //@todo resize should become a generic thing
        if (this.oImage.nodeType == 2 && !this.$resize.done) {
            if (this.oImg) {
                
                //@todo add this to $destroy
                var pNode = apf.hasSingleRszEvent ? this.$pHtmlNode : this.$ext;
                apf.layout.setRules(pNode, this.$uniqueId + "_image",
                    "var o = apf.all[" + this.$uniqueId + "];\
                     if (o) o.$resize()");
                apf.layout.queue(pNode);
                
                this.oImg.onload = function(){
                    apf.layout.forceResize(pNode);
                }
                
            }
            
            this.$resize.done = true;
        }

        if (this.oImg) {
            this.oImg.style.display = value ? "block" : "none";
            
            //RLD: disabled lines below for the preview element. the image is probably not loaded yet.
            //if (value)
                //this.$resize();
        }
    };
    
    this.addEventListener("$clear", function(){
        this.value = "";
        
        if (this.oImg)
            this.oImg.style.display = "none";
    });
    
    /**** Init ****/
    
    this.$draw = function(){
        //Build Main Skin
        this.$int = this.$ext = this.$getExternal();
        this.$ext.onclick = function(e){
            this.host.dispatchEvent("click", {htmlEvent: e || event});
        };
        this.oImage = this.$getLayoutNode("main", "image", this.$ext);
        this.oImg   = this.$int.getElementsByTagName("img")[0];
        if (this.localName == "preview") {
            var _self = this;
            this.$int.onclick = function() {
                if (!_self.sPreview) return;
                _self.$int.innerHTML = _self.sPreview;
                this.onclick = null;
            };
        }
    };

    this.addEventListener("DOMNodeInsertedIntoDocument", function() {
        var node,
            val   = "",
            i     = this.childNodes.length;

        for (; i >= 0; --i) {
            if ((node = this.childNodes[i]) && node.nodeName
              && node.nodeName == "#cdata-section") {
                val = node.nodeValue;
                node.removeNode();
            }
        }

        this.sPreview = val;
    });
    
    this.$resize = function(){
        var diff = apf.getDiff(this.$ext);
        var wratio = 1, hratio = 1;
        
        this.oImg.style.width = "";
        this.oImg.style.height = "";
        
        if (this.oImg.offsetWidth > this.$ext.offsetWidth)
            wratio = this.oImg.offsetWidth / (this.$ext.offsetWidth - diff[0]);
        if (this.oImg.offsetHeight > this.$ext.offsetHeight)
            hratio = this.oImg.offsetHeight / (this.$ext.offsetHeight - diff[1]);

        if (wratio > hratio && wratio > 1)
            this.oImg.style.width = "100%";
        else if (hratio > wratio && hratio > 1)
            this.oImg.style.height = "100%";
        
        this.oImg.style.top = ((this.$ext.offsetHeight - apf.getHeightDiff(this.$ext) 
            - this.oImg.offsetHeight) / 2) + "px";
    }
}).call(apf.img.prototype = new apf.BaseSimple());

apf.preview.prototype = apf.img.prototype;

apf.aml.setElement("img", apf.img);
apf.aml.setElement("preview", apf.preview);

apf.aml.setElement("name", apf.BindingRule);
apf.aml.setElement("image", apf.BindingRule);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/loader.js)SIZE(2115)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @todo description
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.loader = function(){
    this.$init("loader", apf.NODE_HIDDEN);
    
    this.show = function(){
        this.$ext.style.display = "block";
    }
    
    this.hide = function(){
        this.$ext.style.display = "none";
    }
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var pHtmlNode;
        if (!(pHtmlNode = this.parentNode.$int)) 
            return;

        this.$ext = apf.insertHtmlNode(null, pHtmlNode, null, this.$aml 
            ? (this.$aml.serialize ? this.$aml.serialize() : this.$aml.xml)
            : this.serialize());
        
        if (!apf.loaded) {
            var _self = this;
            apf.addEventListener("load", function(){
                if (apf.config.autoHideLoading) {
                    apf.queue.empty();
                    _self.hide();
                }
            });
        }
    });
};

apf.loader.prototype = new apf.AmlElement();

apf.aml.setElement("loader", apf.loader);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/body.js)SIZE(1865)TIME(1259708672)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @todo description
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 */


apf.body = function(){
    this.$init("body", apf.NODE_VISIBLE);
};


apf.AmlConfig = function(){
    this.$init("config", apf.NODE_VISIBLE);
};

(function(){
    this.focussable = false;
    this.$canLeechSkin = true;
    
    this.$draw = function(){
        //Build Main Skin
        this.$ext = this.$int = this.$getExternal(this.$isLeechingSkin
            ? this.localName 
            : "main");
    };

}).call(apf.body.prototype = new apf.Presentation());
apf.AmlConfig.prototype = apf.body.prototype;
apf.aml.setElement("body", apf.body);

apf.aml.setElement("config", apf.AmlConfig);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/state-group.js)SIZE(3135)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Element that groups state elements together and
 * provides a way to set a default state.
 * Example:
 * <code>
 *  <a:state-group
 *    loginMsg.visible  = "false"
 *    winLogin.disabled = "false">
 *      <a:state id="stFail"
 *          loginMsg.value   = "Username or password incorrect"
 *          loginMsg.visible = "true" />
 *      <a:state id="stError"
 *          loginMsg.value   = "An error has occurred. Please check your network."
 *          loginMsg.visible = "true" />
 *      <a:state id="stLoggingIn"
 *          loginMsg.value    = "Please wait while logging in..."
 *          loginMsg.visible  = "true"
 *          winLogin.disabled = "true" />
 *      <a:state id="stIdle" />
 *  </a:state-group>
 * </code>
 * @addnode elements
 * @see element.state
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.stateGroup = function(){
    this.$init("state-group", apf.NODE_HIDDEN);
};
apf.aml.setElement("state-group", apf.stateGroup);

(function(){
    this.$handlePropSet = function(prop, value, force){
        if (prop == "id")
            return;
        
        var node, nodes = this.childNodes;
        for (var i = 0, l = nodes.length; i < l; i++){
            node = nodes[i];
        
            if (node.nodeType != 1 || node.localName != "state")
                continue;

            if (!node[prop] || node.$inheritProperties[prop] == 2) {
                node.$inheritProperties[prop] = 2;
                node.setProperty(prop, value);
            }
        }
    };
    
    //@todo this should use text node insertion
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (!this.id)
            this.id = "stategroup" + this.$uniqueId;
        
        //apf.StateServer.addGroup(this.id, null, this.parentNode); //@todo rearch this
        
        var nodes = this.childNodes;
        for (var i = 0, l = nodes.length; i < l; i++){
            nodes[i].setProperty("group", this.id);
        }
    });
}).call(apf.stateGroup.prototype = new apf.AmlElement());




/*FILEHEAD(/var/lib/platform/source/trunk/elements/bindings.js)SIZE(7886)TIME(1264618245)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @define bindings element containing all the binding rules for the data 
 * bound elements referencing this element.
 * Example:
 * <code>
 *  <a:model id="mdlList">
 *      <data>
 *          <item date="2009-11-12" deleted="0"></item>
 *          <item date="2009-11-11" deleted="0"></item>
 *      </data>
 *  </a:model>
 *  <a:bindings id="bndFolders" >
 *      <a:caption match="[@date]" />
 *      <a:icon match="[@icon]" />
 *      <a:each match="[item]" sort="[@date]" />
 *  </a:bindings>
 *  <a:list 
 *    id       = "list" 
 *    width    = "200" 
 *    height   = "200" 
 *    model    = "mdlList" 
 *    bindings = "bndFolders" />
 * </code>
 * @see element.smartbinding
 *
 * @constructor
 * @apfclass
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 *
 * @default_private
 */
apf.bindings = function(struct, tagName){
    this.$init(tagName || "bindings", apf.NODE_HIDDEN, struct);
    
    this.$bindings = new apf.ruleList();
    this.$amlNodes = {};
};

(function(){
    this.$smartbinding = null;

    this.register = function(amlNode){
        if (amlNode.localName == "smartbinding") {
            this.$smartbinding = amlNode;
            this.$smartbinding.add(this); //Assuming only at init
            return;
        }
        
        if (!amlNode.hasFeature(apf.__DATABINDING__))
            return;

        this.$amlNodes[amlNode.$uniqueId] = amlNode;
        
        if (!this.$amlLoaded)
            return;

        if (!this.$bindings.$isCompiled)
            this.$cbindings = this.$bindings.compile();
        
        amlNode.$bindings  = this.$bindings;
        amlNode.$cbindings = this.$cbindings;
        
        //@todo apf3.0 should be deprecated
        amlNode.dispatchEvent("bindingsload", {
            bindings: this.$bindings, 
            compiled: this.$cbindings
        });
        this.dispatchEvent("noderegister", {
            amlNode: amlNode
        });
        amlNode.$checkLoadQueue();
    };

    this.unregister = function(){
        //unregister element
        this.$amlNodes[this.amlNode.$uniqueId] = null;
        delete this.$amlNodes[this.amlNode.$uniqueId];
        
        this.amlNode.$bindings  = 
        this.amlNode.$cbindings = false;
        
        this.amlNode.dispatchEvent("bindingsunload", {
            bindings: this.$bindings, 
            compiled: this.$cbindings
        });
    };
    
    this.reload = function(){
        for (var id in this.$amlNodes){
            this.$amlNodes[id].reload();
        }
    }
    
    /**** DOM Handlers ****/
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var nodes = this.childNodes;
        for (var node, i = 0, l = nodes.length; i < l; i++) {
            if (!(node = nodes[i]).$amlLoaded && node.nodeType == 1)
                node.dispatchEvent("DOMNodeInsertedIntoDocument"); //{relatedParent : nodes[j].parentNode}
        }
        
        this.register(this.parentNode);
        
        for (var id in this.$amlNodes)
            this.register(this.$amlNodes[id]);
    });
}).call(apf.bindings.prototype = new apf.AmlElement());

apf.ruleList = function(){
    this.$compiled = {};
}
apf.ruleList.prototype = {
    $isCompiled : false,
    
    getRule : function(name, xmlNode){
        var rules = this[name];
        if (!rules) return false;
        
        //@todo Shouldn't allow async calls..., should always give a function
        for (var func, rule, i = 0, l = rules.length; i < l; i++) {
            rule = rules[i];
            if (!rule.match) 
                return rule;

            func = rule.cmatch || rule.compile("match", {injectself: true, xpathmode: 2});
            if (func && func(xmlNode))
                return rule;
        }
    },
    
    compile : function(name){
        var rules, s, c = this.$compiled;

        if (name) {
            s     = [];
            rules = this[name];
            for (var rule, i = 0, l = rules.length; i < l; i++) {
                if (!(rule = rules[i]).match && !rule.value)
                    continue;

                s.push(rule.match, rule.value);
            }
            
            //always give a function, no async calls (could also just error on execution)
            c[name] = apf.lm.compileMatch(s); 
            
            return c;
        }
        
        for (name in this) {
            if (name == "each")
                continue;
            
            rules = this[name];
            if (rules.dataType != apf.ARRAY)
                continue;
            
            s = [];
            for (var rule, i = 0, l = rules.length; i < l; i++) {
                if (!(rule = rules[i]).match && !rule.value)
                    continue;

                s.push(rule.match, rule.value);
            }
            
            //always give a function, no async calls (could also just error on execution)
            c[name] = apf.lm.compileMatch(s); 
        }

        this.$isCompiled = true;
        
        return c;
    },
    
    getRuleIndex : function(name, index) {
        var rule = this[name][index];
        if (rule.value) {
            if (!rule.cvalue)
                rule.compile("value");
        }
        else if (rule.match) {
            if (!rule.cmatch)
                rule.compile("match");
        }
        return rule;
    },
    
    getDataNode : function(name, xmlNode, createNode, ruleList, multiple){
        var i, l, func, node, rule, rules = this[name];
        if (!rules)
            return;
        
        //@todo Shouldn't allow async calls..., should always give a function
        for (rule, i = 0, l = rules.length; i < l; i++) {
            rule = rules[i];
            
            func = rule.cvaluematch;
            if (!func) { //@todo apf3.0 cleanup
                if (rule.match && rule.value)
                    rule.valuematch = "{_n = " + rule.match + "; %[child::" 
                        + rule.value.substr(1, rule.value.length - 2)
                            .split("|").join("|child::") + "]}";
                else
                    rule.valuematch = rule.match || rule.value;
                
                func = rule.$compile("valuematch", {
                    xpathmode  : multiple ? 4 : 3, 
                    injectself : rule.match ? true : false
                });
            }
            
            if (func && (node = func(xmlNode, createNode))) {
                if (ruleList)
                    ruleList.push(rule);

                return node;
            }
        }
        
        return false;
    }
}

apf.aml.setElement("bindings", apf.bindings);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/viewport.js)SIZE(1800)TIME(1263921894)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element that helps Ajax.org GWT specifying a render area.
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.viewport = function(struct, tagName){
    this.$init(tagName || "viewport", apf.NODE_VISIBLE, struct);
    
    if (document.documentElement)
        this.$ext = this.$int = document.documentElement.appendChild(document.createElement("div"));
};

(function(){
    this.$focussable = false;
    
    this.$draw = function(){
        if (!this.$ext)
            this.$ext = this.$int = document.documentElement.appendChild(document.createElement("div"));
    };

    this.$loadAml = function(x){
        
    };
    
}).call(apf.viewport.prototype = new apf.AmlElement());

apf.aml.setElement("viewport", apf.viewport);





/*FILEHEAD(/var/lib/platform/source/trunk/elements/appsettings.js)SIZE(9186)TIME(1263340865)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element specifying the settings of the application.
 * @define appsettings
 * @addnode global
 * @attribute {Boolean} debug                   whether the debug screen is shown at startup.
 * @see core.apf.object.debugwin
 * @see core.apf.object.console
 * @attribute {Boolean} debug-teleport          whether teleport messages are displayed in the log.
 * @attribute {String}  name                    the name of the application, used by many different services to uniquely identify the application.
 * @attribute {Boolean} disable-right-click     whether a user can get the browsers contextmenu when the right mouse button is clicked.
 * @see element.contextmenu
 * @attribute {Boolean} allow-select            whether general text in the application can be selected.
 * @attribute {Boolean} allow-blur              whether it's possible to blur an element while not giving the focus to another element. Defaults to true.
 * @attribute {Boolean} auto-disable-actions    whether smartbinding actions are by default disabled.
 * @see term.action
 * @attribute {Boolean} auto-disable            whether elements that don't have content loaded are automatically disabled.
 * @attribute {Boolean} disable-f5              whether the F5 key for refreshing is disabled.
 * @attribute {Boolean} auto-hide-loading       whether the load screen defined by the loader element is automatically hidden. Setting this to false enables you to control when the loading screen is hidden. Use the following code to do so:
 * <code>
 *  apf.document.getElementsByTagName("a:loader")[0].hide()
 *  //or
 *  loaderId.hide()
 * </code>
 * @attribute {Boolean} disable-space           whether the space button default behaviour of scrolling the page is disabled.
 * @attribute {Boolean} disable-backspace       whether the backspace button default behaviour of going to the previous history state is disabled.
 * @attribute {String}  default-page            the name of the default page if none is specified using the #. Defaults to "home". See {object.history}.
 * @see element.history
 * @attribute {Boolean} undokeys                whether the undo and redo keys (in windows they are ctrl-Z and ctrl-Y) are enabled.
 * @see element.actiontracker
 * @attribute {String, Boolean} outline         whether an outline of an element is shown while dragging or resizing.
 * @see baseclass.interactive
 * @attribute {String, Boolean} drag-outline    whether an outline of an element is shown while dragging.
 * @see baseclass.interactive
 * @attribute {String, Boolean} resize-outline  whether an outline of an element is shown while resizing.
 * @see baseclass.interactive
 * @attribute {String}  layout                  the {@link term.datainstruction data instruction} to retrieve the layout xml definition.
 * @see core.layout
 * @attribute {String}  baseurl                 the basepath for any relative url used throughout your application. This included teleport definitions and {@link term.datainstruction data instruction}.
 * @see teleport.http
 * @see term.datainstruction
 * @attribute {String}  loading-message         the global value for the loading message of elements during a loading state.
 * @see baseclass.databinding.attribute.loading-message
 * @attribute {String}  offline-message         the global value for the offline message of elements not able to display content while offline.
 * @see baseclass.databinding.attribute.offline-message
 * @attribute {String}  empty-message           the global value for the empty message of elements containing no contents.
 * @see baseclass.databinding.attribute.empty-message
 * @attribute {String}  model                   the default model for this application.
 * @see element.model
 * @attribute {String}  realtime                the global value whether bound values are realtime updated. When set to false elements do not update until they lose focus.
 * @see element.editor.attribute.realtime
 * @see element.textbox.attribute.realtime
 * @see element.slider.attribute.realtime
 * @attribute {String}  skinset                 the skin set used by the application.
 * @see baseclass.presentation.attribute.skinset
 * @attribute {String}  storage                 the {@link core.storage storage provider} to be used for key/value storage.
 * @see core.storage
 * @attribute {String}  offline                 the {@link core.storage storage provider} to be used for offline support.
 * @see element.offline
 * @attribute {String}  login                   the {@link term.datainstruction data instruction} which logs a user into the application.
 * @see element.auth
 * @attribute {String}  logout                  the {@link term.datainstruction data instruction} which logs a user out of the application.
 * @see element.auth
 * @attribute {String}  iepngfix                whether the fix for PNG images with transparency should be applied. Default is false.
 * @attribute {String}  iepngfix-elements       a comma-seperated list of CSS identifiers (classes) to which the transparent-PNG fix will be applied.
 * @attribute {Boolean} iphone-fullscreen       whether the application should cover the entire screen of the iPhone. Default is true.
 * @attribute {String}  iphone-statusbar        the style of the statusbar of the iPhone webbrowser. Posssible values: 'default', black-translucent' or 'black'.
 * @attribute {String}  iphone-icon             path pointing to the icon that should be used when this application is put on the iPhone Dashboard.
 * @attribute {Boolean} iphone-icon-is-glossy   whether the icon specified with 'iphone-icon' already is glossy or if the iPhone OS should apply that effect. Default is false.
 * @attribute {Boolean} iphone-fixed-viewport   whether the viewport of the application is fixed and whether the zoom should be enabled. Default is true.
 * @allowchild auth, authentication, offline, printer, defaults
 * @todo describe defaults
 */
apf.appsettings = function(struct, tagName){
    this.$init(tagName || "appsettings", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$parsePrio = "001";
    
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = {
        language : 1,
        login    : 1,
        logout   : 1,
        layout   : 1
    };
    
    this.$supportedProperties = ["debug", "name", "baseurl", "resource-path", 
        "disable-right-click", "allow-select", "allow-blur", 
        "auto-disable-actions", "auto-disable", "disable-f5", 
        "auto-hide-loading", "disable-space", "disable-backspace", "undokeys", 
        "initdelay", "default-page", "query-append", "outline", "drag-outline", 
        "resize-outline", "resize-outline", "iepngfix", "iepngfix-elements", 
        "iphone-fullscreen", "iphone-statusbar", "iphone-icon", 
        "iphone-icon-is-glossy", "iphone-fixed-viewport", "layout", "skinset", 
        "language", "storage", "offline", "login"];
    this.$booleanProperties = {
        "debug":1,
        "disable-right-click":1,
        "allow-select":1,
        "allow-blur":1,
        "auto-disable-actions":1,
        "auto-disable":1,
        "disable-f5":1,
        "auto-hide-loading":1,
        "disable-space":1,
        "disable-backspace":1,
        "undokeys":1,
        "initdelay":1,
        "outline":1,
        "iepngfix":1,
        "iphone-fullscreen":1,
        "iphone-icon-is-glossy":1, 
        "iphone-fixed-viewport":1
    };
    
    this.$handlePropSet = function(prop, value, force){
        if (this.$booleanProperties[prop])
            value = apf.isTrue(value);

        this[prop] = value;

        apf.config.setProperty(prop, value);
    };
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        
        if (apf.isIphone && apf.runIphone) {
            //@todo apf3.0 mike please error check all the settings
            
            apf.runIphone();
            delete apf.runIphone;
        }
        
    });
}).call(apf.appsettings.prototype = new apf.AmlElement());

apf.aml.setElement("appsettings", apf.appsettings);


/*FILEHEAD(/var/lib/platform/source/trunk/elements/bindingcolorrule.js)SIZE(2906)TIME(1258118723)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @todo docs
 */
apf.BindingColorRule = function(struct, tagName){
    this.$init(tagName, apf.NODE_HIDDEN, struct);
};

(function(){
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        //@todo This should support multiple color rules, by inserting the rules at the right place.
        if (this.$bindings && this.$bindings.color) {
            var clr = this.$bindings.color[0];
            apf.setStyleRule("." + this.$baseCSSname + (apf.isIE
                ? " .records .highlight SPAN"
                : " .records .highlight span"), "color", clr.getAttribute("text"), null, this.oWin);
            apf.setStyleRule("." + this.$baseCSSname + (apf.isIE
                ? " .records .highlight SPAN"
                : " .records .highlight span"), "backgroundColor", clr.getAttribute("row"), null, this.oWin);
            apf.setStyleRule("." + this.$baseCSSname + (apf.isIE
                ? " .records .highlight"
                : " .records .highlight"), "backgroundColor", clr.getAttribute("row"), null, this.oWin);
            /*apf.importCssString("." + this.$baseCSSname + " .records div.highlight{background-color:" 
                + clr.getAttribute("row") + ";} ." 
                + this.$baseCSSname + " .records div.highlight span{color:" 
                + clr.getAttribute("text") + ";}");*/
        }
        
        //"." + this.$baseCSSname + " .headings 
        apf.importStylesheet([
          ["." + this.className,
            "width:" + this.$width + (this.$isPercentage ? "%;" : "px;")
            + "text-align:" + h.align],
          ["." + this.className,
            "width:" + this.$width + (this.$isPercentage ? "%;" : "px;")
            + "text-align:" + h.align]
        ]);
        
        this.$draw();
    });
}).call(apf.BindingColorRule.prototype = new apf.BindingRule());

apf.aml.setElement("color", apf.BindingColorRule);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/rpc.js)SIZE(15179)TIME(1264464063)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Baseclass for rpc in teleport. Modules are available for
 * {@link teleport.soap SOAP}, {@link teleport.xmlrpc XML-RPC}, 
 * {@link teleport.cgi CGI}, {@link teleport.jsonrpc JSON-RPC} 
 * and several proprietary protocols.
 * Example:
 * This example shows an rpc element using the xmlrpc protocol. It contains
 * two methods which can be called. The return of the first method is handled
 * by a javascript function called processSearch.
 * <code>
 *  <a:rpc id="comm" protocol="xmlrpc">
 *      <a:method
 *        name    = "searchProduct"
 *        receive = "processSearch" />
 *      <a:method
 *        name = "loadProduct" />
 *  </a:rpc>
 *
 *  <a:script>
 *      //This function is called when the search returns
 *      function processSearch(data, state, extra){
 *          alert(data)
 *      }
 *
 *      //Execute a search for the product car
 *      comm.searchProduct('car', 10);
 *  </a:script>
 * </code>
 *
 * @attribute {String}  protocol         the name of the plugin that is used
 *                                       to provide the messages.
 * @attribute {Boolean} [multicall]      whether the call is stacked until
 *                                       purge() is called.
 * @attribute {String}  [http-method]    the http method used to send the data.
 *                                       This attribute is only used by the cgi protocol.
 *   Possible values:
 *   post   Used to store large chunks of data (on a resource).
 *   get    Used to retrieve data from a resource.
 *   delete Used to delete a resource.
 *   head   Returns only the headers.
 *   put    Used to store data at a resource.
 * @attribute {String}  [method-name]    the variable name used to sent the
 *                                       name of the method called to the
 *                                       server. This attribute is only used
 *                                       by the cgi protocol.
 * @attribute {String}  [soap-xmlns]     the url that uniquely identifies the
 *                                       xml namespace for the message. This
 *                                       attribute is only used by the soap
 *                                       protocol.
 * @attribute {String}  [soap-prefix]    the prefix that is paired with the
 *                                       message xml namespace. This attribute
 *                                       is only used by the soap protocol.
 * @define rpc
 * @allowchild method
 *
 * @constructor
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @author      Mike de Boer (mike AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 * @default_private
 */
apf.rpc = function(struct, tagName){
    this.$init(tagName || "rpc", apf.NODE_HIDDEN, struct);

    if (!this.supportMulticall)
        this.multicall = false;
    this.stack    = {};
    this.urls     = {};
    this.$methods = {};
};

(function(){
    this.useHTTP         = true;
    this.namedArguments  = false;

    this["route-server"] = apf.host + "/cgi-bin/rpcproxy.cgi";
    this.autoroute       = false;

    this.$auth           = false;

    this.$booleanProperties["multicall"] = true;

    this.$supportedProperties.push("protocol", "type", "multicall", "http-method");

    //@todo change this to use prototype
    this.$propHandlers["protocol"] = function(value){
        if (!value)
            return;
        
        if (!apf[value]) {
            
            throw new Error(apf.formatErrorString(1025, null, "Teleport baseclass",
                "Could not find Ajax.org Teleport RPC Component '" + value + "'", this));
            
            return;
        }
        this.implement(apf[value]);
    };

    this.$propHandlers["type"] = function(value) {
        this.$useXml = (typeof value == "string" && value.toUpperCase() == "XML");
    };

    /**
     * Sets the callback for a method on this object.
     * Example:
     * <code>
     *  comm.setCallback("login", function(data, state, extra) {
     *      alert(data);
     *  });
     *
     *  comm.login(user, pass);
     * </code>
     * @param {String}   name the name of the method defined on this object.
     * @param {Function} func the function that is called when the rpc method returns.
     */
    this.setCallback = function(name, func){
        
        if (!this.$methods[name])
            throw new Error(apf.formatErrorString(0, this, "Teleport RPC",
                "Trying to set callback: method not found."));
        
            
        this.$methods[name].callback = func;
    };

    this.$convertArgs = function(name, args){
        if (!this.namedArguments)
            return Array.prototype.slice.call(args);

        var nodes = this.$methods[name].names;
        if (!nodes || !nodes.length)
            return {};

        var value, j, i, l, result = {};
        for (j = 0, i = 0, l = nodes.length; i < l; i++) {
            name  = nodes[i].name;
            value = nodes[i].value;

            if (value) {
                value = apf.parseExpression(value);
            }
            else {
                value = args[j++];

                if (apf.isNot(value) && nodes[i]["default"])
                    value = apf.parseExpression(nodes[i]["default"]);
            }

            //Encode string optionally
            value = apf.isTrue(nodes[i].encoded)
                ? encodeURIComponent(value)
                : value;

            result[name] = value;
        }

        return result;
    };

    this.call = function(name, args, options){
        var callback,
            node = this.$methods[name];
        
        if (typeof args[args.length - 1] == "function") {
            args     = Array.prototype.slice.call(args); //@todo optimize?
            callback = args.pop();
        }
        else {
            callback = (typeof node.callback == "string"
                ? self[node.callback]
                : node.callback) || function(){};
        }

        args = this.$convertArgs(name, args);

        // Set up multicall
        if (this.multicall) {
            if (!this.stack[this.url])
                this.stack[this.url] = this.getMulticallObject
                    ? this.getMulticallObject()
                    : [];

            this.getSingleCall(name, args, this.stack[this.url])
            return true;
        }

        // Get Data
        var _self = this,
            data  = this.createMessage(node["method-name"] || name, args); //function of module

        function pCallback(data, state, extra){
            extra.data = data;

            if (state != apf.SUCCESS)
                callback.call(_self, null, state, extra);
            else if (_self.isValid && !_self.isValid(extra))
                callback.call(_self, null, apf.ERROR, extra);
            else
                callback.call(_self, _self.unserialize(extra.data), state, extra);
        }

        // Send the request
        var auth,
            url  = apf.getAbsolutePath(this.baseurl || apf.config.baseurl, this.url),
            o    = apf.extend({
                callback      : pCallback,
                async         : node.async,
                userdata      : node.userdata,
                nocache       : (this.nocache === false) ? false : true,
                data          : data,
                useXML        : this.$useXml,
                caching       : node.caching,
                ignoreOffline : node["ignore-offline"]
            }, options);

        if (node.auth && this.$auth) {
            if (auth = this.$auth.$credentials) {
                o.username = auth.username;
                o.password = auth.password;
            }
            else {
                return this.$auth.authRequired(function() {
                    auth = _self.$auth.$credentials
                    o.username = auth.username;
                    o.password = auth.password;
                    _self.$get(url, o);
                });
            }
        }

        return this.$get(url, o);
    };

    /**
     * Purge multicalled requests
     */
    this.purge = function(callback, userdata, async, extradata){
        
        if (!this.stack[this.url] || !this.stack[this.url].length) {
            throw new Error(apf.formatErrorString(0, null, "Executing a multicall", 
                "No RPC calls where executed before calling purge()."));
        }
        

        // Get Data
        var data = this.createMessage("multicall", [this.stack[this.url]]), //function of module
            url  = apf.getAbsolutePath(this.baseurl || apf.config.baseurl, this.url);
        if (extradata) {
            for (var vars = [], i = 0; i < extradata.length; i++) {
                vars.push(encodeURIComponent(extradata[i][0]) + "="
                    + encodeURIComponent(extradata[i][1] || ""))
            }
            url = url + (url.match(/\?/) ? "&" : "?") + vars.join("&");
        }

        var info = this.$get(url, {
            callback : callback,
            async    : async,
            userdata : userdata,
            nocache  : true,
            data     : data,
            useXML   : this.$useXml
        });

        this.stack[this.url] = this.getMulticallObject
            ? this.getMulticallObject()
            : [];

        //return info[1];
    };

    this.revert = function(modConst){
        this.stack[modConst.url] = this.getMulticallObject
            ? this.getMulticallObject()
            : [];
    };

    this.getStackLength = function(){
        return this.stack[this.url] ? this.stack[this.url].length : 0;
    };

    /**
     * Loads aml definition
     */
    this.$addMethod = function(amlNode){
        if (amlNode.localName != "method"){
            
            throw new Error(apf.formatErrorString(0, this,
                "Parsing RPC Teleport node",
                "Found element which is not a method", this));
            
            return false;
        }
        
        var name = amlNode.name,
            cb   = amlNode.receive || this.receive,
            i    = 0,
            l    = amlNode.childNodes.length,
            node;

        this[name] = function(){
            return this.call(name, arguments);
        };

        if (cb)
            amlNode.callback = cb;

        this.$methods[name] = amlNode;

        if (!amlNode.names)
            amlNode.names = [];
        for (; i < l; i++) {
            node = amlNode.childNodes[i];
            if (node.localName == "param" || node.localName == "variable") //@todo deprecate variable
                amlNode.names.push(node);
        }

        return true;
    };

    this.$removeMethod = function(amlNode) {
        var name = amlNode.name;
        delete this[name];
        delete this.$methods[name];
    };

    this.$setAuth = function(amlNode) {
        this.$auth = amlNode;
    };

    /*
    this.addEventListener("DOMNodeInserted", function(e){
        var node = e.currentTarget;
        if (node.parentNode != this)
            return;

        this.register(node);
    });

    this.addEventListener("DOMNodeRemoved", function(e){
        var node = e.currentTarget;
        // we support two levels deep:
        if (!(node.parentNode == this || node.parentNode.parentNode == this))
            return;

        this.unregister(node);
    });*/
    
    
    this.exec = function(method, args, callback, options){
        if (!options) options = {};

        //force multicall if needed;
        if (options.multicall)
            this.forceMulticall = true;
    
        //Set information later neeed
        
        if (!this[method])
            throw new Error(apf.formatErrorString(0, null, "Saving/Loading data",
                "Could not find RPC function by name '" + method + "' in data "
              + "instruction '" + options.instruction + "'"));
        
        
        var props = this.$methods[method];

        if (options.userdata)
            props.userdata = options.userdata;
    
        if (!this.multicall)
            props.callback = callback; //&& this[method].async
    
        //Call method
        var retvalue = this.call(method, args, options);
    
        if (this.multicall)
            return this.purge(callback, "&@^%!@"); //Warning!! @todo Make multicall work with offline
        else if (options.multicall) {
            this.forceMulticall = false;
            return this;
        }
    
        
        if (typeof apf.offline != "undefined" && !apf.offline.onLine)
            return;
        
    
        //Call callback for sync calls
        if (!this.multicall && !props.async && callback)
            callback(retvalue, apf.SUCCESS, {tpModule: this});
    };
    

    /*
     * Post a form with ajax
     *
     * @param form     form
     * @param function callback  Called when http result is received
     * /
     this.submitForm = function(form, callback, callName) {
         this.addMethod('postform', callback);
         this.urls['postform'] = form.action;
         var args = [];
         for (var i = 0; i < form.elements.length; i++) {
             var name = form.elements[i].name.split("[");
             for(var j = 0; j < name.length; j++) {
                 //Hmm problem with sequence of names... have to get that from the variable sequence...
             }
             args[] = form.elements[i].value;
         }

         this['postform'].apply(this, args);
     };
     */
}).call(apf.rpc.prototype = new apf.Teleport());

apf.config.$inheritProperties["baseurl"] = 1;

apf.aml.setElement("rpc", apf.rpc);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/frame.js)SIZE(4614)TIME(1257329183)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Element displaying a frame with a caption, containing other elements. This
 * element is called a fieldset in html.
 * Example:
 * <code>
 *  <a:frame caption="Options">
 *      <a:radiobutton value="1">Option 1</a:radiobutton>
 *      <a:radiobutton value="2">Option 2</a:radiobutton>
 *      <a:radiobutton value="3">Option 3</a:radiobutton>
 *      <a:radiobutton value="4">Option 4</a:radiobutton>
 *  </a:frame>
 * </code>
 *
 * @constructor
 * @define fieldset, frame
 * @allowchild {elements}, {anyaml}
 * @addnode elements:frame
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.9
 *
 * @inherits apf.Presentation
 */
apf.panel    = function(struct, tagName){
    this.$init(tagName || "panel", apf.NODE_VISIBLE, struct);
};

apf.fieldset = function(struct, tagName){
    this.$init(tagName || "fieldset", apf.NODE_VISIBLE, struct);
};

apf.frame    = function(struct, tagName){
    this.$init(tagName || "submit", apf.NODE_VISIBLE, struct);
};

(function(){
    this.implement(
        apf.BaseStateButtons
    );

    this.$focussable     = false;
    
    /**** Properties and Attributes ****/
    
    /**
     * @attribute {String} caption the text of the caption. 
     */
    this.$supportedProperties.push("caption", "url");
    this.$propHandlers["caption"] = function(value){
        if (!this.oCaption) return;
        
        if (this.oCaption.nodeType == 1)
            this.oCaption.innerHTML = value;
        else
            this.oCaption.nodeValue = value;
    };
    
    /**
     * @attribute {String} icon the location of the image.
     */
    this.$propHandlers["icon"] = function(value){
        var oIcon = this.$getLayoutNode("main", "icon", this.$ext);
        if (!oIcon) return;

        if (oIcon.nodeType == 1)
            oIcon.style.display = value ? "block" : "none";
        apf.skins.setIcon(oIcon, value, this.iconPath);
    };
    
    this.$propHandlers["url"] = function(value){
        var node = this.oCaption;
        if (node.tagName == "A" || node.nodeType != 1) 
            node = node.parentNode;

        node.innerHTML = "<a href='" + value + "' " 
            + (value.match(/^http:\/\//) ? "target='_blank'" : "") + ">" 
            + this.caption + "</a>";
        this.oCaption = this.oCaption.firstChild;
    };
    
    /** 
     * Sets the text of the title of this element
     * @param {String} value the text of the title.
     */
    this.setTitle = function(value){
        this.setProperty("title", value);
    };
    
    /**** Init ****/
    
    this.$draw = function(){
        //Build Main Skin
        this.$ext     = this.$getExternal(null, null, function(oExt){
            this.$initButtons(oExt);
        });
        this.oCaption = this.$getLayoutNode("main", "caption", this.$ext);
        this.$int     = this.$getLayoutNode("main", "container", this.$ext);
        this.$buttons = this.$getLayoutNode("main", "buttons",  this.$ext);

        /*if (this.oCaption) {
            this.oCaption = this.oCaption.nodeType == 1 
                ? this.oCaption 
                : this.oCaption.parentNode;
        }*/
    };
    
    this.$loadAml = function(x){
        // not implement now.
    };
}).call(apf.frame.prototype = new apf.Presentation());

apf.panel.prototype    =
apf.fieldset.prototype = apf.frame.prototype;

apf.aml.setElement("panel", apf.panel);
apf.aml.setElement("fieldset", apf.fieldset);
apf.aml.setElement("frame", apf.frame);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/axis.js)SIZE(14042)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Element displays a chart.
 *
 * @classDescription This class creates a new chart
 * @return {Chart} Returns a new chart
 * @type {Chart}
 * @constructor
 * @allowchild {elements}, {anyaml}
 * @addnode elements:chart
 *
 * @author      Rik Arends
 * @version     %I%, %G%
 * @since       0.4
 */

 apf.Axis     = function(struct, tagName){
    this.$init(tagName || "axis", apf.NODE_VISIBLE, struct);
    this.$subpos = {left:0,right:0,width:1,height:1};
};

apf.aml.setElement("axis", apf.Axis);
 
(function(){
    this.$supportedProperties = [
        "left","top","width","height","mode",
        "zoom","zoomx", "zoomy","movex", "movey",  
        "orbitx", "orbity", "distance",
        "x1","x2","y1","y2","z1","z2","t1","t2",
        "x3d","y3d","z3d","p3d",
        "orbitxanim","orbityanim","orbitzanim"
    ];

    //this.$attrExcludePropBind = apf.extend({
    //���style : 1
    //}, this.$attrExcludePropBind);
 
    this.$drawCode  = 0;
    this.$_style = null;
    this.$docompile = true;
	this.$doinit = true;
    
    this.$timer;
    this.zoomx = 1,  this.zoomy = 1,   this.zoomz = 1;
    this.movex = 0,  this.movey  = 0,  this.movez  = 0;
    this.mousex = 0, this.mousey = 0;
    this.$tilex = 0,  this.$tiley = 0;
    this.orbitx   = 0,this.orbity = 0, this.orbitz   = 0;
	this.distance = 4; 
    this.rotate = 0;
    // anim crap
    this.orbitxanim = 0;
    this.orbityanim = 0;
    this.orbitzanim = 0;

    // domains
    this.x1 = -2, this.x2 = 2;
    this.y1 = -1, this.y2 = 2;
    this.z1 = -0.7, this.z2 = 1;
    this.t1 = 0, this.t2 = 1;
    // 3D rendering styles
	this.x3d= 2,this.y3d = 2,this.z3d = 2;
    this.p3d = 1; // perspective
    //this.animreset = 1;
	this.$styletag = '';
	this.style = '';
    this.mode = '2D';
    this.left = 0,this.top = 0, this.width = 0,this.height = 0;
    this.resetView = function(){
        if(!this.animreset){
            this.setProperty("movex", 0 ); this.setProperty("movey", 0 );this.setProperty("movez", 0 );
            this.setProperty("zoomx", 1 ); this.setProperty("zoomy", 1 );this.setProperty("zoomz", 1 );
            this.setProperty("orbitx", 0 ); this.setProperty("orbity", 0 );this.setProperty("orbitz", 0 );
            this.setProperty("distance", 4 );
        }
        var step = 0;
		var _self = this;
        var iid = window.setInterval(function(){
            var s1 = 0.7, s2 = 1 - s1;
            if( step++ > 20 ) window.clearInterval( iid ), iid = 0;
            _self.setProperty("movex", !iid?0:s1*_self.movex ); 
            _self.setProperty("movey", !iid?0:s1*_self.movey ); 
            _self.setProperty("zoomx", !iid?1:s2+s1*_self.zoomx ); 
            _self.setProperty("zoomy", !iid?1:s2+s1*_self.zoomy ); 
            _self.setProperty("orbitx", !iid?0:s2*0+s1*_self.orbitx ); 
            _self.setProperty("orbity", !iid?0:s2*0+s1*_self.orbity ); 
            _self.setProperty("distance", !iid?4:s2*4+s1*_self.distance); 
        },20);
    }

    this.$copySubPos = function(t){
		t.left   = this.$subpos.left,  t.top    = this.$subpos.top;
		t.width  = this.$subpos.width, t.height = this.$subpos.height;
    }

    this.$mouseDown = function(x,y,bt,keys){
        if(bt == 3) this.resetView();
        for(var i = 0, d = this.childNodes, len = d.length, n;i<len;)
			if((n = d[i++]).$mouseDown)
				n.$mouseDown(x,y,bt,keys);
    }
    
    this.$mouseUp = function(x,y){
        for(var i = 0, d = this.childNodes, len = d.length, n;i<len;)
			if((n = d[i++]).$mouseUp)
				n.$mouseUp(x,y);
    }
    
    this.$mouseMove = function(dx,dy,bt,ox,oy,lx,ly,keys){
        // send mouseMove to charts
        //document.title = lx+' '+ly+this.left;
        var cx = this.$subpos.left, cy = this.$subpos.top;
        for(var i = 0, d = this.childNodes, len = d.length, n;i<len;)
			if((n = d[i++]).$mouseMove)
				n.$mouseMove(dx,dy, bt, ox-cx, oy-cy, lx-cx, ly-cy,keys);

		dx = dx / this.$subpos.width, dy = dy / this.$subpos.height; 
        var zx = this.zoomx, zy = this.zoomy, zz = this.zoomz, v;
        this.mousex=lx/this.$subpos.width;
        this.mousey=ly/this.$subpos.height;
        if(ox<this.$subpos.left)dx = 0;
        if(oy>this.$subpos.top+this.$subpos.height)dy = 0;

        //2D interaction mode
        if( this.mode=='2D' ) {
            if( bt == 1 ) {
                this.$tilex-=dx*this.$subpos.width;
                this.$tiley-=dy*this.$subpos.height;
                
                this.setProperty("movex",  this.movex + dx * this.zoomx );
                this.setProperty("movey",this.movey + dy * this.zoomy );
                
            } else if(bt==2) {
                var tx = (ox - this.$subpos.left)/this.$subpos.width, 
                    ty = 1-((oy - this.$subpos.top)/this.$subpos.height);
                this.setProperty("zoomx", (v=this.zoomx * (1 - 4*dx))<0.001?0.001:(v>10000?10000:v)  );
                this.setProperty("zoomy", (v=this.zoomy * (1 - 4*dy))<0.001?0.001:(v>10000?10000:v) );
                this.setProperty("movex", this.movex - (zx-this.zoomx)*tx );
                this.setProperty("movey", this.movey + (zy-this.zoomy)*ty );
            }
        } else {
            if(bt == 1){
            
                if(keys&1){
                // lets project the camera on the floor and 
                    this.setProperty("movex", this.movex + dx * this.zoomx * 1.5 );
                    this.setProperty("movey", this.movey + dy * this.zoomy * 1.5 );
                }else if(keys&2){
                    this.setProperty("movex", this.movex + dx * this.zoomx * 1.5 );
                    this.setProperty("movez", this.movez - dy * this.zoomz * 1.5 );
                }else{
                    this.setProperty("orbitx", this.orbitx - 4*dx );
                    this.setProperty("orbity", this.orbity + 4*dy );
                }
            } else if(bt == 2){
                if(keys&1){
                    this.setProperty("zoomx", (v=this.zoomx * (1 - 4*dx))<0.001?0.001:(v>10000?10000:v)  );
                    this.setProperty("zoomy", (v=this.zoomy * (1 - 4*dy))<0.001?0.001:(v>10000?10000:v) );
                    this.setProperty("movex", this.movex - (zx-this.zoomx)*0.5 );
                    this.setProperty("movey", this.movey + (zy-this.zoomy)*0.5);
                }else if(keys&2){
                    this.setProperty("zoomx", (v=this.zoomx * (1 - 4*dx))<0.001?0.001:(v>10000?10000:v)  );
                    this.setProperty("zoomz", (v=this.zoomz * (1 - 4*dy))<0.001?0.001:(v>10000?10000:v) );
                    this.setProperty("movex", this.movex - (zx-this.zoomx)*0.5 );
                    this.setProperty("movez", this.movez + (zz-this.zoomz)*0.5 );
               
                }else{
                    this.setProperty("distance", Math.min(Math.max( this.distance* (1 - 4*dy), 1 ),100) );
                }
            }
        }
        //this.drawAxis();
    }
    
    this.$mouseWheel = function(x,y,d,keys){
        var zx = this.zoomx, zy = this.zoomy, zz = this.zoomz,v,
            tx = (x - this.$subpos.left)/this.$subpos.width, 
            ty = 1-((y - this.$subpos.top)/this.$subpos.height);
         
        if(this.mode=='2D'){
            
            if(!this.lockxzoom)this.setProperty("zoomx", (v=this.zoomx * (1 - 0.1*d))<0.001?0.001:(v>10000?10000:v)  );
            if(!this.lockyzoom)this.setProperty("zoomy", (v=this.zoomy * (1 - 0.1*d))<0.001?0.001:(v>10000?10000:v) );
            this.setProperty("movex", this.movex - (zx-this.zoomx)*tx );
            this.setProperty("movey", this.movey + (zy-this.zoomy)*ty );
        } else {
            if(keys&1){
                if(!this.lockxzoom)this.setProperty("zoomx", (v=this.zoomx * (1 - 0.1*d))<0.001?0.001:(v>10000?10000:v) );
                if(!this.lockyzoom)this.setProperty("zoomy", (v=this.zoomy * (1 - 0.1*d))<0.001?0.001:(v>10000?10000:v) );
                this.setProperty("movex", this.movex - (zx-this.zoomx)*0.5 );
                this.setProperty("movey", this.movey + (zy-this.zoomy)*0.5 );
            }else if(keys&2){
                if(!this.lockzzoom)this.setProperty("zoomz", (v=this.zoomz * (1 - 0.1*d))<0.001?0.001:(v>10000?10000:v) );
                this.setProperty("movez", this.movez + (zz-this.zoomz)*0.5 );
            }else {
                this.setProperty("distance", Math.min(Math.max( this.distance * (1 - 0.1*d), 3 ),100) );
            }
        }
        this.$redraw();
    }

    this.$propHandlers["left"] = 
    this.$propHandlers["top"] =
    this.$propHandlers["width"] =
    this.$propHandlers["height"] =function(value){ }
    this.$propHandlers["mode"] =  function(value){
        // also all our child charts should recompile
        this.$_style = null;
        for(var i = 0, d = this.childNodes, len = d.length, n;i<len;)if((n = d[i++]).$drawGraph){
           n.$regenerate();
        }        
        this.$docompile = true;
        this.$redraw(false,true);
    }
    this.$propHandlers["style"] = function(value){
        // lets reparse our style
        this.$_style = null;
        this.$docompile = true;
        this.$redraw(false,true);
    }

    this.$propHandlers["x1"] =
    this.$propHandlers["x2"] =
    this.$propHandlers["y1"] =
    this.$propHandlers["y2"] = 
    this.$propHandlers["z1"] =
    this.$propHandlers["z2"] = 
    this.$propHandlers["t1"] =
    this.$propHandlers["t2"] = 
    this.$propHandlers["x3d"] =
    this.$propHandlers["y3d"] = 
    this.$propHandlers["z3d"] = 
    this.$propHandlers["p3d"] = 
    this.$propHandlers["orbitxanim"]=
    this.$propHandlers["orbityanim"]=
    this.$propHandlers["orbitzanim"]=
    function(value,name){
        this[name] = parseFloat(value);
        this.$redraw();
    }

    this.$propHandlers["movex"] =
    this.$propHandlers["movey"] =
    this.$propHandlers["movez"] =
    this.$propHandlers["zoomx"] =
    this.$propHandlers["zoomy"] =
    this.$propHandlers["zoomz"] =
    this.$propHandlers["distance"] =
    this.$propHandlers["orbitx"] =
    this.$propHandlers["orbity"] =
    this.$propHandlers["orbitz"] =
    function(value,name){
        this[name] = parseFloat(value);
        this.$redraw();
    }
    
    this.$redraw = function(now,resize){
        // call parent to repaint
        if(this.$parentChart)
            this.$parentChart.$redraw(now,resize);
    }
    
	this.$calcViewport = function() {
		var x1 = this.x1, 
            y1 = this.y1, 
            z1 = this.z1,
            w = this.x2 - x1, 
            h = this.y2 - y1, 
            d = this.z2 - z1;
        this.orbitx += this.orbitxanim;
        this.orbity += this.orbityanim;
        this.orbitz += this.orbitzanim;
        this.a = this.$parentChart.a;
        this.b = this.$parentChart.b;
        this.c = this.$parentChart.c;
        this.d = this.$parentChart.d;
        this.rx = this.orbity, this.ry =  this.orbitx, this.rz = this.orbitz+3.141516;
        this.tx  = 0, this.ty = 0, this.tz = -this.distance;
        this.vx2 = (this.vx1 = x1 + this.movex * -w) + this.zoomx * w,
        this.vy2 = (this.vy1 = y1 + this.movey * h) + this.zoomy * h;
        this.vz2 = (this.vz1 = z1 + this.movez * d) + this.zoomz * d;
	}
    
    this.$drawAxis = function (doresize) {
		this.$calcViewport();
		if(this.$doinit){
            this.$doinit = false;
            this.$parentChart.$copyPos(this);
			apf.draw.initLayer(this, this.$parentChart);
		}else if(doresize){
			// resize layer
            this.$parentChart.$copyPos(this);
            if(this.$_style)this.$parentChart.$copyPos(this.$subpos, this.$_style.margin);
 			apf.draw.resizeLayer(this, this.$parentChart);
		}
		
        // check if we need to recompile
        
        if(this.$docompile){
            this.$docompile = false;
            var err = {};
			var mode = 'axis'+this.mode;
            
            if(!this.$_style) this.$_style = 
                apf.draw.parseStyle( apf.chart_draw['_'+mode], this.style+this.$styletag, err );
            
            if(this.$_style)this.$parentChart.$copyPos(this.$subpos, this.$_style.margin);
            else this.$parentChart.$copyPos(this.$subpos);
            // recompile drawing code
            this.$drawCode  = apf.chart_draw[mode]( this, this.$_style );
            
        }
        if(this.$drawCode){
            this.$drawCode( this, this );
        }
    
        for(var i = 0, d = this.childNodes, len = d.length, n;i<len;)if((n = d[i++]).$drawGraph){
            n.$tilex=this.$tilex, n.$tiley=this.$tiley,
            n.zoomx = this.zoomx,n.zoomy = this.zoomy,n.zoomz = this.zoomz;
			n.p3d = this.p3d;
            n.a = this.a;n.b=this.b;n.c=this.c;n.d=this.d;
            n.$drawGraph( this, doresize );
        }
    }

    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        this.$parentChart = this.parentNode;
		var n = this.getElementsByTagNameNS(apf.ns.apf, "style");
		if(n.length>0)
			this.$styletag = n[0].firstChild.nodeValue.trim().replace(/\t/g,' ');
		
        this.$redraw();
     });
}).call(apf.Axis.prototype = new apf.AmlElement());


/*FILEHEAD(/var/lib/platform/source/trunk/elements/method.js)SIZE(3762)TIME(1259091146)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * element specifying a method available within the rpc element.
 *
 * @attribute {String}  name             the name of the method. This name will
 *                                       be available on the rpc object as a
 *                                       javascript method.
 * Example:
 * <code>
 *  <a:rpc id="comm" protocol="xmlrpc">
 *      <a:method name="save" />
 *  </a:rpc>
 *
 *  <a:script>
 *      comm.save(data);
 *  </a:script>
 * </code>
 * @attribute {String}  [callback]       the name of the method that handles
 *                                       the return of the call.
 * @attribute {Boolean} [async]          whether the call is executed in the
 *                                       backround. Default is true. When set
 *                                       to false the application hangs while
 *                                       this call is executed.
 * @attribute {Boolean} [caching]        whether the call is cached. Default
 *                                       is false. When set to true any call
 *                                       with the same data will return immediately
 *                                       with the cached result.
 * @attribute {Boolean} [ignore-offline] whether the method should not be stored
 *                                       for later execution when offline.
 * @attribute {Boolean} [method-name]    the name sent to the server.
 *
 * @allowchild variable
 */
apf.method = function(struct, tagName){
    this.$init(tagName || "method", apf.NODE_HIDDEN, struct);

    this.async             = true;
    this.caching           = false;
    this["ignore-offline"] = false;
};

(function(){
    this.$parsePrio = "002";
    
    this.$booleanProperties["async"]          = true;
    this.$booleanProperties["caching"]        = true;
    this.$booleanProperties["ignore-offline"] = true;

    this.$supportedProperties.push("name", "receive", "async", "caching",
        "ignore-offline", "method-name");

    this.$propHandlers["ignore-offline"] = function(value){
        this.ignoreOffline = value;
    };
    
    this.$propHandlers["method-name"] = function(value){
        this.methodName = value;
    };

    /**** DOM Handlers ****/

    this.addEventListener("DOMNodeInserted", function(e){
        if (this.parentNode.$addMethod)
            this.parentNode.$addMethod(this);
    });
    
    this.addEventListener("DOMNodeRemoved", function(e){
        if (this.parentNode.$removeMethod)
            this.parentNode.$removeMethod(this);
    });

    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (this.parentNode.$addMethod)
            this.parentNode.$addMethod(this);
    });
}).call(apf.method.prototype = new apf.AmlElement());

apf.aml.setElement("method", apf.method);


/*FILEHEAD(/var/lib/platform/source/trunk/elements/rpc/jsonrpc.js)SIZE(3167)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Implementation of the JSON-RPC protocol as a module for the RPC
 * plugin of apf.teleport. 
 * Example:
 * Ajax.org Markup Language
 * <code>
 *  <a:rpc id="comm" protocol="jsonrpc">
 *      <a:method 
 *        name    = "searchProduct" 
 *        receive = "processSearch">
 *          <a:variable name="search" />
 *          <a:variable name="page" />
 *          <a:variable name="textbanner" value="1" />
 *      </a:method>
 *      <a:method 
 *        name = "loadProduct">
 *          <a:variable name="id" />
 *          <a:variable name="search_id" />
 *      </a:method>
 *  </a:rpc>
 *
 *  <a:script>
 *      //This function is called when the search returns
 *      function processSearch(data, state, extra){
 *          alert(data)
 *      }
 *
 *      //Execute a search for the product car
 *      comm.searchProduct('car', 10);
 *  </a:script>
 * </code>
 *
 * @constructor
 *
 * @addenum rpc[@protocol]:jsonrpc
 *
 * @inherits apf.Teleport
 * @inherits apf.http
 * @inherits apf.rpc
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @default_private
 */
apf.jsonrpc = function(){
    this.supportMulticall = false;
    this.multicall        = false;
    
    this.method           = "POST";
    this.useXML           = false;
    this.id               = 0;
    this.namedArguments   = false;
    
    this.getSingleCall = function(name, args, obj){
        obj.push({
            method: name,
            params: args
        });
    };
    
    // Create message to send
    this.createMessage = function(functionName, args){
        this.fName = functionName;
        this.id++;
        
        //Construct the XML-RPC message
        var message = "{'method':'" + functionName + "','params':"
            + apf.serialize(args) + ",'id':" + this.id + "}";
        return message;
    };
    
    this.$headerHook = function(http){
        http.setRequestHeader("X-JSON-RPC", this.fName);
    };
    
    this.unserialize = function(str){
        var obj = JSON.parse(str);
        return obj.result;
    };
};




/*FILEHEAD(/var/lib/platform/source/trunk/elements/rpc/yql.js)SIZE(3991)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Implementation of the Yahoo! Query Language as a module for the RPC
 * plugin of apf.teleport.
 * Example:
 * Ajax.org Markup Language
 * <code>
 *  <a:rpc id="query" protocol="yql">
 *      <a:method
 *        name        = "flickr"
 *        query       = "SELECT * FROM flickr WHERE text='{keywords}'">
 *          <a:variable name="keywords"/>
 *      </a:method>
 *      <a:method
 *        name        = "weather"
 *        query       = "SELECT * FROM weather.forecast WHERE location={location}">
 *          <a:variable name="location"/>
 *      </a:method>
 *  </a:rpc>
 *
 *  <a:model load="comm.flickr('bacon')" />
 * </code>
 * Remarks:
 * For more info on YQL and how to write
 * {@link http://developer.yahoo.com/yql/guide/statement_summary.html YQL statements}
 * that operate on the various, publicly available
 * {@link http://developer.yahoo.com/yql/guide/yql-opentables-chapter.html Open Data Tables},
 * please visit the {@link http://developer.yahoo.com/yql/ YQL Developer Center}.
 *
 * @addenum rpc[@protocol]:yql
 *
 * @constructor
 *
 * @inherits apf.Teleport
 * @inherits apf.http
 * @inherits apf.rpc
 *
 * @author      Mike de Boer (mike AT javeline DOT com)
 * @version     %I%, %G%
 * @since       3.0
 *
 * @default_private
 */
apf.yql = function(){
    this.supportMulticall = false;
    this.namedArguments   = true;
    this.nocache          = false;
    this.format           = "xml";
    this.diagnostics      = true;
    this.debug            = false;

    this.$booleanProperties["diagnostics"] = true;
    this.$booleanProperties["debug"]       = true;

    this.$supportedProperties.push("diagnostics", "debug", "format");

    this.$propHandlers["format"] = function(value) {
        if (!apf.yql.FORMATS[value])
            this.format = "xml";
    };

    this.unserialize = function(str){
        return str;
    };

    this.getSingleCall = function(name, args, obj){
        obj.push(args);
    };

    // Create message to send
    this.createMessage = function(functionName, args){
        var options = this.$methods[functionName],
            body    = "POST|PUT".indexOf(options["http-method"]) > -1 ? args.pop() : "";

        this.method = options["http-method"];
        if (options["content-type"])
            this.contentType = options["content-type"];

        this.url    = apf.yql.PUBLIC + "?q=" + encodeURIComponent(this.query)
            + "&format=" + (options.format || this.format)
            + (typeof options.callback == "string"
                ? "&callback=" + encodeURIComponent(options.callback)
                : "")
            + "&diagnostics=" + (options.diagnostics || this.diagnostics)
            + "&debug=" + (options.debug || this.debug);

        return body;
    };
};

apf.yql.PUBLIC  = "http://query.yahooapis.com/v1/public/yql";
apf.yql.PRIVATE = "http://query.yahooapis.com/v1/yql";
apf.yql.FORMATS = {"xml":1, "json":1};




/*FILEHEAD(/var/lib/platform/source/trunk/elements/rpc/soap.js)SIZE(11055)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Implementation of the SOAP RPC protocol.
 * Implementation of the Common Gateway Interface (CGI) as a module for the RPC
 * plugin of apf.teleport. 
 * Example:
 * Ajax.org Markup Language
 * <code>
 *  <a:rpc id="comm" 
 *    protocol    = "soap" 
 *    url         = "http://example.com/show-product.php" 
 *    soap-prefix = "m" 
 *    soap-xmlns  = "http://example.com">
 *      <a:method 
 *        name    = "searchProduct" 
 *        receive = "processSearch">
 *          <a:variable name="search" />
 *          <a:variable name="page" />
 *          <a:variable name="textbanner" value="1" />
 *      </a:method>
 *      <a:method 
 *        name = "loadProduct">
 *          <a:variable name="id" />
 *          <a:variable name="search_id" />
 *      </a:method>
 *  </a:rpc>
 *
 *  <a:script>
 *      //This function is called when the search returns
 *      function processSearch(data, state, extra){
 *          alert(data)
 *      }
 *
 *      //Execute a search for the product car
 *      comm.searchProduct('car', 10);
 *  </a:script>
 * </code>
 *
 * @constructor
 *
 * @addenum rpc[@protocol]:soap
 *
 * @inherits apf.Teleport
 * @inherits apf.http
 * @inherits apf.rpc
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.soap = function(){
    this.supportMulticall = false;
    this.method           = "POST";
    this.useXML           = true;

    this.nsName           = "m";
    this.nsURL            = "http://www.ajax.org";
    
    this.namedArguments   = true;
    
    // Serialize Objects
    var createMessage = {
        host : this,

        //Object
        0 : function(o){
            var prop, retstr, wo = o;//.valueOf();

            for (prop in wo) {
                if (typeof wo[prop] != "function" && prop != "type") {
                    retstr += this.host.doSerialize(wo[prop], prop);
                }
            }

            return retstr;
        },

        //String
        5 : function(s){
            return s.replace(/\]\]/g, "] ]");//"<![CDATA[" + s.replace(/\]\]/g, "] ]") + "]]>";
        },

        //Number
        2 : function(i){
            return i;
        },

        //Boolean
        4 : function(b){
            return b == true ? 1 : 0;
        },

        //Date
        3 : function(d){
            //Could build in possibilities to express dates
            //in weeks or other iso8601 possibillities
            //hmmmm ????
            //19980717T14:08:55
            return doYear(d.getUTCYear()) + doZero(d.getMonth())
                + doZero(d.getUTCDate()) + "T" + doZero(d.getHours())
                + ":" + doZero(d.getMinutes()) + ":" + doZero(d.getSeconds());

            function doZero(nr) {
                nr = String("0" + nr);
                return nr.substr(nr.length-2, 2);
            }

            function doYear(year) {
                if (year > 9999 || year < 0)
                    XMLRPC.handleError(new Error("Unsupported year: " + year));

                year = String("0000" + year)
                return year.substr(year.length - 4, 4);
            }
        },

        //Array
        1 : function(a){
            var retstr = "";
            for(var i = 0; i < a.length; i++)
                retstr += this.host.doSerialize(a[i], "item");

            return retstr;
        }
    }

    this.doSerialize = function(args, name){
        var c    = name ? args : args[1],
            name = name ? name : args[0];

        if (typeof c == "function") throw new Error("Cannot Parse functions");

        if (c === false)
            return '<' + name + ' xsi:null="1"/>';
        else
            return '<' + name + ' ' + this.getXSIType(c) + '>'
                + createMessage[c.dataType || 0](c) + '</' + name + '>';
    }

    // get xsi:type
    this.getXSIType = function(c){
        if (!c.dataType)
            return '';
        else if (c.dataType == apf.ARRAY)
            return 'xsi:type="SOAP-ENC:Array" SOAP-ENC:arrayType="xsd:ur-type['
                + c.length + ']"';
        else if (c.dataType == apf.NUMBER)
            return 'xsi:type="' + (parseInt(c) == c ? "xsd:int" : "xsd:float")
                + '"';
        else if (c.dataType == "data")
            return 'xsi:type="xsd:timeInstant"';
        else
            return 'xsi:type="xsd:' + c.dataType + '"';
    }

    // Create message to send
    this.createMessage = function(functionName, args){
        //Construct the SOAP message
        var message = ['<?xml version="1.0"?>',
        '<SOAP-ENV:Envelope SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"',
        ' xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/"',
        ' xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"',
        ' xmlns:xsd="http://www.w3.org/1999/XMLSchema"',
        ' xmlns:xsi="http://www.w3.org/1999/XMLSchema-instance">',
        "<SOAP-ENV:Body><",
            this.nsName, ":", functionName, " xmlns:",
            this.nsName, "=\"", this.nsURL, "\">"]

        for (var i = 0, l = args.length; i < l; i++)
            message.push(this.doSerialize(args[i]));

        message.push("</", this.nsName, ":", functionName,
           "></SOAP-ENV:Body></SOAP-ENV:Envelope>");

        return message.join("");
    }

    this.$headerHook = function(http){
        http.setRequestHeader('SOAPAction', '"'
            + this.url.replace(/http:\/\/.*\/([^\/]*)$/, "$1") + '"');
    }

    this.unserialize = function(data){
        return data;
        var ret, i, nodes;

        //xsi:type
        var type = data.getAttribute("xsi:type");
        switch (type) {
            case "xsd:string":
                return (data.firstChild)
                    ? new String(data.firstChild.nodeValue)
                    : "";
                break;
            case "xsd:int":
            case "xsd:double":
            case "xsd:float":
                return (data.firstChild) ? parseFloat(data.firstChild.nodeValue) : 0;
                break;
            case "xsd:timeInstant":
                /*
                Have to read the spec to be able to completely
                parse all the possibilities in iso8601
                07-17-1998 14:08:55
                19980717T14:08:55
                */

                var sn = apf.dateSeparator;

                if (/^(\d{4})(\d{2})(\d{2})T(\d{2}):(\d{2}):(\d{2})/
                  .test(data.firstChild.nodeValue)){//data.text)){
                    return new Date(RegExp.$2 + sn + RegExp.$3 + sn +
                                    RegExp.$1 + " " + RegExp.$4 + ":" +
                                    RegExp.$5 + ":" + RegExp.$6);
                }
                else {
                    return new Date();
                }
                break;
            case "xsd:boolean":
                return Boolean(isNaN(parseInt(data.firstChild.nodeValue))
                    ? (data.firstChild.nodeValue == "true")
                    : parseInt(data.firstChild.nodeValue))
                break;
            case "SOAP-ENC:base64":
                return apf.crypt.Base64.decode(data.firstChild.nodeValue);
                break;
            case "SOAP-ENC:Array":
                nodes = data.childNodes;

                ret = [];
                for (i = 0; i < nodes.length; i++) {
                    if(nodes[i].nodeType != 1)
                        continue;
                    ret.push(this.unserialize(nodes[i]));
                }

                return ret;
                break;
            default:
                //Custom Type
                if (type && !self[type]) {
                    throw new Error(apf.formatErrorString(1084, null, "SOAP", 
                        "Invalid Object Specified in SOAP message: " + type));
                }

                nodes = data.childNodes;
                var o = type ? new self[type] : {};

                ret = [];
                for(i = 0; i < nodes.length; i++) {
                    if (nodes[i].nodeType != 1) continue;
                    ret[nodes[i].tagName] = this.unserialize(nodes[i]);
                }

                return ret;
                break;
        }
    }

    // Check Received Data for errors
    this.isValid = function(extra){
        /*
        var fault = data.selectSingleNode("Fault");
        if (fault) {
            var nr  = fault.selectSingleNode("faultcode/text()").nodeValue;
            var msg = "\n" + fault.selectSingleNode("faultstring/text()").nodeValue;
            throw new Error(nr, msg);
        }
        else if (data.getElementsByTagName("Errors")) {
            var fault = data.getElementsByTagName("Errors")[0];
            var nr    = fault.selectSingleNode("node()/node()/text()").nodeValue;
            var msg   = "\n" + fault.selectSingleNode("node()/node()[2]/text()").nodeValue;
            throw new Error(nr, msg);
        }
        */

        var data = extra.data;

        // IE Hack
        if (!apf.supportNamespaces)
            data.ownerDocument.setProperty("SelectionNamespaces",
                "xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xmlns:xds='http://www.w3.org/2001/XMLSchema' xmlns:SOAP-ENV='http://schemas.xmlsoap.org/soap/envelope/'");

        var rvalue = data.getElementsByTagName("SOAP-ENV:Body")[0];///node()/node()[2]
        if (!rvalue && data.getElementsByTagNameNS)
            rvalue = data.getElementsByTagNameNS("http://schemas.xmlsoap.org/soap/envelope/", "Body")[0]

        extra.data = rvalue;
        
        return true;
    }

    this.addEventListener("DOMNodeInsertedIntoDocument", function() {
        this.nsName = this["soap-prefix"] || this.nsName;
        this.nsURL  = this["soap-xmlns"] || this.nsURL;
    });
};




/*FILEHEAD(/var/lib/platform/source/trunk/elements/rpc/jphp.js)SIZE(5901)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Implementation of an RPC protocol which encodes the data in a serialized 
 * format in the same way as the php createMessage() function does. It requires
 * json in return. This protocol was originally designed to make use of the 
 * native unserializer methods on both sides of the line.
 * Example:
 * Ajax.org Markup Language
 * <code>
 *  <a:rpc id="comm" protocol="jphp">
 *      <a:method 
 *        name    = "searchProduct" 
 *        receive = "processSearch" />
 *      <a:method 
 *        name = "loadProduct" />
 *  </a:rpc>
 *
 *  <a:script>
 *      //This function is called when the search returns
 *      function processSearch(data, state, extra){
 *          alert(data)
 *      }
 *
 *      //Execute a search for the product car
 *      comm.searchProduct('car', 10);
 *  </a:script>
 * </code>
 *
 * @constructor
 *
 * @addenum rpc[@protocol]:jphp
 *
 * @inherits apf.Teleport
 * @inherits apf.http
 * @inherits apf.rpc
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @default_private
 */
apf.jphp = function(){
    this.supportMulticall = true;
    this.multicall        = false;
    this.mcallname        = "multicall";
    this.method           = "POST";
    this.useXML           = true;
    this.namedArguments   = false;
    
    // Serialize Objects
    var createMessage = {
        host: this,
        
        //Object
        0: function(ob){
            var ob = ob.valueOf();
            
            var length = 0, x = "", prop;
            for (prop in ob) {
                if (typeof this[prop] != "function") {
                    length++;
                    //WEIRD FUCKED UP INTERNET EXPLORER BUG
                    var r = prop;
                    x += this.host.doSerialize(r) + ";"
                        + this.host.doSerialize(ob[r])
                        + (typeof ob[r] == "object" || typeof ob[r] == "array"
                          ? "" : ";");
                }
            }
            
            if (ob.className) 
                return "O:" + ob.className.length + ":\"" + ob.className
                    + "\":" + length + ":{" + x.substr(0, x.length) + "}";
            return "a:" + length + ":{" + x.substr(0, x.length) + "}";
        },
        
        //String
        5: function(str){
            var str = str.replace(/[\r]/g, "");
            str     = str.replace(/\]\]/g, "\]-\]-\]").replace(/\]\]/g, "\]-\]-\]");
            return "s:" + str.length + ":\"" + str + "\"";
        },
        
        //Number
        2: function(nr){
            if (nr == parseInt(nr)) 
                return "i:" + nr;
            else 
                if (nr == parseFloat(nr)) 
                    return "d:" + nr;
                else 
                    return this["boolean"](false);
        },
        
        //Boolean
        4: function(b){
            return "b:" + (b == true ? 1 : 0);
        },
        
        //Array
        1: function(ar){
            var x = "a:" + ar.length + ":{";
            for (var i = 0; i < ar.length; i++) 
                x += "i:" + i + ";" + this.host.doSerialize(ar[i]) 
                    + (i < ar.length
                      && typeof ar[i] != "object"
                      && typeof ar[i] != "array" ? ";" : "");
            
            return x + "}";
        }
    }
    
    this.unserialize = function(str){
        return eval(str.replace(/\|-\|-\|/g, "]]").replace(/\|\|\|/g, "\\n"));
    };
    
    this.doSerialize = function(args){
        if (typeof args == "function") {
            throw new Error("Cannot Parse functions");
        }
        else {
            if (apf.isNot(args)) 
                return createMessage["boolean"](false);
        }
        
        return createMessage[args.dataType || 0](args);
    };
    
    // Create message to send
    this.createMessage = function(functionName, args){
        //Construct the XML-RPC message
        return "<?xml version='1.0' encoding='UTF-16'?><run m='"
            + functionName + "'><![CDATA[" + this.doSerialize(args) + "]]></run>";
    };
    
    // Check Received Data for errors
    this.isValid = function(extra){
        var data = extra.data;
        
        //handle method result
        if (data && data.tagName == "data") {
            data = data.firstChild.nodeValue;
            
            //error handling
            if (data && data[0] == "error") {
                extra.message = data[1];
                return false;
            }
        }
        else {
            extra.message = "Malformed RPC Message: Parse Error\n\n:'" + http.responseText + "'";
            return false;
        }
        
        extra.data = data;
        return true;
    };
};




/*FILEHEAD(/var/lib/platform/source/trunk/elements/rpc/xmlrpc.js)SIZE(11181)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Implementation of the XML-RPC protocol as a module for the RPC
 * plugin of apf.teleport.
 * Example:
 * Ajax.org Markup Language
 * <code>
 *  <a:rpc id="comm" protocol="xmlrpc">
 *      <a:method 
 *        name    = "searchProduct" 
 *        receive = "processSearch" />
 *      <a:method 
 *        name = "loadProduct" />
 *  </a:rpc>
 *
 *  <a:script>
 *      //This function is called when the search returns
 *      function processSearch(data, state, extra){
 *          alert(data)
 *      }
 *
 *      //Execute a search for the product car
 *      comm.searchProduct('car', 10);
 *  </a:script>
 * </code>
 *
 * @constructor
 *
 * @addenum rpc[@protocol]:xmlrpc
 *
 * @inherits apf.Teleport
 * @inherits apf.http
 * @inherits apf.rpc
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @default_private
 */
apf.xmlrpc = function(){
    this.supportMulticall = true;
    this.multicall        = false;
    this.mcallname        = "system.multicall";
    this.method           = "POST";
    this.useXML           = true;
    
    this.namedArguments   = false;
    
    // Serialize Objects
    var createMessage = {
        host: this,
        
        //Object
        0 : function(o){
            var prop, retstr = "<struct>", wo = o;//.valueOf();
            
            for (prop in wo) {
                if (typeof wo[prop] != "function" && prop != "type") {
                    retstr += "<member><name>" + prop + "</name><value>"
                        + this.host.doSerialize(wo[prop]) + "</value></member>";
                }
            }
            retstr += "</struct>";
            
            return retstr;
        },
        
        //String
        5 : function(s){
            //<![CDATA[***your text here***]]>
            //return "<string><![CDATA[" + s.replace(/\]\]\>/g, "")
            //    .replace(/\<\!\[\CDATA\[/g, "") + "]]></string>";
            return "<string><![CDATA[" + apf.xmlentities(s) + "]]></string>";
            //var str = "<string>" + s.replace(/\&/g, "&amp;")
            //    .replace(/\</g, "&lt;").replace(/\>/g, "&gt;") + "</string>";
        },
        
        //Number
        2 : function(i){
            if (i == parseInt(i)) {
                return "<int>" + i + "</int>";
            }
            else 
                if (i == parseFloat(i)) {
                    return "<double>" + i + "</double>";
                }
                else {
                    return this["boolean"](false);
                }
        },
        
        //Boolean
        4 : function(b){
            if (b == true) 
                return "<boolean>1</boolean>";
            else 
                return "<boolean>0</boolean>";
        },
        
        //Date
        3 : function(d){
            //Could build in possibilities to express dates
            //in weeks or other iso8601 possibillities
            //hmmmm ????
            //19980717T14:08:55
            return "<dateTime.iso8601>" + doYear(d.getUTCYear())
                + doZero(d.getMonth()) + doZero(d.getUTCDate()) + "T"
                + doZero(d.getHours()) + ":" + doZero(d.getMinutes()) + ":"
                + doZero(d.getSeconds()) + "</dateTime.iso8601>";
            
            function doZero(nr){
                nr = String("0" + nr);
                return nr.substr(nr.length - 2, 2);
            }
            
            function doYear(year){
                if (year > 9999 || year < 0) 
                    XMLRPC.handleError(new Error(apf.formatErrorString(1085,
                        null, "XMLRPC serialization", "Unsupported year: " + year)));
                
                year = String("0000" + year)
                return year.substr(year.length - 4, 4);
            }
        },
        
        //Array
        1 : function(a){
            var retstr = "<array><data>";
            for (var i = 0; i < a.length; i++) {
                retstr += "<value>";
                retstr += this.host.doSerialize(a[i])
                retstr += "</value>";
            }
            return retstr + "</data></array>";
        }
    }
    
    this.getSingleCall = function(name, args, obj){
        obj.push({
            m: name,
            p: args
        });
    };
    
    this.doSerialize = function(args){
        if (typeof args == "function") {
            throw new Error(apf.formatErrorString(1086, null, 
                "XMLRPC serialization", "Cannot Parse functions"));
        }
        else 
            if (apf.isNot(args)) 
                return createMessage["boolean"](false);
        
        return createMessage[args.dataType || 0](args);
    };
    
    // Create message to send
    this.createMessage = function(functionName, args){
        //Construct the XML-RPC message
        var message = ["<?xml version=\"1.0\" encoding=\"UTF-8\"?><methodCall><methodName>",
            functionName, "</methodName><params>"];
        for (var i = 0; i < args.length; i++)
            message.push("<param><value>", this.doSerialize(args[i]), "</value></param>");
        message.push("</params></methodCall>");
        
        return message.join("");
    };
    
    this.unserialize = function(data){
        var ret, i;
        
        switch (data.tagName) {
            case "string":
                if (apf.isGecko) {
                    data = (new XMLSerializer()).serializeToString(data);
                    data = data.replace(/^\<string\>/, '');
                    data = data.replace(/\<\/string\>$/, '');
                    data = data.replace(/\&lt;/g, "<");
                    data = data.replace(/\&gt;/g, ">");
                    
                    return data;
                }
                
                return (data.firstChild) ? data.firstChild.nodeValue : "";
                break;
            case "int":
            case "i4":
            case "double":
                return (data.firstChild) ? new Number(data.firstChild.nodeValue) : 0;
                break;
            case "dateTime.iso8601":
                /*
                 Have to read the spec to be able to completely
                 parse all the possibilities in iso8601
                 07-17-1998 14:08:55
                 19980717T14:08:55
                 */
                var sn = apf.dateSeparator;
                
                if (/^(\d{4})(\d{2})(\d{2})T(\d{2}):(\d{2}):(\d{2})/
                  .test(data.firstChild.nodeValue)) {
                    ;//data.text)){
                    return new Date(RegExp.$2 + sn + RegExp.$3 + sn +
                    RegExp.$1 +
                    " " +
                    RegExp.$4 +
                    ":" +
                    RegExp.$5 +
                    ":" +
                    RegExp.$6);
                }
                else {
                    return new Date();
                }
                
                break;
            case "array":
                data = apf.getNode(data, [0]);
                
                if (data && data.tagName == "data") {
                    ret = new Array();
                    
                    var child;
                    i = 0;
                    while (child = apf.getNode(data, [i++])) {
                        ret.push(this.unserialize(child));
                    }
                    
                    return ret;
                }
                else {
                    this.handleError(new Error(apf.formatErrorString(1087, null, "", "Malformed XMLRPC Message")));
                    return false;
                }
                break;
            case "struct":
                ret = {};
                
                i = 0;
                while (child = apf.getNode(data, [i++])) {
                    if (child.tagName == "member") {
                        ret[apf.getNode(child, [0]).firstChild.nodeValue] =
                            this.unserialize(apf.getNode(child, [1]));
                    }
                    else {
                        this.handleError(new Error(apf.formatErrorString(1087, null, "", "Malformed XMLRPC Message2")));
                        return false;
                    }
                }
                return ret;
                break;
            case "boolean":
                return Boolean(isNaN(parseInt(data.firstChild.nodeValue))
                    ? (data.firstChild.nodeValue == "true")
                    : parseInt(data.firstChild.nodeValue))
                break;
            case "base64":
                return apf.crypt.Base64.decode(data.firstChild.nodeValue);
                break;
            case "value":
                child = apf.getNode(data, [0]);
                return (!child) ? ((data.firstChild)
                    ? new String(data.firstChild.nodeValue) : "")
                    : this.unserialize(child);
                break;
            default:
                throw new Error(apf.formatErrorString(1088, null, "", "Malformed XMLRPC Message: " + data.tagName));
                return false;
                break;
        }
    }
    
    // Check Received Data for errors
    this.isValid = function(extra){
        var data = extra.data;
        
        if (apf.getNode(data, [0]).tagName == "fault") {
            var nr, msg;
            if (!apf.isWebkit) {
                nr = data.selectSingleNode("//member[name/text()='faultCode']/value/int/text()").nodeValue;
                msg = "\n" + data.selectSingleNode("//member[name/text()='faultString']/value/string/text()").nodeValue;
            }
            else {
                nr = msg = ""
            }
            
            extra.message   = msg;
            extra.errorcode = nr;
            return false;
        }
        
        extra.data = apf.getNode(data, [0, 0, 0]);
        
        return true;
    };
};




/*FILEHEAD(/var/lib/platform/source/trunk/elements/rpc/header.js)SIZE(3104)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Implementation of an RPC protocol which encodes the variable information in 
 * the HTTP headers of the request.
 * Example:
 * Ajax.org Markup Language
 * <code>
 *  <a:rpc id="comm" protocol="header">
 *      <a:method 
 *        name    = "searchProduct" 
 *        receive = "processSearch">
 *          <a:variable name="search" />
 *          <a:variable name="page" />
 *          <a:variable name="textbanner" value="1" />
 *      </a:method>
 *      <a:method 
 *        name = "loadProduct">
 *          <a:variable name="id" />
 *          <a:variable name="search_id" />
 *     </a:method>
 *  </a:rpc>
 *
 *  <a:script>
 *      //This function is called when the search returns
 *      function processSearch(data, state, extra){
 *          alert(data)
 *      }
 *
 *      //Execute a search for the product car
 *      comm.searchProduct('car', 10);
 *  </a:script>
 * </code>
 *
 * @constructor
 *
 * @addenum rpc[@protocol]:header
 *
 * @inherits apf.Teleport
 * @inherits apf.http
 * @inherits apf.rpc
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @default_private
 */
apf.header = function(){
    this.supportMulticall = false;
    this.method           = "GET";
    this.vartype          = "header";
    this.isXML            = true;
    this.namedArguments   = true;
    
    this.unserialize = function(str){
        return str;
    };
    
    // Create message to send
    this.createMessage = function(functionName, args){
        for (var hFunc = [], i = 0, l = args.length; i < l; i++) {
            if (!args[i][0] || !args[i][1]) 
                continue;
            
            
            apf.console.info("<strong>" + args[i][0] + ":</strong> " + args[i][1]
                + "<br />", "teleport");
            
            
            http.setRequestHeader(args[i][0], args[i][1]);
        }
        
        this.$HeaderHook = new Function("http", hFunc.join("\n"));
        
        return "";
    };
};




/*FILEHEAD(/var/lib/platform/source/trunk/elements/rpc/rest.js)SIZE(3554)TIME(1265021706)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Implementation of the Common Gateway Interface (REST) as a module for the RPC
 * plugin of apf.teleport.
 * Example:
 * Ajax.org Markup Language
 * <code>
 *  <a:rpc id="comm" protocol="rest">
 *      <a:method
 *        name        = "deleteProduct"
 *        url         = "http://example.com/products"
 *        http-method = "DELETE"
 *        receive     = "processDelete" />
 *      <a:method
 *        name        = "createProduct"
 *        url         = "http://example.com/products"
 *        http-method = "POST" />
 *  </a:rpc>
 *
 *  <a:script>
 *      //This function is called when the search returns
 *      function processSearch(data, state, extra){
 *          alert(data)
 *      }
 *
 *      //Execute a search for the product car
 *      comm.searchProduct('car', 10);
 *  </a:script>
 * </code>
 * Remarks:
 * Calls can be made to a server using rest variables with a special
 * {@link term.datainstruction data instruction}
 * format.
 * <code>
 *  get="http://www.bla.nl?blah=10&foo=[@bar]&example=[10+5]"
 *  set="post http://www.bla.nl?blah=10&foo={/bar}&example=[10+5]"
 * </code>
 *
 * @addenum rpc[@protocol]:rest
 *
 * @constructor
 *
 * @inherits apf.Teleport
 * @inherits apf.http
 * @inherits apf.rpc
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @author      Mike de Boer (mike AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @default_private
 */
apf.rest = function(){
    this.supportMulticall = false;
    this.namedArguments   = false;
    this.nocache          = false;

    this.unserialize = function(str){
        return str;
    };

    this.getSingleCall = function(name, args, obj){
        obj.push(args);
    };

    // Create message to send
    this.createMessage = function(functionName, args){
        if (!this.baseUrl)
            this.baseUrl = this.url;

        var options = this.$methods[functionName],
            body    = "NOTIFY|SEND|POST|PUT".indexOf(options["http-method"]) > -1 ? args.pop() : "",
            url;

        this.method = options["http-method"];
        if (options["content-type"])
            this.contentType = options["content-type"];

        this.url    = (url = this.urls[functionName]
            ? this.urls[functionName]
            : this.baseUrl) + (args.length 
                ? (url.charAt(url.length - 1) == "/" 
                    ? ""
                    : "/") + args.join("/")
                : "");

        return body;
    };
};




/*FILEHEAD(/var/lib/platform/source/trunk/elements/rpc/cgi.js)SIZE(6700)TIME(1264896063)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Implementation of the Common Gateway Interface (CGI) as a module for the RPC
 * plugin of apf.teleport.
 * Example:
 * Ajax.org Markup Language
 * <code>
 *  <a:rpc id="comm" protocol="cgi">
 *      <a:method
 *        name    = "searchProduct"
 *        url     = "http://example.com/search.php"
 *        receive = "processSearch">
 *          <a:variable name="search" />
 *          <a:variable name="page" />
 *          <a:variable name="textbanner" value="1" />
 *      </a:method>
 *      <a:method
 *        name = "loadProduct"
 *        url  = "http://example.com/show-product.php">
 *          <a:variable name="id" />
 *          <a:variable name="search_id" />
 *      </a:method>
 *  </a:rpc>
 *
 *  <a:script>
 *      //This function is called when the search returns
 *      function processSearch(data, state, extra){
 *          alert(data)
 *      }
 *
 *      //Execute a search for the product car
 *      comm.searchProduct('car', 10);
 *  </a:script>
 * </code>
 * Remarks:
 * Calls can be made to a server using cgi variables with a special
 * {@link term.datainstruction data instruction}
 * format.
 * <code>
 *  get="http://www.bla.nl?blah=10&foo=[@bar]&example=[10+5]"
 *  set="post http://www.bla.nl?blah=10&foo={/bar}&example=[10+5]"
 * </code>
 *
 * @addenum rpc[@protocol]:cgi
 *
 * @constructor
 *
 * @inherits apf.Teleport
 * @inherits apf.http
 * @inherits apf.rpc
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @default_private
 */
apf.cgi = function(){
    this.supportMulticall = false;
    this.namedArguments   = true;

    this.unserialize = function(str){
        return str;
    };

    this.getSingleCall = function(name, args, obj){
        obj.push(args);
    };

    // Create message to send
    this.createMessage = function(functionName, args){
        var prop,
            vars = [];

        function recur(o, stack){
            if (o && o.dataType == apf.ARRAY) {
                for (var j = 0; j < o.length; j++)
                    recur(o[j], stack + "%5B" + j + "%5D");//" + j + "
            }
            else if (typeof o == "object") {
                for (prop in o) {
                    
                    if (apf.isSafariOld && (!o[prop] || typeof o[prop] != "object"))
                        continue;
                    

                    if (typeof o[prop] == "function")
                        continue;
                    recur(o[prop], stack + "%5B" + encodeURIComponent(prop) + "%5D");
                }
            }
            else {
                if (typeof o != "undefined" && o !== null) 
                    vars.push(stack + "=" + encodeURIComponent(o));
            }
        };

        if (this.multicall) {
            vars.push("func" + "=" + this.mcallname);
            for (var i = 0; i < args[0].length; i++)
                recur(args[0][i], "f%5B" + i + "%5D");
        }
        else {
            for (prop in args) {
                
                if (apf.isSafariOld && (!args[prop] || typeof args[prop] == "function"))
                    continue;
                

                recur(args[prop], prop);
            }
        }

        if (!this.baseUrl)
            this.baseUrl = this.url;

        this.url = this.$methods[functionName].url
            ? this.$methods[functionName].url
            : this.baseUrl;

        if (this.method != "GET")
            return vars.join("&");

        this.url = this.url + (vars.length
            ? (this.url.indexOf("?") > -1 ? "&" : "?") + vars.join("&")
            : "");

        return "";
    };

    this.addEventListener("DOMNodeInsertedIntoDocument", function() {
        this.method      = (this["http-method"] || "GET").toUpperCase();
        this.contentType = this.method == "GET"
            ? null
            : "application/x-www-form-urlencoded";
    });

    /**
     * Submit a form with ajax (GET)
     *
     * @param {HTMLElement} form      the html form element to submit.
     * @param {Function}       callback  called when the http call returns.
     */
    this.submitForm = function(form, callback){
        if (!this['postform'])
            this.addMethod('postform', callback);

        var args = [];
        for (var i = 0, l = form.elements.length; i < l; i++) {
            if (!form.elements[i].name)
                continue;
            if (form.elements[i].tagname == "input"
              && (form.elements[i].type  == "checkbox"
              || form.elements[i].type   == "radio")
              && !form.elements[i].checked)
                continue;

            if (form.elements[i].tagname = "select" && form.elements[i].multiple) {
                for (var j = 0; j < form.elements[i].options.length; j++) {
                    if (form.elements[i].options[j].selected)
                        args.push(form.elements[i].name
                            + "="
                            + encodeURIComponent(form.elements[i].options[j].value));
                }
            }
            else {
                args.push(form.elements[i].name
                    + "="
                    + encodeURIComponent(form.elements[i].value));
            }
        }

        var loc               = (form.action || location.href);
        this.urls['postform'] = loc + (loc.indexOf("?") > -1 ? "&" : "?") + args.join("&");
        this['postform'].call(this);

        return false;
    };
};




/*FILEHEAD(/var/lib/platform/source/trunk/elements/audio/type_flash.js)SIZE(12951)TIME(1259091144)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Element displaying a Flash audio
 *
 * @classDescription This class creates a new Flash audio player
 * @return {TypeFlash} Returns a new Flash audio player
 * @type {TypeFlash}
 * @constructor
 * @addnode elements:audio
 *
 * @author      Mike de Boer
 * @version     %I%, %G%
 * @since       1.0
 */

apf.audio.TypeFlash = function(oAudio, oNode, options) {
    this.oAudio              = oAudio;
    this.isNine              = apf.flash.isAvailable('9.0.0');

    
    this.DEFAULT_SWF_PATH    = (apf.config.resourcePath || apf.basePath) + "resources/soundmanager2"
                                + (this.isNine ? "_flash9" : "") + ".swf";
    this.NULL_MP3_PATH       = (apf.config.resourcePath || apf.basePath) + "resources/null.mp3";
    
    

    this.id = apf.flash.addPlayer(this); // Manager manages multiple players
    this.inited = false;

    // Div name, flash name, and container name
    this.divName      = oAudio.$uniqueId;
    this.htmlElement  = oNode;
    this.name         = "soundmgr_" + oAudio.$uniqueId;

    // Audio props
    this.audioPath  = options.src;
    this.paused     = false;

    // Initialize player
    this.player = null;
    apf.extend(this, apf.audio.TypeInterface);

    this.delayCalls = [];

    // Properties set by flash player
    this.totalTime = this.bytesLoaded = this.totalBytes = 0;
    this.state = null;

    // Internal properties that match get/set methods
    this.autoPlay = this.autoLoad = this.firstLoad = true;
    this.volume                 = 50;
    this.playheadTime           = null;
    this.bufferTime             = 0.1;
    this.playheadUpdateInterval = 1000;

    this.setOptions(options).createPlayer();
}

apf.audio.TypeFlash.isSupported = function() {
    return apf.flash.isAvailable();
};

apf.audio.TypeFlash.prototype = {
    properties: ["volume", "autoPlay", "autoLoad", "playHeadTime",
                 "totalTime", "bufferTime", "playheadUpdateInterval"],
    /**
     * Load an audio file.
     *
     * @param {String} audioPath Path to the mp3 file. If the audioPath is null,
     *                           and the mp3 is playing, it will act as a play/pause toggle.
     * @param {Number} totalTime Optional totalTime to override the mp3's built in totalTime
     */
    load: function(audioPath, totalTime) {
        this.setTotalTime(totalTime);
        if (audioPath != null)
            this.audioPath = audioPath;
        if (this.audioPath == null && !this.firstLoad)
            return this.oAudio.$errorHook({type:"error", error:"SoundManager::play - No audioPath has been set."});

        if (audioPath == null && this.firstLoad && !this.autoLoad) // Allow play(null) to toggle playback
            audioPath = this.audioPath;
        this.firstLoad = false;
        this.callMethod('unloadSound', this.NULL_MP3_PATH);
        if (this.isNine)
            this.callMethod("createSound", this.audioPath, 0, true, true, true, false, false);
        else
            this.callMethod("createSound", 0);
        this.callMethod("setVolume", this.volume)
            .callMethod("loadSound", this.audioPath, true, this.autoPlay);
        return this;
    },

    /**
     * Play and/ or resume a audio that has been loaded already
     *
     * @type {Object}
     */
    play: function() {
        if (!this.paused)
            return this.callMethod("startSound", 1, 0);
        return this.pause(); //toggle pause
    },

    /**
     * Toggle the pause state of the audio.
     *
     * @type {Object}
     */
    pause: function() {
        this.paused = !this.paused;
        return this.callMethod("pauseSound");
    },

    /**
     * Stop playback of the audio.
     *
     * @type {Object}
     */
    stop: function() {
        return this.callMethod("stopSound", true);
    },

    /**
     * Seek the audio to a specific position.
     *
     * @param {Number} seconds The number of seconds to seek the playhead to.
     * @type {Object}
     */
    seek: function(seconds) {
        return this.callMethod("setPosition", seconds, this.paused);
    },

    /**
     * Not supported.
     *
     * @type {Object}
     */
    setVolume: function(iVol) {
        return this.callMethod("setVolume", iVol);
    },

    /**
     * Retrive the position of the playhead, in seconds.
     *
     * @type {Number}
     */
    getPlayheadTime: function() {
        return this.playheadTime;
    },

    /**
     * Specifies the position of the playhead, in seconds.
     *
     * @default null
     * @type {Object}
     */
    setPlayheadTime: function(value) {
        return this.playheadTime = value;
    },

    /**
     * Retrieve the total playtime of the audio, in seconds.
     *
     * @type {Number}
     */
    getTotalTime: function() {
        return this.totalTime;
    },

    /**
     * Determines the total time of the audio.  The total time is automatically determined
     * by the player, unless the user overrides it.
     *
     * @default null
     * @type {Object}
     */
    setTotalTime: function(value) {
        if (!value) return;
        return this.totalTime = value;
    },

    /**
     * All public methods use this proxy to make sure that methods called before
     * initialization are properly called after the player is ready.
     * Supply three arguments maximum, because function.apply does not work on
     * the flash object.
     *
     * @param {String} param1
     * @param {String} param2
     * @param {String} param3
     * @param {String} param4
     * @param {String} param5
     * @param {String} param6
     * @type {Object}
     */
    callMethod: function() {
        if (!this.inited || !this.player || !this.player.callMethod) {
            this.delayCalls.push(arguments);
        }
        else {
            var args = Array.prototype.slice.call(arguments);
            args.unshift(this.player, "callMethod");
            apf.flash.remote.apply(null, args);
        }
        return this;
    },

    /**
     * Call methods that were made before the player was initialized.
     *
     * @type {Object}
     */
    makeDelayCalls: function() {
        for (var i = 0, l = this.delayCalls.length; i < l; i++)
            this.callMethod.apply(this, this.delayCalls[i]);
        return this;
    },

    /**
     * Callback from flash; whenever the Flash movie bubbles an event up to the
     * javascript interface, it passes through to this function.
     * Events dispatched by SoundManager instances:
     *    > init: The player is initialized
     *    > ready: The audio is ready
     *    > progress: The audio is downloading. Properties: bytesLoaded, totalBytes
     *    > playHeadUpdate: The audio playhead has moved.  Properties: playheadTime, totalTime
     *    > stateChange: The state of the audio has changed. Properties: state
     *    > change: The player has changed.
     *    > complete: Playback is complete.
     *    > metaData: The audio has returned meta-data. Properties: infoObject
     *    > cuePoint: The audio has passed a cuePoint. Properties: infoObject
     *    > error: An error has occurred.  Properties: error
     *
     * @param {Object} eventName
     * @param {Object} evtObj
     * @type {void}
     */
    event: function(eventName, evtObj) {
        switch (eventName) {
            case "progress":
                this.bytesLoaded = evtObj.bytesLoaded;
                this.totalBytes  = evtObj.totalBytes;
                this.oAudio.$progressHook({
                    type       : "progress",
                    bytesLoaded: this.bytesLoaded,
                    totalBytes : this.totalBytes
                });
                break;
            case "playheadUpdate":
                this.playheadTime = evtObj.playheadTime;
                this.totalTime    = evtObj.totalTime;
                this.oAudio.$changeHook({
                    type        : "change",
                    playheadTime: this.playheadTime,
                    totalTime   : this.totalTime
                });
                if (evtObj.waveData || evtObj.peakData || evtObj.eqData)
                    this.oAudio.$metadataHook({
                        type    : "metadata",
                        waveData: evtObj.waveData,
                        peakData: evtObj.peakData,
                        eqData  : evtObj.eqData
                    });
                break;
            case "stateChange":
                this.state = evtObj.state;
                this.oAudio.$stateChangeHook({type:"stateChange", state:this.state});
                break;
            case "change":
                this.oAudio.$changeHook({type:"change"});
                break;
            case "complete":
                this.oAudio.$completeHook({type:"complete"});
                break;
            case "ready":
                this.callMethod("setPan", 0);
                if (this.paused && this.autoPlay)
                    this.paused = false;
                this.oAudio.$readyHook({type:"ready"});
                break;
            case "metaData":
                this.oAudio.$metadataHook({type:"metaData", infoObject:evtObj});
                break;
            case "cuePoint":
                this.oAudio.$cuePointHook({type:"cuePoint", infoObject:evtObj});
                break;
            case "init":
                if (this.inited) return;
                this.inited = true;
                this.makeDelayCalls();
                this.player.callMethod("setPolling", true);
                this.oAudio.$initHook(apf.extend(evtObj, apf.flash.getSandbox(evtObj.sandboxType)));
                break;
            case "id3":
                this.oAudio.$metadataHook({
                    type: 'metadata',
                    id3Data: evtObj
                });
                break;
            case "debug":
                apf.console.log(">> SWF DBUG: " + evtObj.msg);
                break;
        }
    },

    /**
     * Create the HTML to render the player.
     *
     * @type {Object}
     */
    createPlayer: function() {
        var div = this.htmlElement;
        if (div == null) return this;

        // place the HTML node outside of the viewport
        div.style.position = "absolute";
        div.style.width    = "1px";
        div.style.height   = "1px";
        div.style.left     = "-2000px";
        apf.flash.embed({
            // apf.flash#embed properties
            context          : this,
            htmlNode         : div,
            property         : "player",
            // movie properties
            src              : this.DEFAULT_SWF_PATH,
            //width            : "1",
            //height           : "1",
            align            : "middle",
            id               : this.name,
            quality          : "high",
            //bgcolor          : "#000000",
            //allowFullScreen  : "true",
            name             : this.name,
            flashvars        : "playerID=" + this.id,
            allowScriptAccess: "always",
            type             : "application/x-shockwave-flash",
            pluginspage      : "http://www.adobe.com/go/getflashplayer",
            menu             : "true"
        });

        return this;
    },

    $destroy: function() {
        this.callMethod('destroySound');
        if (this.player) {
            delete this.player;
            this.player = null;
        }
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/elements/audio/type_native.js)SIZE(11013)TIME(1259091144)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Element displaying an &lt;audio&gt; element
 *
 * @classDescription This class creates a &lt;audio&gt; element
 * @return {TypeNative} Returns a new &lt;audio&gt; element
 * @type {TypeNative}
 * @constructor
 * @addnode elements:audio
 *
 * @author      Mike de Boer
 * @version     %I%, %G%
 * @since       1.0
 */

apf.audio.TypeNative = function(oAudio, oNode, options) {
    this.oAudio = oAudio;

    this.inited = false;

    // Div name, flash name, and container name
    this.divName      = oAudio.$uniqueId;
    this.htmlElement  = oNode;
    this.name         = "soundmgr_" + oAudio.$uniqueId;

    // Audio props
    this.audioPath    = options.src;
    this.paused       = false;

    // Initialize player
    this.player       = null;
    apf.extend(this, apf.audio.TypeInterface);

    this.setOptions(options).createPlayer();
};

apf.audio.TypeNative.isSupported = function() {
    return apf.hasAudio;
};

apf.audio.TypeNative.prototype = {
    /**
     * Load an audio file.
     *
     * @param {String} audioPath Path to the mp3 file. If the audioPath is null,
     *                           and the mp3 is playing, it will act as a play/pause toggle.
     * @param {Number} totalTime Optional totalTime to override the mp3's built in totalTime
     */
    load: function(audioPath, totalTime) {
        if (totalTime != null)
            this.setTotalTime(totalTime);
        if (audioPath != null)
            this.audioPath = audioPath;
        if (this.audioPath == null && !this.firstLoad)
            return this.oAudio.$errorHook({type:"error", error:"SoundManager::play - No audioPath has been set."});

        if (audioPath == null && this.firstLoad && !this.autoLoad) // Allow play(null) to toggle playback
            audioPath = this.audioPath;
        this.firstLoad = false;
        this.setVolume(this.volume);
        //    .callMethod("loadSound", this.audioPath, true, this.autoPlay);
        return this;
    },

    /**
     * Play and/ or resume a audio that has been loaded already
     *
     * @type {Object}
     */
    play: function() {
        if (!this.paused)
            return this.player.play();
        return this.pause(); //toggle pause
    },

    /**
     * Toggle the pause state of the audio.
     *
     * @param {Boolean} pauseState The pause state. Setting pause state to true
     *                             will pause the audio.
     * @type {Object}
     */
    pause: function() {
        return this.player.pause();
    },

    /**
     * Stop playback of the audio.
     *
     * @type {Object}
     */
    stop: function() {
        return this.player.stop();
    },

    /**
     * Seek the audio to a specific position.
     *
     * @param {Number} seconds The number of seconds to seek the playhead to.
     * @type {Object}
     */
    seek: function(ms) {
        return this.player.currentTime = parseInt(ms) / 1000;
    },

    /**
     * Not supported.
     *
     * @type {Object}
     */
    setVolume: function(iVol) {
        this.player.volume = parseInt(iVol) / 100;
        return this;
    },

    /**
     * Retrive the position of the playhead, in seconds.
     *
     * @type {Number}
     */
    getPlayheadTime: function() {
        return this.player.playheadTime;
    },

    /**
     * Specifies the position of the playhead, in seconds.
     *
     * @default null
     * @type {Object}
     */
    setPlayheadTime: function(value) {
        this.playheadTime = parseInt(value);
        return this;
    },

    /**
     * Retrieve the total playtime of the audio, in seconds.
     *
     * @type {Number}
     */
    getTotalTime: function() {
        return this.totalTime;
    },

    /**
     * Determines the total time of the audio.  The total time is automatically determined
     * by the player, unless the user overrides it.
     *
     * @default null
     * @type {Object}
     */
    setTotalTime: function(value) {
        this.totalTime = parseInt(value);
        return this;
    },

    /**
     * Callback from flash; whenever the Flash movie bubbles an event up to the
     * javascript interface, it passes through to this function.
     * Events dispatched by SoundManager instances:
     *    > init: The player is initialized
     *    > ready: The audio is ready
     *    > progress: The audio is downloading. Properties: bytesLoaded, totalBytes
     *    > playHeadUpdate: The audio playhead has moved.  Properties: playheadTime, totalTime
     *    > stateChange: The state of the audio has changed. Properties: state
     *    > change: The player has changed.
     *    > complete: Playback is complete.
     *    > metaData: The audio has returned meta-data. Properties: infoObject
     *    > cuePoint: The audio has passed a cuePoint. Properties: infoObject
     *    > error: An error has occurred.  Properties: error
     *
     * @param {Object} eventName
     * @param {Object} evtObj
     * @type {void}
     */
    event: function(eventName, evtObj) {
        switch (eventName) {
            case "progress":
                this.bytesLoaded = evtObj.bytesLoaded;
                this.totalBytes  = evtObj.totalBytes;
                this.oAudio.$progressHook({
                    type       : "progress",
                    bytesLoaded: this.bytesLoaded,
                    totalBytes : this.totalBytes
                });
                break;
            case "playheadUpdate":
                this.playheadTime = evtObj.playheadTime;
                this.totalTime    = evtObj.totalTime;
                this.oAudio.$changeHook({
                    type        : "change",
                    playheadTime: this.playheadTime,
                    totalTime   : this.totalTime
                });
                if (evtObj.waveData || evtObj.peakData || evtObj.eqData)
                    this.oAudio.$metadataHook({
                        type    : "metadata",
                        waveData: evtObj.waveData,
                        peakData: evtObj.peakData,
                        eqData  : evtObj.eqData
                    });
                break;
            case "stateChange":
                this.state = evtObj.state;
                this.oAudio.$stateChangeHook({type:"stateChange", state:this.state});
                break;
            case "change":
                this.oAudio.$changeHook({type:"change"});
                break;
            case "complete":
                this.oAudio.$completeHook({type:"complete"});
                break;
            case "ready":
                if (this.paused && this.autoPlay)
                    this.paused = false;
                this.oAudio.$readyHook({type:"ready"});
                break;
            case "metaData":
                this.oAudio.$metadataHook({type:"metaData", infoObject:evtObj});
                break;
            case "cuePoint":
                this.oAudio.$cuePointHook({type:"cuePoint", infoObject:evtObj});
                break;
            case "init":
                this.inited = true;
                this.oAudio.$initHook(apf.extend(evtObj, apf.flash.getSandbox(evtObj.sandboxType)));
                break;
            case "id3":
                this.oAudio.$metadataHook({
                    type: 'metadata',
                    id3Data: evtObj
                });
                break;
            case "debug":
                apf.console.log(">> SWF DBUG: " + evtObj.msg);
                break;
        }
    },

    /**
     * Create the HTML to render the player.
     *
     * @type {Object}
     */
    createPlayer: function() {
        var div = this.htmlElement;
        if (div == null) return this;

        // place the HTML node outside of the viewport
        div.style.position = "absolute";
        div.style.width    = "1px";
        div.style.height   = "1px";
        div.style.left     = "-2000px";
        var a = this.player = document.createElement("audio");
        a.setAttribute("src", this.audioPath);
        a.setAttribute("volume", this.volume);
        if (this.autoPlay)
            a.setAttribute("autoplay", "true");
        div.appendChild(a);

        var _self = this,
            timeHandler;
        a.addEventListener("canplay", function() {
            _self.oAudio.$readyHook({type:"ready"});
        }, false);
        a.addEventListener("timeupdate", timeHandler = function(e) {
            //console.dir(e);
            //console.log("playing: ", _self.player.currentTime, _self.player.duration);
            _self.playheadTime = parseInt(_self.player.currentTime || 0) * 1000;
            _self.totalTime    = parseInt(_self.player.duration) * 1000;
            _self.oAudio.$changeHook({
                type        : "change",
                playheadTime: _self.playheadTime,
                totalTime   : _self.totalTime
            });
        }, false);
        a.addEventListener("duration", timeHandler, false);
        a.addEventListener("volumechange", function() {
            _self.oAudio.$changeHook({
                type   : "change",
                volume : _self.player.muted ? 0 : parseInt(_self.player.volume) * 100
            });
        }, false);
        a.addEventListener("progress", function(e) {
            _self.bytesLoaded = e.loaded;
            _self.totalBytes  = e.total;
            _self.oAudio.$progressHook({
                type       : "progress",
                bytesLoaded: _self.bytesLoaded,
                totalBytes : _self.totalBytes
            });
        }, false);
        a.addEventListener("ended", function() {
            _self.oAudio.$completeHook({type:"complete"});
        }, false);
        a.addEventListener("error", function(e) {
            throw new Error(apf.formatErrorString(0, _self, "Audio playback",
                e.message, _self.oAudio));
        }, false);

        a.load();

        return this;
    },

    $destroy: function() {
        if (!this.player) return;
        this.player.setAttribute("src", "");
        delete this.player;
        this.player = null;
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/elements/modalwindow/widget.js)SIZE(7077)TIME(1259091144)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @private
 * @constructor
 */
apf.modalwindow.widget = function(){
    var nX, nY, verdiff, hordiff, cData;
    var _self   = this;
    
    this.$isWindowContainer = false;
    this.kbclose          = false;
    this.$isWidget         = true;

    this.dragStart = function(e){
        if (!e) e = event;

        if (_self.state.indexOf("maximized") > -1 || !_self.draggable)
            return;

        nX = _self.$ext.offsetLeft - e.clientX - document.documentElement.scrollLeft;
        nY = _self.$ext.offsetTop - e.clientY - document.documentElement.scrollTop;

        var htmlNode = _self.$ext;
        var p        = _self.positionHolder;
        if (!p)
            var p = this.positionHolder = document.body.appendChild(document.createElement("div"));
        p.className  = "position_holder";

        htmlNode.parentNode.insertBefore(p, htmlNode);
        //p.style.width = (htmlNode.offsetWidth - 2) + "px";
        p.style.height  = (htmlNode.offsetHeight - (apf.isIE6 ? 0 : apf.getHeightDiff(p))) + "px";

        //var diff     = apf.getDiff(htmlNode);
        var lastSize = [htmlNode.style.width, htmlNode.style.height];
        htmlNode.style.width = (htmlNode.offsetWidth - apf.getWidthDiff(htmlNode)) + "px";
        //htmlNode.style.height = (htmlNode.offsetHeight - diff[1]) + "px";

        htmlNode.style.left = (e.clientX + nX) + "px";
        htmlNode.style.top  = (e.clientY + nY) + "px";
        htmlNode.style.position = "absolute";
        htmlNode.style.zIndex   = htmlNode.parentNode.style.zIndex = 100000;
        //htmlNode.parentNode.style.position = "relative";
        htmlNode.parentNode.style.left     = "0"; //hack
        htmlNode.parentNode.style.minHeight = (htmlNode.parentNode.offsetHeight - apf.getHeightDiff(htmlNode.parentNode)) + "px";

        if (apf.isIE < 8)
            apf.setStyleClass(htmlNode, "dockletDrag"); //@todo mayor hack!! apf3.0

        if (!apf.hasStyleFilters)
            apf.tween.fade(htmlNode, 0.8);
            
        //if (_self.$int && apf.hasSingleResizeEvent)
            //apf.layout.forceResize(_self.$int); //@todo recursive apf3.0

        apf.dragMode = true;

        cData                = [htmlNode, p];
        document.onmousemove = _self.dragMove;
        document.onmouseup   = function(){
            document.onmousemove = document.onmouseup = null;

            htmlNode.style.position = "";//relative";
            htmlNode.style.left     = 0;
            htmlNode.style.top      = 0;
            htmlNode.style.width    = lastSize[0];
            //htmlNode.style.height = lastSize[1];
            htmlNode.style.zIndex   = htmlNode.parentNode.style.zIndex = 1;
            //htmlNode.parentNode.style.position = "static";

            htmlNode.parentNode.style.minHeight = ""; //@todo apf3.0 animate here

            p.parentNode.insertBefore(htmlNode, p);
            p.parentNode.removeChild(p);
            apf.tween.fade(htmlNode, 1);

            if (apf.isIE < 8)
                apf.setStyleClass(htmlNode, "", ["dockletDrag"]); //@todo see above apf3.0

            _self.parentNode.$moveDocklet(_self);
            
            if (!apf.supportOpacity || htmlNode.className.indexOf("dockblank") > -1) //@todo hack apf3.0
                htmlNode.style.filter = "";
            
            if (_self.$ext) //apf.hasSingleResizeEvent)
                apf.layout.forceResize(_self.$ext); //@todo recursive apf3.0
            

            apf.dragMode = false;
        };
        
        if (apf.isIE) //@todo hack to solve IE bug... should investigate
            document.onmousemove();

        e.cancelBubble = true;
        return false;
    };

    //Search for insert position
    function insertInColumn(el, ey){
        var pos   = apf.getAbsolutePosition(el);
        var cy    = ey - pos[1];
        var nodes = el.childNodes;

        for (var th = 0, i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];
            if (node.nodeType != 1
              || apf.getStyle(node, "position") == "absolute")
                continue;

            th = node.offsetTop + node.offsetHeight;
            if (th > cy) {
                el.insertBefore(cData[1],
                    th - (node.offsetHeight / 2) > cy
                        ? node
                        : node.nextSibling);
                break;
            }
        }

        if (i == nodes.length)
            el.appendChild(cData[1]);
    }

    this.dragMove = function(e){
        if (!e) e = event;

        _self.$ext.style.top = "10000px";
        var ex  = e.clientX;// + document.documentElement.scrollLeft;
        var ey  = e.clientY;// + document.documentElement.scrollTop;
        var el  = document.elementFromPoint(ex, ey);
        
        if (el) {
            if (el.isColumn){
                insertInColumn(el, ey);
            }
            else {
                //search for element
                while (el.parentNode && !el.isColumn) {
                    el = el.parentNode;
                }
    
                if (el.isColumn)
                    insertInColumn(el, ey);
            }
        }
        
        _self.$ext.style.left = (e.clientX + nX + document.documentElement.scrollLeft) + "px";
        _self.$ext.style.top  = (e.clientY + nY + document.documentElement.scrollTop) + "px";

        e.cancelBubble = true;
    };

    this.$loadAml = function(x) {
        //this.$aml = x;

        this.$create();
    };
    
    this.$create = function(){
        apf.WinServer.setTop(this);

        var diff = apf.getDiff(this.$ext);
        hordiff  = diff[0];
        verdiff  = diff[1];
        
        this.oDrag.onmousedown = this.dragStart;

        this.collapsedHeight = this.$getOption("Main", "collapsed-height");

        if (this.resizable)
            this.resizable = false;

        if (this.draggable === undefined)
            this.draggable = true;

        this.minwidth  = this.$getOption("Main", "min-width");
        this.minheight = this.$getOption("Main", "min-height");
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/elements/textbox/masking.js)SIZE(13238)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @constructor
 * @private
 */
apf.textbox.masking = function(){
    /*
        Special Masking Values:
        - PASSWORD
        
        <a:Textbox name="custref" mask="CS20999999" maskmsg="" validation="/CS200[3-5]\d{4}/" invalidmsg="" bind="custref/text()" />
    */
    
    var _FALSE_ = 9128748732;

    var _REF = {
        "0" : "\\d",
        "1" : "[12]",
        "9" : "[\\d ]",
        "#" : "[\\d +-]",
        "L" : "[A-Za-z]",
        "?" : "[A-Za-z ]",
        "A" : "[A-Za-z0-9]",
        "a" : "[A-Za-z0-9 ]",
        "X" : "[0-9A-Fa-f]",
        "x" : "[0-9A-Fa-f ]",
        "&" : "[^\s]",
        "C" : "."
    };
    
    var lastPos = -1;
    var masking = false;
    var oExt    = this.$ext
    var initial, pos = [], myvalue, format, fcase, replaceChar;

    this.setPosition = function(setpos){
        setPosition(setpos || lastPos || 0);
    };

    this.addEventListener("$clear", function(){
        this.value = "";
        if (this.mask) 
            return this.setValue("");
    });
    
    this.$propHandlers["value"] = function(value){
        var data = "";
        if (this.includeNonTypedChars) {
            for (var i = 0; i < initial.length; i++) {
                if (initial.substr(i, 1) != value.substr(i, 1))
                    data += value.substr(i, 1);//initial.substr(i,1) == replaceChar
            }
        }
        
        this.$insertData(data || value);
    };
    
    //Char conversion
    var numpadKeys = {
        "96": "0",
        "97": "1",
        "98": "2",
        "99": "3",
        "100": "4",
        "101": "5",
        "102": "6",
        "103": "7",
        "104": "8",
        "105": "9",
        "106": "*",
        "107": "+",
        "109": "-",
        "110": ".",
        "110": "/"
    }
    
    this.addEventListener("keydown", function(e){
        var key  = e.keyCode,
            stop = false;

        switch (key) {
            case 39:	
                //RIGHT
                setPosition(lastPos + 1);
                stop = true;
                break;
            case 37:
                //LEFT
                setPosition(lastPos - 1);
                stop = true;
                break;
            case 35:
            case 34:
                setPosition(myvalue.length);
                stop = true;
                break;
            case 33:
            case 36:
                setPosition(0);
                stop = true;
                break;
            case 8:
                //BACKSPACE
                deletePosition(lastPos - 1);
                setPosition(lastPos - 1);
                stop = true;
                break;
            case 46:
                //DEL
                deletePosition(lastPos);
                setPosition(lastPos);
                stop = true;
                break;
            default:
                if (key == 67 && e.ctrlKey) {
                    window.clipboardData.setData("Text", this.getValue());  
                    stop = true;
                }
                /*
                else if ((key == 86 && ctrlKey) || (shiftKey && key == 45)) {
                    this.setValue(window.clipboardData.getData("Text"));
                    setPosition(lastPos);
                }
                else
                    return;*/
            break;
        }

        //@todo why isnt the conversion not always good? Check backtick.
        var chr = numpadKeys[key] || String.fromCharCode(key);
        if (setCharacter(chr))
            setPosition(lastPos + 1);

        var value, pos = lastPos;
        if (this.realtime && (value = this.getValue()) != this.value) {
            this.change(value);
            setPosition(pos);
        }

        if (apf.isCharacter(e.keyCode) || stop)
            return false;
    }, true);
    
    /* ***********************
            Init
    ************************/
    
    this.$initMasking = function(){
        ///this.keyHandler = this._keyHandler;
        this.$keyHandler = null; //temp solution
        masking = true;
        
        this.$int[apf.isIphone ? "onclick" : "onmouseup"] = function(e){
            var pos = Math.min(calcPosFromCursor(), myvalue.length);
            setPosition(pos);
            return false;
        };
        
        this.$int.onpaste = function(e){
            e = e || window.event;
            e.returnValue = false;
            this.host.setValue(window.clipboardData.getData("Text") || "");
            //setPosition(lastPos);
            $setTimeout(function(){
                setPosition(lastPos);
            }, 1); //HACK good enough for now...
        };
        
        this.getValue = function(){
            if (this.includeNonTypedChars)
                return initial == this.$int.value 
                    ? "" 
                    : this.$int.value.replace(new RegExp(replaceChar, "g"), "");
            else
                return myvalue.join("");
        };
        
        this.setValue = function(value){
            if (this.includeNonTypedChars) {
                for (var data = "", i = 0; i < initial.length; i++) {
                    if (initial.substr(i,1) != value.substr(i,1))
                        data += value.substr(i, 1);//initial.substr(i,1) == replaceChar
                }
            }
            this.$insertData(data);
        };
    };
    
    this.setMask = function(m){
        if (!masking)
            this.$initMasking();
        
        m = m.split(";");
        replaceChar = m.pop();
        this.includeNonTypedChars = parseInt(m.pop()) !== 0;
        var mask = m.join(""); //why a join here???
        var validation = "",
            visual     = "",
            mode_case  = "-",
            strmode    = false,
            startRight = false,
            chr;
        pos = [], format = "", fcase = "";
        
        for (var looppos = -1, i = 0; i < mask.length; i++) {
            chr = mask.substr(i,1);
            
            if (!chr.match(/[\!\'\"\>\<\\]/))
                looppos++;
            else {
                if (chr == "!")
                    startRight = true;
                else if (chr == "<" || chr == ">")
                    mode_case = chr;
                else if (chr == "'" || chr == "\"")
                    strmode = !strmode;
                continue;
            }
            
            if (!strmode && _REF[chr]) {
                pos.push(looppos);
                visual     += replaceChar;
                format     += chr;
                fcase      += mode_case;
                validation += _REF[chr];
            }
            else
                visual += chr;
        }

        this.$int.value = visual;
        initial         = visual;
        //pos = pos;
        myvalue = [];
        //format = format;
        //fcase = fcase;
        replaceChar = replaceChar;
        
        //setPosition(0);//startRight ? pos.length-1 : 0);
        
        //validation..
        //forgot \ escaping...
    };
    
    function checkChar(chr, p){
        var f = format.substr(p, 1);
        var c = fcase.substr(p, 1);
    
        if (chr.match(new RegExp(_REF[f])) == null)
            return _FALSE_;
        if (c == ">")
            return chr.toUpperCase();
        if (c == "<")
            return chr.toLowerCase();
        return chr;
    }

    function setPosition(p){
        if (p < 0)
            p = 0;

        if (apf.hasMsRangeObject) {
            var range = oExt.createTextRange();
            range.expand("textedit");
            range.select();

            if (pos[p] == null) {
                range.collapse(false);
                range.select();
                lastPos = pos.length;
                return false;
            }

            range.collapse();
            range.moveStart("character", pos[p]);
            range.moveEnd("character", 1);
            range.select();
        }
        else {
            if (typeof pos[p] == "undefined") {
                oExt.selectionStart = oExt.selectionEnd = pos[pos.length - 1] + 1;
                lastPos = pos.length;
                return false;
            }
            oExt.selectionStart = pos[p];
            oExt.selectionEnd   = pos[p] + 1;
        }

        lastPos = p;
    }
    
    function setCharacter(chr){
        if (pos[lastPos] == null) return false;
        
        chr = checkChar(chr, lastPos);
        if (chr == _FALSE_) return false;

        if (apf.hasMsRangeObject) {
            var range = oExt.createTextRange();
            range.expand("textedit");
            range.collapse();
            range.moveStart("character", pos[lastPos]);
            range.moveEnd("character", 1);
            range.text = chr;
            if (apf.document.activeElement == this)
                range.select();
        }
        else {
            var val    = oExt.value,
                start  = oExt.selectionStart,
                end    = oExt.selectionEnd;
            oExt.value = val.substr(0, start) + chr + val.substr(end);
            oExt.selectionStart = start;
            oExt.selectionEnd   = end;
        }
        
        myvalue[lastPos] = chr;
        
        return true;
    }
    
    function deletePosition(p){
        if(pos[p] == null) return false;
        
        if (apf.hasMsRangeObject) {
            var range = oExt.createTextRange();
            range.expand("textedit");
            range.collapse();

            range.moveStart("character", pos[p]);
            range.moveEnd("character", 1);
            range.text = replaceChar;
            range.select();
        }
        else {
            var val    = oExt.value,
                start  = pos[p],
                end    = pos[p] + 1;
            oExt.value = val.substr(0, start) + replaceChar + val.substr(end);
            oExt.selectionStart = start;
            oExt.selectionEnd   = end;
        }
        
        //ipv lastPos
        myvalue[p] = " ";
    }
    
    this.$insertData = function(str){
        if (str == this.getValue()) return;
        
        var i, j;
        
        try {
            if (!apf.hasMsRangeObject && oExt.selectionStart == oExt.selectionEnd) {
                setPosition(0); // is this always correct? practice will show...
            }
        }
        catch (ex) {
            // in FF (as we know it), we cannot access the selectStart property
            // when the control/ input doesn't have the focus or is not visible.
            // A workaround is provided here...
            if (!str) return;
            var chr, val;
            for (i = 0, j = str.length; i < j; i++) {
                lastPos = i;
                if (pos[lastPos] == null) continue;
                chr = checkChar(str.substr(i, 1), i);
                if (chr == _FALSE_) continue;
                val = oExt.value;
                oExt.value = val.substr(0, pos[i]) + chr + val.substr(pos[i] + 1);
            }
            if (str.length)
                lastPos++;
            return; // job done, bail out
        }

        str = this.dispatchEvent("insert", { data : str }) || str;
        
        if (!str) {
            if (!this.getValue()) return; //maybe not so good fix... might still flicker when content is cleared
            for (i = this.getValue().length - 1; i >= 0; i--)
                deletePosition(i);
            setPosition(0);	
            return;
        }
        
        for (i = 0, j = str.length; i < j; i++) {
            lastPos = i;
            setCharacter(str.substr(i, 1));
            if (!apf.hasMsRangeObject)
                setPosition(i + 1);
        }
        if (str.length)
            lastPos++;
    };
    
    function calcPosFromCursor(){
        var range, lt = 0;

        if (!apf.hasMsRangeObject) {
            lt = oExt.selectionStart;
        }
        else {
            range  = document.selection.createRange();
            var r2 = range.duplicate();
            r2.expand("textedit");
            r2.setEndPoint("EndToStart", range);
            lt = r2.text.length;
        }
    
        for (var i = 0; i < pos.length; i++) {
            if (pos[i] > lt)
                return (i == 0) ? 0 : i - 1;
        }

        return myvalue.length; // always return -a- value...
    }
};




/*FILEHEAD(/var/lib/platform/source/trunk/elements/textbox/autocomplete.js)SIZE(7030)TIME(1257329183)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Adds autocomplete to the textbox element
 *
 * @define textbox
 * @allowchild autocomplete
 * @define autocomplete
 * @attribute {String} [nodeset]    how to retrieve the nodeset. This is a combination of model name and an xpath statement seperated by a colon (i.e. mdlUsers:users)
 * @attribute {String} [method]     the name of a function that returns a nodeset.
 * @attribute {String} value        an xpath which selects the value of each node in the nodeset.
 * @attribute {String} [count]      the number of visible items in the list at the same time.
 * @attribute {String} [sort]       an xpath on which the list is ordered.
 *
 * @constructor
 * @private
 */

apf.textbox.autocomplete = function(){
    /*
        missing features:
        - web service based autocomplete
    */
    var autocomplete = {};
    
    this.initAutocomplete = function(ac){
        ac.parentNode.removeChild(ac);
        autocomplete.nodeset   = ac.getAttribute("nodeset").split(":");
        autocomplete.method    = ac.getAttribute("method");
        autocomplete.value     = ac.getAttribute("value");
        autocomplete.count     = parseInt(ac.getAttribute("count")) || 5;
        autocomplete.sort      = ac.getAttribute("sort");
        autocomplete.lastStart = -1;
        
        this.oContainer = apf.insertHtmlNode(this.$getLayoutNode("container"),
            this.$ext.parentNode, this.$ext.nextSibling);	
    };
    
    this.fillAutocomplete = function(keyCode){
        if (keyCode) {
            switch(keyCode){
                case 9:
                case 27: 
                case 13:  
                    return this.oContainer.style.display = "none";
                case 40: //DOWN
                    if(autocomplete.suggestData 
                      && autocomplete.lastStart < autocomplete.suggestData.length){
                        this.clear();
                        var value       = autocomplete.suggestData[autocomplete.lastStart++];
                        this.$int.value = value; //hack!
                        this.change(value);
                        //this.$int.select(); this.$int.focus();
                        this.oContainer.style.display = "none";
                        return;
                    }
                    break;
                case 38: //UP
                    if (autocomplete.lastStart > 0) {
                        if(autocomplete.lastStart >= autocomplete.suggestData.length) 
                            autocomplete.lastStart = autocomplete.suggestData.length - 1;

                        this.clear();
                        var value = autocomplete.suggestData[autocomplete.lastStart--];
                        this.$int.value = value; //hack!
                        this.change(value);
                        //this.$int.select(); this.$int.focus();
                        this.oContainer.style.display = "none";
                        return;
                    }
                    break;
            }
            
            if (keyCode > 10 && keyCode < 20) return;
        }
        
        if (autocomplete.method) {
            var start = 0, suggestData = self[autocomplete.method]();
            autocomplete.count = suggestData.length;
        }
        else {
            if (this.$int.value.length == 0){
                this.oContainer.style.display = "none";
                return;
            }
            if (!autocomplete.suggestData) {
                //Get data from model
                var nodes = self[autocomplete.nodeset[0]].data.selectNodes(autocomplete.nodeset[1]);
                for(var value, suggestData = [], i = 0; i < nodes.length; i++) {
                    value = apf.queryValue(nodes[i], autocomplete.value);
                    if (value)
                        suggestData.push(value.toLowerCase());
                }
                if (autocomplete.sort)
                    suggestData.sort();
                autocomplete.suggestData = suggestData;
            }
            else {
                suggestData = autocomplete.suggestData;
            }
            
            //Find Startpoint in lookup list
            var value = this.$int.value.toUpperCase();
            for(var start = suggestData.length - autocomplete.count, i = 0; i < suggestData.length; i++) {
                if (value <= suggestData[i].toUpperCase()) {
                    start = i;
                    break;
                }
            }
            autocomplete.lastStart = start;
        }
        
        //Create html items
        this.oContainer.innerHTML  = "";
        this.oContainer.style.left = this.$int.offsetLeft + "px";
        this.oContainer.style.top  = this.$int.offsetTop + "px";
        
        for (var arr = [], j = start; j < Math.min(start + autocomplete.count, suggestData.length); j++) {
            this.$getNewContext("item")
            var oItem = this.$getLayoutNode("item");
            apf.setNodeValue(this.$getLayoutNode("item", "caption"), suggestData[j]);
            
            oItem.setAttribute("onmouseover", 'this.className = "hover"');
            oItem.setAttribute("onmouseout",  'this.className = ""');
            oItem.setAttribute("onmousedown", 'event.cancelBubble = true');
            oItem.setAttribute("onclick",
               "var o = apf.lookup(" + this.$uniqueId + ");\
                o.$int.value = this.innerHTML;\
                o.change(this.innerHTML);\
                o.$int.select();\
                o.$int.focus();\
                o.oContainer.style.display = 'none';");
            
            arr.push(this.$getLayoutNode("item"));
        }
        apf.insertHtmlNode(arr, this.oContainer);
        
        this.oContainer.style.display = "block";
    };
    
    this.setAutocomplete = function(model, each, value){
        autocomplete.lastStart   = -1;
        autocomplete.suggestData = null;
        
        autocomplete.nodeset = [model, each];
        autocomplete.value = value;
        this.oContainer.style.display = "none";
    };
};




/*FILEHEAD(/var/lib/platform/source/trunk/elements/textbox/autocomplete2.js)SIZE(14468)TIME(1258118723)*/




/*FILEHEAD(/var/lib/platform/source/trunk/elements/xmpp/muc.js)SIZE(12364)TIME(1257329183)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Interface implementing a Multi User Chat service for the apf.xmpp object.
 * The Multi User Chat class is a class that contains all the functions needed
 * to start, end, join, leave any XMPP/ Jabber chat room, and more.
 * @link http://xmpp.org/extensions/xep-0045.html
 *
 * @author      Mike de Boer
 * @version     %I%, %G%
 * @since       3.0
 * @classDescription This class intantiates a new XMPP MUC object
 * @return {apf.xmpp.Roster} A new XMPP MUC object
 * @type {Object}
 * @constructor
 */
apf.xmpp_muc = function(){
    var _self   = this,
        mucVars = {},
        // munge often-used strings
        SID     = "SID",
        JID     = "JID",
        CONN    = "connected";
    this.$mucRoster = new apf.xmpp_roster(this.oMucModel, {muc: true}, this.resource);

    /*
     * Wrapper function for apf.xmpp.$doXmlRequest. Since all MUC request are 
     * asynchronous - responses to each call return via the message poll/ push -
     * the only variable left for each request is the text body.
     * 
     * @param {String} sBody
     * @private
     */
    function doRequest(sBody) {
        if (!sBody) return;
        _self.$doXmlRequest(_self.$restartListener, _self.$isPoll
            ? _self.$createStreamElement(null, null, sBody)
            : _self.$createBodyElement({
                rid   : _self.$getRID(),
                sid   : _self.$serverVars[SID],
                xmlns : apf.xmpp.NS.httpbind
            }, sBody)
        );
    }

    /**
     * Get the status code from a server response XML document and compare it
     * with an expected status 'iStatus'. Status codes are usually located in a
     * 'code' attribute on a <status> stanza.
     *
     * @param {XMLDocument} oXml    Document that may contain <status> nodes
     * @param {Number}      iStatus Expected status code
     * @type  {mixed}
     */
    this.$getStatusCode = function(oXml, iStatus) {
        var aStatuses = oXml.getElementsByTagName("status");
        for (var i = 0, l = aStatuses.length; i < l; i++) {
            if (aStatuses[i]
              && parseInt(aStatuses[i].getAttribute("code")) == iStatus)
                return iStatus;
        }
        return false;
    }

    /**
     * Get a list of available chat rooms from the XMPP server.
     * 
     * @type {void}
     */
    this.queryRooms = function() {
        if (!this.$canMuc || !this.$serverVars[CONN]) return;
        doRequest(this.$createIqBlock({
                from  : this.$serverVars[JID],
                to    : this.$mucDomain,
                type  : "get",
                id    : this.$makeUnique("disco")
            }, "<query xmlns='" + apf.xmpp.NS.disco_items + "'/>")
        );
    };

    /**
     * Adds/ registers a room to the local Roster instance.
     * 
     * @param {String} sJID    Jabber ID of the room we're adding
     * @param {String} [sName] Optional name of the room
     */
    this.$addRoom = function(sJID, sName) {
        return this.$mucRoster.getEntityByJID(sJID.replace(/\/.*$/, ""), sName);
    };

    /**
     * Checks if a specified Jabber ID is registered locally as a chatroom.
     * 
     * @param {String} sJID Jabber ID to check
     * @type  {void}
     */
    this.$isRoom = function(sJID) {
        var parts = sJID.replace(/\/.*$/, "").split("@");
        return this.$mucRoster.getEntity(parts[0], parts[1], null, true) 
            ? true
            : false;
    };

    /**
     * Add a Jabber ID - who most probably just joined - to a chatroom and 
     * thereby to the Roster.
     * 
     * @param {String} sJID Jabber ID that just joined a chatroom
     * @type  {Object}
     */
    this.$addRoomOccupant = function(sJID) {
        return this.$mucRoster.getEntityByJID(sJID);
    };

    /**
     * Provided a room, get all its info and capabilities.
     * Not implemented yet.
     * 
     * @param {String} sRoom
     */
    this.queryRoomInfo = function(sRoom) {
        // @todo Room info querying
    };

    this.getRoom = function(sRoom, callback) {
        if (!this.$canMuc || !this.$serverVars[CONN]) return;
        mucVars["room_cb_" + sRoom] = callback;
        doRequest(this.$createIqBlock({
                from  : this.$serverVars[JID],
                to    : sRoom,
                type  : "get",
                id    : this.$makeUnique("disco")
            }, "<query xmlns='" + apf.xmpp.NS.disco_items + "'/>")
        );
    };

    this.$mucSignal = function(iType, sRoom) {
        sRoom  = sRoom.replace(/\/.*$/, "");
        var f  = "room_cb_" + sRoom,
            cb = mucVars[f];
        delete mucVars[f];
        if (typeof cb != "function") return;
        switch (iType) {
            case apf.xmpp_muc.ROOM_CREATE:
            case apf.xmpp_muc.ROOM_EXISTS:
                cb(true);
                break;
            case apf.xmpp_muc.ROOM_NOTFOUND:
                cb(false);
                break;
        }
    };

    this.joinRoom = function(sRoom, sPassword, sNick) {
        // @todo check for reserved nickname as described in
        //       http://xmpp.org/extensions/xep-0045.html#reservednick
        if (!sRoom || !this.$canMuc || !this.$serverVars[CONN]) return;
        if (!sNick)
            sNick = this.$serverVars["username"];
        var parts = sRoom.split("@");
        this.$mucRoster.registerAccount(parts[0], parts[1], sNick);
        doRequest(this.$createPresenceBlock({
                from  : this.$serverVars[JID],
                to    : sRoom + "/" + sNick
            },
            "<x xmlns='" + apf.xmpp.NS.muc + (sPassword
                ? "'><password>" + sPassword + "</x>"
                : "'/>"))
        );
    };

    this.leaveRoom = function(sRoom, sMsg, sNick) {
        if (!sRoom || !this.$canMuc || !this.$serverVars[CONN]) return;
        if (!sNick)
            sNick = this.$serverVars["username"];
        doRequest(this.$createPresenceBlock({
                from  : this.$serverVars[JID],
                to    : sRoom + "/" + sNick,
                type  : apf.xmpp.TYPE_UNAVAILABLE
            }, sMsg ? "<status>" + sMsg + "</status>" : "")
        );
    };

    this.leaveAllRooms = function(sMsg, sNick) {
        if (!this.$canMuc || !this.$serverVars[CONN]) return;
        if (!sNick)
            sNick = this.$serverVars["username"];
        var i, l, aRooms = this.$mucRoster.getRooms();
        for (i = 0, l = aRooms.length; i < l; i++)
            this.leaveRoom(aRooms[i].bareJID, sMsg, sNick);
    };

    this.changeNick = function(sRoom, sNewNick) {
        if (!sRoom || !this.$canMuc || !this.$serverVars[CONN]) return;
        if (!sNewNick)
            sNewNick = this.username;
        var parts = sRoom.split("@");
        this.$mucRoster.registerAccount(parts[0], parts[1], sNewNick);
        doRequest(this.$createPresenceBlock({
                from  : this.$serverVars[JID],
                to    : sRoom + "/" + sNewNick
            })
        );
    };

    this.invite = function(sRoom, sJID, sReason) {
        var oUser = this.$serverVars["roster"].getEntityByJID(sJID);
        if (!oUser) return;

        doRequest(createMessageBlock({
                from : _self.$serverVars[JID],
                to   : sRoom
            },
            "<x xmlns='" + apf.xmpp.NS.muc_user + "'><invite to='"
            + oUser.bareJID + (sReason
                ? "'><reason>" + sReason + "</reason></invite>"
                : "'/>") + "</x>")
        );
    };

    this.declineInvite = function(sRoom, sJID, sReason) {
        var oUser = this.$serverVars["roster"].getEntityByJID(sJID);
        if (!oUser) return;

        doRequest(createMessageBlock({
                from : _self.$serverVars[JID],
                to   : sRoom
            },
            "<x xmlns='" + apf.xmpp.NS.muc_user + "'><decline to='"
            + oUser.bareJID + (sReason
                ? "'><reason>" + sReason + "</reason></invite>"
                : "'/>") + "</x>")
        );
    };

    this.moderate = function(action, options) {
        // @todo
    };

    this.createRoom = function(sRoom, sNick, callback) {
        // @todo implement/ support Reserved Rooms
        if (!sRoom || !this.$canMuc || !this.$serverVars[CONN]) return;
        if (!sNick)
            sNick = this.$serverVars["username"];
        sRoom = this.$mucRoster.sanitizeJID(sRoom);
        var parts = sRoom.split("@"),
            f     = "room_cb_" + sRoom;
        this.$mucRoster.registerAccount(parts[0], parts[1], sNick);

        mucVars[f] = function(bSuccess) {
            // @todo notify user
            delete mucVars[f];
            if (!bSuccess)
                return (typeof callback == "function" ? callback(bSuccess) : false);
            mucVars[f] = function(bSuccess) {
                delete mucVars[f];
                _self.$addRoom(sRoom, sRoom.substr(0, sRoom.indexOf("@")));
                if (callback)
                    callback(bSuccess);
            };
            doRequest(_self.$createIqBlock({
                    from  : _self.$serverVars[JID],
                    to    : sRoom,
                    type  : "set",
                    id    : _self.$makeUnique("create")
                },
                "<query xmlns='" + apf.xmpp.NS.muc_owner + "'><x xmlns='"
                + apf.xmpp.NS.data + "' type='submit'/></query>")
            );
        };

        doRequest(this.$createPresenceBlock({
                from  : this.$serverVars[JID],
                to    : sRoom + "/" + sNick
            },
            "<x xmlns='" + apf.xmpp.NS.muc + "'/>")
        );
    };

    this.joinOrCreateRoom = function(sRoom, sNick) {
        if (!sRoom || !this.$canMuc || !this.$serverVars[CONN]) return;
        if (!sNick)
            sNick = this.$serverVars["username"];
        var parts = sRoom.split("@");
        this.$mucRoster.registerAccount(parts[0], parts[1], sNick);
        sRoom = this.$mucRoster.sanitizeJID(sRoom);
        this.getRoom(sRoom, function(bSuccess) {
            if (bSuccess) //@todo should we provide a password input prompt?
                return _self.joinRoom(sRoom, null, sNick);
            _self.createRoom(sRoom, sNick, function(bSuccess2) {
                if (bSuccess2)
                    _self.joinRoom(sRoom, null, sNick);
            });
        });
    };

    this.destroyRoom = function(sRoom, sReason) {
        if (!sRoom || !this.$canMuc || !this.$serverVars[CONN]) return;
        doRequest(this.$createIqBlock({
                from  : this.$serverVars[JID],
                to    : sRoom,
                type  : "set",
                id    : this.$makeUnique("create")
            },
            "<query xmlns='" + apf.xmpp.NS.muc_owner + "'><destroy jid='"
            + sRoom + (sReason 
                ? "'><reason>" + sReason + "</reason></destroy>"
                : "'/>")
            + "</query>")
        );
    };

    // @todo: implement room registration as per JEP-77
    // @todo: implement all moderator features
    // @todo: implement all admin & owner features
};

apf.xmpp_muc.ROOM_CREATE    = 1;
apf.xmpp_muc.ROOM_EXISTS    = 2;
apf.xmpp_muc.ROOM_NOTFOUND  = 3;
apf.xmpp_muc.ROOM_JOINED    = 4;
apf.xmpp_muc.ROOM_LEFT      = 5;

apf.xmpp_muc.ACTION_SUBJECT = 0x0001;
apf.xmpp_muc.ACTION_KICK    = 0x0002;
apf.xmpp_muc.ACTION_BAN     = 0x0004;
apf.xmpp_muc.ACTION_GRANT   = 0x0008;
apf.xmpp_muc.ACTION_REVOKE  = 0x0010;




/*FILEHEAD(/var/lib/platform/source/trunk/elements/xmpp/roster.js)SIZE(11173)TIME(1258118723)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Element implementing a Roster service for the apf.xmpp object.
 * The Roster is a centralised registry for Jabber ID's (JID) to which
 * the user subscribed. Whenever the presence info of a JID changes, the roster
 * will get updated accordingly.
 * @todo implement removal of entities
 *
 * @author      Mike de Boer
 * @version     %I%, %G%
 * @since       3.0
 * @classDescription This class intantiates a new XMPP Roster object
 * @return {apf.xmpp.Roster} A new XMPP Roster object
 * @type {Object}
 * @constructor
 */
apf.xmpp_roster = function(model, modelContent, res) {
    this.resource = res;
    this.username = this.domain = this.fullJID = "";

    var aEntities = [],
        aRooms    = [],
        userProps = {"node": 1, "domain": 1, "resource": 1, "bareJID": 1,
                     "fullJID": 1, "status": 1};

    this.registerAccount = function(username, domain, resource) {
        if (!resource)
            resource = this.resource;
        else
            this.resource = resource;
        this.username = username || "";
        this.domain   = domain   || "";
        this.bareJID  = this.username + "@" + this.domain;
        this.fullJID  = this.username + "@" + this.domain
            + (resource ? "/" + resource : "");
    };

    /**
     * Lookup function; searches for a JID with node object, domain and/ or
     * resource info provided.
     * It may return an collection of JID's when little info to search with is
     * provided.
     *
     * @param {String} node
     * @param {String} domain
     * @param {String} resource
     * @type  {mixed}
     */
    this.getEntity = function(node, domain, resource, bRoom) {
        if (typeof node == "undefined") return null;

        var aResult = [];

        // the code below is just a failsafe for user items that arrive through
        // an <IQ> query for a roster.
        if (node.indexOf("@") != -1) {
            var aTemp = node.split("@");
            node      = aTemp[0];
            domain    = aTemp[1];
        }

        var n, i, l, oExact,
            bResource = (resource && !bRoom),
            fullJID   = node + "@" + domain + (resource ? "/" + resource : "");

        for (i = 0, l = aEntities.length; i < l; i++) {
            n = aEntities[i]
            if (n && n.node == node && n.domain == domain
              && (!bResource || n.resources.contains(resource))
              && (!bRoom || n.isRoom)) {
                aResult.push(n);
                if (n.fullJID == fullJID)
                    oExact = n;
            }
        }

        if (aResult.length === 0)
            return null;

        if (aResult.length > 1 && oExact)
            return oExact;

        return (aResult.length == 1) ? aResult[0] : aResult;
    };

    /**
     * Lookup function; searches for a JID object with JID info provided in the
     * following, common, XMPP format: 'node@domain/resource'
     *
     * @param {String}  jid
     * @param {String}  [sSubscr]
     * @param {String}  [sGroup]
     * @param {Boolean} [bRoom]
     * @type  {Object}
     */
    this.getEntityByJID = function(jid, options) {
        var resource = null, node;
        if (!options)
            options = {};

        if (jid.indexOf("/") != -1) {
            resource = jid.substring(jid.indexOf("/") + 1) || "";
            jid      = jid.substring(0, jid.indexOf("/"));
        }
        if (jid.indexOf("@") != -1) {
            node = jid.substring(0, jid.indexOf("@"));
            jid  = jid.substring(jid.indexOf("@") + 1);
        }

        var domain  = jid,
            oEnt    = this.getEntity(node, domain,
                        modelContent.muc ? resource : null),
            bareJID = node + "@" + domain;

        // Auto-add new users with status TYPE_UNAVAILABLE
        // Status TYPE_AVAILABLE only arrives with <presence> messages
        if (!oEnt) {// && node && domain) {
            var bIsRoom = (modelContent.muc && !resource);
            oEnt = this.update({
                node        : node,
                domain      : domain,
                resources   : resource ? [resource] : [],
                bareJID     : bareJID,
                fullJID     : bareJID + (resource ? "/" + resource : ""),
                isRoom      : bIsRoom,
                room        : (modelContent.muc && resource) ? bareJID : null,
                roomJID     : null,
                subscription: options.subscription || "",
                affiliation : null,
                role        : null,
                group       : options.group || "",
                status      : (bIsRoom || (modelContent.muc && resource))
                    ? apf.xmpp.TYPE_AVAILABLE
                    : apf.xmpp.TYPE_UNAVAILABLE
            });
        }
        else {
            this.update(apf.extend(oEnt, options));
        }

        //adding of an additional 'resource'...except for chat rooms
        if (resource && oEnt && !oEnt.isRoom && !oEnt.resources.contains(resource)) {
            oEnt.resources.push(resource);
            oEnt.fullJID = bareJID + "/" + resource;
        }

        return oEnt;
    };

    /**
     * When a JID is added, deleted or updated, it will pass this function that
     * marshalls the Roster contents.
     * It ensures that the Remote SmartBindings link with a model is synchronized
     * at all times.
     *
     * @param {Object} oEnt
     * @param {Number} status
     * @type  {Object}
     */
    this.update = function(oEnt, status) {
        if (!oEnt.xml) {
            var bIsAccount = (oEnt.node == this.username
                              && oEnt.domain == this.domain
                              && (!modelContent.muc || oEnt.resources.contains(this.resource)));
            aEntities.push(oEnt);
            if (oEnt.isRoom)
                aRooms.push(oEnt);
            // Update the model with the new User
            if (model && (modelContent.roster || modelContent.muc)) {
                oEnt.xml = model.data.ownerDocument.createElement(bIsAccount
                    ? "account"
                    : oEnt.isRoom ? "room" : "user");
                this.updateEntityXml(oEnt);
                apf.xmldb.appendChild((oEnt.room && !oEnt.isRoom)
                    ? this.getEntity(oEnt.node, oEnt.domain, null, true).xml
                    : model.data, oEnt.xml);
            }
        }

        if (typeof status != "undefined")
            oEnt.status = status;

        return this.updateEntityXml(oEnt);
    };

    /**
     * Propagate any change in the JID to the model to which the XMPP connection
     * is attached.
     *
     * @param {Object} oEnt
     * @type  {Object}
     */
    this.updateEntityXml = function(oEnt) {
        if (!oEnt || !oEnt.xml) return null;
        for (var i in userProps) {
            if (typeof oEnt[i] != "undefined")
                oEnt.xml.setAttribute(i, oEnt[i]);
        }
        if (modelContent.muc) {
            oEnt.xml.setAttribute("name", oEnt.isRoom 
                ? oEnt.subscription
                : oEnt.resources[oEnt.resources.length - 1]);
            if (!oEnt.isRoom && oEnt.room)
                oEnt.xml.setAttribute("room", oEnt.room);
        }

        apf.xmldb.applyChanges("synchronize", oEnt.xml);

        return oEnt;
    };

    /**
     * Append incoming chat messages to the user XML element, so they are
     * accessible to the model.
     *
     * @param {String} sJID The Jabber Identifier of the sender
     * @param {String} sMsg The actual message
     * @type  {void}
     */
    this.updateMessageHistory = function(sJID, sMsg) {
        if (!model || !(modelContent.chat || modelContent.muc)) return false;

        var oEnt, oRoom;
        if (modelContent.muc)
            oRoom = this.getEntityByJID(sJID.replace(/\/.*$/, ""));
        oEnt = this.getEntityByJID(sJID);
        if (!oEnt || !oEnt.xml) return false;

        var oDoc = model.data.ownerDocument,
            oMsg = oDoc.createElement("message");
        oMsg.setAttribute("from", sJID);
        oMsg.appendChild(oDoc.createTextNode(sMsg));

        apf.xmldb.appendChild((oRoom ? oRoom.xml : oEnt.xml), oMsg);
        apf.xmldb.applyChanges("synchronize", oEnt.xml);

        // only send events to messages from contacts, not the acount itself
        return !(oEnt.node == this.username && oEnt.domain == this.domain);
    };

    /**
     * API; return the last JID that is available for messaging through XMPP.
     *
     * @type {Object}
     */
    this.getLastAvailableEntity = function() {
        for (var i = aEntities.length - 1; i >= 0; i--) {
            if (aEntities[i].status !== apf.xmpp.TYPE_UNAVAILABLE)
                return aEntities[i];
        }

        return null;
    };

    /**
     * Get the full list (Array) of rooms that are currently active/ used/ 
     * available.
     * 
     * @type {Array}
     */
    this.getRooms = function() {
        return aRooms;
    };

    /**
     * Get the full list (Array) of entities (users/ contacts).
     * 
     * @param {Number}  [iStatus]  Optional. Required status of the returned entities
     * @param {Boolean} [bIncSelf] Optional. Whether to include the user himself
     * @type  {Array}
     */
    this.getAllEntities = function(iStatus, bIncSelf) {
        if (typeof iStatus != "string")
            return aEntities;

        var o = [],
            i = 0,
            l = aEntities.length;
        for (; i < l; i++) {
            if (!bIncSelf && aEntities[i].bareJID == this.bareJID) continue;
            if (aEntities[i].status == iStatus)
                o.push(aEntities[i]);
        }

        return o;
    };

    /**
     * Reset this roster instance to its original values.
     *
     * @type {void}
     */
    this.reset = function() {
        if (model)
            model.reset();
        aEntities = [];
        aRooms    = [];
        this.username = this.domain = this.fullJID = "";
    };

    /**
     * Clean a JID (Jabber ID) of unwanted cruft.
     * 
     * @param {String} sJID Jabber ID to process.
     * @type  {String}
     */
    this.sanitizeJID = function(sJID) {
        return sJID.replace(/[\"\s\&\\\/\:<>]+/, "");
    };
};




/*FILEHEAD(/var/lib/platform/source/trunk/elements/video/type_qt.js)SIZE(23357)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.video.TypeQTCompat = (function(){
    var gTagAttrs           = null;
    var gQTBehaviorID       = "qt_event_source";
    var gQTEventsEnabled    = true;

    /**
     * Create an <OBJECT> tag for Internet Explorer only, that will enable us to
     * capture events from the Quicktime Player object.
     *
     * @type {String}
     */
    function _QTGenerateBehavior(){
        return apf.isIE
            ? '<object id="' + gQTBehaviorID
              + '" classid="clsid:CB927D12-4FF7-4a9e-A169-56E4B8A75598" \
              codebase="http://www.apple.com/qtactivex/qtplugin.cab#version=7,3,0,0"></object>'
            : '';
    }

    /**
     * Check if the behavior object from _QTGenerateBehavior() has been inserted
     * into the DOM already.
     *
     * @param {String} callingFcnName
     * @param {Object} args
     * @type  {Boolean}
     */
    function _QTPageHasBehaviorObject(callingFcnName, args){
        var haveBehavior = false;
        var objects = document.getElementsByTagName("object");

        for (var ndx = 0, obj; obj = objects[ndx]; ndx++) {
            if (obj.getAttribute("classid") == "clsid:CB927D12-4FF7-4a9e-A169-56E4B8A75598") {
                if (obj.getAttribute("id") == gQTBehaviorID)
                    haveBehavior = false;
                break;
            }
        }

        return haveBehavior;
    }

    /**
     * Check if we should insert an object tag for behaviors seperately, in order
     * to be able to catch events.
     *
     * @type {Boolean}
     */
    function _QTShouldInsertBehavior(){
        var shouldDo = false;

        if (gQTEventsEnabled && apf.isIE && !_QTPageHasBehaviorObject())
            shouldDo = true;

        return shouldDo;
    }

    /**
     * Apple function soup.
     *
     * @param {String} prefix
     * @param {String} slotName
     * @param {String} tagName
     */
    function _QTAddAttribute(prefix, slotName, tagName){
        var value;

        value = gTagAttrs[prefix + slotName];
        if (null == value)
            value = gTagAttrs[slotName];

        if (null != value) {
            if (0 == slotName.indexOf(prefix) && (null == tagName))
                tagName = slotName.substring(prefix.length);
            if (null == tagName)
                tagName = slotName;
            return ' ' + tagName + '="' + value + '"';
        }
        else
            return "";
    }

    /**
     * Apple function soup.
     *
     * @param {String} slotName
     * @param {String} tagName
     */
    function _QTAddObjectAttr(slotName, tagName){
        // don't bother if it is only for the embed tag
        if (0 == slotName.indexOf("emb#"))
            return "";

        if (0 == slotName.indexOf("obj#") && (null == tagName))
            tagName = slotName.substring(4);

        return _QTAddAttribute("obj#", slotName, tagName);
    }

    /**
     * Create and parse an attribute of the <EMBED> that is created.
     *
     * @param {String} slotName
     * @param {String} tagName
     * @type  {String}
     */
    function _QTAddEmbedAttr(slotName, tagName){
        // don't bother if it is only for the object tag
        if (0 == slotName.indexOf("obj#"))
            return "";

        if (0 == slotName.indexOf("emb#") && (null == tagName))
            tagName = slotName.substring(4);

        return _QTAddAttribute("emb#", slotName, tagName);
    }

    /**
     * Create a <PARAM> tag to be placed inside an <OBJECT> tag
     *
     * @param {String}  slotName
     * @param {Boolean} generateXHTML
     * @type  {String}
     */
    function _QTAddObjectParam(slotName, generateXHTML){
        var paramValue;
        var paramStr = "";
        var endTagChar = (generateXHTML) ? " />" : ">";

        if (-1 == slotName.indexOf("emb#")) {
            // look for the OBJECT-only param first. if there is none, look for a generic one
            paramValue = gTagAttrs["obj#" + slotName];
            if (null == paramValue)
                paramValue = gTagAttrs[slotName];

            if (0 == slotName.indexOf("obj#"))
                slotName = slotName.substring(4);

            if (null != paramValue)
                paramStr = '<param name="' + slotName + '" value="' + paramValue + '"' + endTagChar;
        }

        return paramStr;
    }

    /**
     * Unset all globally declared attributes to its original values.
     *
     * @type {void}
     */
    function _QTDeleteTagAttrs(){
        for (var ndx = 0; ndx < arguments.length; ndx++) {
            var attrName = arguments[ndx];
            delete gTagAttrs[attrName];
            delete gTagAttrs["emb#" + attrName];
            delete gTagAttrs["obj#" + attrName];
        }
    }

    /**
     * Generate an embed and object tag, return as a string
     *
     * @param {String}  callingFcnName
     * @param {Boolean} generateXHTML
     * @param {Array}   args
     * @type  {String}
     */
    function _QTGenerate(callingFcnName, generateXHTML, args){
        // allocate an array, fill in the required attributes with fixed place params and defaults
        gTagAttrs = {
            src        : args[0],
            width      : args[1],
            height     : args[2],
            classid    : "clsid:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B",
            //Important note: It is recommended that you use this exact classid in order to ensure a seamless experience for all viewers
            pluginspage: "http://www.apple.com/quicktime/download/"
        };

        // set up codebase attribute with specified or default version before parsing args so
        // anything passed in will override
        var activexVers = args[3]
        if ((null == activexVers) || ("" == activexVers))
            activexVers = "7,3,0,0";
        gTagAttrs["codebase"] = "http://www.apple.com/qtactivex/qtplugin.cab#version=" + activexVers;

        var attrName, attrValue;

        // add all of the optional attributes to the array
        for (var ndx = 4; ndx < args.length; ndx += 2) {
            attrName = args[ndx].toLowerCase();
            attrValue = args[ndx + 1];

            gTagAttrs[attrName] = attrValue;

            if (("postdomevents" == attrName) && (attrValue.toLowerCase() != "false")) {
                gQTEventsEnabled = true;
                if (apf.isIE)
                    gTagAttrs["obj#style"] = "behavior:url(#" + gQTBehaviorID + ")";
            }
        }

        // init both tags with the required and "special" attributes
        var objTag = ["<object ",
            _QTAddObjectAttr("classid"),
            _QTAddObjectAttr("width"),
            _QTAddObjectAttr("height"),
            _QTAddObjectAttr("codebase"),
            _QTAddObjectAttr("name"),
            _QTAddObjectAttr("id"),
            _QTAddObjectAttr("tabindex"),
            _QTAddObjectAttr("hspace"),
            _QTAddObjectAttr("vspace"),
            _QTAddObjectAttr("border"),
            _QTAddObjectAttr("align"),
            _QTAddObjectAttr("class"),
            _QTAddObjectAttr("title"),
            _QTAddObjectAttr("accesskey"),
            _QTAddObjectAttr("noexternaldata"),
            _QTAddObjectAttr("obj#style"),
            ">",
            _QTAddObjectParam("src", generateXHTML)];
        var embedTag = ["<embed ",
            _QTAddEmbedAttr("src"),
            _QTAddEmbedAttr("width"),
            _QTAddEmbedAttr("height"),
            _QTAddEmbedAttr("pluginspage"),
            _QTAddEmbedAttr("name"),
            _QTAddEmbedAttr("id"),
            _QTAddEmbedAttr("align"),
            _QTAddEmbedAttr("tabindex")];

        // delete the attributes/params we have already added
        _QTDeleteTagAttrs("src", "width", "height", "pluginspage", "classid",
            "codebase", "name", "tabindex", "hspace", "vspace", "border",
            "align", "noexternaldata", "class", "title", "accesskey", "id", "style");

        // and finally, add all of the remaining attributes to the embed and object
        for (var attrName in gTagAttrs) {
            attrValue = gTagAttrs[attrName];
            if (null != attrValue) {
                embedTag.push(_QTAddEmbedAttr(attrName));
                objTag.push(_QTAddObjectParam(attrName, generateXHTML));
            }
        }

        // end both tags, we're done
        return objTag.join("") + embedTag.join("") + "></em" + "bed></ob" + "ject" + ">";
    }

    /**
     * Generate an embed and object tag, return as a string and append a behavior
     * script if necessary.
     *
     * @type {String}
     */
    function QT_GenerateOBJECTText(){
        var txt = _QTGenerate("QT_GenerateOBJECTText_XHTML", true, arguments);
        if (_QTShouldInsertBehavior())
            txt = _QTGenerateBehavior() + txt;
        return txt;
    }

    /**
     * Checks if Apple QuickTime has been installed and is accessible on the
     * client's browser.
     *
     * @type {Boolean}
     */
    function QT_IsInstalled(){
        var U = false;
        if (navigator.plugins && navigator.plugins.length) {
            for(var M = 0; M < navigator.plugins.length; M++) {
                var g = navigator.plugins[M];
                if (g.name.indexOf("QuickTime") > -1)
                    U = true;
            }
        }
        else {
            var qtObj = false;
            execScript("on error resume next: qtObj = IsObject(CreateObject(\"QuickTimeCheckObject.QuickTimeCheck.1\"))", "VBScript");
            U = qtObj;
        }
        return U;
    }

    /**
     * Retrieve the version number of the Apple Quicktime browser plugin.
     *
     * @type {String}
     */
    function QT_GetVersion() {
        var U = "0";
        if (navigator.plugins && navigator.plugins.length) {
            for (var g = 0; g < navigator.plugins.length; g++) {
                var S = navigator.plugins[g];
                var M = S.name.match(/quicktime\D*([\.\d]*)/i);
                if (M && M[1])
                    U = M[1];
            }
        }
        else {
            var ieQTVersion = null;
            execScript("on error resume next: ieQTVersion = CreateObject(\"QuickTimeCheckObject.QuickTimeCheck.1\").QuickTimeVersion", "VBScript");
            if (ieQTVersion) {
                var temp = "";
                U = (ieQTVersion).toString(16) / 1000000 + "";//(ieQTVersion>>24).toString(16);
                temp += parseInt(U) + ".";
                temp += ((parseFloat(U) - parseInt(U)) * 1000) / 100 + "";
                U = temp;
            }
        }
        return U;
    }

    /**
     * Check if the currently installed version of Apple Quicktime is compatible
     * with the version specified with major number as g and minor as j.
     *
     * @param {String} g
     * @param {String} j
     * @type  {Boolean}
     */
    function QT_IsCompatible(g, j){
        function M(w, R) {
            var i = parseInt(w[0], 10);
            if (isNaN(i))
                i = 0;
            var V = parseInt(R[0], 10);
            if (isNaN(V))
                V = 0;
            if (i === V) {
                if (w.length > 1)
                    return M(w.slice(1), R.slice(1));
                else
                    return true;
            }
            else
                return (i < V);
        }
        var S = g.split(/\./);
        var U = j ? j.split(/\./) : QT_GetVersion().split(/\./);
        return M(S, U);
    }

    var aIsAvailable = {};
    /*
     * Checks whether a valid version of Apple Quicktime is available on the
     * clients' system. Default version to check for is 7.2.1, because that was
     * the first version that supported the scripting interface.
     *
     * @param {String} sVersion
     * @type  {Boolean}
     */
    function QT_IsValidAvailable(sVersion) {
        if (typeof sVersion == "undefined")
            sVersion = "7.2.1";
        if (typeof aIsAvailable[sVersion] == "undefined")
            aIsAvailable[sVersion] = QT_IsInstalled() && QT_IsCompatible(sVersion);
        return aIsAvailable[sVersion];
    }

    return {
        generateOBJECTText: QT_GenerateOBJECTText,
        isAvailable       : QT_IsValidAvailable
    };
})();

/**
 * Element displaying a Apple Quicktime video (.mov)
 *
 * @classDescription This class creates a new Quicktime video player
 * @return {TypeQT} Returns a new Quicktime video player
 * @type {TypeQT}
 * @constructor
 * @addnode elements:video
 *
 * @author      Mike de Boer
 * @version     %I%, %G%
 * @since       1.0
 */
apf.video.TypeQT = function(oVideo, node, options) {
    this.oVideo      = oVideo;
    this.name        = "QT_" + this.oVideo.$uniqueId;
    this.htmlElement = node;

    // Properties set by QT player
    this.videoWidth = this.videoHeight = this.totalTime =
        this.bytesLoaded = this.totalBytes = 0;
    this.state = null;

    // Internal properties that match get/set methods
    this.autoPlay = this.autoLoad = this.showControls = true;
    this.volume   = 50;
    this.mimeType = "video/quicktime";

    this.firstLoad   = true;
    this.pluginError = false;

    this.pollTimer   = null;
    this.videoPath   = options.src;

    this.player = null;
    apf.extend(this, apf.video.TypeInterface);

    this.setOptions(options);
    var _self = this;
    window.setTimeout(function() {
        _self.oVideo.$initHook({state: 1});
    }, 1);
}

apf.video.TypeQT.isSupported = function() {
    // QuickTime 7.2.1 is the least we'd expect, no?
    return apf.video.TypeQTCompat.isAvailable();
}

apf.video.TypeQT.prototype = {
    /**
     * Play a Quicktime movie. Does a call to the embedded QT object to load or
     * load & play the video, depending on the 'autoPlay' flag (TRUE for play).
     *
     * @param {String} videoPath Path to the movie.
     * @type  {Object}
     */
    load: function(videoPath) {
        this.videoPath = videoPath.splitSafe(",")[this.oVideo.$lastMimeType] || videoPath;
        return this.$draw().attachEvents();
    },

    /**
     * Play and/ or resume a video that has been loaded already
     *
     * @type {Object}
     */
    play: function() {
        if (this.player) {
            try {
                this.player.Play();
                if (apf.isIE)
                    this.handleEvent({type: "qt_play"});
            }
            catch(e) {
                this.oVideo.$stateChangeHook({type: "stateChange", state: "connectionError"});
            }
        }
        return this;
    },

    /**
     * Toggle the pause state of the video.
     *
     * @type {Object}
     */
    pause: function() {
        if (this.player) {
            try {
                this.player.Stop();
                if (apf.isIE)
                    this.handleEvent({type: "qt_pause"});
            }
            catch(e) {
                this.oVideo.$stateChangeHook({type: "stateChange", state: "connectionError"});
            }
        }
        return this;
    },

    /**
     * Stop playback of the video.
     *
     * @type {Object}
     */
    stop: function() {
        return this.pause();
    },

    /**
     * Seek the video to a specific position.
     *
     * @param {Number} iTo The number of seconds to seek the playhead to.
     * @type  {Object}
     */
    seek: function(iTo) {
        if (!this.player) return;
        try {
            this.player.SetTime(iTo);
        }
        catch(e) {
            this.oVideo.$stateChangeHook({type: "stateChange", state: "connectionError"});
        }
        return this;
    },

    /**
     * Set the volume of the video to a specific range (0 - 100)
     *
     * @param {Number} iVolume
     * @type  {Object}
     */
    setVolume: function(iVolume) {
        if (this.player) {
            try {
                this.player.SetVolume(Math.round((iVolume / 100) * 256));
            }
            catch(e) {
                this.oVideo.$stateChangeHook({type: "stateChange", state: "connectionError"});
            }
        }
        return this;
    },

    /**
     * Retrieve the total playtime of the video, in seconds.
     *
     * @type {Number}
     */
    getTotalTime: function() {
        if (!this.player) return 0;
        return this.player.GetDuration();
    },

    /**
     * Draw the HTML for an Apple Quicktime video control (<OBJECT> tag)
     * onto the browser canvas into a container element (usually a <DIV>).
     * When set, it captures the reference to the newly created object.
     *
     * @type {Object}
     */
    $draw: function() {
        if (this.player) {
            this.stopPlayPoll();
            delete this.player;
            this.player = null;
        }

        this.htmlElement.innerHTML = apf.video.TypeQTCompat.generateOBJECTText(
                this.videoPath, "100%", "100%", "",
                "autoplay",            apf.isIE ? "false" : this.autoPlay.toString(), //Not unloading of plugin, bad bad bad hack by Ruben
                "controller",          this.showControls.toString(),
                "kioskmode",           "true",
                "showlogo",            "true",
                "bgcolor",             "black",
                "scale",               "aspect",
                "align",               "middle",
                "EnableJavaScript",    "True",
                "postdomevents",       "True",
                "target",              "myself",
                "cache",               "false",
                "qtsrcdontusebrowser", "true",
                "type",                this.mimeType.splitSafe(",")[this.oVideo.$lastMimeType] || this.mimeType,
                "obj#id",              this.name,
                "emb#NAME",            this.name,
                "emb#id",              this.name + "emb");

        this.player = document[this.name];

        return this;
    },

    events: ["qt_begin", "qt_abort", "qt_canplay", "qt_canplaythrough",
             "qt_durationchange", "qt_ended", "qt_error", "qt_load",
             "qt_loadedfirstframe", "qt_loadedmetadata", "qt_pause", "qt_play",
             "qt_progress", "qt_stalled", "qt_timechanged", "qt_volumechange",
             "qt_waiting"],

    /**
     * Subscribe to events that will be fired by the Quicktime player during playback
     * of the mov file.
     *
     * @type {Object}
     */
    attachEvents: function() {
        var nodeEvents = document.getElementById(this.name);
        if (!nodeEvents) //try the embed otherwise ;)
            nodeEvents = document.getElementById(this.name + "emb");
        var _self = this;
        function exec(e) {
            if (!e) e = window.event;
            _self.handleEvent(e);
        }

        var hook = nodeEvents.addEventListener ? "addEventListener" : "attachEvent";
        var pfx  = nodeEvents.addEventListener ? "" : "on";
        this.events.forEach(function(evt) {
            nodeEvents[hook](pfx + evt, exec, false);
        });

        if (apf.isIE && this.autoPlay)
            this.handleEvent({type: "qt_play"});

        return this;
    },

    /**
     * Callback from Quicktime plugin; whenever the player bubbles an event up
     * to the javascript interface, it passes through to this function.
     *
     * @param {Object} e
     * @type  {Object}
     */
    handleEvent: function(e) {
        switch (e.type) {
            case "qt_play":
                this.oVideo.$stateChangeHook({type: "stateChange", state: "playing"});
                this.startPlayPoll();
                break;
            case "qt_pause":
                this.oVideo.$stateChangeHook({type: "stateChange", state: "paused"});
                this.stopPlayPoll();
                break;
            case "qt_volumechange":
                // volume has to be normalized to 100 (Apple chose a range from 0-256)
                this.oVideo.$changeHook({
                    type  : "change",
                    volume: Math.round((this.player.GetVolume() / 256) * 100)
                });
                break;
            case "qt_timechanged":
                this.oVideo.$changeHook({
                    type        : "change",
                    playheadTime: this.player.GetTime()
                });
                break;
            case "qt_stalled":
                this.oVideo.$completeHook({type: "complete"});
                this.stopPlayPoll();
                break;
            case "qt_canplay":
                this.oVideo.$readyHook({type: "ready"});
                break;
            // unique QT stuff:
            //case "qt_loadedmetadata":
            //    this.oVideo.$metadataHook();
            //    break;
            case "qt_load":
            case "qt_canplaythrough":
                this.oVideo.setProperty("readyState", apf.Media.HAVE_ENOUGH_DATA);
                if (this.autoPlay && apf.isIE) //Not unloading of plugin, bad bad bad hack by Ruben
                    this.player.Play();
                break;
        }
        return this;
    },

    /**
     * Start the polling mechanism that checks for progress in playtime of the
     * video.
     *
     * @type {Object}
     */
    startPlayPoll: function() {
        clearTimeout(this.pollTimer);
        var _self = this;
        this.pollTimer = $setTimeout(function() {
            if (!_self.player) return;
            try {
                _self.handleEvent({type: "qt_timechanged"});
                var iLoaded = _self.player.GetMaxBytesLoaded();
                var iTotal  = _self.player.GetMovieSize();
                _self.oVideo.$progressHook({
                    bytesLoaded: iLoaded,
                    totalBytes : iTotal
                });
                if (!_self.oVideo.ready && Math.abs(iLoaded - iTotal) <= 20)
                    _self.handleEvent({type: "qt_load"});
            }
            catch (e) {}
            _self.startPlayPoll();
        }, 100);
        return this;
    },

    /**
     * Stop the polling mechanism, started by startPlayPoll().
     *
     * @type {Object}
     */
    stopPlayPoll: function() {
        clearTimeout(this.pollTimer);
        return this;
    },

    $destroy: function() {
        this.stopPlayPoll();
        if (this.player) {
            try {
                this.player.Stop();
            }
            catch (e) {}
            this.player = null;
            delete this.player;
        }
        this.oVideo = this.htmlElement = null;
        delete this.oVideo;
        delete this.htmlElement;
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/elements/video/type_wmp.js)SIZE(12632)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.video.TypeWmpCompat = (function() {
    var hasWMP = false;

    /**
     * Windows Media Player checking code adapted from
     * eMedia Communications Strategies information and Microsoft documentation
     * see http://www.learningapi.com/sm5/articlesm5.html
     * and http://support.microsoft.com/default.aspx?scid=kb;en-us;279022
     *
     * Note: Windows Media Player version 7+ ships with the old 6.4
     *       control as well as the newest version.  For this reason,
     *       is_WMP64 will remain true even if is_WMP7up
     *       is set to true.
     *
     * @type {Number}
     */
    function WMP_getVersion() {
        var is_WMP64  = false,
            is_WMP7up = false;

        if (apf.isWin && apf.isIE) {  //use ActiveX test
            var oMP;
            try {
                oMP      = new ActiveXObject("MediaPlayer.MediaPlayer.1");
                hasWMP   = true;
                is_WMP64 = true;
            }
            catch (objError) {
                hasWMP   = false;
                is_WMP64 = false;
            }

            if (hasWMP) {
                try {
                    oMP       = new ActiveXObject("WMPlayer.OCX");
                    is_WMP7up = true;
                }
                catch (objError) {
                    is_WMP7up = false;
                }
            }
        }
        else {  //use plugin test (this not tested yet)
            for (var i = 0, j = navigator.plugins.length; i < j; i++) {
                if (navigator.plugins[i].name.indexOf("Windows Media Player") != -1) {
                    hasWMP    = true;
                    is_WMP64  = true;
                    is_WMP7up = true; //no way to know this with certainty, because M$ doesn't provide version info...
                    oMP       = { versionInfo: "7.3" };
                }
            }
        }

        var WMPVer;
        if (is_WMP7up) {
            WMPVer = oMP.versionInfo;
            oMP    = null;
        }
        else
            WMPVer = "6.4";

        return parseFloat(WMPVer);
    }

    /**
     * Create the HTML for a <PARAM> tag inside the <OBJECT> tag of the player.
     *
     * @param {String} name
     * @param {String} value
     * @type  {String}
     */
    function WMP_generateParamTag(name, value) {
        if (!name || !value) return "";
        return '<param name="' + name + '" value="' + value + '" />';
    }

    /**
     * Create the HTML for the Windows Media Player <OBJECT> HTML tag.
     *
     * @param {String} id
     * @param {String} url
     * @param {Number} width
     * @param {Number} height
     * @param {Object} params
     * @type  {String}
     */
    function WMP_generateOBJECTText(id, url, width, height, params) {
        params.URL = url;
        params.src = url;
        params.SendPlayStateChangeEvents = "true";
        params.StretchToFit = "true";
        var out = ['<object id="', id, '" width="', width, '" height="', height, '" \
            classid="clsid:6BF52A52-394A-11d3-B153-00C04F79FAA6" \
            type="application/x-oleobject">'];
        var emb = ['<embed id="', id, 'emb" width="', width, '" height="', height, '"'];
        for (var param in params) {
            if (!param || !params[param]) continue;
            out.push('<param name="', param, '" value="', params[param], '" />');
            emb.push(' ', param, '="', params[param], '"');
        }
        return out.join("") + emb.join("") + " /></object>";
    }

    var bIsAvailable = null;
    /*
     * Checks whether a valid version of Windows Media Player is available on
     * the clients' system. The version number needs to be higher than 7 in order
     * to be able to control the movie with JScript.
     *
     * @type {Boolean}
     */
    function WMP_isAvailable() {
        if (bIsAvailable === null)
            bIsAvailable = WMP_getVersion() >= 7 && hasWMP;
        return bIsAvailable;
    }

    return  {
        isAvailable       : WMP_isAvailable,
        generateOBJECTText: WMP_generateOBJECTText
    }
})();

/**
 * Element displaying a Windows Media Player video
 *
 * @classDescription This class creates a new Windows Media Player video player
 * @return {TypeWmp} Returns a new Windows Media Player video player
 * @type {TypeWmp}
 * @constructor
 * @addnode elements:video
 *
 * @author      Mike de Boer
 * @version     %I%, %G%
 * @since       1.0
 */
apf.video.TypeWmp = function(oVideo, node, options) {
    this.oVideo      = oVideo;
    this.name        = "WMP_" + this.oVideo.$uniqueId;
    this.htmlElement = node;

    this.player    = this.pollTimer = null;
    this.volume    = 50; //default WMP
    this.videoPath = options.src;
    apf.extend(this, apf.video.TypeInterface);

    this.setOptions(options);
    var _self = this;
    window.setTimeout(function() {
        _self.oVideo.$initHook({state: 1});
    }, 1);
};

apf.video.TypeWmp.isSupported = function(){
    return apf.video.TypeWmpCompat.isAvailable();
};

apf.video.TypeWmp.prototype = {
    /**
     * Play a Quicktime movie. Does a call to the embedded QT object to load or
     * load & play the video, depending on the 'autoPlay' flag (TRUE for play).
     *
     * @param {String} videoPath Path to the movie.
     * @type  {Object}
     */
    load: function(videoPath) {
        this.videoPath = videoPath.splitSafe(",")[this.oVideo.$lastMimeType] || videoPath;
        return this.$draw();
    },

    /**
     * Play and/ or resume a video that has been loaded already
     *
     * @type {Object}
     */
    play: function() {
        if (this.player)
            this.player.controls.play();

        return this;
    },

    /**
     * Toggle the pause state of the video.
     *
     * @type {Object}
     */
    pause: function() {
        if (this.player)
            this.player.controls.pause();
        return this;
    },

    /**
     * Stop playback of the video.
     *
     * @type {Object}
     */
    stop: function() {
        if (this.player)
            this.player.controls.stop();
        return this;
    },

    /**
     * Seek the video to a specific position.
     *
     * @param {Number} iTo The number of seconds to seek the playhead to.
     * @type  {Object}
     */
    seek: function(iTo) {
        if (this.player) {
            this.player.controls.pause(); //@todo fix by ruben to enable seeking in wmp
            this.player.controls.currentPosition = iTo / 1000;
            if (!this.oVideo.paused)
                this.player.controls.play(); //@todo fix by ruben to enable seeking in wmp
        }
        return this;
    },

    fullscreen : function(value){
        this.player.fullscreen = value ? true : false;
    },

    /**
     * Set the volume of the video to a specific range (0 - 100)
     *
     * @param {Number} iVolume
     * @type  {Object}
     */
    setVolume: function(iVolume) {
        if (this.player)
            this.player.settings.volume = iVolume;
        return this;
    },

    /**
     * Retrieve the total playtime of the video, in seconds.
     *
     * @type {Number}
     */
    getTotalTime: function() {
        if (!this.player)
            return 0;
        return Math.round(this.player.controls.currentItem.duration * 1000);
    },

    /**
     * Draw the HTML for a Windows Media Player video control (<OBJECT> tag)
     * onto the browser canvas into a container element (usually a <DIV>).
     * When set, it captures the reference to the newly created object.
     *
     * @type {Object}
     */
    $draw: function() {
        if (this.player) {
            this.stopPlayPoll();
            delete this.player;
            this.player = null;
        }

        var playerId = this.name + "_Player";

        this.htmlElement.innerHTML = apf.video.TypeWmpCompat.generateOBJECTText(playerId,
            this.videoPath, "100%", "100%", {
                "AutoStart": this.autoPlay.toString(),
                "uiMode"   : this.showControls ? "mini" : "none",
                "PlayCount": 1 //@todo: implement looping
            });

        this.player = this.getElement(playerId);//.object;
        var _self = this;
        try {
            this.player[window.addEventListener ? "addEventListener" : "attachEvent"]("PlayStateChange", function(iState) {
              _self.handleEvent(iState);
            });
        } catch (e) {
            this.player.onplaystatechange = function(iState) {
              _self.handleEvent(iState);
            }
        }

        return this;
    },

    /**
     * Callback from flash; whenever the Window Media Player video bubbles an
     * event up to the javascript interface, it passes through to this function.
     *
     * @param {Number} iState
     * @type  {Object}
     */
    handleEvent: function(iState) {
        switch (iState) {
            case 1:   //Stopped - Playback of the current media clip is stopped.
            case 8:   //MediaEnded - Media has completed playback and is at its end.
                this.oVideo.$completeHook({type: "complete"});
                this.stopPlayPoll();
                break;
            case 2:   //Paused - Playback of the current media clip is paused. When media is paused, resuming playback begins from the same location.
                this.oVideo.$stateChangeHook({type: "stateChange", state: "paused"});
                this.stopPlayPoll();
                break;
            case 3:   //Playing - The current media clip is playing.
                this.oVideo.$stateChangeHook({type: "stateChange", state: "playing"})
                if (!this.oVideo.ready)
                    this.oVideo.setProperty("readyState", apf.Media.HAVE_ENOUGH_DATA);
                this.startPlayPoll();
                break;
            case 10:  //Ready - Ready to begin playing.
                this.oVideo.$stateChangeHook({type: "ready"});
                break;
            case 4:  //ScanForward - The current media clip is fast forwarding.
            case 5:  //ScanReverse - The current media clip is fast rewinding.
            case 6:  //Buffering - The current media clip is getting additional data from the server.
            case 7:  //Waiting - Connection is established, however the server is not sending bits. Waiting for session to begin.
            case 9:  //Transitioning - Preparing new media.
            case 11: //Reconnecting - Reconnecting to stream.
                break;
        }
        return this;
    },

    /**
     * Start the polling mechanism that checks for progress in playtime of the
     * video.
     *
     * @type {Object}
     */
    startPlayPoll: function() {
        clearTimeout(this.pollTimer);
        var _self = this;
        this.pollTimer = $setTimeout(function() {
            if (!_self.player || !_self.player.controls) return;
            _self.oVideo.$changeHook({
                type        : "change",
                playheadTime: Math.round(_self.player.controls.currentPosition * 1000)
            });
            _self.startPlayPoll();
        }, 200);
        return this;
    },

    /**
     * Stop the polling mechanism, started by startPlayPoll().
     *
     * @type {Object}
     */
    stopPlayPoll: function() {
        clearTimeout(this.pollTimer);
        return this;
    },

    $destroy: function() {
        this.stopPlayPoll();
        if (this.player) {
            try {
                this.player.controls.stop();
            } catch(e) {}
            this.player = null;
            delete this.player;
        }
        this.htmlElement.innerHTML = "";
        this.oVideo = this.htmlElement = null;
        delete this.oVideo;
        delete this.htmlElement;
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/elements/video/type_silverlight.js)SIZE(15347)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element displaying a Silverlight video
 *
 * @classDescription This class creates a new Silverlight video player
 * @return {TypeSilverlight} Returns a new Silverlight video player
 * @type {TypeSilverlight}
 * @constructor
 * @addnode elements:video
 *
 * @author      Mike de Boer
 * @version     %I%, %G%
 * @since       1.0
 */
apf.video.TypeSilverlight = function(oVideo, node, options) {
    this.oVideo         = oVideo;
    if (!apf.video.TypeSilverlight.INITED) {
        apf.silverlight.startup();
        apf.video.TypeSilverlight.INITED = true;
    }

    
    this.DEFAULT_PLAYER = (apf.config.resourcePath || apf.basePath) + "resources/wmvplayer.xaml";
    
    
    this.htmlElement    = node;
    this.options        = {
        backgroundcolor: "000000",
        windowless:      "false",
        file:            "",
        image:           "",
        backcolor:       "000000",
        frontcolor:      "FFFFFF",
        lightcolor:      "FFFFFF",
        screencolor:     "FFFFFF",
        width:           "100%",
        height:          "100%",
        logo:            "",
        overstretch:     "true",
        shownavigation:  "false",
        showstop:        "false",
        showdigits:      "true",
        usefullscreen:   "true",
        usemute:         "false",
        autostart:       "true",
        bufferlength:    "3",
        duration:        "0",
        repeat:          "false",
        sender:          "",
        start:           "0",
        volume:          "90",
        link:            "",
        linkfromdisplay: "false",
        linktarget:      "_self"
    };
    this.options.file = options.src;

    for (var itm in this.options) {
        if (options[itm] != undefined) {
            if (itm.indexOf("color") > 0)
                this.options[itm] = options[itm].substr(options[itm].length - 6);
            else
                this.options[itm] = options[itm];
        }
    }

    apf.silverlight.createObjectEx({
        id:            this.oVideo.$uniqueId + "_Player",
        source:        this.DEFAULT_PLAYER,
        parentElement: node,
        properties:    {
            width:                "100%",
            height:               "100%",
            version:              "1.0",
            inplaceInstallPrompt: true,
            isWindowless:         this.options["windowless"],
            background:           "#" + this.options["backgroundcolor"]
        },
        events:        {
            onLoad:  this.onLoadHandler,
            onError: apf.silverlight.default_error_handler
        },
        context:       this
    });

    //apf.extend(this, apf.video.TypeInterface);
    
    apf.layout.setRules(this.oVideo.$ext, this.oVideo.$uniqueId + "_silverlight",
        "apf.all[" + this.oVideo.$uniqueId + "].player.resizePlayer()");
    apf.layout.queue(this.oVideo.$ext);
    
};

apf.video.TypeSilverlight.isSupported = function(){
    return apf.silverlight.isAvailable("1.0");
};

apf.video.TypeSilverlight.INITED = false;

apf.video.TypeSilverlight.prototype = {
    /**
     * Play a WMV movie. Does a call to the XAML Silverlight player to load or
     * load & play the video, depending on the 'autoPlay' flag (TRUE for play).
     *
     * @param {String} videoPath Path to the movie.
     * @type  {Object}
     */
    load: function(videoPath) {
        this.video.Source = this.options["file"];

        this.oVideo.$readyHook({ type: "ready" });

        if (this.options["usemute"] == "true")
            this.setVolume(0);
        else
            this.setVolume(this.options["volume"]);
        if (this.options["autostart"] == "true")
            this.play();
        else
            this.pause();

        return this;
    },

    /**
     * Play and/ or resume a video that has been loaded already
     *
     * @type {Object}
     */
    play: function() {
        if (this.state == "buffering" || this.state == "playing") {
            if (this.options["duration"] == 0)
                this.stop();
            else
                this.pause();
        }
        else {
            this.video.Visibility   = "Visible";
            this.preview.Visibility = "Collapsed";
            if (this.state == "closed")
                this.video.Source = this.options["file"];
            else
                this.video.play();
        }
        return this;
    },

    /**
     * Toggle the pause state of the video.
     *
     * @type {Object}
     */
    pause: function() {
        if (!this.video) return this;
        this.video.pause();
        return this;
        //this.oVideo.$changeHook({
        //    type        : "change",
        //    playheadTime: Math.round(this.video.Position.Seconds * 10) / 10
        //});
    },

    /**
     * Stop playback of the video.
     *
     * @type {Object}
     */
    stop: function() {
        if (!this.video) return;
        this.stopPlayPoll();
        this.video.Visibility   = "Collapsed";
        this.preview.Visibility = "Visible";
        this.pause().seek(0);
        this.video.Source = "null";
        return this;
    },

    /**
     * Seek the video to a specific position.
     *
     * @param {Number} iTo The number of seconds to seek the playhead to.
     * @type {Object}
     */
    seek: function(iTo) {
        if (!this.video) return;
        this.stopPlayPoll();
        if (iTo < 2)
            iTo = 0;
        else if (iTo > this.options["duration"] - 4)
            iTo = this.options["duration"] - 4;
        //this.play();
        if (!isNaN(iTo)) {
            try{ //@todo added by ruben
                this.video.Position = this.oVideo.getCounter(iTo, "%H:%M:%S");//this.spanstring(iTo);
            }
            catch(e){}
        }
        if (this.state == "buffering" || this.state == "playing")
            this.play();
        else
            this.pause();
        return this;
    },

    /**
     * Set the volume of the video to a specific range (0 - 100)
     *
     * @param {Number} iVolume
     * @type {Object}
     */
    setVolume: function(iVolume) {
        if (!this.video) return;
        this.video.Volume = iVolume / 100;
        return this;
    },

    /**
     * Retrieve the total playtime of the video, in seconds.
     *
     * @type {Number}
     */
    getTotalTime: function() {
        if (!this.video) return 0;
        return this.options["duration"] || 0;
    },

    /**
     * Format a number of seconds to a format the player groks:
     * HH:MM:SS
     *
     * @param {Number} stp In seconds
     * @type {String}
     */
    spanstring: function(stp) {
        var hrs = Math.floor(stp / 3600);
        var min = Math.floor(stp % 3600 / 60);
        var sec = Math.round(stp % 60 * 10) / 10;
        var str = hrs + ":" + min + ":" + sec;
        return str;
    },

    /**
     * Fired when the XAML player object has loaded its resources (including
     * the video file inside the <MediaElement> object and is ready to play.
     * Captures the reference to the player object.
     *
     * @param {String} pId
     * @param {Object} _self  Context of the player ("this")
     * @param {Object} sender XAML Player object instance
     * @type {void}
     */
    onLoadHandler: function(pId, _self, sender) {
        // 'o = this' in this case, sent back to us from the Silverlight helper script

        _self.options["sender"] = sender;
        _self.video   = _self.options["sender"].findName("VideoWindow");
        _self.preview = _self.options["sender"].findName("PlaceholderImage");
        var str = {
            "true" : "UniformToFill",
            "false": "Uniform",
            "fit"  : "Fill",
            "none" : "None"
        }
        _self.state = _self.video.CurrentState.toLowerCase();
        _self.pollTimer;
        _self.video.Stretch   = str[_self.options["overstretch"]];
        _self.preview.Stretch = str[_self.options["overstretch"]];

        _self.display               = sender.findName("PlayerDisplay");
        _self.display.Visibility    = "Visible";

        _self.video.BufferingTime = _self.spanstring(_self.options["bufferlength"]);
        _self.video.AutoPlay      = true;

        _self.video.AddEventListener("CurrentStateChanged", function() {
            _self.handleState("CurrentStateChanged");
        });
        _self.video.AddEventListener("MediaEnded", function() {
            _self.handleState("MediaEnded");
        });
        // BufferProgressChanged is of no use in XAML
        _self.video.AddEventListener("DownloadProgressChanged", function(o) {
            _self.oVideo.$progressHook({
                bytesLoaded: Math.round(o.downloadProgress * 100), //percentage
                totalBytes : 100
            });
        });
        if (_self.options["image"] != "")
            _self.preview.Source = _self.options["image"];

        _self.resizePlayer();

        _self.oVideo.$initHook({state: _self.state});
    },

    /**
     * Process a 'CurrentStateChanged' event when the player fired it or a
     * 'MediaEnded' event when the video stopped playing.
     *
     * @param {Object} sEvent Name of the event that was fired (either 'CurrentStateChanged' or 'MediaEnded')
     * @type void
     */
    handleState: function(sEvent) {
        var state = this.video.CurrentState.toLowerCase();
        if (sEvent == "MediaEnded") {
            this.stopPlayPoll();
            this.oVideo.$changeHook({
                type        : "change",
                playheadTime: Math.round(this.video.Position.Seconds * 1000)
            });
            if (this.options["repeat"] == "true") {
                this.seek(0).play();
            } else {
                this.state              = "completed";
                this.video.Visibility   = "Collapsed";
                this.preview.Visibility = "Visible";
                this.seek(0).pause().oVideo.$completeHook({ type: "complete" });
            }
        }
        //CurrentStateChanged:
        else if (state != this.state) {
            this.state = state;
            this.options["duration"] = Math.round(this.video.NaturalDuration.Seconds * 1000);
            if (state != "playing" && state != "buffering" && state != "opening") {
                this.oVideo.$stateChangeHook({type: "stateChange", state: "paused"});
                this.stopPlayPoll();
            }
            else {
                this.oVideo.$stateChangeHook({type: "stateChange", state: "playing"});
                this.startPlayPoll();
            }
        }
    },

    /**
     * Start the polling mechanism that checks for progress in playtime of the
     * video.
     *
     * @type {Object}
     */
    startPlayPoll: function() {
        clearTimeout(this.pollTimer);
        var _self = this;
        this.pollTimer = $setTimeout(function() {
            if (_self.oVideo && !_self.oVideo.ready && _self.video.CanSeek)
                _self.oVideo.setProperty("readyState", apf.Media.HAVE_ENOUGH_DATA);
            _self.oVideo.$changeHook({
                type        : "change",
                playheadTime: Math.round(_self.video.Position.Seconds * 1000)
            });
            _self.startPlayPoll();
        }, 100);
        return this;
    },

    /**
     * Stop the polling mechanism, started by startPlayPoll().
     *
     * @type {Object}
     */
    stopPlayPoll: function() {
        clearTimeout(this.pollTimer);
        return this;
    },

    /**
     * Resize the dimensions of the player object to the ones specified by the
     * <VIDEO> tag width and height properties. The video will be scaled/ stretched
     * accordingly
     *
     * @type {Object}
     */
    resizePlayer: function() {
        var oSender  = this.options["sender"];
        if (!oSender) return;
        var oContent = this.display.getHost().content;
        var width    = oContent.actualWidth;
        var height   = oContent.actualHeight;

        this.stretchElement("PlayerDisplay", width, height)
            .stretchElement("VideoWindow", width,height)
            .stretchElement("PlaceholderImage", width, height)
            .centerElement("BufferIcon", width, height)
            .centerElement("BufferText", width, height)
        this.display.findName("OverlayCanvas")["Canvas.Left"] = width -
        this.display.findName("OverlayCanvas").Width - 10;
        this.display.Visibility = "Visible";

        return this;
    },

    /**
     * Position a XAML element in the center of the canvas it is a member of
     *
     * @param {String} sName   Name or ID of the element
     * @param {Number} iWidth  Current width of the canvas
     * @param {Number} iHeight Current height of the canvas
     * @type {Object}
     */
    centerElement: function(sName, iWidth, iHeight) {
        var elm = this.options["sender"].findName(sName);
        elm["Canvas.Left"] = Math.round(iWidth  / 2 - elm.Width  / 2);
        elm["Canvas.Top"]  = Math.round(iHeight / 2 - elm.Height / 2);
        return this;
    },

    /**
     * Set the dimensions of a XAML element to be the same of the canvas it is
     * a member of.
     *
     * @param {Object} sName   Name or ID of the element
     * @param {Number} iWidth  Current width of the canvas
     * @param {Number} iHeight Current height of the canvas. Optional.
     * @type {Object}
     */
    stretchElement: function(sName, iWidth, iHeight) {
        var elm = this.options["sender"].findName(sName);
        elm.Width = iWidth;
        if (iHeight != undefined)
            elm.Height = iHeight;
        return this;
    },

    $destroy: function() {
        
        apf.layout.removeRule(this.oVideo.$ext, this.oVideo.$uniqueId + "_silverlight");
        
        this.stopPlayPoll();
        if (this.player) {
            this.player = this.video = this.preview = null;
            delete this.player;
            delete this.video;
            delete this.preview
        }
        this.htmlElement.innerHTML = "";
        this.oVideo = this.htmlElement = null;
        delete this.oVideo;
        delete this.htmlElement;
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/elements/video/type_vlc.js)SIZE(12493)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/video/type_native.js)SIZE(10825)TIME(1259091144)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Element displaying an &lt;video&gt; element
 *
 * @classDescription This class creates a &lt;video&gt; element
 * @return {TypeNative} Returns a new &lt;video&gt; element
 * @type {TypeNative}
 * @constructor
 * @addnode elements:video
 *
 * @author      Mike de Boer
 * @version     %I%, %G%
 * @since       1.0
 */

apf.video.TypeNative = function(oVideo, oNode, options) {
    this.oVideo = oVideo;

    this.inited = false;

    // Div name, flash name, and container name
    this.divName      = oVideo.$uniqueId;
    this.htmlElement  = oNode;
    this.name         = "soundmgr_" + oVideo.$uniqueId;

    // Audio props
    this.videoPath    = options.src;
    this.paused       = false;

    // Initialize player
    this.player       = null;
    apf.extend(this, apf.video.TypeInterface);

    this.setOptions(options).createPlayer();
};

apf.video.TypeNative.isSupported = function() {
    return apf.hasVideo;
};

apf.video.TypeNative.prototype = {
    /**
     * Load an video file.
     *
     * @param {String} videoPath Path to the ogg file. If the videoPath is null,
     *                           and the ogg is playing, it will act as a play/pause toggle.
     * @param {Number} totalTime Optional totalTime to override the ogg's built in totalTime
     */
    load: function(videoPath, totalTime) {
        if (totalTime != null)
            this.setTotalTime(totalTime);
        if (videoPath != null)
            this.videoPath = videoPath;
        if (this.videoPath == null && !this.firstLoad)
            return this.oVideo.$errorHook({type:"error", error:"SoundManager::play - No videoPath has been set."});

        if (videoPath == null && this.firstLoad && !this.autoLoad) // Allow play(null) to toggle playback
            videoPath = this.videoPath;
        this.firstLoad = false;
        this.setVolume(this.volume);
        //    .callMethod("loadSound", this.videoPath, true, this.autoPlay);
        return this;
    },

    /**
     * Play and/ or resume a video that has been loaded already
     *
     * @type {Object}
     */
    play: function() {
        if (!this.paused)
            return this.player.play();
        return this.pause(); //toggle pause
    },

    /**
     * Toggle the pause state of the video.
     *
     * @param {Boolean} pauseState The pause state. Setting pause state to true will pause the video.
     * @type {Object}
     */
    pause: function() {
        return this.player.pause();
    },

    /**
     * Stop playback of the video.
     *
     * @type {Object}
     */
    stop: function() {
        return this.player.stop();
    },

    /**
     * Seek the video to a specific position.
     *
     * @param {Number} seconds The number of seconds to seek the playhead to.
     * @type {Object}
     */
    seek: function(ms) {
        return this.player.currentTime = parseInt(ms) / 1000;
    },

    /**
     * Not supported.
     *
     * @type {Object}
     */
    setVolume: function(iVol) {
        this.player.volume = parseInt(iVol) / 100;
        return this;
    },

    /**
     * Retrive the position of the playhead, in seconds.
     *
     * @type {Number}
     */
    getPlayheadTime: function() {
        return this.player.playheadTime;
    },

    /**
     * Specifies the position of the playhead, in seconds.
     *
     * @default null
     * @type {Object}
     */
    setPlayheadTime: function(value) {
        this.playheadTime = parseInt(value);
        return this;
    },

    /**
     * Retrieve the total playtime of the video, in seconds.
     *
     * @type {Number}
     */
    getTotalTime: function() {
        return this.totalTime;
    },

    /**
     * Determines the total time of the video.  The total time is automatically determined
     * by the player, unless the user overrides it.
     *
     * @default null
     * @type {Object}
     */
    setTotalTime: function(value) {
        this.totalTime = parseInt(value);
        return this;
    },

    /**
     * Callback from flash; whenever the Flash movie bubbles an event up to the
     * javascript interface, it passes through to this function.
     * Events dispatched by SoundManager instances:
     *    > init: The player is initialized
     *    > ready: The video is ready
     *    > progress: The video is downloading. Properties: bytesLoaded, totalBytes
     *    > playHeadUpdate: The video playhead has moved.  Properties: playheadTime, totalTime
     *    > stateChange: The state of the video has changed. Properties: state
     *    > change: The player has changed.
     *    > complete: Playback is complete.
     *    > metaData: The video has returned meta-data. Properties: infoObject
     *    > cuePoint: The video has passed a cuePoint. Properties: infoObject
     *    > error: An error has occurred.  Properties: error
     *
     * @param {Object} eventName
     * @param {Object} evtObj
     * @type {void}
     */
    event: function(eventName, evtObj) {
        switch (eventName) {
            case "progress":
                this.bytesLoaded = evtObj.bytesLoaded;
                this.totalBytes  = evtObj.totalBytes;
                this.oVideo.$progressHook({
                    type       : "progress",
                    bytesLoaded: this.bytesLoaded,
                    totalBytes : this.totalBytes
                });
                break;
            case "playheadUpdate":
                this.playheadTime = evtObj.playheadTime;
                this.totalTime    = evtObj.totalTime;
                this.oVideo.$changeHook({
                    type        : "change",
                    playheadTime: this.playheadTime,
                    totalTime   : this.totalTime
                });
                if (evtObj.waveData || evtObj.peakData || evtObj.eqData)
                    this.oVideo.$metadataHook({
                        type    : "metadata",
                        waveData: evtObj.waveData,
                        peakData: evtObj.peakData,
                        eqData  : evtObj.eqData
                    });
                break;
            case "stateChange":
                this.state = evtObj.state;
                this.oVideo.$stateChangeHook({type:"stateChange", state:this.state});
                break;
            case "change":
                this.oVideo.$changeHook({type:"change"});
                break;
            case "complete":
                this.oVideo.$completeHook({type:"complete"});
                break;
            case "ready":
                if (this.paused && this.autoPlay)
                    this.paused = false;
                this.oVideo.$readyHook({type:"ready"});
                break;
            case "metaData":
                this.oVideo.$metadataHook({type:"metaData", infoObject:evtObj});
                break;
            case "cuePoint":
                this.oVideo.$cuePointHook({type:"cuePoint", infoObject:evtObj});
                break;
            case "init":
                this.inited = true;
                this.oVideo.$initHook(apf.extend(evtObj, apf.flash.getSandbox(evtObj.sandboxType)));
                break;
            case "id3":
                this.oVideo.$metadataHook({
                    type: 'metadata',
                    id3Data: evtObj
                });
                break;
            case "debug":
                apf.console.log(">> SWF DBUG: " + evtObj.msg);
                break;
        }
    },

    /**
     * Create the HTML to render the player.
     *
     * @type {Object}
     */
    createPlayer: function() {
        var div = this.htmlElement;
        if (div == null) return this;

        // place the HTML node outside of the viewport
        var a = this.player = document.createElement("video");
        a.setAttribute("src", this.videoPath);
        a.setAttribute("volume", this.volume);
        if (this.autoPlay)
            a.setAttribute("autoplay", "true");
        div.appendChild(a);

        var _self = this,
            timeHandler;
        a.addEventListener("canplay", function() {
            _self.oVideo.$readyHook({type:"ready"});
        }, false);
        a.addEventListener("timeupdate", timeHandler = function(e) {
            //console.dir(e);
            //console.log("playing: ", _self.player.currentTime, _self.player.duration);
            _self.playheadTime = parseInt(_self.player.currentTime || 0) * 1000;
            _self.totalTime    = parseInt(_self.player.duration) * 1000;
            _self.oVideo.$changeHook({
                type        : "change",
                playheadTime: _self.playheadTime,
                totalTime   : _self.totalTime
            });
        }, false);
        a.addEventListener("duration", timeHandler, false);
        a.addEventListener("volumechange", function() {
            _self.oVideo.$changeHook({
                type   : "change",
                volume : _self.player.muted ? 0 : parseInt(_self.player.volume) * 100
            });
        }, false);
        a.addEventListener("progress", function(e) {
            _self.bytesLoaded = e.loaded;
            _self.totalBytes  = e.total;
            _self.oVideo.$progressHook({
                type       : "progress",
                bytesLoaded: _self.bytesLoaded,
                totalBytes : _self.totalBytes
            });
        }, false);
        a.addEventListener("ended", function() {
            _self.oVideo.$completeHook({type:"complete"});
        }, false);
        a.addEventListener("error", function(e) {
            throw new Error(apf.formatErrorString(0, _self, "Audio playback",
                e.message, _self.oVideo));
        }, false);

        a.load();

        return this;
    },

    $destroy: function() {
        if (!this.player) return;
        this.player.setAttribute("src", "");
        delete this.player;
        this.player = null;
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/elements/video/type_flv.js)SIZE(17057)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Element displaying a Flash video
 *
 * @classDescription This class creates a new Flash video player
 * @return {TypeFlv} Returns a new Flash video player
 * @type {TypeFlv}
 * @constructor
 * @addnode elements:video
 *
 * @author      Mike de Boer
 * @version     %I%, %G%
 * @since       1.0
 */
apf.video.TypeFlv = function(oVideo, node, options) {
    this.oVideo              = oVideo;
    
    this.DEFAULT_SWF_PATH    = (apf.config.resourcePath || apf.basePath) + "resources/FAVideo.swf";
    
    
    //this.DEFAULT_WIDTH       = "100%";
    //this.DEFAULT_HEIGHT      = "100%";

    this.id = apf.flash.addPlayer(this); // Manager manages multiple players
    this.inited       = false;
    this.resizeTimer  = null;

    // Div name, flash name, and container name
    this.divName      = this.oVideo.$uniqueId;
    this.htmlElement  = node;
    this.name         = "FAVideo_" + this.oVideo.$uniqueId;

    // Video props
    this.videoPath    = options.src;
    this.width        = "100%"; //(options.width  > 0) ? options.width  : this.DEFAULT_WIDTH;
    this.height       = "100%"; //(options.height > 0) ? options.height : this.DEFAULT_HEIGHT;

    // Initialize player
    this.player = null;
    apf.extend(this, apf.video.TypeInterface);

    this.initProperties().setOptions(options).createPlayer();
}

apf.video.TypeFlv.isSupported = function() {
    return apf.flash.isAvailable();
};

apf.video.TypeFlv.prototype = {
    /**
     * Play an FLV. Does a call to the flash player to load or load & play the
     * video, depending on the 'autoPlay' flag (TRUE for play).
     *
     * @param {String} videoPath Path to the FLV. If the videoPath is null, and the FLV is playing, it will act as a play/pause toggle.
     * @param {Number} totalTime Optional totalTime to override the FLV's built in totalTime
     * @type  {Object}
     */
    load: function(videoPath, totalTime) {
        videoPath = videoPath.splitSafe(",")[this.oVideo.$lastMimeType] || videoPath;

        if (totalTime != null)
            this.setTotalTime(totalTime);
        if (videoPath != null)
            this.videoPath = videoPath;
        if (this.videoPath == null && !this.firstLoad)
            return this.oVideo.$errorHook({type:"error", error:"FAVideo::play - No videoPath has been set."});

        if (videoPath == null && this.firstLoad && !this.autoLoad) // Allow play(null) to toggle playback
            videoPath = this.videoPath;

        this.firstLoad = false;
        if (this.autoPlay)
            this.callMethod("playVideo", videoPath, totalTime);
        else
            this.callMethod("loadVideo", this.videoPath);
        return this;
    },

    /**
     * Play and/ or resume a video that has been loaded already
     *
     * @type {Object}
     */
    play: function() {
        return this.pause(false);
    },

    /**
     * Toggle the pause state of the video.
     *
     * @param {Boolean} pauseState The pause state. Setting pause state to true will pause the video.
     * @type {Object}
     */
    pause: function(pauseState) {
        if (typeof pauseState == "undefined")
            pauseState = true;
        this.callMethod("pause", pauseState);
        return this;
    },

    /**
     * Stop playback of the video.
     *
     * @type {Object}
     */
    stop: function() {
        this.callMethod("stop");
        return this;
    },

    /**
     * Seek the video to a specific position.
     *
     * @param {Number} millis The number of milliseconds to seek the playhead to.
     * @type {Object}
     */
    seek: function(millis) {
        this.callMethod("seek", millis / 1000);
        return this;
    },

    /**
     * Set the volume of the video to a specific range (0 - 100)
     *
     * @param {Number} iVolume
     * @type  {Object}
     */
    setVolume: function(iVolume) {
        this.callMethod("setVolume", iVolume);
        return this;
    },

    /**
     * Resize event handler, used by the layoutManager hook
     *
     * @type {void}
     */
    onResize: function() {
        clearTimeout(this.resizeTimer);
        var _self = this;
        this.resizeTimer = window.setTimeout(function() {
            _self.setSize();
        }, 20);
    },

    /**
     * Set the size of the video.
     *
     * @type {Object}
     */
    setSize: function() {
        this.callMethod("setSize", this.htmlElement.offsetWidth,
            this.htmlElement.offsetHeight);
        return this;
    },

    /**
     * Retrive the position of the playhead, in seconds.
     *
     * @type {Number}
     */
    getPlayheadTime: function() {
        return this.playheadTime;
    },

    /**
     * Specifies the position of the playhead, in seconds.
     *
     * @default null
     * @type {Object}
     */
    setPlayheadTime: function(value) {
        return this.setProperty("playheadTime", value);
    },

    /**
     * Retrieve the total playtime of the video, in seconds.
     *
     * @type {Number}
     */
    getTotalTime: function() {
        return this.totalTime;
    },

    /**
     * Determines the total time of the video.  The total time is automatically determined
     * by the player, unless the user overrides it.
     *
     * @default null
     * @type {Object}
     */
    setTotalTime: function(value) {
        return this.setProperty("totalTime", value);
    },

    /*setFullscreen: function(value) {
        apf.console.info('video::flash - going fullscreen = ' + value);
        return this.callMethod('setFullscreen', value);
    },*/

    /**
     * All public methods use this proxy to make sure that methods called before
     * initialization are properly called after the player is ready.
     *
     * @type {Object}
     */
    callMethod: function() {
        if (!this.inited || !this.player || !this.player.callMethod) {
            this.delayCalls.push(arguments);
        }
        else {
            var args = Array.prototype.slice.call(arguments);
            args.unshift(this.player, "callMethod");
            apf.flash.remote.apply(null, args);
        }

        return this;
    },

    /**
     * Call methods that were made before the player was initialized.
     *
     * @type {Object}
     */
    makeDelayCalls: function() {
        for (var i = 0, l = this.delayCalls.length; i < l; i++)
            this.callMethod.apply(this, this.delayCalls[i]);
        return this;
    },

    /**
     * Callback from flash; synchronizes the state of properties of the Flash
     * movie with the properties of the javascript object
     *
     * @param {Object} props
     * @type {void}
     */
    update: function(props) {
        for (var n in props) {
            if (n.indexOf("Time") != -1 && typeof props[n] == "number")
                props[n] = props[n] * 1000;
            this[n] = props[n]; // Set the internal property
        }
        props.type = "change";
        this.oVideo.$changeHook(props); // This needs to have an array of changed props.
    },

    /**
     * Callback from flash; whenever the Flash movie bubbles an event up to the
     * javascript interface, it passes through to this function.
     * Events dispatched by FAVideo instances:
     *    > init: The player is initialized
     *    > ready: The video is ready
     *    > progress: The video is downloading. Properties: bytesLoaded, bytesTotal
     *    > playHeadUpdate: The video playhead has moved.  Properties: playheadTime, totalTime
     *    > stateChange: The state of the video has changed. Properties: state
     *    > change: The player has changed.
     *    > complete: Playback is complete.
     *    > metaData: The video has returned meta-data. Properties: infoObject
     *    > cuePoint: The video has passed a cuePoint. Properties: infoObject
     *    > error: An error has occurred.  Properties: error
     *
     * @param {Object} eventName
     * @param {Object} evtObj
     * @type {void}
     */
    event: function(eventName, evtObj) {
        apf.console.log("[FLASH] video event: " + eventName + ", " + evtObj);
        switch (eventName) {
            case "progress":
                this.bytesLoaded = evtObj.bytesLoaded;
                this.totalBytes  = evtObj.bytesTotal;
                this.oVideo.$progressHook({
                    type       : "progress",
                    bytesLoaded: this.bytesLoaded,
                    totalBytes : this.totalBytes
                });
                break;
            case "playheadUpdate":
                this.playheadTime = evtObj.playheadTime * 1000;
                this.totalTime    = evtObj.totalTime * 1000;
                this.oVideo.$playheadUpdateHook({
                    type        : "playheadUpdate",
                    playheadTime: this.playheadTime,
                    totalTime   : this.totalTime
                });
                break;
            case "stateChange":
                this.state = evtObj.state;
                this.oVideo.$stateChangeHook({type:"stateChange", state:this.state});
                break;
            case "change":
                this.oVideo.$changeHook({type:"change"});
                break;
            case "complete":
                this.oVideo.$completeHook({type:"complete"});
                break;
            case "ready":
                this.oVideo.$readyHook({type:"ready"});
                break;
            case "metaData":
                this.oVideo.$metadataHook({type:"metadata", infoObject:evtObj});
                break;
            case "cuePoint":
                this.oVideo.$cuePointHook({type:"cuePoint", infoObject:evtObj});
                break;
            case "fullscreen":
                apf.console.log('fullscreen: ', evtObj.state);
                this.oVideo.fullscreen = false;
            case "init":
                this.inited = true;
                // There is a bug in IE innerHTML. Tell flash what size it is.
                // This will probably not work with liquid layouts in IE.
                this.invalidateProperty("clickToTogglePlay", "skinVisible",
                    "skinAutoHide", "autoPlay", "autoLoad", "volume", "bufferTime",
                    "videoScaleMode", "videoAlign", "playheadUpdateInterval",
                    "previewImagePath").validateNow().makeDelayCalls();

                this.oVideo.$initHook({type:"init"});
                this.onResize();
                var node = this.oVideo.$int;
                
                $setTimeout(function() {
                    apf.layout.forceResize(node);
                }, 1000);
                
                break;
            
            case "debug":
                apf.console.log('Flash debug: ' + evtObj.msg);
                break;
            
        }
    },

    /**
     * Mark out the properties, so they are initialized, and documented.
     *
     * @type {Object}
     */
    initProperties: function() {
        this.delayCalls = [];

        // Properties set by flash player
        this.videoWidth = this.videoHeight = this.totalTime = this.bytesLoaded = this.totalBytes = 0;
        this.state = null;

        // Internal properties that match get/set methods
        this.clickToTogglePlay = this.autoPlay = this.autoLoad = this.skinVisible = true;
        this.volume                 = 50;
        this.skinVisible            = false;
        this.skinAutoHide           = false;
        this.playheadTime           = null;
        this.bufferTime             = 0.1;
        this.videoScaleMode         = "maintainAspectRatio"; //maintainAspectRatio || exactFit || noScale
        this.videoAlign             = "center";
        this.playheadUpdateInterval = 1000;
        this.previewImagePath       = this.themeColor = null

        this.firstLoad   = true;
        this.pluginError = false;

        this.properties = ["volume", "skinAutoHide", "showControls", "autoPlay",
            "clickToTogglePlay", "autoLoad", "playHeadTime", "totalTime",
            "bufferTime", "videoScaleMode", "videoAlign", "playheadUpdateInterval",
            "previewImagePath"];
        
        apf.layout.setRules(this.oVideo.$ext, this.oVideo.$uniqueId + "_favideo",
            "(apf.all[" + this.oVideo.$uniqueId + "].player && apf.all["
            + this.oVideo.$uniqueId + "].player.onResize \
                ? apf.all[" + this.oVideo.$uniqueId + "].player \
                : {onResize:apf.K}).onResize()");
        apf.layout.queue(this.oVideo.$ext);
        
        return this;
    },

    /**
     * Create the HTML to render the player.
     *
     * @type {Object}
     */
    createPlayer: function() {
        if (this.htmlElement == null) return this;

        this.pluginError = false;
        
        apf.flash.embed({
            // apf.flash#embed properties
            context          : this,
            htmlNode         : this.htmlElement,
            property         : "player",
            // movie properties
            src              : this.DEFAULT_SWF_PATH,
            width            : "100%",
            height           : "100%",
            align            : "middle",
            id               : this.name,
            quality          : "high",
            bgcolor          : "#000000",
            allowFullScreen  : "true",
            name             : this.name,
            flashvars        : "playerID=" + this.id + "&volume=" + this.volume
            
            ,
            allowScriptAccess: "always",
            type             : "application/x-shockwave-flash",
            pluginspage      : "http://www.adobe.com/go/getflashplayer",
            menu             : "true"
        });

        return this;
    },

    /**
     * Mark a property as invalid, and create a timeout for redraw
     *
     * @type {Object}
     */
    invalidateProperty: function() {
        if (this.invalidProperties == null)
            this.invalidProperties = {};

        for (var i = 0; i < arguments.length; i++)
            this.invalidProperties[arguments[i]] = true;

        if (this.validateInterval == null && this.inited) {
            var _this = this;
            this.validateInterval = $setTimeout(function() {
                _this.validateNow();
            }, 100);
        }

        return this;
    },

    /**
     * Updated player with properties marked as invalid.
     *
     * @type {Object}
     */
    validateNow: function() {
        this.validateInterval = null;
        var props = {};
        for (var n in this.invalidProperties)
            props[n] = this[n];
        this.invalidProperties = {};
        this.callMethod("update", props);
        return this;
    },

    /**
     * All public properties use this proxy to minimize player updates
     *
     * @param {String} property
     * @param {String} value
     * @type {Object}
     */
    setProperty: function(property, value) {
        this[property] = value; // Set the internal property
        if (this.inited)
            this.invalidateProperty(property); // Otherwise, it is already invalidated on init.
        return this;
    },

    $destroy: function() {
        
        if (apf.layout)
            apf.layout.removeRule(this.oVideo.$ext, this.oVideo.$uniqueId + "_favideo");
        
        if (this.player) {
            try {
                this.stop();
            }
            catch(e) {}
            this.player = null;
            delete this.player;
        }
        this.htmlElement.innerHTML = "";
        this.oVideo = this.htmlElement = null;
        delete this.oVideo;
        delete this.htmlElement;
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/processinginstructions/livemarkup.js)SIZE(3408)TIME(1264772818)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Live Markup processor for a processing instruction
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.9
 */

apf.LiveMarkupPi = function(){
    //this.$data;
    this.$init();
};

(function(){
    this.mainBind = "data";
    
    this.implement(apf.StandardBinding);

    this.getDocument = function(){
        return this.$data && this.$data.ownerDocument;
    }
    
    this.clear = function(msg){
        if (msg == "loading" && apf.getInheritedAttribute(this, "loading-message")) {
            this.$propHandlers["calcdata"].call(this, "<div class='loading'>Loading...</div>");
            this.calcdata = "";
        }
    }

    this.$propHandlers["calcdata"] = function(data){
        /*if (this.$data) {
            var newXml = apf.getXml("<a:application xmlns:a='" 
              + apf.ns.apf + "'>" + apf.xmlentities(data) + "</a:application>"); //@todo apf3.0 slow, rethink xmlentities
            var oldXml = this.$data;
            apf.xmlDiff(oldXml, newXml);
            
            return;
        }*/

//var dt = new Date().getTime();

        if (this.$data) {
            var nodes = this.$data.childNodes;
            for (var i = nodes.length - 1; i >= 0; i--)
                nodes[i].destroy(true);
        }

        //if (!this.xmlRoot)
            //return this.$int.innerHTML = "loading...";

        if (data && data.indexOf("<a:") > -1) {
            this.$int.innerHTML = "";//data;

            this.$data = this.ownerDocument.$domParser.parseFromString("<a:application xmlns:a='" 
              + apf.ns.apf + "'>" + data + "</a:application>", "text/xml", {
                htmlNode : this.$int
                //nodelay  : true
            }).documentElement;
            
            //apf.queue.empty();
            
            //alert(new Date().getTime() - dt);
        }
        else {
            if (this.$data) {
                var nodes = this.$data.childNodes;
                for (var i = 0; i < nodes.length; i++)
                    nodes[i].destroy(true);
            }
            
            this.$int.innerHTML = data || "";
        }
    };
}).call(apf.LiveMarkupPi.prototype = new apf.AmlProcessingInstruction(true));

apf.aml.setProcessingInstruction("lm", apf.LiveMarkupPi);
apf.aml.setProcessingInstruction("livemarkup", apf.LiveMarkupPi);




/*FILEHEAD(/var/lib/platform/source/trunk/processinginstructions/livetext.js)SIZE(1641)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Live Markup processor for a processing instruction
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.9
 */

apf.LiveTextPi = function(){
    //this.$data;
    this.$init();
};

(function(){
    this.mainBind = "data";
    
    this.implement(apf.StandardBinding);

    this.$propHandlers["calcdata"] = function(data){
        this.$int.innerHTML = data && apf.htmlentities(data) || "";
    };
}).call(apf.LiveTextPi.prototype = new apf.AmlProcessingInstruction(true));

apf.aml.setProcessingInstruction("lt", apf.LiveTextPi);
apf.aml.setProcessingInstruction("livetext", apf.LiveTextPi);



/*FILEHEAD(/var/lib/platform/source/trunk/jpack_end.js)SIZE(769)TIME(1263910419)*/



//Conditional compilation workaround... (can this be improved??)
if (document.all) {
    var oldWinError = window.onerror;
    window.onerror = function(m){
        apf.console.error("Error caught from early startup. Might be a html parser syntax error (not your fault). " + m);

        if (!arguments.caller)
            return true;
    }
}
apf.Init.addConditional(function(){
    if (document.all) //Conditional compilation workaround... (can this be improved??)
        window.onerror = oldWinError;

    apf.dispatchEvent("domready");
}, null, ["body", "class"]);

/*if(document.body)
    apf.Init.run("body");
else*/
    apf.addDomLoadEvent(function(){apf.Init.run('body');});

//Start
apf.start();



/*FILEHEAD(/var/lib/platform/source/trunk/loader-o3.js)SIZE(7176)TIME(1263239583)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/apf-o3.js)SIZE(13666)TIME(1259091146)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/loader.js)SIZE(14959)TIME(1265021706)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

/**
 * Bootloader for Ajax.org Platform
 *
 * Include apf.js, then just go about it as you would with the 
 * packaged version. Adapt this file to include your preferred modules
 */


